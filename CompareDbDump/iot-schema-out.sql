--
-- PostgreSQL database dump
--

-- Dumped from database version 10.6
-- Dumped by pg_dump version 11.5

SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SELECT pg_catalog.set_config('search_path', '', false);
SET check_function_bodies = false;
SET xmloption = content;
SET client_min_messages = warning;
SET row_security = off;

--
-- Name: aws_dms; Type: SCHEMA; Schema: -; Owner: dbservice
--

CREATE SCHEMA aws_dms;


ALTER SCHEMA aws_dms OWNER TO dbservice;

--
-- Name: beta; Type: SCHEMA; Schema: -; Owner: dbservice
--

CREATE SCHEMA beta;


ALTER SCHEMA beta OWNER TO dbservice;

--
-- Name: SCHEMA beta; Type: COMMENT; Schema: -; Owner: dbservice
--

COMMENT ON SCHEMA beta IS 'development schema';


--
-- Name: byt_devops; Type: SCHEMA; Schema: -; Owner: dbservice
--

CREATE SCHEMA byt_devops;


ALTER SCHEMA byt_devops OWNER TO dbservice;

--
-- Name: byte_pgdu; Type: SCHEMA; Schema: -; Owner: dbservice
--

CREATE SCHEMA byte_pgdu;


ALTER SCHEMA byte_pgdu OWNER TO dbservice;

--
-- Name: develop; Type: SCHEMA; Schema: -; Owner: dbservice
--

CREATE SCHEMA develop;


ALTER SCHEMA develop OWNER TO dbservice;

--
-- Name: dms7; Type: SCHEMA; Schema: -; Owner: dbservice
--

CREATE SCHEMA dms7;


ALTER SCHEMA dms7 OWNER TO dbservice;

--
-- Name: fnrenames; Type: SCHEMA; Schema: -; Owner: dbservice
--

CREATE SCHEMA fnrenames;


ALTER SCHEMA fnrenames OWNER TO dbservice;

--
-- Name: inm; Type: SCHEMA; Schema: -; Owner: dbservice
--

CREATE SCHEMA inm;


ALTER SCHEMA inm OWNER TO dbservice;

--
-- Name: SCHEMA inm; Type: COMMENT; Schema: -; Owner: dbservice
--

COMMENT ON SCHEMA inm IS 'Demand planning';


--
-- Name: inm_backup; Type: SCHEMA; Schema: -; Owner: dbservice
--

CREATE SCHEMA inm_backup;


ALTER SCHEMA inm_backup OWNER TO dbservice;

--
-- Name: SCHEMA inm_backup; Type: COMMENT; Schema: -; Owner: dbservice
--

COMMENT ON SCHEMA inm_backup IS 'back up of tables containing inm settings such as kiosk_sku_preference before the latest changes.';


--
-- Name: inm_beta; Type: SCHEMA; Schema: -; Owner: dbservice
--

CREATE SCHEMA inm_beta;


ALTER SCHEMA inm_beta OWNER TO dbservice;

--
-- Name: SCHEMA inm_beta; Type: COMMENT; Schema: -; Owner: dbservice
--

COMMENT ON SCHEMA inm_beta IS 'New schema to be used by LambdaZen. Contains iINM related objects plus new versions of other general objects currently in pantry schema such as KIOSK and KIOSK related tables.';


--
-- Name: inm_test; Type: SCHEMA; Schema: -; Owner: dbservice
--

CREATE SCHEMA inm_test;


ALTER SCHEMA inm_test OWNER TO dbservice;

--
-- Name: SCHEMA inm_test; Type: COMMENT; Schema: -; Owner: dbservice
--

COMMENT ON SCHEMA inm_test IS 'Where as inm schema will contain production pick result, inm_test will contain test pick results so that they do not affect actual inm production stats.';


--
-- Name: iplanner; Type: SCHEMA; Schema: -; Owner: dbservice
--

CREATE SCHEMA iplanner;


ALTER SCHEMA iplanner OWNER TO dbservice;

--
-- Name: mixalot; Type: SCHEMA; Schema: -; Owner: dbservice
--

CREATE SCHEMA mixalot;


ALTER SCHEMA mixalot OWNER TO dbservice;

--
-- Name: monitor; Type: SCHEMA; Schema: -; Owner: dbservice
--

CREATE SCHEMA monitor;


ALTER SCHEMA monitor OWNER TO dbservice;

--
-- Name: SCHEMA monitor; Type: COMMENT; Schema: -; Owner: dbservice
--

COMMENT ON SCHEMA monitor IS 'stores kiosk monitor data';


--
-- Name: pantry; Type: SCHEMA; Schema: -; Owner: dbservice
--

CREATE SCHEMA pantry;


ALTER SCHEMA pantry OWNER TO dbservice;

--
-- Name: report; Type: SCHEMA; Schema: -; Owner: dbservice
--

CREATE SCHEMA report;


ALTER SCHEMA report OWNER TO dbservice;

--
-- Name: rptg; Type: SCHEMA; Schema: -; Owner: dbservice
--

CREATE SCHEMA rptg;


ALTER SCHEMA rptg OWNER TO dbservice;

--
-- Name: test; Type: SCHEMA; Schema: -; Owner: dbservice
--

CREATE SCHEMA test;


ALTER SCHEMA test OWNER TO dbservice;

--
-- Name: util; Type: SCHEMA; Schema: -; Owner: dbservice
--

CREATE SCHEMA util;


ALTER SCHEMA util OWNER TO dbservice;

--
-- Name: plperl; Type: PROCEDURAL LANGUAGE; Schema: -; Owner: dbservice
--

CREATE OR REPLACE PROCEDURAL LANGUAGE plperl;


ALTER PROCEDURAL LANGUAGE plperl OWNER TO dbservice;

--
-- Name: btree_gin; Type: EXTENSION; Schema: -; Owner: 
--

CREATE EXTENSION IF NOT EXISTS btree_gin WITH SCHEMA public;


--
-- Name: EXTENSION btree_gin; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION btree_gin IS 'support for indexing common datatypes in GIN';


--
-- Name: intarray; Type: EXTENSION; Schema: -; Owner: 
--

CREATE EXTENSION IF NOT EXISTS intarray WITH SCHEMA public;


--
-- Name: EXTENSION intarray; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION intarray IS 'functions, operators, and index support for 1-D arrays of integers';


--
-- Name: pg_stat_statements; Type: EXTENSION; Schema: -; Owner: 
--

CREATE EXTENSION IF NOT EXISTS pg_stat_statements WITH SCHEMA public;


--
-- Name: EXTENSION pg_stat_statements; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION pg_stat_statements IS 'track execution statistics of all SQL statements executed';


--
-- Name: pg_trgm; Type: EXTENSION; Schema: -; Owner: 
--

CREATE EXTENSION IF NOT EXISTS pg_trgm WITH SCHEMA public;


--
-- Name: EXTENSION pg_trgm; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION pg_trgm IS 'text similarity measurement and index searching based on trigrams';


--
-- Name: tablefunc; Type: EXTENSION; Schema: -; Owner: 
--

CREATE EXTENSION IF NOT EXISTS tablefunc WITH SCHEMA public;


--
-- Name: EXTENSION tablefunc; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION tablefunc IS 'functions that manipulate whole tables, including crosstab';


--
-- Name: text100; Type: DOMAIN; Schema: inm_beta; Owner: dbservice
--

CREATE DOMAIN inm_beta.text100 AS text
	CONSTRAINT text100_check CHECK ((length(VALUE) <= 30));


ALTER DOMAIN inm_beta.text100 OWNER TO dbservice;

--
-- Name: text100_nb; Type: DOMAIN; Schema: inm_beta; Owner: dbservice
--

CREATE DOMAIN inm_beta.text100_nb AS inm_beta.text100
	CONSTRAINT text100_nb_check CHECK ((length((VALUE)::text) >= 1));


ALTER DOMAIN inm_beta.text100_nb OWNER TO dbservice;

--
-- Name: text10k; Type: DOMAIN; Schema: inm_beta; Owner: dbservice
--

CREATE DOMAIN inm_beta.text10k AS text
	CONSTRAINT text10k_check CHECK ((length(VALUE) <= 10000));


ALTER DOMAIN inm_beta.text10k OWNER TO dbservice;

--
-- Name: text1k; Type: DOMAIN; Schema: inm_beta; Owner: dbservice
--

CREATE DOMAIN inm_beta.text1k AS text
	CONSTRAINT text1k_check CHECK ((length(VALUE) <= 1000));


ALTER DOMAIN inm_beta.text1k OWNER TO dbservice;

--
-- Name: text200; Type: DOMAIN; Schema: inm_beta; Owner: dbservice
--

CREATE DOMAIN inm_beta.text200 AS text
	CONSTRAINT text200_check CHECK ((length(VALUE) <= 200));


ALTER DOMAIN inm_beta.text200 OWNER TO dbservice;

--
-- Name: text2k; Type: DOMAIN; Schema: inm_beta; Owner: dbservice
--

CREATE DOMAIN inm_beta.text2k AS text
	CONSTRAINT text2k_check CHECK ((length(VALUE) <= 2000));


ALTER DOMAIN inm_beta.text2k OWNER TO dbservice;

--
-- Name: text400; Type: DOMAIN; Schema: inm_beta; Owner: dbservice
--

CREATE DOMAIN inm_beta.text400 AS text
	CONSTRAINT text400_check CHECK ((length(VALUE) <= 400));


ALTER DOMAIN inm_beta.text400 OWNER TO dbservice;

--
-- Name: text4k; Type: DOMAIN; Schema: inm_beta; Owner: dbservice
--

CREATE DOMAIN inm_beta.text4k AS text
	CONSTRAINT text4k_check CHECK ((length(VALUE) <= 4000));


ALTER DOMAIN inm_beta.text4k OWNER TO dbservice;

--
-- Name: text_name; Type: DOMAIN; Schema: inm_beta; Owner: dbservice
--

CREATE DOMAIN inm_beta.text_name AS text
	CONSTRAINT text_name_check CHECK ((length(VALUE) <= 100));


ALTER DOMAIN inm_beta.text_name OWNER TO dbservice;

--
-- Name: bringg_vs_optimo_delta(date, date); Type: FUNCTION; Schema: beta; Owner: dbservice
--

CREATE FUNCTION beta.bringg_vs_optimo_delta(start_date date, end_date date) RETURNS TABLE(bringg_kid integer, bringg_task_id bigint, bringg_ts timestamp with time zone, optimo_ts timestamp with time zone, optimo_kid integer)
    LANGUAGE plpgsql
    AS $$

/*
Purpose - compare pick to restock
Input - 
start_date: first pick date to consider
end_date: last pick date to consider
Output - 
difference between Bringg and Optimo routes
*/

declare target_date date;
declare pick_window_start timestamp with time zone;
declare pick_window_end timestamp with time zone;
begin
set timezone to 'US/Pacific';
return query
select cast(b.kid as integer) b_kid, b.task_id, b.route_date_time b_ts, o.route_date_time o_ts, o.location_number o_kid
from bringg.order b 
full outer join mixalot.route_stop o
on cast(b.kid as integer) = o.location_number and b.route_date_time::date = o.route_date_time::date and  o.location_number <> -1
where (b.route_date_time::date between start_date and end_date or o.route_date_time::date between start_date and end_date)
and (o.route_date_time is null or b.route_date_time is null)
order by coalesce(b.route_date_time, o.route_date_time);

end;

$$;


ALTER FUNCTION beta.bringg_vs_optimo_delta(start_date date, end_date date) OWNER TO dbservice;

--
-- Name: compare_pick_vs_delivery(date, date); Type: FUNCTION; Schema: beta; Owner: dbservice
--

CREATE FUNCTION beta.compare_pick_vs_delivery(start_date date, end_date date DEFAULT NULL::date) RETURNS TABLE(kiosk_id integer, route_date date, restocker text, product_id integer, pick_qty integer, restock_qty integer, discrepancy integer)
    LANGUAGE plpgsql
    AS $$

/*
Purpose - compare pick to restock
Input - 
	start_date: first pick date to consider
	end_date: last pick date to consider. If not given, compute the result for only start_date
Output - 
	kiosk_id: id for kiosk
	route_date: delivery date
	kiosk_title: kiosk name
	product_id: what picked/allocated
	pick_qty: quantity above product_id picked
	restock_qty: quantity of above product_id for the same route_date
	discrepancy: restock_qty - pick_quantity for target_date  
*/

declare target_date date;
declare pick_window_start timestamp with time zone;
declare pick_window_end timestamp with time zone;
begin
	set timezone to 'US/Pacific';
	return query
		select a.kiosk_id, a.route_date, r.restocker, a.sku_id, cast(sum(a.qty) as integer), 
			coalesce(cast(sum(l.total) as integer), 0), cast(coalesce(sum(l.total), 0) - sum(a.qty) as integer)
			from inm.pick_allocation a 
			left join 
				(select to_timestamp(time_created)::date restock_date, pantry.label.kiosk_id, pantry.label.product_id, count(*) total
					from pantry.label group by 1,2,3) l
					on a.route_date = l.restock_date and a.kiosk_id=l.kiosk_id and a.sku_id = l.product_id
			left join 
					-- restocker
					(select distinct to_timestamp(created)::date route_date, o.kiosk_id, first_name || ' ' || last_name restocker from pantry.order o
						where order_id like 'RE%' and to_timestamp(created)::date between start_date and end_date + 1 order by 1,2) r
					on r.route_date = a.route_date and r.kiosk_id = a.kiosk_id
			where a.route_date between start_date and end_date
		group by 1, 2, 3, 4;
end;

$$;


ALTER FUNCTION beta.compare_pick_vs_delivery(start_date date, end_date date) OWNER TO dbservice;

--
-- Name: compare_pick_vs_delivery_by_sku(date, date); Type: FUNCTION; Schema: beta; Owner: dbservice
--

CREATE FUNCTION beta.compare_pick_vs_delivery_by_sku(start_date date, end_date date DEFAULT NULL::date) RETURNS TABLE(route_date date, driver_name character varying, restocker text, product_id integer, pick_qty integer, restock_qty integer, discrepancy integer)
    LANGUAGE plpgsql
    AS $$

/*
Purpose - compare pick to restock
Input - 
	start_date: first pick date to consider
	end_date: last pick date to consider. If not given, compute the result for only start_date
Output - 
	kiosk_id: id for kiosk
	route_date: delivery date
	kiosk_title: kiosk name
	product_id: what picked/allocated
	pick_qty: quantity above product_id picked
	restock_qty: quantity above product_id restocked between target_date and the following delivery date_time for the kiosk
	discrepancy: restock_qty - pick_quantity for target_date  
*/

declare target_date date;
declare pick_window_start timestamp with time zone;
declare pick_window_end timestamp with time zone;
begin
	set timezone to 'US/Pacific';
	return query
		select allocation.route_date, allocation.driver_name, restock.restocker, allocation.sku_id, cast(sum(allocation.total) as integer), 
			cast(sum(restock.total) as integer), cast(sum(allocation.total) - sum(restock.total) as integer)
			
			-- route_date, driver_name, sku_id, qty
			from (select a.route_date, route.driver_name, a.sku_id, sum(a.qty) total
				  from inm.pick_allocation a 
					left join inm.pick_route route
					on a.route_date = route.route_date and a.kiosk_id = route.kiosk_id
				  	group by 1,2,3) allocation
				
			left join 
				-- restock_date, restocker, sku, qty
				(select to_timestamp(l.time_created)::date restock_date, r.restocker, l.product_id, count(*) total
					from pantry.label l
				 	left join 
					-- restocker
					(select distinct to_timestamp(created)::date route_date, o.kiosk_id, first_name || ' ' || last_name restocker from pantry.order o
						where order_id like 'RE%' and to_timestamp(created)::date between start_date and end_date + 1 order by 1,2) r
				 	on to_timestamp(l.time_created)::date = r.route_date and l.kiosk_id = r.kiosk_id
				 
				 	group by 1,2,3) restock
					
					on restock.restock_date = allocation.route_date and restock.product_id = allocation.sku_id and restock.restocker = allocation.driver_name
			where allocation.route_date between start_date and end_date
		group by 1, 2, 3,4;
end;

$$;


ALTER FUNCTION beta.compare_pick_vs_delivery_by_sku(start_date date, end_date date) OWNER TO dbservice;

--
-- Name: compare_pick_vs_delivery_ignore_null(date, date); Type: FUNCTION; Schema: beta; Owner: dbservice
--

CREATE FUNCTION beta.compare_pick_vs_delivery_ignore_null(start_date date, end_date date DEFAULT NULL::date) RETURNS TABLE(kiosk_id integer, route_date date, restocker text, product_id integer, pick_qty integer, restock_qty integer, discrepancy integer)
    LANGUAGE plpgsql
    AS $$

/*
Purpose - compare pick to restock
Input - 
	start_date: first pick date to consider
	end_date: last pick date to consider. If not given, compute the result for only start_date
Output - 
	kiosk_id: id for kiosk
	route_date: delivery date
	kiosk_title: kiosk name
	product_id: what picked/allocated
	pick_qty: quantity above product_id picked
	restock_qty: quantity above product_id restocked between target_date and the following delivery date_time for the kiosk
	discrepancy: restock_qty - pick_quantity for target_date  
*/

declare target_date date;
declare pick_window_start timestamp with time zone;
declare pick_window_end timestamp with time zone;
begin
	set timezone to 'US/Pacific';
	return query
		select a.kiosk_id, a.route_date, r.restocker, a.sku_id, cast(sum(a.qty) as integer), 
			cast(sum(l.total) as integer), cast(sum(a.qty) - sum(l.total) as integer)
			from inm.pick_allocation a 
			left join 
				(select to_timestamp(time_created)::date restock_date, pantry.label.kiosk_id, pantry.label.product_id, count(*) total
					from pantry.label group by 1,2,3) l
					on a.route_date = l.restock_date and a.kiosk_id=l.kiosk_id and a.sku_id = l.product_id
			left join 
					-- restocker
					(select distinct to_timestamp(created)::date route_date, o.kiosk_id, first_name || ' ' || last_name restocker from pantry.order o
						where order_id like 'RE%' and to_timestamp(created)::date between start_date and end_date + 1 order by 1,2) r
					on r.route_date = a.route_date and r.kiosk_id = a.kiosk_id
			where a.route_date between start_date and end_date
		group by 1, 2, 3, 4;
end;

$$;


ALTER FUNCTION beta.compare_pick_vs_delivery_ignore_null(start_date date, end_date date) OWNER TO dbservice;

--
-- Name: compare_pick_vs_delivery_test(date, date); Type: FUNCTION; Schema: beta; Owner: dbservice
--

CREATE FUNCTION beta.compare_pick_vs_delivery_test(start_date date, end_date date DEFAULT NULL::date) RETURNS TABLE(kiosk_id integer, route_date date, kiosk_title character varying, driver_name character varying, restocker text, product_id integer, pick_qty bigint, restock_qty bigint, discrepancy bigint)
    LANGUAGE plpgsql
    AS $$

/*
Purpose - compare pick to restock
Input - 
	start_date: first pick date to consider
	end_date: last pick date to consider. If not given, compute the result for only start_date
Output - 
	kiosk_id: id for kiosk
	route_date: delivery date
	kiosk_title: kiosk name
	product_id: what picked/allocated
	pick_qty: quantity above product_id picked
	restock_qty: quantity above product_id restocked between target_date and the following delivery date_time for the kiosk
	discrepancy: restock_qty - pick_quantity for target_date  
*/

declare target_date date;
declare pick_window_start timestamp with time zone;
declare pick_window_end timestamp with time zone;
begin
	set timezone to 'US/Pacific';
	if end_date is null
		then end_date = start_date;
	end if;
	for target_date in select * from generate_series(start_date, end_date, interval '1 days') loop
		pick_window_start = cast(target_date as timestamp with time zone) + interval '13 hours';
		pick_window_end = pick_window_start + interval '22 hours';

		return query
			select
				a.kiosk_id, a.route_date, k.title, d.driver_name, r.restocker, a.sku_id, a.pick_qty, coalesce(rs.restock_qty, 0) restock_qty, coalesce(rs.restock_qty, 0) - a.pick_qty discrepancy
				from
					-- next 2 delivery schedules for each kiosks
					(select t1.kiosk_id, t1.route_date_time, t1.next_delivery_ts, t1.driver_name from inm.pick_get_plan_kiosk(pick_window_start, pick_window_end) t1) d
					join
					-- allocation
					(select t2.kiosk_id, t2.route_date, t2.sku_id, sum(t2.qty) pick_qty
						from inm.pick_allocation t2
						where pick_date = target_date
						group by 1,2,3) a
					on d.kiosk_id = a.kiosk_id and d.route_date_time::date = a.route_date

				left join
					-- restock
					(select t3.kiosk_id, to_timestamp(time_added)::date restock_date, t3.product_id, count(*) restock_qty
					  from pantry.label t3
					  where to_timestamp(time_added) between pick_window_start and pick_window_start + interval '2 days' -- optimize to a safe upper limit of 2 days
					  group by 1,2,3) rs
					on a.kiosk_id = rs.kiosk_id and a.route_date = rs.restock_date and a.sku_id = rs.product_id -- now match exactly restock_date to route_date
					
				left join 
					-- restocker
					(select distinct to_timestamp(created)::date route_date, o.kiosk_id, first_name || ' ' || last_name restocker from pantry.order o
						where order_id like 'RE%' and to_timestamp(created)::date between target_date and target_date + 1 order by 1,2) r
					on r.route_date = a.route_date and r.kiosk_id = a.kiosk_id

				join pantry.kiosk k on a.kiosk_id = k.id and k.campus_id = 87
				order by a.kiosk_id;
		end loop;
end;

$$;


ALTER FUNCTION beta.compare_pick_vs_delivery_test(start_date date, end_date date) OWNER TO dbservice;

--
-- Name: compare_pick_vs_delivery_v2(date, date); Type: FUNCTION; Schema: beta; Owner: dbservice
--

CREATE FUNCTION beta.compare_pick_vs_delivery_v2(start_date date, end_date date DEFAULT NULL::date) RETURNS TABLE(kiosk_id integer, route_date date, product_id integer, pick_qty integer, restock_qty integer, discrepancy integer)
    LANGUAGE plpgsql
    AS $$

/*
Purpose - compare pick to restock
Input - 
	start_date: first pick date to consider
	end_date: last pick date to consider. If not given, compute the result for only start_date
Output - 
	kiosk_id: id for kiosk
	route_date: delivery date
	kiosk_title: kiosk name
	product_id: what picked/allocated
	pick_qty: quantity above product_id picked
	restock_qty: quantity above product_id restocked between target_date and the following delivery date_time for the kiosk
	discrepancy: restock_qty - pick_quantity for target_date  
*/

declare target_date date;
declare pick_window_start timestamp with time zone;
declare pick_window_end timestamp with time zone;
begin
	set timezone to 'US/Pacific';
	return query
		select a.kiosk_id, a.route_date, a.sku_id, cast(sum(a.qty) as integer), cast(sum(l.total) as integer), cast(sum(a.qty) - sum(l.total) as integer)
			from inm.pick_allocation a 
			left join 
				(select to_timestamp(time_created)::date restock_date, pantry.label.kiosk_id, pantry.label.product_id, count(*) total
					from pantry.label group by 1,2,3) l
					on a.route_date = l.restock_date and a.kiosk_id=l.kiosk_id and a.sku_id = l.product_id
			where a.route_date between start_date and end_date
		group by 1, 2, 3;
end;

$$;


ALTER FUNCTION beta.compare_pick_vs_delivery_v2(start_date date, end_date date) OWNER TO dbservice;

--
-- Name: compare_pick_vs_delivery_v3(date, date); Type: FUNCTION; Schema: beta; Owner: dbservice
--

CREATE FUNCTION beta.compare_pick_vs_delivery_v3(start_date date, end_date date DEFAULT NULL::date) RETURNS TABLE(kiosk_id integer, route_date date, restocker text, product_id integer, pick_qty integer, restock_qty integer, discrepancy integer)
    LANGUAGE plpgsql
    AS $$

/*
Purpose - compare pick to restock
Input - 
	start_date: first pick date to consider
	end_date: last pick date to consider. If not given, compute the result for only start_date
Output - 
	kiosk_id: id for kiosk
	route_date: delivery date
	kiosk_title: kiosk name
	product_id: what picked/allocated
	pick_qty: quantity above product_id picked
	restock_qty: quantity of above product_id for the same route_date
	discrepancy: restock_qty - pick_quantity for target_date  
*/

declare target_date date;
declare pick_window_start timestamp with time zone;
declare pick_window_end timestamp with time zone;
begin
	set timezone to 'US/Pacific';
	return query
		select a.kiosk_id, a.route_date, r.restocker, a.sku_id, cast(sum(a.qty) as integer), 
			coalesce(cast(sum(l.total) as integer), 0), cast(coalesce(sum(l.total), 0) - sum(a.qty) as integer)
			from inm.pick_allocation a 
			left join 
				(select to_timestamp(time_created)::date restock_date, pantry.label.kiosk_id, pantry.label.product_id, count(*) total
					from pantry.label group by 1,2,3) l
					on a.route_date = l.restock_date and a.kiosk_id=l.kiosk_id and a.sku_id = l.product_id
			left join 
					-- restocker
					(select distinct to_timestamp(created)::date route_date, o.kiosk_id, first_name || ' ' || last_name restocker from pantry.order o
						where order_id like 'RE%' and to_timestamp(created)::date between start_date and end_date + 1 order by 1,2) r
					on r.route_date = a.route_date and r.kiosk_id = a.kiosk_id
			where a.route_date between start_date and end_date
		group by 1, 2, 3, 4;
end;

$$;


ALTER FUNCTION beta.compare_pick_vs_delivery_v3(start_date date, end_date date) OWNER TO dbservice;

--
-- Name: get_label_stats(date, date, integer[]); Type: FUNCTION; Schema: beta; Owner: dbservice
--

CREATE FUNCTION beta.get_label_stats(start_date date, end_date date, product_list integer[]) RETURNS TABLE(label_epc character varying, label_total bigint, label_order_total bigint, label_order_sold_total bigint, history_total bigint, history_unique_order_total bigint, history_unique_kid_total bigint, history_min_ts timestamp without time zone, history_max_ts timestamp without time zone, history_last_kid bigint, spoilage_total bigint, byte_spoilage_total bigint, label_spoilage_total bigint, label_ok_total bigint)
    LANGUAGE plpgsql
    AS $$

/*
Purpose: compute label stats
Input: 
	start_date, end_date of label created
	list of kiosks
Return
	stats
*/
begin
	return query
		select t0.epc, coalesce(t1.label_total, 0), coalesce(t2.label_order_total, 0), coalesce(t3.label_order_sold_total, 0), coalesce(t4.history_total, 0),
		coalesce(t5.history_unique_order_total, 0), coalesce(t6.history_unique_kid_total, 0),
		cast(t7.history_min_ts as timestamp), cast(t7.history_max_ts as timestamp), coalesce(t8.history_last_kid, 0), 
		coalesce(t9.spoilage_total, 0), coalesce(t10.byte_spoilage_total, 0), coalesce(t11.label_spoilage_total, 0), coalesce(t12.label_ok_total, 0)
	
		from
			(select distinct epc
				from pantry.label l
			 		join pantry.kiosk k on l.kiosk_id = k.id and k.campus_id = 87 and k.enable_reporting = 1
				where to_timestamp(time_added) between start_date and end_date
					and product_id in (select unnest(product_list))
			)t0
			
		left join 
			-- label table: number of records
			(
			select epc, count(*) label_total 
				from pantry.label
				where to_timestamp(time_added) between start_date and end_date
			 	group by epc
			)t1 on t0.epc = t1.epc
			
		left join 
			-- label table: number of records with order_id
			(
			select epc, count(*) label_order_total 
				from pantry.label
				where to_timestamp(time_added) between start_date and end_date
				and order_id is not null 
			 	group by epc
			)t2 on t0.epc = t2.epc
			
		left join 
			-- label table: number of records with order_id and status = sold
			(
			select epc, count(*) label_order_sold_total 
				from pantry.label
				where to_timestamp(time_added) between start_date and end_date
				and order_id is not null and status='sold'
			 	group by epc
			)t3 on t0.epc = t3.epc
			
		left join
			-- history table: number of records
			(select h.epc, count(*) history_total 
			 	from 
			 
					(select distinct epc
						from pantry.label
						where to_timestamp(time_added) between start_date and end_date
					) l
				join pantry.history h on l.epc = h.epc
				group by h.epc
			)t4  on t0.epc = t4.epc
			
		left join
			-- history table: number of unique order
			(select h.epc, count(distinct h.order_id) history_unique_order_total 
			 	from 
					(select distinct epc
						from pantry.label
						where to_timestamp(time_added) between start_date and end_date
					) l
				join pantry.history h on l.epc = h.epc and h.order_id is not null
				group by h.epc
			)t5 on t0.epc = t5.epc
			
		left join
			-- history table: number of unique kid 
			(select h.epc, count(distinct h.kiosk_id) history_unique_kid_total 
				from 
					(select distinct epc
						from pantry.label
						where to_timestamp(time_added) between start_date and end_date
					) l
				join pantry.history h on l.epc = h.epc and h.kiosk_id is not null
				group by h.epc
			)t6 on t0.epc = t6.epc
			
		left join
		-- history table: min and max record time
		(select h.epc, min(to_timestamp(time)) history_min_ts, max(to_timestamp(time)) history_max_ts
			from 
				(select distinct epc
					from pantry.label
					where to_timestamp(time_added) between start_date and end_date
				) l
			join pantry.history h on l.epc = h.epc
		 	group by h.epc
		)t7 on t0.epc = t7.epc
		
		left join
		-- history table: last kid
			(select h_disctinct_last_kid.epc, h_disctinct_last_kid.kiosk_id history_last_kid
				from 
					(select distinct epc
						from pantry.label
						where to_timestamp(time_added) between start_date and end_date
					) l
					join 
					(select distinct epc, kiosk_id
					 from
						(select epc, kiosk_id, to_timestamp(time) ts,
								rank() over (partition by epc order by time desc) r
						from pantry.history
						where to_timestamp(time) >= start_date and kiosk_id is not null
						) h_last_kid where r = 1) h_disctinct_last_kid
					on l.epc = h_disctinct_last_kid.epc
			)t8 on t0.epc = t8.epc
		
		left join
		-- Spoilage table indicator for each EPC: number of records
		(select s.epc, count(*) spoilage_total
			from
				(select distinct epc
					from pantry.label
					where to_timestamp(time_added) between start_date and end_date
				) l
				join pantry.spoilage s on l.epc = s.epc
				group by s.epc
		)t9 on t0.epc = t9.epc
		
		left join
		-- Byte spoilage table indicator for each EPC: number of records
		(select bs.epc, count(*) byte_spoilage_total
			from
				(select distinct epc
					from pantry.label
					where to_timestamp(time_added) between start_date and end_date
				) l 
			join public.byte_spoilage bs
				on l.epc = bs.epc
			group by bs.epc
		)t10 on t0.epc = t10.epc
		
		left join
		-- Spoilage table indicator for each EPC: number of spoils in label
		(select epc, count(*) label_spoilage_total
			from pantry.label
			where to_timestamp(time_added) between start_date and end_date
			and status = 'out' and order_id like 'RE%' group by 1
		)t11 on t0.epc = t11.epc

		left join
		-- label ok indicator for each EPC: number of records in label table where status is OK but no order_id
		(select epc, count(*) label_ok_total
			from pantry.label
			where to_timestamp(time_added) between start_date and end_date
			and status = 'ok' and order_id is null group by 1
		)t12 on t0.epc = t12.epc;
end;

$$;


ALTER FUNCTION beta.get_label_stats(start_date date, end_date date, product_list integer[]) OWNER TO dbservice;

--
-- Name: get_label_stats(date, date, integer[], integer[]); Type: FUNCTION; Schema: beta; Owner: dbservice
--

CREATE FUNCTION beta.get_label_stats(start_date date, end_date date, product_list integer[], kiosk_list integer[]) RETURNS TABLE(label_epc character varying, label_total bigint, label_order_total bigint, label_order_sold_total bigint, history_total bigint, history_unique_order_total bigint, history_unique_kid_total bigint, history_min_ts timestamp without time zone, history_max_ts timestamp without time zone, history_last_kid bigint, spoilage_total bigint, byte_spoilage_total bigint, label_spoilage_total bigint, label_ok_total bigint)
    LANGUAGE plpgsql
    AS $$

/*
Purpose: compute label stats
Input: 
	start_date, end_date of label created
	list of kiosks
Return
	stats
*/
begin
	return query
		select t0.epc, coalesce(t1.label_total, 0), coalesce(t2.label_order_total, 0), coalesce(t3.label_order_sold_total, 0), coalesce(t4.history_total, 0),
		coalesce(t5.history_unique_order_total, 0), coalesce(t6.history_unique_kid_total, 0),
		cast(t7.history_min_ts as timestamp), cast(t7.history_max_ts as timestamp), coalesce(t8.history_last_kid, 0), coalesce(t9.spoilage_total, 0),
		coalesce(t10.byte_spoilage_total, 0), coalesce(t11.label_spoilage_total, 0), coalesce(t12.label_ok_total, 0)
	
		from
			(select distinct epc
				from pantry.label l
			 	join pantry.kiosk k on l.kiosk_id = k.id and k.campus_id = 87 and k.enable_reporting = 1
				where to_timestamp(time_added) between start_date and end_date
					and product_id in (select unnest(product_list))
			  		and kiosk_id in (select unnest(kiosk_list))
			)t0
			
		left join 
			-- label table: number of records
			(
			select epc, count(*) label_total 
				from pantry.label
				where to_timestamp(time_added) between start_date and end_date
			 	group by epc
			)t1 on t0.epc = t1.epc
			
		left join 
			-- label table: number of records with order_id
			(
			select epc, count(*) label_order_total 
				from pantry.label
				where to_timestamp(time_added) between start_date and end_date
				and order_id is not null 
			 	group by epc
			)t2 on t0.epc = t2.epc
			
		left join 
			-- label table: number of records with order_id and status = sold
			(
			select epc, count(*) label_order_sold_total 
				from pantry.label
				where to_timestamp(time_added) between start_date and end_date
				and order_id is not null and status='sold'
			 	group by epc
			)t3 on t0.epc = t3.epc
			
		left join
			-- history table: number of records
			(select h.epc, count(*) history_total 
			 	from 
			 
					(select distinct epc
						from pantry.label
						where to_timestamp(time_added) between start_date and end_date
					) l
				join pantry.history h on l.epc = h.epc
				group by h.epc
			)t4  on t0.epc = t4.epc
			
		left join
			-- history table: number of unique order
			(select h.epc, count(distinct h.order_id) history_unique_order_total 
			 	from 
					(select distinct epc
						from pantry.label
						where to_timestamp(time_added) between start_date and end_date
					) l
				join pantry.history h on l.epc = h.epc and h.order_id is not null
				group by h.epc
			)t5 on t0.epc = t5.epc
			
		left join
			-- history table: number of unique kid 
			(select h.epc, count(distinct h.kiosk_id) history_unique_kid_total 
				from 
					(select distinct epc
						from pantry.label
						where to_timestamp(time_added) between start_date and end_date
					) l
				join pantry.history h on l.epc = h.epc and h.kiosk_id is not null
				group by h.epc
			)t6 on t0.epc = t6.epc
			
		left join
		-- history table: min, max record time
		(select h.epc, min(to_timestamp(time)) history_min_ts, max(to_timestamp(time)) history_max_ts
			from 
				(select distinct epc
					from pantry.label
					where to_timestamp(time_added) between start_date and end_date
				) l
			join pantry.history h on l.epc = h.epc
		 	group by h.epc
		)t7 on t0.epc = t7.epc
		
		left join
		-- history table: last kid
			(select h_disctinct_last_kid.epc, h_disctinct_last_kid.kiosk_id history_last_kid
				from 
					(select distinct epc
						from pantry.label
						where to_timestamp(time_added) between start_date and end_date
					) l
					join 
					(select distinct epc, kiosk_id
					 from
						(select epc, kiosk_id, to_timestamp(time) ts,
								rank() over (partition by epc order by time desc) r
						from pantry.history
						where to_timestamp(time) >= start_date and kiosk_id is not null
						) h_last_kid where r = 1) h_disctinct_last_kid
					on l.epc = h_disctinct_last_kid.epc
			)t8 on t0.epc = t8.epc
		
		left join
		-- Spoilage table indicator for each EPC: number of records
		(select s.epc, count(*) spoilage_total
			from
				(select distinct epc
					from pantry.label
					where to_timestamp(time_added) between start_date and end_date
				) l
				join pantry.spoilage s on l.epc = s.epc
				group by s.epc
		)t9 on t0.epc = t9.epc
		
		left join
		-- Byte spoilage table indicator for each EPC: number of records
		(select bs.epc, count(*) byte_spoilage_total
			from
				(select distinct epc
					from pantry.label
					where to_timestamp(time_added) between start_date and end_date
				) l 
			join public.byte_spoilage bs
				on l.epc = bs.epc
			group by bs.epc
		)t10 on t0.epc = t10.epc
		
		left join
		-- Spoilage table indicator for each EPC: number of spoils in label
		(select epc, count(*) label_spoilage_total
			from pantry.label
			where to_timestamp(time_added) between start_date and end_date
			and status = 'out' and order_id like 'RE%' group by 1
		)t11 on t0.epc = t11.epc
		
		left join
		-- label ok indicator for each EPC: number of records in label table where status is OK but no order_id
		(select epc, count(*) label_ok_total
			from pantry.label
			where to_timestamp(time_added) between start_date and end_date
			and status = 'ok' and order_id is null group by 1
		)t12 on t0.epc = t12.epc;
end;

$$;


ALTER FUNCTION beta.get_label_stats(start_date date, end_date date, product_list integer[], kiosk_list integer[]) OWNER TO dbservice;

--
-- Name: get_label_stats_v0(date, date, integer[]); Type: FUNCTION; Schema: beta; Owner: dbservice
--

CREATE FUNCTION beta.get_label_stats_v0(start_date date, end_date date, product_list integer[]) RETURNS TABLE(label_epc character varying, label_total bigint, label_order_total bigint, label_order_sold_total bigint, history_total bigint, history_unique_order_total bigint, history_unique_kid_total bigint, history_min_ts timestamp without time zone, history_max_ts timestamp without time zone, history_last_kid bigint, spoilage_total bigint)
    LANGUAGE plpgsql
    AS $$

/*
Purpose: compute label stats
Input: 
	start_date, end_date of label created
	list of kiosks
Return
	stats
*/
begin
	return query
		select t0.epc, coalesce(t1.label_total, 0), coalesce(t2.label_order_total, 0), coalesce(t3.label_order_sold_total, 0), coalesce(t4.history_total, 0),
		coalesce(t5.history_unique_order_total, 0), coalesce(t6.history_unique_kid_total, 0),
		cast(t7.history_min_ts as timestamp), cast(t7.history_max_ts as timestamp), coalesce(t8.history_last_kid, 0), coalesce(t9.spoilage_total, 0)
	
		from
			(select distinct epc
				from pantry.label l
			 		join pantry.kiosk k on l.kiosk_id = k.id and k.campus_id = 87
				where to_timestamp(time_added) between start_date and end_date
					and product_id in (select unnest(product_list))
			)t0
			
		left join 
			-- label table: number of records
			(
			select epc, count(*) label_total 
				from pantry.label
				where to_timestamp(time_added) between start_date and end_date
			 	group by epc
			)t1 on t0.epc = t1.epc
			
		left join 
			-- label table: number of records with order_id
			(
			select epc, count(*) label_order_total 
				from pantry.label
				where to_timestamp(time_added) between start_date and end_date
				and order_id is not null 
			 	group by epc
			)t2 on t0.epc = t2.epc
			
		left join 
			-- label table: number of records with order_id and status = sold
			(
			select epc, count(*) label_order_sold_total 
				from pantry.label
				where to_timestamp(time_added) between start_date and end_date
				and order_id is not null and status='sold'
			 	group by epc
			)t3 on t0.epc = t3.epc
			
		left join
			-- history table: number of records
			(select h.epc, count(*) history_total 
			 	from 
			 
					(select distinct epc
						from pantry.label
						where to_timestamp(time_added) between start_date and end_date
					) l
				join pantry.history h on l.epc = h.epc
				group by h.epc
			)t4  on t0.epc = t4.epc
			
		left join
			-- history table: number of unique order
			(select h.epc, count(distinct h.order_id) history_unique_order_total 
			 	from 
					(select distinct epc
						from pantry.label
						where to_timestamp(time_added) between start_date and end_date
					) l
				join pantry.history h on l.epc = h.epc and h.order_id is not null
				group by h.epc
			)t5 on t0.epc = t5.epc
			
		left join
			-- history table: number of unique kid 
			(select h.epc, count(distinct h.kiosk_id) history_unique_kid_total 
				from 
					(select distinct epc
						from pantry.label
						where to_timestamp(time_added) between start_date and end_date
					) l
				join pantry.history h on l.epc = h.epc and h.kiosk_id is not null
				group by h.epc
			)t6 on t0.epc = t6.epc
			
		left join
		-- history table: min and max record time
		(select h.epc, min(to_timestamp(time)) history_min_ts, max(to_timestamp(time)) history_max_ts
			from 
				(select distinct epc
					from pantry.label
					where to_timestamp(time_added) between start_date and end_date
				) l
			join pantry.history h on l.epc = h.epc
		 	group by h.epc
		)t7 on t0.epc = t7.epc
		
		left join
		-- history table: last kid
			(select h_disctinct_last_kid.epc, h_disctinct_last_kid.kiosk_id history_last_kid
				from 
					(select distinct epc
						from pantry.label
						where to_timestamp(time_added) between start_date and end_date
					) l
					join 
					(select distinct epc, kiosk_id
					 from
						(select epc, kiosk_id, to_timestamp(time) ts,
								rank() over (partition by epc order by time desc) r
						from pantry.history
						where kiosk_id is not null
						) h_last_kid) h_disctinct_last_kid
					on l.epc = h_disctinct_last_kid.epc
			)t8 on t0.epc = t8.epc
		
		left join
		-- Spoilage table indicator for each EPC: number of records
		(select s.epc, count(*) spoilage_total
			from
				(select distinct epc
					from pantry.label
					where to_timestamp(time_added) between start_date and end_date
				) l
				join pantry.spoilage s on l.epc = s.epc
				group by s.epc
		)t9 on t0.epc = t9.epc;
end;

$$;


ALTER FUNCTION beta.get_label_stats_v0(start_date date, end_date date, product_list integer[]) OWNER TO dbservice;

--
-- Name: pick_audit(date, date); Type: FUNCTION; Schema: beta; Owner: dbservice
--

CREATE FUNCTION beta.pick_audit(start_date date, end_date date DEFAULT NULL::date) RETURNS TABLE(kiosk_id integer, route_date date, restocker text, product_id integer, pick_qty integer, restock_qty integer, discrepancy integer)
    LANGUAGE plpgsql
    AS $$

/*
Purpose - compare pick to restock
Input - 
	start_date: first pick date to consider
	end_date: last pick date to consider. If not given, compute the result for only start_date
Output - 
	kiosk_id: id for kiosk
	route_date: delivery date
	kiosk_title: kiosk name
	product_id: what picked/allocated
	pick_qty: quantity above product_id picked
	restock_qty: quantity of above product_id for the same route_date
	discrepancy: restock_qty - pick_quantity for target_date  
*/

declare target_date date;
declare pick_window_start timestamp with time zone;
declare pick_window_end timestamp with time zone;
begin
	set timezone to 'US/Pacific';
	return query
		select a.kiosk_id, a.route_date, r.restocker, a.sku_id, cast(sum(a.qty) as integer), 
			coalesce(cast(sum(l.total) as integer), 0), cast(coalesce(sum(l.total), 0) - sum(a.qty) as integer)
			from inm.pick_allocation a 
			left join 
				(select to_timestamp(time_created)::date restock_date, pantry.label.kiosk_id, pantry.label.product_id, count(*) total
					from pantry.label group by 1,2,3) l
					on a.route_date = l.restock_date and a.kiosk_id=l.kiosk_id and a.sku_id = l.product_id
			left join 
					-- restocker
					(select distinct to_timestamp(created)::date route_date, o.kiosk_id, first_name || ' ' || last_name restocker from pantry.order o
						where order_id like 'RE%' and to_timestamp(created)::date between start_date and end_date + 1 order by 1,2) r
					on r.route_date = a.route_date and r.kiosk_id = a.kiosk_id
			where a.route_date between start_date and end_date
		group by 1, 2, 3, 4;
end;

$$;


ALTER FUNCTION beta.pick_audit(start_date date, end_date date) OWNER TO dbservice;

--
-- Name: pick_get_delivery_schedule_optimo(date); Type: FUNCTION; Schema: beta; Owner: dbservice
--

CREATE FUNCTION beta.pick_get_delivery_schedule_optimo(target_date date) RETURNS TABLE(driver_name character varying, route_date_time timestamp with time zone, kiosk_id integer, kiosk_title character varying, address character varying, delivery_order integer)
    LANGUAGE plpgsql
    AS $$

	declare latest_import_ts timestamp;
	declare plan_window_start timestamp;
	declare plan_window_stop timestamp;

/*
Purpose: return INM delivery schedule for a pick window.
Input
	target_date: pick_date
Return
	Data to generate the drivers sheets
*/
begin
	-- calculate various date params
	select max(import_ts) from mixalot.inm_data into latest_import_ts;
	select i.route_date from mixalot.inm_data i
		where import_ts = latest_import_ts and data_type = 'Plan Window Start'
		into plan_window_start;
	select i.route_date from mixalot.inm_data i
		where import_ts = latest_import_ts and data_type = 'Plan Window Stop'
		into plan_window_stop;
	
	return query
		select rs.driver_name, rs.route_date_time, location_number kiosk_id, k.title kiosk_title, k.address, rs.stop_number delivery_order
			from mixalot.route_stop rs join pantry.kiosk k on rs.location_number = k.id
			where rs.route_date_time between plan_window_start and plan_window_stop;
end;

$$;


ALTER FUNCTION beta.pick_get_delivery_schedule_optimo(target_date date) OWNER TO dbservice;

--
-- Name: pick_get_order_by_sales_4wk(timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: beta; Owner: dbservice
--

CREATE FUNCTION beta.pick_get_order_by_sales_4wk(start_ts timestamp with time zone, end_ts timestamp with time zone) RETURNS TABLE(kiosk_id integer, route_date_time timestamp with time zone, sku_group_id integer, fc_title character varying, plan_qty integer)
    LANGUAGE plpgsql ROWS 10000
    AS $$

/*
Purpose - return INM order for the next sale period which is the time between the deliveries of this pick and the next pick
Input -
  start_ts: plan window start date time with time zone
  end_ts: plan window end date time with time zone
Return -
  kiosk_id: together with route_date_time is unique for the plan window
  route_date_time: route starting date time
  fc_title: sku group name
  plan_qty: order quantity for the above fc_title for the next sale period
*/

-- FIX ME: 
-- handle missing past data
-- check kid with multiple deliveries
begin
	return query
		select four_weeks.kiosk_id, four_weeks.route_date_time, four_weeks.id, four_weeks.fc_title, cast (sum(qty) as integer)
		from
			(-- week -1
			select pk.kiosk_id, pk.route_date_time, sga.id, p.fc_title, count(*) qty
				from inm.pick_get_plan_kiosk(start_ts, end_ts) pk
					join pantry.label l on pk.kiosk_id=l.kiosk_id
					join pantry.product p on l.product_id = p.id
					left join inm.sku_group_attribute sga on sga.title = p.fc_title
					where l.status in ('out', 'sold') and to_timestamp(l.time_updated) between pk.route_date_time - interval '7 days' and pk.next_delivery_ts - interval '7 days'
					group by 1,2,3,4
			union
			-- week -2
			select pk.kiosk_id, pk.route_date_time, sga.id, p.fc_title, count(*) qty
				from inm.pick_get_plan_kiosk(start_ts, end_ts) pk
					join pantry.label l on pk.kiosk_id=l.kiosk_id
					join pantry.product p on l.product_id = p.id
					left join inm.sku_group_attribute sga on sga.title = p.fc_title
					where l.status in ('out', 'sold') and to_timestamp(l.time_updated) between pk.route_date_time - interval '14 days' and pk.next_delivery_ts - interval '14 days'
					group by 1,2,3,4
			union
			-- week -3
			select pk.kiosk_id, pk.route_date_time, sga.id, p.fc_title, count(*) qty
				from inm.pick_get_plan_kiosk(start_ts, end_ts) pk
					join pantry.label l on pk.kiosk_id=l.kiosk_id
					join pantry.product p on l.product_id = p.id
					left join inm.sku_group_attribute sga on sga.title = p.fc_title
					where l.status in ('out', 'sold') and to_timestamp(l.time_updated) between pk.route_date_time - interval '21 days' and pk.next_delivery_ts - interval '21 days'
					group by 1,2,3,4

			union
			-- week -4
			select pk.kiosk_id, pk.route_date_time, sga.id, p.fc_title, count(*) qty
				from inm.pick_get_plan_kiosk(start_ts, end_ts) pk
					join pantry.label l on pk.kiosk_id=l.kiosk_id
					join pantry.product p on l.product_id = p.id
					left join inm.sku_group_attribute sga on sga.title = p.fc_title
					where l.status in ('out', 'sold') and to_timestamp(l.time_updated) between pk.route_date_time - interval '28 days' and pk.next_delivery_ts - interval '28 days'
					group by 1,2,3,4
				) four_weeks
				
				group by 1, 2, 3, 4;
	end;

$$;


ALTER FUNCTION beta.pick_get_order_by_sales_4wk(start_ts timestamp with time zone, end_ts timestamp with time zone) OWNER TO dbservice;

--
-- Name: pick_get_order_by_sales_4wk_avg(timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: beta; Owner: dbservice
--

CREATE FUNCTION beta.pick_get_order_by_sales_4wk_avg(start_ts timestamp with time zone, end_ts timestamp with time zone) RETURNS TABLE(kiosk_id integer, route_date_time timestamp with time zone, sku_group_id integer, fc_title character varying, plan_qty integer)
    LANGUAGE plpgsql ROWS 10000
    AS $$

/*
Purpose - return INM order for the next sale period which is the time between the deliveries of this pick and the next pick
Input -
  start_ts: plan window start date time with time zone
  end_ts: plan window end date time with time zone
Return -
  kiosk_id: together with route_date_time is unique for the plan window
  route_date_time: route starting date time
  fc_title: sku group name
  plan_qty: order quantity for the above fc_title for the next sale period
*/

-- FIX ME: 
-- check kid with multiple deliveries
begin
	return query
		select q.kiosk_id, q.route_date_time, q.sku_group_id, q.fc_title, cast(ceiling(q.plan_qty/a.weeks_with_sales) as integer)
			from inm.pick_get_order_by_sales_4wks_availability(start_ts, end_ts) a
			join inm.pick_get_order_by_sales_4wk(start_ts, end_ts) q
			on a.kiosk_id = q.kiosk_id;
end;

$$;


ALTER FUNCTION beta.pick_get_order_by_sales_4wk_avg(start_ts timestamp with time zone, end_ts timestamp with time zone) OWNER TO dbservice;

--
-- Name: pick_get_order_by_sales_4wks_availability(timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: beta; Owner: dbservice
--

CREATE FUNCTION beta.pick_get_order_by_sales_4wks_availability(start_ts timestamp with time zone, end_ts timestamp with time zone) RETURNS TABLE(kiosk_id integer, weeks_with_sales smallint)
    LANGUAGE plpgsql ROWS 10000
    AS $$

/*
Purpose - return sales data availability for the last 4 weeks
Input -
  start_ts: plan window start date time with time zone
  end_ts: plan window end date time with time zone
Return -
  kiosk_id: together with route_date_time is unique for the plan window
  route_date_time: route starting date time
  week_count: 0-4 which indicates the number of weeks sales data is available
*/

begin
	return query
		select weeks_available.kiosk_id, cast(sum(available) as smallint)
		from
			(
			-- week -1
			select wk_minus_1.kiosk_id,
				case when count(*) >= 1 then 1 else 0 end as available from
				(select pk.kiosk_id, count(*)
					from inm.pick_get_plan_kiosk(start_ts, end_ts) pk
					join pantry.label l on pk.kiosk_id=l.kiosk_id
					where l.status in ('out', 'sold') and to_timestamp(l.time_updated) between pk.route_date_time - interval '7 days' and pk.next_delivery_ts - interval '7 days'
					group by 1) wk_minus_1
					group by 1
					
			union all 
			-- week -2
			select wk_minus_2.kiosk_id,
				case when count(*) >= 1 then 1 else 0 end as available from
				(select pk.kiosk_id, count(*)
					from inm.pick_get_plan_kiosk(start_ts, end_ts) pk
					join pantry.label l on pk.kiosk_id=l.kiosk_id
					where l.status in ('out', 'sold') and to_timestamp(l.time_updated) between pk.route_date_time - interval '14 days' and pk.next_delivery_ts - interval '14 days'
					group by 1) wk_minus_2
					group by 1
			
			union all
			-- week -3
			select wk_minus_3.kiosk_id,
				case when count(*) >= 1 then 1 else 0 end as available from
				(select pk.kiosk_id, count(*)
					from inm.pick_get_plan_kiosk(start_ts, end_ts) pk
					join pantry.label l on pk.kiosk_id=l.kiosk_id
					where l.status in ('out', 'sold') and to_timestamp(l.time_updated) between pk.route_date_time - interval '21 days' and pk.next_delivery_ts - interval '21 days'
					group by 1) wk_minus_3
					group by 1
				
			union all	
			-- week -4
			select wk_minus_4.kiosk_id,
				case when count(*) >= 1 then 1 else 0 end as available from
				(select pk.kiosk_id, count(*)
					from inm.pick_get_plan_kiosk(start_ts, end_ts) pk
					join pantry.label l on pk.kiosk_id=l.kiosk_id
					where l.status in ('out', 'sold') and to_timestamp(l.time_updated) between pk.route_date_time - interval '28 days' and pk.next_delivery_ts - interval '28 days'
					group by 1) wk_minus_4
					group by 1
			) weeks_available
			group by 1;
	end;

$$;


ALTER FUNCTION beta.pick_get_order_by_sales_4wks_availability(start_ts timestamp with time zone, end_ts timestamp with time zone) OWNER TO dbservice;

--
-- Name: sku_pick_order(timestamp with time zone); Type: FUNCTION; Schema: beta; Owner: dbservice
--

CREATE FUNCTION beta.sku_pick_order(target_ts timestamp with time zone) RETURNS TABLE(sku_id integer, pick_order integer)
    LANGUAGE plpgsql
    AS $$
declare latest_import_ts timestamp with time zone;

/*
Purpose: return a sku pick_order for the most recent import data for a given date
*/
begin
	select max(import_ts) from mixalot.inm_data
		where import_ts <= target_ts and data_type = 'Warehouse SKU Inventory'
		into latest_import_ts;
	
	return query
		select distinct product_id, d.sort_order
		  from mixalot.inm_data d
		  where import_ts = latest_import_ts and data_type = 'Warehouse SKU Inventory'
	  	and qty > 0;	
end;

$$;


ALTER FUNCTION beta.sku_pick_order(target_ts timestamp with time zone) OWNER TO dbservice;

--
-- Name: test_insert(integer, integer); Type: FUNCTION; Schema: beta; Owner: dbservice
--

CREATE FUNCTION beta.test_insert(n integer, m integer, OUT submitted_data integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$

/*
Purpose - Submit a pick with task_option controlling how to deal with conflict.

Input -
  target_date: pick date
  overwrite: 0 or 1. If 1, overwrite old pick.
  timeout_seconds: minimum amount of time the task can be in status = "started" before it's considered timed out 
Return -
  submitted_status:
  	submitted - pick submitted.
	started - a pick already in progress for target date.
	ready - a completed pick already existed (and overwrite=0)
*/

begin
	insert into beta.test(n) values (n+m);
	submitted_data = n+m;
end;

$$;


ALTER FUNCTION beta.test_insert(n integer, m integer, OUT submitted_data integer) OWNER TO dbservice;

--
-- Name: fn_kiosk_audit_log_insert(); Type: FUNCTION; Schema: fnrenames; Owner: dbservice
--

CREATE FUNCTION fnrenames.fn_kiosk_audit_log_insert() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
INSERT INTO pantry.kiosk_audit_log (
    kiosk_id, archived, enable_reporting, enable_monitoring
) VALUES (
    NEW.id, NEW.archived, NEW.enable_reporting, NEW.enable_monitoring
);
RETURN NEW;
END;
$$;


ALTER FUNCTION fnrenames.fn_kiosk_audit_log_insert() OWNER TO dbservice;

--
-- Name: fn_kiosk_audit_log_update(); Type: FUNCTION; Schema: fnrenames; Owner: dbservice
--

CREATE FUNCTION fnrenames.fn_kiosk_audit_log_update() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
IF (
 NEW.archived != OLD.archived
 OR
 NEW.enable_reporting != OLD.enable_reporting
 OR
 NEW.enable_monitoring != OLD.enable_monitoring
) THEN
 INSERT INTO pantry.kiosk_audit_log (
    kiosk_id, archived, enable_reporting, enable_monitoring
 ) VALUES (
    OLD.id, NEW.archived, NEW.enable_reporting, NEW.enable_monitoring
);
END IF;
RETURN NEW;
END;
$$;


ALTER FUNCTION fnrenames.fn_kiosk_audit_log_update() OWNER TO dbservice;

--
-- Name: fn_ro_order_update_full_price(character varying); Type: FUNCTION; Schema: fnrenames; Owner: dbservice
--

CREATE FUNCTION fnrenames.fn_ro_order_update_full_price(orderid character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
    orderid varchar(135);
BEGIN
UPDATE pantry.ro_order
SET
    real_full_price = rt.rfp, full_price = ft.fp, created = rt.tc
FROM (
    SELECT
        CASE WHEN (o.state <> 'NonTrans')
            THEN
                COALESCE(SUM(l.price), 0)
            ELSE
                0
            END AS rfp,
            o.order_id,
            date_part('epoch', CURRENT_TIMESTAMP)::int as tc
    FROM pantry.label l
    JOIN pantry.order o ON o.order_id = l.order_id
    WHERE l.order_id = orderid
    GROUP BY o.order_id
) rt JOIN (
    SELECT
        CASE WHEN (o.state <> 'NonTrans')
            THEN
                COALESCE(SUM(l.price), 0)
            ELSE
                0
            END AS fp,
        o.order_id
    FROM pantry.label l
    JOIN pantry.order o ON o.order_id = l.order_id
    JOIN pantry.kiosk k ON k.id = o.kiosk_id
    JOIN pantry.product p ON p.id = l.product_id
    JOIN pantry.group_campus gc1 ON gc1.campus_id = k.campus_id AND gc1.owner = 1
    JOIN pantry.group_campus gc2 ON gc2.campus_id = p.campus_id AND gc2.owner = 1
    WHERE l.order_id = orderid
    AND gc1.group_id = gc2.group_id
    GROUP BY o.order_id
) ft ON rt.order_id = ft.order_id
WHERE ro_order.order_id = orderid;
END
$$;


ALTER FUNCTION fnrenames.fn_ro_order_update_full_price(orderid character varying) OWNER TO dbservice;

--
-- Name: pg_create_logical_replication_slot(name, name, boolean); Type: FUNCTION; Schema: fnrenames; Owner: dbservice
--

CREATE FUNCTION fnrenames.pg_create_logical_replication_slot(slot_name name, plugin name, temporary boolean DEFAULT false, OUT slot_name name, OUT xlog_position pg_lsn) RETURNS record
    LANGUAGE sql
    AS $$
   SELECT slot_name::NAME, lsn::pg_lsn FROM pg_catalog.pg_create_logical_replication_slot(slot_name, plugin,
   temporary); $$;


ALTER FUNCTION fnrenames.pg_create_logical_replication_slot(slot_name name, plugin name, temporary boolean, OUT slot_name name, OUT xlog_position pg_lsn) OWNER TO dbservice;

--
-- Name: pg_current_xlog_flush_location(); Type: FUNCTION; Schema: fnrenames; Owner: dbservice
--

CREATE FUNCTION fnrenames.pg_current_xlog_flush_location() RETURNS pg_lsn
    LANGUAGE sql
    AS $$
   SELECT pg_current_wal_flush_lsn(); $$;


ALTER FUNCTION fnrenames.pg_current_xlog_flush_location() OWNER TO dbservice;

--
-- Name: pg_current_xlog_insert_location(); Type: FUNCTION; Schema: fnrenames; Owner: dbservice
--

CREATE FUNCTION fnrenames.pg_current_xlog_insert_location() RETURNS pg_lsn
    LANGUAGE sql
    AS $$
   SELECT pg_current_wal_insert_lsn(); $$;


ALTER FUNCTION fnrenames.pg_current_xlog_insert_location() OWNER TO dbservice;

--
-- Name: pg_current_xlog_location(); Type: FUNCTION; Schema: fnrenames; Owner: dbservice
--

CREATE FUNCTION fnrenames.pg_current_xlog_location() RETURNS pg_lsn
    LANGUAGE sql
    AS $$
   SELECT pg_current_wal_lsn(); $$;


ALTER FUNCTION fnrenames.pg_current_xlog_location() OWNER TO dbservice;

--
-- Name: pg_is_xlog_replay_paused(); Type: FUNCTION; Schema: fnrenames; Owner: dbservice
--

CREATE FUNCTION fnrenames.pg_is_xlog_replay_paused() RETURNS boolean
    LANGUAGE sql
    AS $$
   SELECT pg_is_wal_replay_paused(); $$;


ALTER FUNCTION fnrenames.pg_is_xlog_replay_paused() OWNER TO dbservice;

--
-- Name: pg_last_xlog_receive_location(); Type: FUNCTION; Schema: fnrenames; Owner: dbservice
--

CREATE FUNCTION fnrenames.pg_last_xlog_receive_location() RETURNS pg_lsn
    LANGUAGE sql
    AS $$
   SELECT pg_last_wal_receive_lsn(); $$;


ALTER FUNCTION fnrenames.pg_last_xlog_receive_location() OWNER TO dbservice;

--
-- Name: pg_last_xlog_replay_location(); Type: FUNCTION; Schema: fnrenames; Owner: dbservice
--

CREATE FUNCTION fnrenames.pg_last_xlog_replay_location() RETURNS pg_lsn
    LANGUAGE sql
    AS $$
   SELECT pg_last_wal_replay_lsn(); $$;


ALTER FUNCTION fnrenames.pg_last_xlog_replay_location() OWNER TO dbservice;

--
-- Name: pg_switch_xlog(); Type: FUNCTION; Schema: fnrenames; Owner: dbservice
--

CREATE FUNCTION fnrenames.pg_switch_xlog() RETURNS pg_lsn
    LANGUAGE sql
    AS $$
   SELECT pg_switch_wal(); $$;


ALTER FUNCTION fnrenames.pg_switch_xlog() OWNER TO dbservice;

--
-- Name: pg_xlog_location_diff(pg_lsn, pg_lsn); Type: FUNCTION; Schema: fnrenames; Owner: dbservice
--

CREATE FUNCTION fnrenames.pg_xlog_location_diff(lsn1 pg_lsn, lsn2 pg_lsn) RETURNS numeric
    LANGUAGE sql
    AS $$
   SELECT pg_wal_lsn_diff(lsn1, lsn2); $$;


ALTER FUNCTION fnrenames.pg_xlog_location_diff(lsn1 pg_lsn, lsn2 pg_lsn) OWNER TO dbservice;

--
-- Name: pg_xlog_replay_pause(); Type: FUNCTION; Schema: fnrenames; Owner: dbservice
--

CREATE FUNCTION fnrenames.pg_xlog_replay_pause() RETURNS void
    LANGUAGE sql
    AS $$
   SELECT pg_wal_replay_pause(); $$;


ALTER FUNCTION fnrenames.pg_xlog_replay_pause() OWNER TO dbservice;

--
-- Name: pg_xlog_replay_resume(); Type: FUNCTION; Schema: fnrenames; Owner: dbservice
--

CREATE FUNCTION fnrenames.pg_xlog_replay_resume() RETURNS void
    LANGUAGE sql
    AS $$
   SELECT pg_wal_replay_resume(); $$;


ALTER FUNCTION fnrenames.pg_xlog_replay_resume() OWNER TO dbservice;

--
-- Name: pg_xlogfile_name(pg_lsn); Type: FUNCTION; Schema: fnrenames; Owner: dbservice
--

CREATE FUNCTION fnrenames.pg_xlogfile_name(lsn pg_lsn) RETURNS text
    LANGUAGE sql
    AS $$
   SELECT pg_walfile_name(lsn); $$;


ALTER FUNCTION fnrenames.pg_xlogfile_name(lsn pg_lsn) OWNER TO dbservice;

--
-- Name: pg_xlogfile_name_offset(pg_lsn); Type: FUNCTION; Schema: fnrenames; Owner: dbservice
--

CREATE FUNCTION fnrenames.pg_xlogfile_name_offset(lsn pg_lsn, OUT text, OUT integer) RETURNS record
    LANGUAGE sql
    AS $$
   SELECT pg_walfile_name_offset(lsn); $$;


ALTER FUNCTION fnrenames.pg_xlogfile_name_offset(lsn pg_lsn, OUT text, OUT integer) OWNER TO dbservice;

--
-- Name: pick_get_order_with_velocity(timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: fnrenames; Owner: dbservice
--

CREATE FUNCTION fnrenames.pick_get_order_with_velocity(start_ts timestamp with time zone, end_ts timestamp with time zone) RETURNS TABLE(kiosk_id integer, route_date_time timestamp with time zone, sku_group_id integer, fc_title text, week_demand_qty numeric, plan_demand_qty numeric, plan_order_qty numeric)
    LANGUAGE plpgsql
    AS $$
  /*
  Purpose - return INM order based on sales ratio for pick sales period (time between deliveries)
  Input -
    start_ts: plan window start date time with time zone
    end_ts: plan window end date time with time zone
  Return -
    kiosk_id: together with route_date_time is unique for the plan window
    route_date_time: route starting date time
    fc_title: sku group name
    week_demand_qty: demand based on once a week delivery (without minimum)
    plan_demand_qty: demand based on sales ratio for pick sales period (without minimum)
    plan_order_qty: order based on sales ratio for pick sales period
  */

begin
	return query
		--  Given
		--		sales period = time between this pick delivery and next pick delivery (may be changed to pick times in the future)
		--		inm.demand_weekly = week demand
		--		sr.sales_ratio = sale ratio for this sum items sold for pick sales period for the last 4 weeks vs items sold for the last 4 weeks 
		-- 	if item is restricted (inm_qty=0), then set demand to 0. 
		--  else 
		--		if item doesn't exist in the kiosk (inv.count is null), set its inv count to 0
		-- 		order_before_min_max = 2.0 * sr.sales_ratio * inm.demand_weekly - inv.count
		-- 		final_order = min + order_before_min_max, capped by max as defined for each sku group
	  -- 20190213, changed 1.4 to 2.0 to increase levels in the kiosks
		
		select sr.kiosk_id, sr.route_date_time, sga.id, dwbv.fc_title, dwbv.demand_weekly as week_demand_qty, 
			cast(2.0 * sr.sales_ratio * dwbv.demand_weekly as numeric (8,2)) plan_demand_qty,
			case 
				-- restricted item if demand_weekly is 0 or kiosk_sku_group manual scale is zero
				when dwbv.demand_weekly = 0 or ksms.scale = 0.0 then 0 
				else
					ceiling(
						-- change minimum is 0 (don't remove from a kiosk)
						least(greatest(least(2.0 * sr.sales_ratio * dwbv.demand_weekly, dwbv.demand_weekly) + sga.minimum_kiosk_qty - coalesce(inv.count, 0),
											  0) /* change negative demand to 0 */
								   , sga.maximum_kiosk_qty))
			end as plan_order_qty -- end case
					   
			from inm.pick_get_sales_period_ratio(start_ts, end_ts) sr
			
				join inm.pick_get_demand_weekly_by_velocity() dwbv
					on sr.kiosk_id = dwbv.kiosk_id 
												
				join inm.sku_group_attribute sga
					on sga.title = dwbv.fc_title			
				left join inm.kiosk_projected_stock inv
					on dwbv.kiosk_id = inv.kiosk_id and dwbv.fc_title = inv.fc_title
				left join inm.kiosk_sku_group_manual_scale ksms
					on sr.kiosk_id = ksms.kiosk_id and sga.id = ksms.sku_group_id;				
	end;

$$;


ALTER FUNCTION fnrenames.pick_get_order_with_velocity(start_ts timestamp with time zone, end_ts timestamp with time zone) OWNER TO dbservice;

--
-- Name: allocation_ratio_by_sku_group(date); Type: FUNCTION; Schema: inm; Owner: dbservice
--

CREATE FUNCTION inm.allocation_ratio_by_sku_group(target_date date) RETURNS TABLE(sku_group character varying, warehouse_qty bigint, order_total bigint, allocation_total bigint, allocation_percentage integer)
    LANGUAGE plpgsql
    AS $$

begin
	return query
		select a.fc_title, inv.total , o.order_total, a.allocation_total,  cast(100*a.allocation_total/cast(o.order_total as decimal) as integer) allocation_percentage
			from
				(select pick_date, sku_group_id, sum(qty) order_total
				from inm.pick_demand
				group by 1,2) o
			left join
				(select pick_date, sgs.fc_title, sgs.sku_group_id, sum(qty) allocation_total
				from inm.pick_allocation a
				join inm.view_sku_sku_group sgs
				on a.sku_id = sgs.product_id
				group by 1,2,3)a
				on a.pick_date = o.pick_date and o.sku_group_id = a.sku_group_id
				
			left join
				(select sgs.fc_title, sum(qty) total 
				 	from mixalot.inm_data i
				 		join inm.view_sku_sku_group sgs
							on i.product_id = sgs.product_id
					where import_ts = (select max(import_ts) from mixalot.inm_data 
									   where import_ts::date = target_date) and data_type = 'Warehouse SKU Inventory'
				 	group by 1				 
					) inv
					
				on a.fc_title = inv.fc_title
			where a.pick_date = target_date;
end

$$;


ALTER FUNCTION inm.allocation_ratio_by_sku_group(target_date date) OWNER TO dbservice;

--
-- Name: allocation_ratio_by_sku_group_test(date); Type: FUNCTION; Schema: inm; Owner: dbservice
--

CREATE FUNCTION inm.allocation_ratio_by_sku_group_test(target_date date) RETURNS TABLE(sku_group character varying, order_total bigint, allocation_total bigint, allocation_percentage integer)
    LANGUAGE plpgsql
    AS $$

begin
	return query
		select a.fc_title, o.order_total, a.allocation_total,  cast(100*a.allocation_total/cast(o.order_total as decimal) as integer) allocation_percentage
			from
				(select pick_date, sku_group_id, sum(qty) order_total
				from inm.pick_demand
				group by 1,2) o
			left join
				(select pick_date, sgs.fc_title, sgs.sku_group_id, sum(qty) allocation_total
				from inm.pick_allocation a
				join inm.view_sku_sku_group sgs
				on a.sku_id = sgs.product_id
				group by 1,2,3)a
				on a.pick_date = o.pick_date and o.sku_group_id = a.sku_group_id;
				
end

$$;


ALTER FUNCTION inm.allocation_ratio_by_sku_group_test(target_date date) OWNER TO dbservice;

--
-- Name: f_kiosk_sku_group_sku_pick_stats(timestamp with time zone); Type: FUNCTION; Schema: inm; Owner: dbservice
--

CREATE FUNCTION inm.f_kiosk_sku_group_sku_pick_stats(pick_time timestamp with time zone) RETURNS TABLE(kiosk_id integer, sku_group character varying, sku_group_id integer, sku integer, kiosk_on_route integer, kiosk_sku_enabled integer, kiosk_priority integer, sku_priority integer, sku_group_demand_week integer, kiosk_demand_plan_ratio numeric, sku_group_inventory_qty integer, sku_inventory_actual_qty integer, sku_group_inventory_actual_qty integer, sku_group_min_qty integer, sku_group_order_qty integer, sku_group_allocation_total integer, sku_allocation_qty integer, fleet_sku_group_order_total integer, fleet_sku_group_allocation_total integer, fleet_sku_allocation_total integer, warehouse_sku_inventory_stickered integer, warehouse_sku_inventory_unstickered integer, warehouse_sku_group_inventory_stickered integer, warehouse_sku_group_inventory_unstickered integer, substituted character varying, substituted_qty character varying, substituting character varying, substituting_qty character varying, sku_rejection integer, sku_preference_velocity numeric, sku_preference_normalized integer)
    LANGUAGE plpgsql
    AS $$

begin
  return query
    -- TODO: improve inventory actual computation
    select k.kiosk_id::int kiosk_id,
           p.sku_group sku_group,
           sg.sku_group_id sku_group_id,
           p.sku::int sku,
           coalesce(pr.on_route, 0) kiosk_on_route,
           coalesce(kpd.enabled, 1) kiosk_sku_enabled,
           coalesce(ppk.priority, 100) kiosk_priority,
           coalesce(pps.priority, 100) sku_priority,
           coalesce(pgo.demand_week, 0) sku_group_demand_week,
           coalesce(kdpr.kiosk_demand_plan_ratio, 0) kiosk_demand_plan_ratio,
           coalesce(pi.inventory_qty, 0) sku_group_inventory_qty,
           coalesce(l.stock_count, 0)::int sku_inventory_actual_qty,
           coalesce(sum(l.stock_count) over (partition by sg.sku_group, k.kiosk_id), 0)::int sku_group_inventory_actual_qty,
           coalesce(sga.sku_group_min_qty, 0) sku_group_min_qty,
           coalesce(pd.order_qty, 0) sku_group_order_qty,
           coalesce(sum(pa.allocation_qty) over (partition by sg.sku_group, k.kiosk_id), 0)::int sku_group_allocation_total,
           coalesce(pa.allocation_qty, 0) sku_allocation_qty,
           coalesce((sum(pd.order_qty) over (partition by sg.sku_group))/(count(p.sku) over (partition by sg.sku_group, k.kiosk_id)), 0)::int fleet_sku_group_order_total,
           coalesce(sum(pa.allocation_qty) over (partition by sg.sku_group), 0)::int fleet_sku_group_allocation_total,
           coalesce(sum(pa.allocation_qty) over (partition by p.sku), 0)::int fleet_sku_allocation_total,
           coalesce(wi.inventory_stickered, 0) warehouse_sku_inventory_stickered,
           coalesce(wi.inventory_unstickered, 0) warehouse_sku_inventory_unstickered,
           coalesce(sum(wi.inventory_stickered) over (partition by sg.sku_group, k.kiosk_id), 0)::int warehouse_sku_group_inventory_stickered,
           coalesce(sum(wi.inventory_unstickered) over (partition by sg.sku_group, k.kiosk_id), 0)::int warehouse_sku_group_inventory_unstickered,
           ps.substituted::varchar substituted,
           ps.substituted_qty::varchar substituted_qty,
           ps2.substituting::varchar substituting,
           ps2.substituting_qty::varchar substituting_qty,
           coalesce(pre.rejection, 0)::int sku_rejection,
           ksv.preference sku_preference_velocity,
           ppks.preference::int sku_preference_normalized
    from (
           select k.id as kiosk_id
           from pantry.kiosk k
           where k.campus_id=87
             and k.archived=0
             and k.enable_reporting=1
         ) k

           cross join (
      select p.fc_title sku_group,
             p.id sku
      from pantry.product p
      where p.campus_id=87
        and p.archived=0
        and p.fc_title is not null
        and p.fc_title!='N/A'
    ) p

           left join (
      select sg.fc_title sku_group,
             sg.id sku_group_id
      from inm.sku_group sg
    ) sg on p.sku_group=sg.sku_group

           left join (
      select pr.kiosk_id kiosk_id,
             1 on_route
      from inm.pick_route pr
      where pr.pick_date=pick_time::date
    ) pr on k.kiosk_id=pr.kiosk_id

           left join (
      -- warehouse inventory
      select wi.product_id sku,
             wi.units_per_case*wi.stickered_cases+wi.stickered_units inventory_stickered,
             wi.units_per_case*wi.unstickered_cases+wi.unstickered_units inventory_unstickered
      from inm.warehouse_inventory wi
      where wi.inventory_date=pick_time::date
    ) wi on p.sku=wi.sku

           left join (
      --  demand_week
      select pgo.kiosk_id kiosk_id,
             pgo.fc_title sku_group,
             pgo.week_qty demand_week
      from inm.pick_get_order(pick_time::date+interval '21 hours', pick_time::date+interval '43 hours') pgo
    ) pgo on k.kiosk_id=pgo.kiosk_id and p.sku_group=pgo.sku_group

           left join (
      -- kiosk inventory
      select pi.kiosk_id kiosk_id,
             pi.sku_group_id sku_group_id,
             pi.qty inventory_qty
      from inm.pick_inventory pi
      where pi.pick_date=pick_time::date
    ) pi on k.kiosk_id=pi.kiosk_id and sg.sku_group_id=pi.sku_group_id

           left join (
      -- order
      select pd.kiosk_id kiosk_id,
             pd.sku_group_id sku_group_id,
             pd.qty order_qty
      from inm.pick_demand pd
      where pd.pick_date=pick_time::date
    ) pd on k.kiosk_id=pd.kiosk_id and sg.sku_group_id=pd.sku_group_id

           left join (
      -- allocation
      select pa.kiosk_id kiosk_id,
             pa.sku_id sku,
             pa.qty allocation_qty
      from inm.pick_allocation pa
      where pa.pick_date=pick_time::date
    ) pa on k.kiosk_id=pa.kiosk_id and p.sku=pa.sku

           left join (
      select ppk.kiosk_id kiosk_id,
             ppk.priority priority
      from inm.pick_priority_kiosk ppk
    ) ppk on k.kiosk_id=ppk.kiosk_id

           left join (
      select pps.sku_id sku,
             pps.priority priority
      from inm.pick_priority_sku pps
    ) pps on p.sku=pps.sku

           left join (
      select kpd.kiosk_id kiosk_id,
             kpd.product_id sku,
             case when kpd.product_id is not null then 0
                  else 1
               end as enabled
      from inm.kiosk_product_disabled kpd
    ) kpd on k.kiosk_id=kpd.kiosk_id and p.sku=kpd.sku

           left join (
      select l.kiosk_id as kiosk_id,
             p.fc_title as sku_group,
             l.product_id as sku,
             count(*) as stock_count
      from pantry.label l
             left join pantry.product p
                       on l.product_id=p.id
      where to_timestamp(time_added) < pick_time
        and to_timestamp(time_updated) > pick_time
        and p.campus_id=87
        and p.archived=0
        and p.fc_title is not null
        and p.fc_title!='N/A'
      group by l.kiosk_id,
               p.fc_title,
               l.product_id
    ) l on k.kiosk_id=l.kiosk_id and p.sku=l.sku

           left join (
      select ps.substituting_sku_group_id sku_group_id,
             string_agg(ps.substituted_sku_group_id::text, ',' order by ps.substituted_sku_group_id asc) substituted,
             string_agg(ps.qty::text, ',' order by ps.substituted_sku_group_id) substituted_qty
      from inm.pick_substitution ps
      where ps.pick_date=pick_time::date
      group by ps.substituting_sku_group_id
    ) ps on sg.sku_group_id=ps.sku_group_id

           left join (
      select ps.substituted_sku_group_id sku_group_id,
             string_agg(ps.substituting_sku_group_id::text, ',' order by ps.substituting_sku_group_id asc) substituting,
             string_agg(ps.qty::text, ',' order by ps.substituting_sku_group_id) substituting_qty
      from inm.pick_substitution ps
      where ps.pick_date=pick_time::date
      group by ps.substituted_sku_group_id
    ) ps2 on sg.sku_group_id=ps2.sku_group_id

           left join (
      select pre.kiosk_id kiosk_id,
             pre.item_id  sku,
             count(pre.reason) as rejection
      from inm.pick_rejection pre
      where pre.pick_date=pick_time::date
        and item_type = 'sku_id'
      group by pre.kiosk_id,
               pre.item_id
    ) pre on k.kiosk_id=pre.kiosk_id and p.sku=pre.sku

           left join (
      select ksv.kiosk_id kiosk_id,
             ksv.sku sku,
             ksv.preference preference
      from inm.v_kiosk_sku_velocity ksv
    ) ksv on k.kiosk_id=ksv.kiosk_id and p.sku=ksv.sku

           left join (
      select ppks.kiosk_id kiosk_id,
             ppks.sku_id sku,
             ppks.preference preference
      from mixalot.pick_preference_kiosk_sku ppks
    ) ppks on k.kiosk_id=ppks.kiosk_id and p.sku=ppks.sku

           left join (
      select sga.id as sku_group_id,
             sga.minimum_kiosk_qty as sku_group_min_qty
      from inm.sku_group_attribute sga
    ) sga on sg.sku_group_id=sga.sku_group_id

           left join (
      select kdpr.kiosk_id kiosk_id,
             case when extract(dow from pick_time)=0 then d0_plan_demand_ratio
                  when extract(dow from pick_time)=1 then d1_plan_demand_ratio
                  when extract(dow from pick_time)=2 then d2_plan_demand_ratio
                  when extract(dow from pick_time)=3 then d3_plan_demand_ratio
                  when extract(dow from pick_time)=4 then d4_plan_demand_ratio
                  else 0
               end kiosk_demand_plan_ratio
      from inm.v_kiosk_demand_plan_ratio kdpr
    ) kdpr on k.kiosk_id=kdpr.kiosk_id

    order by k.kiosk_id asc,
             p.sku_group asc,
             p.sku asc;

end;

$$;


ALTER FUNCTION inm.f_kiosk_sku_group_sku_pick_stats(pick_time timestamp with time zone) OWNER TO dbservice;

--
-- Name: get_all_pull_list(integer); Type: FUNCTION; Schema: inm; Owner: dbservice
--

CREATE FUNCTION inm.get_all_pull_list(given_kiosk_id integer) RETURNS TABLE(category character varying, kiosk_id_ bigint, kiosk_title_ character varying, product_id_ bigint, product_tile_ character varying, epc character varying)
    LANGUAGE plpgsql
    AS $$
    BEGIN
        RETURN QUERY
        --- This function runs all pull_list functions.
        --- SEE ENG-555
        SELECT *
    FROM inm.get_spoilage_pull_list(given_kiosk_id)
 UNION ALL
 SELECT *
    FROM inm.get_performance_pull_list(given_kiosk_id);
        END;
$$;


ALTER FUNCTION inm.get_all_pull_list(given_kiosk_id integer) OWNER TO dbservice;

--
-- Name: get_performance_pull_list(integer); Type: FUNCTION; Schema: inm; Owner: dbservice
--

CREATE FUNCTION inm.get_performance_pull_list(given_kiosk_id integer) RETURNS TABLE(category character varying, kiosk_id_ integer, kiosk_title_ character varying, product_id_ integer, product_tile_ character varying, epc character varying)
    LANGUAGE plpgsql
    AS $$
    BEGIN
        RETURN QUERY
        /* This query is used to identify skus that do not sell well in a given kiosk. A poor
        performing sku meets the following criteria
          1. Qualifier - SKU has been present in the kiosk for 4 weeks (28 days)(not consecutive).
          2. Spoilage >= 30% of sales over 3 of the past 6 weeks.
          3. No sales in past 2 weeks when the item was available (there has to be a least one
          SKU present in the kiosk every single day of those 2 weeks) OR  less than 50% of sku fleet
           average (by month).
         SEE ENG-555
        This query takes less than a minute to run for 1 kiosk and 7 minutes to run for all kiosks
        */
        SELECT 'LOW PERFORMANCE'::varchar as category,
            SKU_performance_qualifiers.kid as kiosk_id_,
            SKU_performance_qualifiers.k_title as kiosk_title_,
            SKU_performance_qualifiers.pid as product_id_,
            SKU_performance_qualifiers.p_title as product_tile_,
            (SKU_performance_qualifiers.epc)::varchar as epc
            /* The following subquery selects all kiosk/sku combination that qualify to be analyzed
            for poor performance. A kiosk/sku combination qualifies to be analyzed for poor
            performance if a given sku has been present in a given kiosk for 28 days (4 weeks) non
            consecutively.
            */
            FROM (SELECT *
                --- How many days a given kiosk has seen a given sku
                FROM (SELECT kiosk_id as kid,
                product_id as pid,
                k_title,
                p_title,
                sum(status) as number_of_days_in_kiosk
                    /* List of all date/kiosk/sku combination and whether the given sku has been
                    seen by the given kiosk on a given day*/
                    FROM (SELECT kiosk_id,
                        product_id,
                        date::date,
                        k.title as k_title,
                        p.title as p_title,
                        --- per day, if a product was present in a given kiosk, status = 1, else 0
                        CASE WHEN count(*) > 0 THEN 1 else 0 END as status
                        FROM inventory_history ih
                        JOIN pantry.kiosk k
                        ON ih.kiosk_id = k.id
                        JOIN pantry.product p
                        ON ih.product_id = p.id
                        WHERE k.campus_id = 87
                        AND p.campus_id = 87
                        AND k.enable_reporting = 1
                        AND k.id = given_kiosk_id
                        AND k.archived = 0
                        AND p.archived = 0
                        GROUP BY kiosk_id, product_id, date, p.title, k.title
                    ) as sku_kiosk_status_per_day
                    GROUP BY kiosk_id, product_id, k_title, p_title
                ) as sum_days_product_in_kiosk
                JOIN (SELECT kiosk_id,
                        product_id,
                        l.epc
                        FROM pantry.label l
                        JOIN pantry.kiosk k on k.id  = l.kiosk_id
                        JOIN pantry.product p on p.id  = l.product_id
                        WHERE status = 'ok'
                        AND k.enable_reporting = 1
                        AND p.campus_id = 87
                        AND k.id = given_kiosk_id
                    ) as in_kiosk
                    ON sum_days_product_in_kiosk.kid = in_kiosk.kiosk_id
                    AND sum_days_product_in_kiosk.pid = in_kiosk.product_id
                WHERE number_of_days_in_kiosk >= 28
            ) as SKU_performance_qualifiers

            /* The following is set up to analyze if a given sku in a given kiosk has a spoilage % (
            (spoilage/sales)* 100) >= 30% over 3 of the past 6 weeks. To set this up, we will get a
            weekly spoilage for each sku per kiosk. We will then use LAG() OVER (PARTITION BY)
            in order to have all weeks spoilage values in one row. The row containing all
            spoilage values will be the 6th row of each kiosk/sku combination (week_rank = 6) */
            LEFT JOIN (SELECT week_rank,
                kid,
                k_title,
                pid,
                p_title,
                COALESCE(lag(second_week_spoilage) OVER (PARTITION BY kid, pid ORDER BY week_rank), 0)
                    as first_week_spoilage,
                second_week_spoilage,
                third_week_spoilage,
                fourth_week_spoilage,
                fifth_week_spoilage,
                spoilage_percent as sixth_week_spoilage
                FROM (SELECT *
                    FROM (SELECT *,
                        lag(third_week_spoilage) OVER (Partition by kid, pid ORDER BY week_rank)
                            as second_week_spoilage
                        FROM (SELECT *,
                            lag(fourth_week_spoilage) OVER (Partition by kid, pid ORDER BY week_rank)
                                as third_week_spoilage
                            FROM (SELECT *,
                                lag(fifth_week_spoilage) OVER (Partition by kid, pid ORDER BY week_rank)
                                    as fourth_week_spoilage
                                FROM (SELECT week,
                                    week_rank,
                                    kid,
                                    k_title,
                                    pid,
                                    p_title,
                                    spoilage_percent ,
                                    lag(spoilage_percent) OVER (Partition by kid, pid ORDER BY week_rank)
                                        as fifth_week_spoilage
                                    --- Calculate given sku in given kiosk spoilage per week
                                    FROM (SELECT all_weeks_kiosks_products.week,
                                        all_weeks_kiosks_products.week_rank,
                                        all_weeks_kiosks_products.kid,
                                        all_weeks_kiosks_products.k_title,
                                        all_weeks_kiosks_products.pid,
                                        all_weeks_kiosks_products.p_title,
                                        COALESCE(total_spoilage, 0) as spoilage,
                                        COALESCE(total_sales, 0) as total_sales,
                                        COALESCE(ROUND(100.0 * (COALESCE(total_spoilage, 0)/
                                            NULLIF(COALESCE(total_sales, 0),0)),2),0) as spoilage_percent
                                        --- Get all kiosks, products and weeks
                                        FROM (SELECT week_and_rank.week,
                                            kid,
                                            k_title,
                                            pid,
                                            p_title,
                                            week_and_rank.week_rank
                                            --- Get all weeks within the last 6 weeks, excluding this current week
                                            FROM (SELECT week,
                                                rank() OVER (ORDER BY week) as week_rank
                                                FROM (SELECT distinct(EXTRACT('week' FROM dd)) as week
                                                FROM generate_series( (NOW()::DATE-EXTRACT(DOW FROM NOW())::INTEGER -6)::date
                                                    - INTERVAL '6 weeks' , (NOW()::DATE-EXTRACT(DOW FROM NOW())::INTEGER -6)::date,
                                                    '1 day'::interval) dd
                                                ) as weeks
                                                GROUP BY week
                                            ) as week_and_rank
                                            --- Get all kiosks and skus
                                            CROSS JOIN (SELECT k.id as kid,
                                                k.title as k_title,
                                                p.id as pid,
                                                p.title as p_title
                                                FROM pantry.kiosk k
                                                CROSS JOIN
                                                pantry.product p
                                                WHERE k.campus_id = 87
                                                AND p.campus_id = 87
                                                AND k.enable_reporting = 1
                                                AND k.id = given_kiosk_id
                                                AND k.archived = 0
                                                AND p.archived = 0
                                            ) as kiosk_and_product
                                        ) as all_weeks_kiosks_products
                                        --- Get sales per week for the last 6 weeks (not including current week)
                                        LEFT JOIN (SELECT EXTRACT('week' FROM to_timestamp(created)::date)
                                                as week,
                                        l.kiosk_id,
                                        l.product_id,
                                        sum(l.price) as total_sales
                                        FROM byte_tickets bt
                                        JOIN pantry.label l
                                        ON bt.order_id = l.order_id
                                        WHERE to_timestamp(created)::date>= (NOW()::DATE-EXTRACT(DOW FROM NOW())::INTEGER
                                            -6)::date - INTERVAL '6 weeks'
                                        AND to_timestamp(created)::date <= (NOW()::DATE-EXTRACT(DOW FROM NOW())::INTEGER
                                            -7)::date
                                        GROUP BY l.kiosk_id, l.product_id, EXTRACT('week' FROM to_timestamp(created)::date)
                                        ) as sales_per_week
                                        ON all_weeks_kiosks_products.kid = sales_per_week.kiosk_id
                                        AND all_weeks_kiosks_products.pid = sales_per_week.product_id
                                        AND all_weeks_kiosks_products.week = sales_per_week.week
                                        --- Get spoilage per week for the last 6 weeks (not including current week)
                                        LEFT JOIN (SELECT EXTRACT('week' FROM date::date) as week,
                                        kiosk_id,
                                        product_id,
                                        sum(cost) as total_spoilage
                                        FROM byte_spoilage
                                        WHERE date::date>= (NOW()::DATE-EXTRACT(DOW FROM NOW())::INTEGER -6)::date
                                            - INTERVAL '6 weeks'
                                        AND date::date <= (NOW()::DATE-EXTRACT(DOW FROM NOW())::INTEGER -7)::date
                                        GROUP BY kiosk_id, product_id, EXTRACT('week' FROM date::date)
                                        ) as spoilage_per_week
                                        ON all_weeks_kiosks_products.kid = spoilage_per_week.kiosk_id
                                        AND all_weeks_kiosks_products.pid = spoilage_per_week.product_id
                                        AND all_weeks_kiosks_products.week = spoilage_per_week.week
                                    ) as spoilage_percent_per_week
                                ) as lag_second_spoilage
                            ) as lag_third_spoilage
                        ) as lag_fourth_spoilage
                    ) as lag_fifth_spoilage
                ) as lag_sixth_spoilage
            --- the 6th row contains all weeks' spoilage info
            WHERE week_rank = 6
            ) as spoilage_per_week
            ON SKU_performance_qualifiers.kid = spoilage_per_week.kid
            AND SKU_performance_qualifiers.pid = spoilage_per_week.pid

            /* The following subquery is set up to analyze if a sku's total sales in a given kiosk last
            month is less than 50% of the sku's entire fleet average. To do this, we need a sku's average
            sale across the entire fleet last month, and the sku's total sale in a given kiosk last month
            */
            LEFT JOIN (SELECT kiosk_and_product.kid,
                kiosk_and_product.pid,
                COALESCE(avg_sku_sales.avg_sales_across_all_fleet, 0)/ 2 as fifty_percent_avg_sales_across_all_fleet,
                COALESCE(avg_sku_sales.avg_sales_across_all_fleet, 0) as avg_sales_across_all_fleet,
                COALESCE(sum_kiosk_sales_per_kiosk.sales_per_kiosk, 0) as sales_per_kiosk
                --- Average sku sales across all fleet for the last month
                FROM (SELECT k.id as kid,
                    k.title as k_title,
                    p.id as pid,
                    p.title as p_title
                    FROM pantry.kiosk k
                    CROSS JOIN
                    pantry.product p
                    WHERE k.campus_id = 87
                    AND p.campus_id = 87
                    AND k.enable_reporting = 1
                    AND k.id = given_kiosk_id
                    AND k.archived = 0
                    AND p.archived = 0
                ) as kiosk_and_product
                LEFT JOIN (SELECT product_id,
                    avg(sales_per_kiosk) as avg_sales_across_all_fleet
                    --- Total sku sales in a given kiosk for the last month
                    FROM (SELECT product_id,
                        bt.kiosk_id,
                        count(*) as sales_per_kiosk
                        FROM byte_tickets bt
                        JOIN pantry.label l
                        ON bt.order_id = l.order_id
                        WHERE to_timestamp(bt.created)::date >= now()::date - interval '1 month'
                        GROUP BY product_id, bt.kiosk_id
                    ) as sum_sales_per_kiosk_last_month
                    GROUP BY product_id
                ) as avg_sku_sales
                ON avg_sku_sales.product_id = kiosk_and_product.pid
                --- Total sku sales in a given kiosk for the last month
                LEFT JOIN (SELECT product_id ,
                    bt.kiosk_id,
                    count(*) as sales_per_kiosk
                    FROM byte_tickets bt
                    JOIN pantry.label l
                    ON bt.order_id = l.order_id
                    WHERE to_timestamp(bt.created)::date >= now()::date - interval '1 month'
                    GROUP BY product_id, bt.kiosk_id
                ) as sum_kiosk_sales_per_kiosk
                ON kiosk_and_product.pid = sum_kiosk_sales_per_kiosk.product_id
                AND kiosk_and_product.kid = sum_kiosk_sales_per_kiosk.kiosk_id
            ) as low_sales
            ON  SKU_performance_qualifiers.kid = low_sales.kid
            AND SKU_performance_qualifiers.pid = low_sales.pid

            /*The following subquery is used to determine if there were no sku sales in the last 2
            consecutive weeks when the sku was available. This means that we need to look for the last 14
            consecutive days where a given sku was in a given kiosk during all days of those 14
            consecutive days.
            */
            LEFT JOIN (SELECT get_date.kiosk_id,
                get_date.k_title,
                get_date.product_id,
                get_date.p_title,
                get_date.date as last_date_with_previous_14_consecutive_item_present,
                COALESCE(total_price, 0) as total_price_last_consecutive_14_days
                --- Get the last date where the product was in the kiosk for at least 14 consecutive days from that day
                FROM (SELECT kiosk_id,
                    k_title,
                    product_id,
                    p_title,
                    max(date) as date
                    FROM (SELECT kiosk_id,
                        k_title,
                        product_id,
                        p_title,
                        number_in_fridge_consecutively,
                        date
                        FROM (SELECT *,
                            /* We use rank() OVER (PARTITION BY) as a way to determine when a sku has been
                            in a kiosk consecutively. It will tell how many days a sku has
                            been in a kiosk for consecutive days.
                            I used the method described in
                            https://stackoverflow.com/questions/47654348/postgres-rank-based-on-consecutive-values
                            */
                            rank() OVER (PARTITION BY kiosk_id, product_id, days_passed_since_last_present,
                                rank_2 - rank_1 ORDER BY date) as number_in_fridge_consecutively
                            FROM (SELECT *
                                FROM (SELECT *,
                                    rank() OVER (PARTITION BY kiosk_id, product_id, days_passed_since_last_present
                                        ORDER BY date::date) as rank_1,
                                    rank() OVER (PARTITION BY kiosk_id, product_id ORDER BY date::date) as rank_2
                                    /* Get all dates where a sku was present in a kiosk,
                                    and how many days has passed since that same sku was present in
                                    that same kiosk
                                    */
                                    FROM (SELECT ih.kiosk_id,
                                        k.title as k_title,
                                        ih.product_id,
                                        p.title as p_title,
                                        --- per day, if a product was present in a given kiosk, status = 1, else 0
                                        CASE WHEN count(*) > 0 THEN 1 else 0 END as status,
                                        ih.date::date,
                                        ih.date::date - lag(ih.date::date) OVER (PARTITION BY ih.kiosk_id, ih.product_id
                                            ORDER BY ih.date::date) as days_passed_since_last_present
                                        FROM inventory_history ih
                                        JOIN pantry.kiosk k
                                        ON ih.kiosk_id = k.id
                                        JOIN pantry.product p
                                        ON ih.product_id = p.id
                                        WHERE k.campus_id = 87
                                        AND p.campus_id = 87
                                        AND k.enable_reporting = 1
                                        AND k.id = given_kiosk_id
                                        AND p.archived = 0
                                        AND k.archived = 0
                                        GROUP BY ih.kiosk_id, ih.product_id, ih.date, p.title, k.title
                                    ) as get_days_passed_since_last_present
                                ) as set_up_for_ranking_part_1
                                /* Before we do the ranking, we need to get rid of any rows that are not
                                consecutive in days. Those are found where rank_1 = 1. Not doing so will
                                result in inaccurate ranking */
                                WHERE rank_1 !=1
                            ) set_up_for_ranking_part_2
                        ) as ranking
                        --- SELECT all rows that have had 14 days or more consecutive
                         WHERE number_in_fridge_consecutively >= 14
                    ) as consecutive_for_2_weeks_max_date
                    GROUP BY kiosk_id,  k_title, product_id,  p_title
                )  as get_date
                --- For each day, get the total sales for the last 14 days, including the chosen day
                LEFT JOIN (SELECT p1.date,
                    p1.kiosk_id,
                    p1.product_id,
                    SUM(p2.price) total_price
                    FROM (SELECT to_timestamp(bt.created)::date as date,
                    l.kiosk_id,
                    l.product_id,
                    sum(l.price) as price
                    FROM byte_tickets bt
                    JOIN pantry.label l
                    ON bt.order_id = l.order_id
                    GROUP BY l.kiosk_id, l.product_id, to_timestamp(bt.created)::date
                ) as p1
                    INNER JOIN (SELECT to_timestamp(bt.created)::date as date,
                    l.kiosk_id,
                    l.product_id,
                    sum(l.price) as price
                    FROM byte_tickets bt
                    JOIN pantry.label l
                    ON bt.order_id = l.order_id
                    GROUP BY l.kiosk_id, l.product_id, to_timestamp(bt.created)::date
                ) as p2
                ON p1.kiosk_id = p2.kiosk_id
                AND p1.product_id = p2.product_id
                AND p2.date BETWEEN (p1.date - INTERVAL '14 DAY') AND p1.date
                 GROUP BY p1.kiosk_id, p1.product_id, p1.date
                 ORDER BY p1.kiosk_id, p1.date
             )sales on get_date.date = sales.date
                AND get_date.kiosk_id = sales.kiosk_id
                AND get_date.product_id = sales.product_id
            ) as no_sales_last_2_weeks
            ON SKU_performance_qualifiers.kid = no_sales_last_2_weeks.kiosk_id
            AND SKU_performance_qualifiers.pid = no_sales_last_2_weeks.product_id
            ----Below are all the filters we need to apply
            --- less than 50% of sku fleet average OR  No sales in past 2 weeks when the item was available
            WHERE (
                ( fifty_percent_avg_sales_across_all_fleet > sales_per_kiosk)
                OR
                (total_price_last_consecutive_14_days = 0)
            )
            /* Where Spoilage >= 30% of sales over 3 of the past 6 weeks. I used the combination calculator
            found on https://www.mathsisfun.com/combinatorics/combinations-permutations-calculator.html
            to generate all week_spoilage combinations.*/
            AND ((first_week_spoilage >= 30 AND second_week_spoilage >= 30 AND third_week_spoilage >= 30) OR
                (first_week_spoilage >= 30 AND second_week_spoilage >= 30 AND fourth_week_spoilage >= 30) OR
                (first_week_spoilage >= 30 AND second_week_spoilage >= 30 AND fifth_week_spoilage >= 30) OR
                (first_week_spoilage >= 30 AND second_week_spoilage >= 30 AND sixth_week_spoilage >= 30) OR
                (first_week_spoilage >= 30 AND third_week_spoilage >= 30 AND fourth_week_spoilage >= 30) OR
                (first_week_spoilage >= 30 AND third_week_spoilage >= 30 AND fifth_week_spoilage >= 30) OR
                (first_week_spoilage >= 30 AND third_week_spoilage >= 30 AND sixth_week_spoilage >= 30) OR
                (first_week_spoilage >= 30 AND fourth_week_spoilage >= 30 AND fifth_week_spoilage >= 30) OR
                (first_week_spoilage >= 30 AND fourth_week_spoilage >= 30 AND sixth_week_spoilage >= 30) OR
                (first_week_spoilage >= 30 AND fifth_week_spoilage >= 30 AND sixth_week_spoilage >= 30) OR
                (second_week_spoilage >= 30 AND third_week_spoilage >= 30 AND fourth_week_spoilage >= 30) OR
                (second_week_spoilage >= 30 AND third_week_spoilage >= 30 AND fifth_week_spoilage >= 30) OR
                (second_week_spoilage >= 30 AND third_week_spoilage >= 30 AND sixth_week_spoilage >= 30) OR
                (second_week_spoilage >= 30 AND fourth_week_spoilage >= 30 AND fifth_week_spoilage >= 30) OR
                (second_week_spoilage >= 30 AND fourth_week_spoilage >= 30 AND sixth_week_spoilage >= 30) OR
                (second_week_spoilage >= 30 AND fifth_week_spoilage >= 30 AND sixth_week_spoilage >= 30) OR
                (third_week_spoilage >= 30 AND fourth_week_spoilage >= 30 AND fifth_week_spoilage >= 30) OR
                (third_week_spoilage >= 30 AND fourth_week_spoilage >= 30 AND sixth_week_spoilage >= 30) OR
                (third_week_spoilage >= 30 AND fifth_week_spoilage >= 30 AND sixth_week_spoilage >= 30) OR
                (fourth_week_spoilage >= 30 AND fifth_week_spoilage >= 30 AND sixth_week_spoilage >=30)
            );

    END;
$$;


ALTER FUNCTION inm.get_performance_pull_list(given_kiosk_id integer) OWNER TO dbservice;

--
-- Name: get_pull_date(timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: inm; Owner: dbservice
--

CREATE FUNCTION inm.get_pull_date(plan_window_start timestamp with time zone, plan_window_stop timestamp with time zone) RETURNS TABLE(kiosk_id integer, delivery_date date, pull_date date)
    LANGUAGE plpgsql
    AS $$
  /*
    Purpose: return INM pull date aka next delivery date
    Note: this used to be part of mixalot.plan_kiosk, but due to unreliable time portion of route_stop.route_date_time,
    this pull_date function is created to restrict the result to date portion of the data which is accurate and sufficient
    because pull_date doesn't need accurate time unlike mixalot.plan_kiosk.
    */
begin
	return query
		select ds.kiosk_id, ds.delivery_date_time::date, ps.pull_date_time::date
			from
			-- kiosk_id, delivery_date
			(select t.kiosk_id, t.delivery_date_time  from
				(select location_number as kiosk_id, rs.route_date_time as delivery_date_time,
					rank() over (partition by location_number order by rs.route_date_time) as r
					from mixalot.route_stop rs
					where rs.route_date_time >= plan_window_start -- look at routes starting at plan winddow start
					and location_number > 0) t
					where r = 1) ds

			left join
      (select o.kiosk_id kiosk_id,
             --o.pull_date_time as pull_date_time_old,
             if(o.os=0, o.pull_date_time, (o.pull_date_time - interval '1 day'*(o.os+1))) pull_date_time
             --if(o.os=0, o.os, o.os+1) as offset
      from (
        select nd.kiosk_id,
          nd.pull_date_time,
          nd.pull_dow,
          nd.pull_dow-os.os as pull_dow_os,
          mod((7+nd.pull_dow-os.os)::integer,7) as pull_dow_os_mod,
          os.os,
          ks.kiosk_sale_daily as kiosk_sale_daily,
          row_number() over (partition by nd.kiosk_id order by (nd.pull_dow-os.os) desc) as row_number
        from (
          select t.kiosk_id,
            t.delivery_date_time - interval '1 day' pull_date_time,
            EXTRACT(DOW from (t.delivery_date_time - interval '1 day')) as pull_dow
          from (
            select location_number as kiosk_id, rs.route_date_time::date as delivery_date_time,
              rank() over (partition by location_number order by rs.route_date_time) as r
            from mixalot.route_stop rs
            where rs.route_date_time >= plan_window_start -- look at routes starting at plan window start
              and location_number > 0) t
          where r = 2
          ) nd
        cross join (
          select generate_series as os from generate_series(0, 6)
          ) os
        left join (
          select vksh.kiosk_id, vksh.dow, sum(vksh.units_sold_normalized) as kiosk_sale_daily from inm.v_kiosk_sale_hourly vksh group by vksh.kiosk_id, vksh.dow
          ) ks
        on nd.kiosk_id=ks.kiosk_id and mod((7+nd.pull_dow-os.os)::integer,7)=ks.dow
        where ks.kiosk_sale_daily>=0.05
        order by nd.kiosk_id asc, (nd.pull_dow-os.os) desc
        ) o
      where o.row_number=1) ps
-- kiosk_id, pull_date
-- 			(select t.kiosk_id, t.delivery_date_time - interval '1 day' pull_date_time from
-- 				(select location_number as kiosk_id, rs.route_date_time::date as delivery_date_time,
-- 					rank() over (partition by location_number order by rs.route_date_time) as r
-- 					from mixalot.route_stop rs
-- 					where rs.route_date_time >= plan_window_start -- look at routes starting at plan window start
-- 					and location_number > 0) t
-- 					where r = 2) ps

			on ds.kiosk_id = ps.kiosk_id
			join pantry.kiosk k on ds.kiosk_id = k.id
			where ds.delivery_date_time between plan_window_start and plan_window_stop
			and k.campus_id= 87;	
end;

$$;


ALTER FUNCTION inm.get_pull_date(plan_window_start timestamp with time zone, plan_window_stop timestamp with time zone) OWNER TO dbservice;

--
-- Name: get_spoilage_pull_list(); Type: FUNCTION; Schema: inm; Owner: dbservice
--

CREATE FUNCTION inm.get_spoilage_pull_list() RETURNS TABLE(category character varying, kiosk_id bigint, kiosk_title character varying, product_id bigint, product_tile character varying, epc character varying)
    LANGUAGE plpgsql
    AS $$
    BEGIN
        RETURN QUERY
/*
This query is used to identify items that will spoil before the next delivery.
This function does not use kiosk id as an input.
It return expected spoilage for the whole Byte fleet.
A spoiled item uses the following
criteria:
if ( skuShelfLife <= 7 days ) {
if ( skuEpcDateAdded + kioskNextDelvieryDate > skuShelfLife )
{Show in pull list (red);}
}
else if ( skuShelfLife > 7 days && skuShelfLife <= 30 days ){
if ( skuEpcDateAdded + kioskNextDelvieryDate > skuShelfLife )
{Show in check list (yellow);}
}
SEE ENG-555
*/
        SELECT CASE WHEN shelf_time <= 7 THEN 'SPOILAGE RED'::varchar ELSE 'SPOILAGE YELLOW'::varchar END as category,
            l.kiosk_id as kiosk_id,
            k.title as kiosk_title,
            l.product_id as product_id,
            p.title as product_tile,
            l.epc as epc
            FROM pantry.label l
            JOIN pantry.product p ON l.product_id = p.id
            JOIN pantry.kiosk k ON l.kiosk_id = k.id
            --- Get next delivery date
            JOIN (select location_number,
                min(route_date_time) as next_delivery_date
                FROM mixalot.route_stop
                WHERE route_date_time::date > now()::date
                GROUP BY location_number
            ) as next_delivery
            ON l.kiosk_id = next_delivery.location_number
            WHERE l.status = 'ok'
            AND k.archived = 0
            AND k.enable_monitoring = 1
            AND k.campus_id = 87
            AND p.campus_id = 87
            AND (
                    (
                        shelf_time <= 7
                        AND
                        (next_delivery.next_delivery_date::date - to_timestamp(l.time_added)::date) > p.shelf_time
                    )
                    OR
                    (
                        shelf_time > 7
                        AND shelf_time <= 30
                        AND
                        (next_delivery.next_delivery_date::date - to_timestamp(l.time_added)::date) > p.shelf_time
                    )
                )
            ORDER BY kiosk_id, category;
    END;
$$;


ALTER FUNCTION inm.get_spoilage_pull_list() OWNER TO dbservice;

--
-- Name: get_spoilage_pull_list(integer); Type: FUNCTION; Schema: inm; Owner: dbservice
--

CREATE FUNCTION inm.get_spoilage_pull_list(given_kiosk_id integer) RETURNS TABLE(category character varying, kiosk_id bigint, kiosk_title character varying, product_id bigint, product_tile character varying, epc character varying)
    LANGUAGE plpgsql
    AS $$
    BEGIN
        RETURN QUERY
/*
This query is used to identify items that will spoil before the next delivery. A spoiled item uses the following
criteria:
if ( skuShelfLife <= 7 days ) {
if ( skuEpcDateAdded + kioskNextDelvieryDate > skuShelfLife )
{Show in pull list (red);}
} 
else if ( skuShelfLife > 7 days && skuShelfLife <= 30 days ){
if ( skuEpcDateAdded + kioskNextDelvieryDate > skuShelfLife )
{Show in check list (yellow);}
}
SEE ENG-555
*/
        SELECT CASE WHEN shelf_time <= 7 THEN 'SPOILAGE RED'::varchar ELSE 'SPOILAGE YELLOW'::varchar END as category,
            l.kiosk_id as kiosk_id,
            k.title as kiosk_title,
            l.product_id as product_id,
            p.title as product_tile,
            l.epc as epc
            FROM pantry.label l
            JOIN pantry.product p ON l.product_id = p.id
            JOIN pantry.kiosk k ON l.kiosk_id = k.id
            --- Get next delivery date
            JOIN (select location_number,
                min(route_date_time) as next_delivery_date
                FROM mixalot.route_stop
                WHERE route_date_time::date > now()::date
                GROUP BY location_number
            ) as next_delivery
            ON l.kiosk_id = next_delivery.location_number
            WHERE l.status = 'ok'
            AND k.archived = 0
            AND k.enable_monitoring = 1
            AND k.campus_id = 87
            AND p.campus_id = 87
            AND (
                    (
                        shelf_time <= 7
                        AND
                        (next_delivery.next_delivery_date::date - to_timestamp(l.time_added)::date) > p.shelf_time
                    )
                    OR
                    (
                        shelf_time > 7
                        AND shelf_time <= 30
                        AND
                        (next_delivery.next_delivery_date::date - to_timestamp(l.time_added)::date) > p.shelf_time
                    )
                )
            AND l.kiosk_id = given_kiosk_id
            ORDER BY 2,1;
    END;
$$;


ALTER FUNCTION inm.get_spoilage_pull_list(given_kiosk_id integer) OWNER TO dbservice;

--
-- Name: pick_check_restriction(date); Type: FUNCTION; Schema: inm; Owner: dbservice
--

CREATE FUNCTION inm.pick_check_restriction(_pick_date date) RETURNS TABLE(kiosk_id integer, product_id integer)
    LANGUAGE plpgsql
    AS $$

/*
Purpose: return restricted products found in allocation
*/

begin
	return query
		select a.kiosk_id, a.sku_id
			from (select * from inm.pick_allocation a where a.pick_date = _pick_date) a
				join inm.kiosk_product_disabled d on a.kiosk_id = d.kiosk_id and a.sku_id = d.product_id;
end;

$$;


ALTER FUNCTION inm.pick_check_restriction(_pick_date date) OWNER TO dbservice;

--
-- Name: FUNCTION pick_check_restriction(_pick_date date); Type: COMMENT; Schema: inm; Owner: dbservice
--

COMMENT ON FUNCTION inm.pick_check_restriction(_pick_date date) IS 'Run this after a pick to find restricted products in allocation.';


--
-- Name: pick_get_delivery_schedule(date); Type: FUNCTION; Schema: inm; Owner: dbservice
--

CREATE FUNCTION inm.pick_get_delivery_schedule(pick_date date) RETURNS TABLE(driver_name character varying, route_date_time timestamp with time zone, kiosk_id integer, kiosk_title character varying, address character varying, delivery_order integer)
    LANGUAGE plpgsql
    AS $$

	
	declare 
		latest_import_ts timestamp;
		pst_plan_window_start_str text;
		plan_window_start timestamp with time zone;
	 	plan_window_stop timestamp with time zone;

/*
Purpose: return INM delivery schedule for a pick window.
Input
	target_date: pick_date
Return
	Data to generate the drivers sheets
*/
begin
	if pick_date is not null
		then
			-- compose US/Pacific start window timestamp string
			pst_plan_window_start_str = cast(pick_date as text) || ' 13:00 -8';	
			select into plan_window_start cast(pst_plan_window_start_str as timestamp with time zone);
			plan_window_stop = plan_window_start + interval '22 hours';
			
		-- fixme: remove when obsolete
		-- backward compat with run pick using inm gsheets with plan window imported into mixalot.inm_data
		else
			select max(import_ts) from mixalot.inm_data into latest_import_ts;
			select i.route_date from mixalot.inm_data i
				where import_ts = latest_import_ts and data_type = 'Plan Window Start'
				into plan_window_start;
			select i.route_date from mixalot.inm_data i
				where import_ts = latest_import_ts and data_type = 'Plan Window Stop'
				into plan_window_stop;
		end if;
	
	return query
		select rs.driver_name, rs.route_date_time, location_number kiosk_id, k.title kiosk_title, k.address, rs.stop_number delivery_order
			from mixalot.route_stop rs join pantry.kiosk k on rs.location_number = k.id
			where rs.route_date_time between plan_window_start and plan_window_stop;
end;

$$;


ALTER FUNCTION inm.pick_get_delivery_schedule(pick_date date) OWNER TO dbservice;

--
-- Name: pick_get_delivery_schedule_optimo(date); Type: FUNCTION; Schema: inm; Owner: dbservice
--

CREATE FUNCTION inm.pick_get_delivery_schedule_optimo(target_date date) RETURNS TABLE(driver_name character varying, route_date_time timestamp with time zone, kiosk_id integer, kiosk_title character varying, address character varying, delivery_order integer)
    LANGUAGE plpgsql
    AS $$

	declare latest_import_ts timestamp;
	declare plan_window_start timestamp;
	declare plan_window_stop timestamp;

/*
Purpose: return INM delivery schedule for a pick window.
Input
	target_date: pick_date
Return
	Data to generate the drivers sheets
*/
begin
	-- calculate various date params
	select max(import_ts) from mixalot.inm_data into latest_import_ts;
	select i.route_date from mixalot.inm_data i
		where import_ts = latest_import_ts and data_type = 'Plan Window Start'
		into plan_window_start;
	select i.route_date from mixalot.inm_data i
		where import_ts = latest_import_ts and data_type = 'Plan Window Stop'
		into plan_window_stop;
	
	return query
		select rs.driver_name, rs.route_date_time, location_number kiosk_id, k.title kiosk_title, k.address, rs.stop_number delivery_order
			from mixalot.route_stop rs join pantry.kiosk k on rs.location_number = k.id
			where rs.route_date_time between plan_window_start and plan_window_stop;
end;

$$;


ALTER FUNCTION inm.pick_get_delivery_schedule_optimo(target_date date) OWNER TO dbservice;

--
-- Name: pick_get_demand_weekly_by_velocity(); Type: FUNCTION; Schema: inm; Owner: dbservice
--

CREATE FUNCTION inm.pick_get_demand_weekly_by_velocity() RETURNS TABLE(kiosk_id bigint, sku_group_id integer, fc_title text, kc_start_level numeric, kc_min_level numeric, kc_manual_multiplier numeric, sgc_default_level numeric, sgc_scale numeric, ksms_scale numeric, ws_live bigint, velocity_demand numeric, demand_weekly numeric)
    LANGUAGE plpgsql
    AS $$

/*
Revision Date: 2019-01-09
Purpose: return INM weekly demand by velocity
*/

begin
	return query
		select cast(dwwom.kiosk_id as bigint),
			dwwom.sku_group_id,
			dwwom.sku_group,
			dwwom.kc_start_level,
			dwwom.kc_min_level,
			dwwom.kc_manual_multiplier,
			dwwom.sgc_default_level,
			dwwom.sgc_scale,
			dwwom.ksms_scale,
			dwwom.ws_live,
			dwwom.preference_count,
		
			case when dwwom.ws_live < 4
			then greatest(dwwom.start_count, dwwom.preference_count)
			else greatest(dwwom.min_count, dwwom.preference_count)
			end as wk_demand
		
		from inm.pick_get_demand_weekly_wo_min() dwwom;
end;

$$;


ALTER FUNCTION inm.pick_get_demand_weekly_by_velocity() OWNER TO dbservice;

--
-- Name: pick_get_demand_weekly_wo_min(); Type: FUNCTION; Schema: inm; Owner: dbservice
--

CREATE FUNCTION inm.pick_get_demand_weekly_wo_min() RETURNS TABLE(kiosk_id integer, sku_group_id integer, sku_group text, sample_size bigint, preference numeric, ws_avg numeric, ws_std numeric, ws_live bigint, kc_start_level numeric, kc_min_level numeric, kc_manual_multiplier numeric, sgc_default_level numeric, sgc_scale numeric, ksms_scale numeric, start_count numeric, min_count numeric, scaled_preference numeric, scaled_preference_total numeric, preference_count numeric)
    LANGUAGE plpgsql
    AS $$
  /*
  Revision date: 2019-01-09
  Purpose: return INM weekly demand without min by velocity
  */

begin
	return query
select kc.kiosk_id as kiosk_id, 
	sg.id as sku_group_id,
	cast(sg.fc_title as text) as sku_group,
	coalesce(dwwom.sample_size, 0) as sample_size, -- dwwom missing some records for archived/old kiosks
	coalesce(dwwom.preference, 0.00) as preference, -- dwwom missing some records for archived/old kiosks
	max(coalesce(dwwom.ws_avg, 0.00)) over (partition by kc.kiosk_id) as ws_avg, --dwwom missing some records for archived/old kiosks
	max(coalesce(dwwom.ws_std, 0.00)) over (partition by kc.kiosk_id) as ws_std, --dwwom missing some records for archived/old kiosks
	max(coalesce(dwwom.ws_live, 0)) over (partition by kc.kiosk_id) as ws_live, -- dwwom missing some records for archived/old kiosks
	kc.start_level as kc_start_level,
	kc.min_level as kc_min_level,
	kc.manual_multiplier as kc_manual_multiplier, 
	sgc.default_level as sgc_default_level,
	sgc.scale as sgc_scale,
	coalesce(ksms.scale, 1.00) as ksms_scale,
	round(kc.start_level*kc.manual_multiplier*sgc.scale*coalesce(ksms.scale, 1.00)*sgc.default_level, 2) as start_count,
	round(kc.min_level*kc.manual_multiplier*sgc.scale*coalesce(ksms.scale, 1.00)*sgc.default_level, 2) as min_count,
	round(coalesce(dwwom.preference, 0.00)*kc.manual_multiplier*sgc.scale*coalesce(ksms.scale, 1.00), 2) as scaled_preference,
	round(sum(coalesce(dwwom.preference, 0.00)*kc.manual_multiplier*sgc.scale*coalesce(ksms.scale, 1.00)) over (partition by kc.kiosk_id), 2) as scaled_preference_total,
	round(coalesce(dwwom.ws_avg + dwwom.ws_std, 0.00) * (coalesce(dwwom.preference, 0.00)*kc.manual_multiplier*sgc.scale*coalesce(ksms.scale, 1.00) / greatest(0.01, sum(coalesce(dwwom.preference, 0.00)*kc.manual_multiplier*sgc.scale*coalesce(ksms.scale, 1.00)) over (partition by kc.kiosk_id))), 2) as preference_count
from inm.sku_group sg
cross join inm.kiosk_control kc
left join inm.kiosk_sku_group_manual_scale ksms on ksms.kiosk_id=kc.kiosk_id and ksms.sku_group_id=sg.id
left join inm.sku_group_control sgc on sgc.sku_group_id = sg.id
left join 
	(select t4.kiosk_id,
		t4.sku_group,
		t4.sample_size,
		t4.dt_avg,
		t4.dt_std,
		t4.w_departure_time,
		t4.preference,
		t6.ws_avg,
		t6.ws_std,
		t6.ws_live
	from (
		select t3.kiosk_id, 
			t3.sku_group, 
			count(t3.purchase_index) as sample_size,
			round((avg(t3.departure_time))::numeric, 2) as dt_avg,
			coalesce(round((stddev(t3.departure_time))::numeric, 2), 0) as dt_std,
			round(sum(t3.departure_time*t3.w)/sum(t3.w)::numeric, 2) as w_departure_time,
			least(round(1.00/(sum(t3.departure_time*t3.w)/sum(t3.w))::numeric, 2), case when count(t3.purchase_index)=1 then 0.10 else 0.20 end) as preference
		from (
			select *,
				greatest(coalesce(round((t2.time_sold - greatest(t2.last_sale, t2.time_stocked))::numeric/3600, 2), 50.00), 1.00) as departure_time,
				0 as qty_sold,
				1 as w
				--(t2.purchase_index - t2.last_purchase_index) as qty_sold,
				--coalesce(round((t2.purchase_index - t2.last_purchase_index)::numeric/greatest(coalesce((t2.time_sold - greatest(t2.last_sale, t2.time_stocked))::numeric/3600, 100.00), 1.00), 2), 1.00) as w
			from (
				select *,
					lag(t1.time_sold, 1) over (partition by t1.kiosk_id, t1.sku_group order by t1.time_sold) as last_sale,
					lag(t1.purchase_index, 1) over (partition by t1.kiosk_id, t1.sku_group order by t1.time_sold) as last_purchase_index
				from (
					select k.kiosk_id,
						p.sku_group,
						l.time_stocked,
						l.time_sold,
						l.purchase_index
					from (
						select k.id as kiosk_id
						from pantry.kiosk k
						where k.campus_id=87
							and k.archived=0
							and k.enable_reporting=1
							--and k.id=1274
					) k
					cross join (
						select distinct fc_title as sku_group
						from pantry.product p
						where p.campus_id=87
							and p.archived=0
							and p.fc_title is not null
							and p.fc_title!='N/A'
						order by p.fc_title asc
					) p
					left outer join (
						select l.kiosk_id as kiosk_id,
							p.fc_title as sku_group,
							l.time_created as time_stocked, 
							l.time_updated as time_sold,
							row_number() over (partition by l.kiosk_id order by l.time_updated) as purchase_index
						from pantry.label l
							join pantry.product p on l.product_id=p.id
						where l.kiosk_id is not null
							and l.status='sold'
							and to_timestamp(l.time_updated) at time zone 'US/Pacific' > date_trunc('week', current_timestamp) - interval '24 weeks'
							and p.campus_id=87
							and p.archived=0
							and p.fc_title is not null
					) l on k.kiosk_id=l.kiosk_id and p.sku_group=l.sku_group
					order by k.kiosk_id, p.sku_group, l.purchase_index
				) t1
			) t2
		) t3
		group by t3.kiosk_id, t3.sku_group
	) t4
	join 
	-- get sale average and standard diviation
	(select t5.kiosk_id, round(avg(units_sold), 2) ws_avg, round(stddev(units_sold), 2) ws_std, count(units_sold) ws_live
		from (
			-- get units sold per week over last 3 month
			SELECT concat(kk.kiosk_id::character varying(4), ' ', kk.woy) AS key,
				kk.kiosk_id,
				kk.woy,
				ss.units_sold
			FROM (
				SELECT k.id AS kiosk_id,
					generate_series(1, 52) AS woy
				FROM pantry.kiosk k
				WHERE k.campus_id = 87 AND k.archived = 0 AND k.enable_reporting = 1 AND k.enable_monitoring = 1) kk
			LEFT JOIN ( 
				SELECT s.kiosk_id,
					date_part('week'::text, s.ts) AS woy,
					count(*) AS units_sold
				FROM byte_epcssold_3months s
				GROUP BY s.kiosk_id, (date_part('week'::text, s.ts))) ss ON kk.kiosk_id = ss.kiosk_id AND kk.woy::double precision = ss.woy
			ORDER BY ss.kiosk_id, ss.woy) t5
		group by t5.kiosk_id
		order by t5.kiosk_id asc
	) t6 on t4.kiosk_id=t6.kiosk_id) dwwom on dwwom.kiosk_id = kc.kiosk_id and dwwom.sku_group = sg.fc_title;

			
end;

$$;


ALTER FUNCTION inm.pick_get_demand_weekly_wo_min() OWNER TO dbservice;

--
-- Name: pick_get_order(timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: inm; Owner: dbservice
--

CREATE FUNCTION inm.pick_get_order(start_ts timestamp with time zone, end_ts timestamp with time zone) RETURNS TABLE(kiosk_id integer, route_date_time timestamp with time zone, sku_group_id integer, fc_title text, week_qty integer, plan_qty integer)
    LANGUAGE plpgsql ROWS 10000
    AS $$
  /*
    Purpose - return INM order for the next sale period which is the time between the deliveries of this pick and the next pick
    Comment - Why go through this function and not call pick_get_order_with_velocity(start_date, end_date) directly? There are 2 reasons:
      1. We can replace pick_get_order_with_velocity with a newer fucntion here and not having to change the client code to test the new function.
      2. pick_get_order_with_velocity returns richer data that can be used for troubleshooting which is not necessary for production.
    
    Input -
      start_ts: plan window start date time with time zone
      end_ts: plan window end date time with time zone
    Return -
      kiosk_id: together with route_date_time is unique for the plan window
      route_date_time: route starting date time
      fc_title: sku group name
      plan_qty: order quantity for the above fc_title for the next sale period
    */

declare latest_import_ts_for_pick_window timestamp with time zone;
begin
	/* update pick_preference_kiosk_sku */
-- 	truncate mixalot.pick_preference_kiosk_sku;
-- 	insert into mixalot.pick_preference_kiosk_sku
-- 		select i.kiosk_id, i.sku, cast(i.preference * 100 as integer) from mixalot.inm_sku_velocity i;

	return query
		-- seletively comment to use week order calc or between delivery order calc
		
		-- sales ratio
		-- select osr.kiosk_id, osr.route_date_time, osr.sku_group_id, osr.fc_title, osr.week_demand_qty, cast(osr.plan_order_qty as integer) from inm.pick_get_order_with_sales_ratio(start_ts, end_ts) osr;
		
		-- with sales ratio and velocity
		select distinct ov.kiosk_id, ov.route_date_time, ov.sku_group_id, ov.fc_title,
			cast(ceiling(ov.week_demand_qty) as integer), cast(ceiling(ov.plan_order_qty) as integer)
			from inm.pick_get_order_with_velocity(start_ts, end_ts) ov;
		
end;

$$;


ALTER FUNCTION inm.pick_get_order(start_ts timestamp with time zone, end_ts timestamp with time zone) OWNER TO dbservice;

--
-- Name: pick_get_order_with_velocity(timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: inm; Owner: dbservice
--

CREATE FUNCTION inm.pick_get_order_with_velocity(start_ts timestamp with time zone, end_ts timestamp with time zone) RETURNS TABLE(kiosk_id integer, route_date_time timestamp with time zone, sku_group_id integer, fc_title text, week_demand_qty numeric, plan_demand_qty numeric, plan_order_qty numeric)
    LANGUAGE plpgsql
    AS $$
  /*
    Purpose - return INM order based on sales ratio for pick sales period (time between deliveries)
    Input -
      start_ts: plan window start date time with time zone
      end_ts: plan window end date time with time zone
    Return -
      kiosk_id: together with route_date_time is unique for the plan window
      route_date_time: route starting date time
      fc_title: sku group name
      week_demand_qty: demand based on once a week delivery (without minimum)
      plan_demand_qty: demand based on sales ratio for pick sales period (without minimum)
      plan_order_qty: order based on sales ratio for pick sales period
    */

begin
	return query
		--  Given
		--		sales period = time between this pick delivery and next pick delivery (may be changed to pick times in the future)
		--		inm.demand_weekly = week demand
		--		sr.sales_ratio = sale ratio for this sum items sold for pick sales period for the last 4 weeks vs items sold for the last 4 weeks 
		-- 	if item is restricted (inm_qty=0), then set demand to 0. 
		--  else 
		--		if item doesn't exist in the kiosk (inv.count is null), set its inv count to 0
		-- 		order_before_min_max = 2.0 * sr.sales_ratio * inm.demand_weekly - inv.count
		-- 		final_order = min + order_before_min_max, capped by max as defined for each sku group
        -- 20190213, changed 1.4 to 2.0 to increase levels in the kiosks
		
		select sr.kiosk_id, sr.route_date_time, sga.id, dwbv.fc_title, dwbv.demand_weekly as week_demand_qty, 
			cast(1.7 * sr.sales_ratio * dwbv.demand_weekly as numeric (8,2)) plan_demand_qty,
			case 
				-- restricted item if demand_weekly is 0 or kiosk_sku_group manual scale is zero
				when dwbv.demand_weekly = 0 or ksms.scale = 0.0 then 0 
				else
					ceiling(
						-- change minimum is 0 (don't remove from a kiosk)
						least(greatest(least(1.7 * sr.sales_ratio * dwbv.demand_weekly, dwbv.demand_weekly) + sga.minimum_kiosk_qty - coalesce(inv.count, 0),
											  0) /* change negative demand to 0 */
								   , sga.maximum_kiosk_qty))
			end as plan_order_qty -- end case
					   
			from inm.pick_get_sales_period_ratio(start_ts, end_ts) sr
			
				join inm.pick_get_demand_weekly_by_velocity() dwbv
					on sr.kiosk_id = dwbv.kiosk_id 
												
				join inm.sku_group_attribute sga
					on sga.title = dwbv.fc_title			
				left join inm.kiosk_projected_stock inv
					on dwbv.kiosk_id = inv.kiosk_id and dwbv.fc_title = inv.fc_title
				left join inm.kiosk_sku_group_manual_scale ksms
					on sr.kiosk_id = ksms.kiosk_id and sga.id = ksms.sku_group_id;				
	end;

$$;


ALTER FUNCTION inm.pick_get_order_with_velocity(start_ts timestamp with time zone, end_ts timestamp with time zone) OWNER TO dbservice;

--
-- Name: pick_get_plan_kiosk(date); Type: FUNCTION; Schema: inm; Owner: dbservice
--

CREATE FUNCTION inm.pick_get_plan_kiosk(pick_date date) RETURNS TABLE(kiosk_id integer, route_date_time timestamp with time zone, driver_name character varying, location_name character varying, next_delivery_ts timestamp with time zone, time_to_next_delivery interval, days_to_next_delivery double precision, delivery_order bigint)
    LANGUAGE plpgsql
    AS $$

declare
	pst_plan_window_start_str text;
	plan_window_start timestamp with time zone;
	plan_window_stop timestamp with time zone;
/*
Purpose: return INM plan kiosks for a pick date.
*/

begin
	-- compose US/Pacific start window timestamp string
	pst_plan_window_start_str = cast(pick_date as text) || ' 13:00 -8';
	
	select into plan_window_start cast(pst_plan_window_start_str as timestamp with time zone);
	plan_window_stop = plan_window_start + interval '22 hours';
	return query
		select * from inm.pick_get_plan_kiosk(plan_window_start, plan_window_stop);
end;

$$;


ALTER FUNCTION inm.pick_get_plan_kiosk(pick_date date) OWNER TO dbservice;

--
-- Name: pick_get_plan_kiosk(timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: inm; Owner: dbservice
--

CREATE FUNCTION inm.pick_get_plan_kiosk(plan_window_start timestamp with time zone, plan_window_stop timestamp with time zone) RETURNS TABLE(kiosk_id integer, route_date_time timestamp with time zone, driver_name character varying, location_name character varying, next_delivery_ts timestamp with time zone, time_to_next_delivery interval, days_to_next_delivery double precision, delivery_order bigint)
    LANGUAGE plpgsql
    AS $$

/*
Purpose: return INM plan kiosks for a pick window.
*/

begin
	return query
		-- comment appropriate line to switch between optimo and bringg
		select * from inm.pick_get_plan_kiosk_optimo(plan_window_start, plan_window_stop);
		-- select * from inm.pick_get_plan_kiosk_bringg(plan_window_start, plan_window_stop);
end;

$$;


ALTER FUNCTION inm.pick_get_plan_kiosk(plan_window_start timestamp with time zone, plan_window_stop timestamp with time zone) OWNER TO dbservice;

--
-- Name: pick_get_plan_kiosk_bringg(timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: inm; Owner: dbservice
--

CREATE FUNCTION inm.pick_get_plan_kiosk_bringg(plan_window_start timestamp with time zone, plan_window_stop timestamp with time zone) RETURNS TABLE(kiosk_id integer, route_date_time timestamp with time zone, driver_name character varying, location_name character varying, next_delivery_ts timestamp with time zone, time_to_next_delivery interval, days_to_next_delivery double precision, delivery_order bigint)
    LANGUAGE plpgsql
    AS $$

/*
Purpose: return INM plan kiosks for a pick window.
*/

begin
	return query
		select ds.kiosk_id, ds.route_date_time, ds.driver_name, k.title, ps.next_delivery_ts,
		ps.next_delivery_ts - ds.route_date_time as time_to_next_delivery,		
		  case 
		  	when ps.next_delivery_ts - ds.route_date_time between interval '12 hours' and interval '24 hours' then 1
			else extract(day from ps.next_delivery_ts - ds.route_date_time)
			end as days_to_next_delivery,
		  row_number() over (order by ds.route_date_time asc) as delivery_order
		 		
		from
		-- kiosk_id, delivery_date
		(select t.kiosk_id, t.route_date_time, t.driver_name from
			(select cast(kid as integer) as kiosk_id, rs.route_date_time, rs.driver_name,
				rank() over (partition by kid, rs.route_date_time order by rs.route_date_time) as r
				from bringg.order rs
				where rs.route_date_time >= plan_window_start -- look at routes starting at plan winddow start
			 	and rs.status <> 7
				) t
				where r = 1) ds

		left join 
		-- kiosk_id, pull_date
		(select t.kiosk_id, t.route_date_time next_delivery_ts from
			(select cast(kid as integer) as kiosk_id, rs.route_date_time,
				rank() over (partition by kid order by rs.route_date_time) as r
				from bringg.order rs
				where rs.route_date_time >= plan_window_start -- look at routes starting at plan window start
			 	and rs.status <> 7
				) t
				where r = 2) ps

			on ds.kiosk_id = ps.kiosk_id
			join pantry.kiosk k on ds.kiosk_id = k.id
			where ds.route_date_time between plan_window_start and plan_window_stop
			and k.campus_id= 87;	
end;

$$;


ALTER FUNCTION inm.pick_get_plan_kiosk_bringg(plan_window_start timestamp with time zone, plan_window_stop timestamp with time zone) OWNER TO dbservice;

--
-- Name: pick_get_plan_kiosk_disabled_product(date); Type: FUNCTION; Schema: inm; Owner: dbservice
--

CREATE FUNCTION inm.pick_get_plan_kiosk_disabled_product(pick_date date) RETURNS TABLE(kiosk_id bigint, product_id integer)
    LANGUAGE plpgsql
    AS $$

declare 
	plan_window_start timestamp with time zone;
	plan_window_stop timestamp with time zone;
/*
Purpose: return disabled products for kiosks on the pick for a pick date.
*/

begin
	return query
		select dp.kiosk_id, dp.product_id
		from inm.pick_get_plan_kiosk(pick_date) pk
			join inm.kiosk_product_disabled dp on pk.kiosk_id = dp.kiosk_id;
end;

$$;


ALTER FUNCTION inm.pick_get_plan_kiosk_disabled_product(pick_date date) OWNER TO dbservice;

--
-- Name: pick_get_plan_kiosk_optimo(timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: inm; Owner: dbservice
--

CREATE FUNCTION inm.pick_get_plan_kiosk_optimo(plan_window_start timestamp with time zone, plan_window_stop timestamp with time zone) RETURNS TABLE(kiosk_id integer, route_date_time timestamp with time zone, driver_name character varying, location_name character varying, next_delivery_ts timestamp with time zone, time_to_next_delivery interval, days_to_next_delivery double precision, delivery_order bigint)
    LANGUAGE plpgsql
    AS $$

/*
Purpose: return INM plan kiosks for a pick window.
*/

begin
	return query
		select ds.kiosk_id, ds.route_date_time, ds.driver_name, ds.location_name, ps.next_delivery_ts,
		ps.next_delivery_ts - ds.route_date_time as time_to_next_delivery,		
		  case 
		  	when ps.next_delivery_ts - ds.route_date_time between interval '12 hours' and interval '24 hours' then 1
			else extract(day from ps.next_delivery_ts - ds.route_date_time)
			end as days_to_next_delivery,
		  row_number() over (order by ds.route_date_time asc) as delivery_order
		  
		
		from
		-- kiosk_id, delivery_date
		(select t.kiosk_id, t.route_date_time, t.driver_name, t.location_name from
			(select location_number as kiosk_id, rs.route_date_time, rs.driver_name, rs.location_name,
				rank() over (partition by location_number, rs.route_date_time order by rs.route_date_time) as r
				from mixalot.route_stop rs
				where rs.route_date_time >= plan_window_start -- look at routes starting at plan winddow start
				and location_number > 0) t
				where r = 1) ds

		left join 
		-- kiosk_id, pull_date
		(select t.kiosk_id, t.route_date_time next_delivery_ts from
			(select location_number as kiosk_id, rs.route_date_time,
				rank() over (partition by location_number order by rs.route_date_time) as r
				from mixalot.route_stop rs
				where rs.route_date_time >= plan_window_start -- look at routes starting at plan window start
				and location_number > 0) t
				where r = 2) ps

			on ds.kiosk_id = ps.kiosk_id
			join pantry.kiosk k on ds.kiosk_id = k.id
			where ds.route_date_time between plan_window_start and plan_window_stop
			and k.campus_id= 87;	
end;

$$;


ALTER FUNCTION inm.pick_get_plan_kiosk_optimo(plan_window_start timestamp with time zone, plan_window_stop timestamp with time zone) OWNER TO dbservice;

--
-- Name: pick_get_plan_kiosk_projected_stock(timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: inm; Owner: dbservice
--

CREATE FUNCTION inm.pick_get_plan_kiosk_projected_stock(plan_window_start timestamp with time zone, plan_window_stop timestamp with time zone) RETURNS TABLE(kiosk_id integer, fc_title character varying, qty integer)
    LANGUAGE plpgsql
    AS $$
  /*
    Purpose: return projected stock for plan kiosks for a pick window.
    */

begin
	return query
		select pk.kiosk_id, kps.fc_title, cast(kps.count as integer) from inm_beta.pick_get_plan_kiosk(plan_window_start, plan_window_stop) pk			
		left join inm.kiosk_projected_stock kps on pk.kiosk_id = kps.kiosk_id
			where kps.fc_title is not null;
end;
$$;


ALTER FUNCTION inm.pick_get_plan_kiosk_projected_stock(plan_window_start timestamp with time zone, plan_window_stop timestamp with time zone) OWNER TO dbservice;

--
-- Name: pick_get_sales_period_ratio(timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: inm; Owner: dbservice
--

CREATE FUNCTION inm.pick_get_sales_period_ratio(start_ts timestamp with time zone, end_ts timestamp with time zone) RETURNS TABLE(kiosk_id integer, route_date_time timestamp with time zone, sales_ratio numeric)
    LANGUAGE plpgsql ROWS 10000
    AS $$

  /*
  Purpose - return INM the ratio of the next sale period(time between the deliveries of this pick and the next pick) vs sales for the week using 12 week history
  Input -
    start_ts: plan window start date time with time zone
    end_ts: plan window end date time with time zone
  Return -
    kiosk_id: together with route_date_time is unique for the plan window
    route_date_time: route starting date time
    fc_title: sku group name
    plan_qty: order quantity for the above fc_title for the next sale period
  */

begin	
	return query
		select scheduled_kiosks.kiosk_id, scheduled_kiosks.route_date_time, coalesce(existing_kiosk_with_sales_ratio.ratio, 1.0/3.0)
			from inm.pick_get_plan_kiosk(start_ts, end_ts) scheduled_kiosks -- all the kiosks on route
				left join -- kiosks with sales history
					(
					select whole_12_weeks.kiosk_id, whole_12_weeks.route_date_time, 
						case when whole_12_weeks.qty < 5 then 1.0/3.0 -- new kiosk, assume period sale is 1/3 of total week
							else cast(period_12_weeks.qty as decimal)/cast(whole_12_weeks.qty as decimal)
							end ratio		
					from
						-- count of sales for the whole previous 4 weeks 
						(select pk.kiosk_id, pk.route_date_time, count(*) qty 
							from inm.pick_get_plan_kiosk(start_ts, end_ts) pk
								join pantry.label l on pk.kiosk_id=l.kiosk_id
								where l.status in ('sold') -- 20190213 changed from ('out', 'sold')
									and to_timestamp(l.time_updated) between
										pk.next_delivery_ts - interval '91 days'
										and pk.next_delivery_ts - interval '7 days'
							group by 1, 2
						 ) whole_12_weeks

						join 

						-- count of sales for the sales peiod of previous 4 weeks 
						(
						select pk.kiosk_id, pk.route_date_time, count(*) qty
							from inm.pick_get_plan_kiosk(start_ts, end_ts) pk
								join pantry.label l on pk.kiosk_id=l.kiosk_id
								where l.status in ('sold') and  -- 20190213 changed from ('out', 'sold')
									(
									 to_timestamp(l.time_updated) between now() - interval '7 days'  + interval '4 hours' and pk.next_delivery_ts - interval '7 days'  + interval '4 hours' or
									 to_timestamp(l.time_updated) between now() - interval '14 days' + interval '4 hours' and pk.next_delivery_ts - interval '14 days' + interval '4 hours' or
									 to_timestamp(l.time_updated) between now() - interval '21 days' + interval '4 hours' and pk.next_delivery_ts - interval '21 days' + interval '4 hours' or
									 to_timestamp(l.time_updated) between now() - interval '28 days' + interval '4 hours' and pk.next_delivery_ts - interval '28 days' + interval '4 hours' or

									 to_timestamp(l.time_updated) between now() - interval '35 days' + interval '4 hours' and pk.next_delivery_ts - interval '35 days' + interval '4 hours' or
									 to_timestamp(l.time_updated) between now() - interval '42 days' + interval '4 hours' and pk.next_delivery_ts - interval '42 days' + interval '4 hours' or
									 to_timestamp(l.time_updated) between now() - interval '49 days' + interval '4 hours' and pk.next_delivery_ts - interval '49 days' + interval '4 hours' or
									 to_timestamp(l.time_updated) between now() - interval '56 days' + interval '4 hours' and pk.next_delivery_ts - interval '56 days' + interval '4 hours' or

									 to_timestamp(l.time_updated) between now() - interval '63 days' + interval '4 hours' and pk.next_delivery_ts - interval '63 days' + interval '4 hours' or
									 to_timestamp(l.time_updated) between now() - interval '70 days' + interval '4 hours' and pk.next_delivery_ts - interval '70 days' + interval '4 hours' or
									 to_timestamp(l.time_updated) between now() - interval '77 days' + interval '4 hours' and pk.next_delivery_ts - interval '77 days' + interval '4 hours' or
									 to_timestamp(l.time_updated) between now() - interval '84 days' + interval '4 hours' and pk.next_delivery_ts - interval '84 days' + interval '4 hours'
									 
									/*
									 to_timestamp(l.time_updated) between pk.route_date_time - interval '7 days'  + interval '4 hours' and pk.next_delivery_ts - interval '7 days'  + interval '4 hours' or
 									 to_timestamp(l.time_updated) between pk.route_date_time - interval '14 days' + interval '4 hours' and pk.next_delivery_ts - interval '14 days' + interval '4 hours' or
 									 to_timestamp(l.time_updated) between pk.route_date_time - interval '21 days' + interval '4 hours' and pk.next_delivery_ts - interval '21 days' + interval '4 hours' or
 									 to_timestamp(l.time_updated) between pk.route_date_time - interval '28 days' + interval '4 hours' and pk.next_delivery_ts - interval '28 days' + interval '4 hours' or

 									 to_timestamp(l.time_updated) between pk.route_date_time - interval '35 days' + interval '4 hours' and pk.next_delivery_ts - interval '35 days' + interval '4 hours' or
 									 to_timestamp(l.time_updated) between pk.route_date_time - interval '42 days' + interval '4 hours' and pk.next_delivery_ts - interval '42 days' + interval '4 hours' or
 									 to_timestamp(l.time_updated) between pk.route_date_time - interval '49 days' + interval '4 hours' and pk.next_delivery_ts - interval '49 days' + interval '4 hours' or
 									 to_timestamp(l.time_updated) between pk.route_date_time - interval '56 days' + interval '4 hours' and pk.next_delivery_ts - interval '56 days' + interval '4 hours' or

 									 to_timestamp(l.time_updated) between pk.route_date_time - interval '63 days' + interval '4 hours' and pk.next_delivery_ts - interval '63 days' + interval '4 hours' or
 									 to_timestamp(l.time_updated) between pk.route_date_time - interval '70 days' + interval '4 hours' and pk.next_delivery_ts - interval '70 days' + interval '4 hours' or
 									 to_timestamp(l.time_updated) between pk.route_date_time - interval '77 days' + interval '4 hours' and pk.next_delivery_ts - interval '77 days' + interval '4 hours' or
 									 to_timestamp(l.time_updated) between pk.route_date_time - interval '84 days' + interval '4 hours' and pk.next_delivery_ts - interval '84 days' + interval '4 hours'
									*/

									)
								group by 1, 2
							) period_12_weeks

						on whole_12_weeks.kiosk_id = period_12_weeks.kiosk_id
					 ) existing_kiosk_with_sales_ratio 
					 
				on scheduled_kiosks.kiosk_id = existing_kiosk_with_sales_ratio.kiosk_id and scheduled_kiosks.route_date_time = existing_kiosk_with_sales_ratio.route_date_time;
					
	end;

$$;


ALTER FUNCTION inm.pick_get_sales_period_ratio(start_ts timestamp with time zone, end_ts timestamp with time zone) OWNER TO dbservice;

--
-- Name: pick_get_summary(date); Type: FUNCTION; Schema: inm; Owner: dbservice
--

CREATE FUNCTION inm.pick_get_summary(target_date date) RETURNS TABLE(property text, name text, value text)
    LANGUAGE plpgsql
    AS $$

/*
Returns pick summary for a given date.
*/

declare 
	pick_tickets_generated integer;
	-- one-based arrays of 3 numbers, 1 for target date and 2 for the same weekday one and two weeks ago
	ticket integer ARRAY;
	demand integer ARRAY;
	allocation integer ARRAY;
	property text;
	name text;
	value text;
	total integer;
	result_row record;
	kiosks_added text;
	kiosks_removed text;
	percentage integer;

begin
	
	FOR i IN 0..2 LOOP
 		select count(*) from inm.pick_route where pick_date = target_date - 7*i  into total;
		ticket[i+1] = total; -- convert to one-based index
		select sum(qty) from inm.pick_demand where pick_date = target_date - 7*i into total;
		demand[i+1] = total;
		select sum(qty) from inm.pick_allocation where pick_date = target_date - 7*i into total;
		allocation[i+1] = total;
   	END LOOP;
	
	select array_to_string(array_agg(cast (kiosk_id as varchar) order by kiosk_id), ',') from inm.pick_route 
		where pick_date = target_date and kiosk_id not in
			(select kiosk_id from inm.pick_route where pick_date = target_date - 7)
	into kiosks_added;
	
	select array_to_string(array_agg(cast (kiosk_id as varchar) order by kiosk_id), ',') from inm.pick_route 
		where pick_date = target_date - 7  and kiosk_id not in
			(select kiosk_id from inm.pick_route where pick_date = target_date)
	into kiosks_removed;
		
	property = 'stats';
	name = 'pick tickets today/ -7 days/ -14 days: ';
	value = ticket[1] || '/' || ticket[2] || '/' || ticket[3];
	return query select property, name, value;
	
	property = 'stats';
	name = 'demand qty today/ -7 days/ -14 days: ';
	value = coalesce(demand[1], 0) || '/' || coalesce(demand[2],0) || '/' || coalesce(demand[3],0);
	return query select property, name, value;
	
	property = 'stats';
	name = 'allocation qty today/ -7 days/ -14 days: ';
	value = coalesce(allocation[1], 0) || '/' || coalesce(allocation[2], 0) || '/' || coalesce(allocation[3], 0);
	return query select property, name, value;
	
	property = 'stats';
	name = 'kiosks added';
	value = kiosks_added;
	return query select property, name, value;
	
	property = 'stats';
	name = 'kiosks removed';
	value = kiosks_removed;
	return query select property, name, value;
	
-- 	property = 'stats';
-- 	name = 'allocation summary';
-- 	percentage = 100*cast(demand[1] as decimal)/cast(allocation[1] as decimal);
-- 	value = 'allocation: ' || allocation[1] || ', demand: ' || demand[1] || ', allocation percentage: ' || percentage;
-- 	return query select property, name, value;
end

$$;


ALTER FUNCTION inm.pick_get_summary(target_date date) OWNER TO dbservice;

--
-- Name: pick_get_ticket(date); Type: FUNCTION; Schema: inm; Owner: dbservice
--

CREATE FUNCTION inm.pick_get_ticket(target_date date) RETURNS TABLE(pick_station bigint, vendor character varying, item_code bigint, item_name character varying, site_code bigint, site_name character varying, proposed_supply integer, total_pick_qty bigint, total_pick_sku integer, driver_name character varying, route_date date, route_time time without time zone, route_date_time timestamp without time zone, route_number character varying, restrictions text, address character varying, pull_date date, delivery_order integer, pick_order integer)
    LANGUAGE plpgsql
    AS $$

	declare latest_import_ts timestamp;
	declare plan_window_start timestamp;
	declare plan_window_stop timestamp;
begin
	-- return pick ticket data for the latest pick
	
	-- calculate various date params
	select max(import_ts) from mixalot.inm_data into latest_import_ts;
	select i.route_date from mixalot.inm_data i
		where import_ts = latest_import_ts and data_type = 'Plan Window Start'
		into plan_window_start;
	select i.route_date from mixalot.inm_data i
		where import_ts = latest_import_ts and data_type = 'Plan Window Stop'
		into plan_window_stop;
	
	if target_date is null
		then target_date = plan_window_start::date;
	end if;
		
	return query
		select 
				p.pick_station, p.vendor, p.id, p.title ItemName,
				k.id sitecode, k.title sitename, a.qty proposed_supply, 
				sum(a.qty) over(partition by k.id, route.route_date) total_pick_qty,
				-1 total_pick_sku, route.driver_name DriverName,
				route.route_date RouteDate, route.route_time RouteTime,
				route.route_date + route.route_time route_date_time, route.route_number,
				r.restrictions,
				k.address,
				pd.pull_date,
				cast(route.delivery_order as integer),
				spo.pick_order
			from inm.pick_allocation a 
				left join pantry.kiosk k on a.kiosk_id = k.id
				-- left join mixalot.inm_kiosk_restriction_list r on k.id = r.kiosk_id
				left join inm.kiosk_restriction_list r on k.id = r.kiosk_id
				join pantry.product p on a.sku_id = p.id
				
				-- FIXME remove all following comments after verify 2018-12-05
				-- Actually, need to compare both route_date and route_time so the next line is not correct
				-- join inm.pick_route route on a.route_date=route.route_date and a.kiosk_id = route.kiosk_id 
				-- so instead use this line:
				join inm.pick_route route on a.pick_date=route.pick_date and a.route_date = route.route_date and a.kiosk_id = route.kiosk_id
				
				left join inm.get_pull_date(plan_window_start, plan_window_stop) pd on a.kiosk_id = pd.kiosk_id
				left join mixalot.sku_pick_order(latest_import_ts) spo on p.id = spo.sku_id
			where k.campus_id = 87
			and a.pick_date = target_date;
end

$$;


ALTER FUNCTION inm.pick_get_ticket(target_date date) OWNER TO dbservice;

--
-- Name: pick_submit(date, integer, integer); Type: FUNCTION; Schema: inm; Owner: dbservice
--

CREATE FUNCTION inm.pick_submit(target_date date, overwrite integer DEFAULT 0, wait_time_seconds integer DEFAULT 300, OUT submit_status text) RETURNS text
    LANGUAGE plpgsql
    AS $$

/*
Purpose - Submit a pick with task_option controlling how to deal with conflict.

Input -
  target_date: pick date
  overwrite: 0 or 1. If 1, overwrite old pick.
  timeout_seconds: minimum amount of time the task can be in status = "started" before it's considered timed out 
Return -
  submitted_status:
  	submitted - pick submitted.
	started - a pick already in progress for target date.
	ready - a completed pick already existed (and overwrite=0)
*/

declare
	_status text;

begin
	-- delete existing pick for target date if overwrite=1
	if overwrite = 1 
		then delete from inm.pick_list where pick_date = target_date;
	-- delete failed and timed out items
	else 
		delete from inm.pick_list p
			-- where (pick_date = target_date and create_ts + wait_time_seconds < now())
			where (pick_date = target_date 
				   	and extract(epoch from now() - create_ts) > timeout_seconds)
				or status = 'failed';
	end if;
	
	-- remaining pick_list entry for target date is a pick that is in progress and should not be deleted  
	select status
		from inm.pick_list where pick_date = target_date
		into _status;
			
	if _status is null
		then insert into inm.pick_list(pick_date, timeout_seconds) values(target_date, wait_time_seconds);
		submit_status = 'submitted';
	else submit_status = _status;		
	end if;
end;

$$;


ALTER FUNCTION inm.pick_submit(target_date date, overwrite integer, wait_time_seconds integer, OUT submit_status text) OWNER TO dbservice;

--
-- Name: sync_restriction_by_property(integer, character varying); Type: FUNCTION; Schema: inm; Owner: dbservice
--

CREATE FUNCTION inm.sync_restriction_by_property(kiosk_id integer, restriction character varying) RETURNS TABLE(status character varying)
    LANGUAGE plpgsql ROWS 10
    AS $$

begin
	-- sync restrictions by properties with inm gsheets.
	
	-- boiler plate function...to be completed
	-- update inm.restrictions set kiosk...
		
	return query
		select 
		    'Ok';
end

$$;


ALTER FUNCTION inm.sync_restriction_by_property(kiosk_id integer, restriction character varying) OWNER TO dbservice;

--
-- Name: pick_get_delivery_schedule(date); Type: FUNCTION; Schema: inm_backup; Owner: dbservice
--

CREATE FUNCTION inm_backup.pick_get_delivery_schedule(target_date date) RETURNS TABLE(driver_name character varying, route_date_time timestamp with time zone, kiosk_id integer, kiosk_title character varying, address character varying, delivery_order integer)
    LANGUAGE plpgsql
    AS $$

	declare latest_import_ts timestamp;
	declare plan_window_start timestamp;
	declare plan_window_stop timestamp;

/*
Purpose: return INM delivery schedule for a pick window.
Input
	target_date: pick_date
Return
	Data to generate the drivers sheets
*/
begin
	return query
		-- comment appropriate line to switch between optimo and bringg
		select * from inm.pick_get_delivery_schedule_optimo(target_date);
		--select * from inm.pick_get_delivery_schedule_bringg(target_date);
end;

$$;


ALTER FUNCTION inm_backup.pick_get_delivery_schedule(target_date date) OWNER TO dbservice;

--
-- Name: pick_get_demand_weekly_by_velocity(); Type: FUNCTION; Schema: inm_backup; Owner: dbservice
--

CREATE FUNCTION inm_backup.pick_get_demand_weekly_by_velocity() RETURNS TABLE(kiosk_id bigint, sku_group_id integer, fc_title text, demand_weekly numeric)
    LANGUAGE plpgsql
    AS $$

/*
Purpose: return INM weekly demand by velocity
*/

begin
	return query
		select dwwom.kiosk_id , sg.id, cast(sg.fc_title as text),
			cast(
				-- kiosk live less than 4 week
				case when ws_live < 4
				then greatest(
					coalesce (demand_weekly_wo_min, 0),
					kc.start_level * sgc.default_level * coalesce(ksms.scale, 1.0) * kc.manual_multiplier * sgc.scale
					)
				-- kiosk live longer than 4 week
				else greatest(
					coalesce (demand_weekly_wo_min, 0),
					kc.min_level * sgc.default_level * coalesce(ksms.scale, 1.0) * kc.scale * kc.manual_multiplier * sgc.scale
					)
				end as decimal(4,2)) as wk_demand
				
			from  inm.pick_get_demand_weekly_wo_min() dwwom
				  left join inm.kiosk_control kc on dwwom.kiosk_id = kc.kiosk_id
				  left join inm.sku_group sg on dwwom.sku_group = sg.fc_title
				  left join inm.sku_group_control sgc on sgc.sku_group_id = sg.id
				  left join inm.kiosk_sku_group_manual_scale ksms on ksms.kiosk_id = dwwom.kiosk_id and ksms.sku_group_id = sg.id;
end;

$$;


ALTER FUNCTION inm_backup.pick_get_demand_weekly_by_velocity() OWNER TO dbservice;

--
-- Name: pick_get_demand_weekly_by_velocity_20190108(); Type: FUNCTION; Schema: inm_backup; Owner: dbservice
--

CREATE FUNCTION inm_backup.pick_get_demand_weekly_by_velocity_20190108() RETURNS TABLE(kiosk_id bigint, sku_group_id integer, fc_title text, demand_weekly numeric, kc_start_level numeric, kc_min_level numeric, kc_scale numeric, kc_manual_multiplier numeric, sgc_default_level numeric, sgc_scale numeric, ksms_scale numeric, ws_live bigint, velocity_demand numeric)
    LANGUAGE plpgsql
    AS $$
/*
Purpose: return INM weekly demand by velocity
*/

begin
	return query
		select cast(kc.kiosk_id as bigint) , sg.id, cast(sg.fc_title as text),
			cast(
				-- kiosk live less than 4 week
				case when coalesce(dwwom.ws_live, 0) < 4
				then greatest(
					coalesce (demand_weekly_wo_min * coalesce(ksms.scale, 1.0) * kc.manual_multiplier * sgc.scale, 0),
					coalesce (kc.start_level * sgc.default_level * kc.manual_multiplier * sgc.scale, 0)
					)
				-- kiosk live longer than 4 week
				else greatest(
					coalesce (demand_weekly_wo_min * coalesce(ksms.scale, 1.0) * kc.manual_multiplier * sgc.scale, 0),
					coalesce (kc.min_level * sgc.default_level * coalesce(ksms.scale, 1.0) * kc.manual_multiplier * sgc.scale, 0)
					)
				end as decimal(4,2)) as wk_demand,
				
				kc.start_level, kc.min_level, kc.scale, kc.manual_multiplier, sgc.default_level, sgc.scale, coalesce(ksms.scale, 1.0) , coalesce(dwwom.ws_live, 0),
				dwwom.demand_weekly_wo_min
				
			from inm.sku_group sg
				cross join inm.kiosk_control kc
				left join inm.kiosk_sku_group_manual_scale ksms on ksms.kiosk_id=kc.kiosk_id and ksms.sku_group_id=sg.id
				left join inm.sku_group_control sgc on sgc.sku_group_id = sg.id
				left join inm.pick_get_demand_weekly_wo_min() dwwom on dwwom.kiosk_id = kc.kiosk_id and dwwom.sku_group = sg.fc_title;
end;

$$;


ALTER FUNCTION inm_backup.pick_get_demand_weekly_by_velocity_20190108() OWNER TO dbservice;

--
-- Name: pick_get_demand_weekly_wo_min_20190108(); Type: FUNCTION; Schema: inm_backup; Owner: dbservice
--

CREATE FUNCTION inm_backup.pick_get_demand_weekly_wo_min_20190108() RETURNS TABLE(kiosk_id bigint, sku_group character varying, sample_size bigint, dt_avg numeric, dt_std numeric, w_departure_time numeric, preference numeric, pref_total numeric, ws_avg numeric, ws_std numeric, ws_live bigint, demand_weekly_wo_min numeric)
    LANGUAGE plpgsql
    AS $$

/*
Purpose: return INM weekly demand without min by velocity
*/

begin
	return query
			select *,
	round((t7.preference/t7.pref_total)*(t7.ws_avg+t7.ws_std), 2) as demand_weekly_wo_min
from (
	select t4.kiosk_id,
		t4.sku_group,
		t4.sample_size,
		t4.dt_avg,
		t4.dt_std,
		t4.w_departure_time,
		t4.preference,
		sum(t4.preference) over (partition by t4.kiosk_id) as pref_total,
		t6.ws_avg,
		t6.ws_std,
		t6.ws_live
	from (
		select t3.kiosk_id, 
			t3.sku_group, 
			count(t3.purchase_index) as sample_size,
			round((avg(t3.departure_time))::numeric, 2) as dt_avg,
			coalesce(round((stddev(t3.departure_time))::numeric, 2), 0) as dt_std,
			round(sum(t3.departure_time*t3.w)/sum(t3.w)::numeric, 2) as w_departure_time,
			least(round(1.00/(sum(t3.departure_time*t3.w)/sum(t3.w))::numeric, 2), 0.20) as preference
		from (
			select *,
				greatest(coalesce(round((t2.time_sold - greatest(t2.last_sale, t2.time_stocked))::numeric/3600, 2), 50.00), 1.00) as departure_time,
				0 as qty_sold,
				1 as w
				--(t2.purchase_index - t2.last_purchase_index) as qty_sold,
				--coalesce(round((t2.purchase_index - t2.last_purchase_index)::numeric/greatest(coalesce((t2.time_sold - greatest(t2.last_sale, t2.time_stocked))::numeric/3600, 100.00), 1.00), 2), 1.00) as w
			from (
				select *,
					lag(t1.time_sold, 1) over (partition by t1.kiosk_id, t1.sku_group order by t1.time_sold) as last_sale,
					lag(t1.purchase_index, 1) over (partition by t1.kiosk_id, t1.sku_group order by t1.time_sold) as last_purchase_index
				from (
					select k.kiosk_id,
						p.sku_group,
						l.time_stocked,
						l.time_sold,
						l.purchase_index
					from (
						select k.id as kiosk_id
						from pantry.kiosk k
						where k.campus_id=87
							and k.archived=0
							and k.enable_reporting=1
							--and k.id=1274
					) k
					cross join (
						select distinct fc_title as sku_group
						from pantry.product p
						where p.campus_id=87
							and p.archived=0
							and p.fc_title is not null
							and p.fc_title!='N/A'
						order by p.fc_title asc
					) p
					left outer join (
						select l.kiosk_id as kiosk_id,
							p.fc_title as sku_group,
							l.time_created as time_stocked, 
							l.time_updated as time_sold,
							row_number() over (partition by l.kiosk_id order by l.time_updated) as purchase_index
						from pantry.label l
							join pantry.product p on l.product_id=p.id
						where l.kiosk_id is not null
							and l.status='sold'
							and to_timestamp(l.time_updated) at time zone 'US/Pacific' > date_trunc('week', current_timestamp) - interval '24 weeks'
							and p.campus_id=87
							and p.archived=0
							and p.fc_title is not null
					) l on k.kiosk_id=l.kiosk_id and p.sku_group=l.sku_group
					order by k.kiosk_id, p.sku_group, l.purchase_index
				) t1
			) t2
		) t3
		group by t3.kiosk_id, t3.sku_group
	) t4
	join 
	(select t5.kiosk_id, round(avg(units_sold), 2) ws_avg, round(stddev(units_sold), 2) ws_std, count(units_sold) ws_live
		from (
			SELECT concat(kk.kiosk_id::character varying(4), ' ', kk.woy) AS key,
				kk.kiosk_id,
				kk.woy,
				ss.units_sold
			FROM (
				SELECT k.id AS kiosk_id,
					generate_series(1, 52) AS woy
				FROM pantry.kiosk k
				WHERE k.campus_id = 87 AND k.archived = 0 AND k.enable_reporting = 1 AND k.enable_monitoring = 1) kk
			LEFT JOIN ( 
				SELECT s.kiosk_id,
					date_part('week'::text, s.ts) AS woy,
					count(*) AS units_sold
				FROM byte_epcssold_3months s
				GROUP BY s.kiosk_id, (date_part('week'::text, s.ts))) ss ON kk.kiosk_id = ss.kiosk_id AND kk.woy::double precision = ss.woy
			ORDER BY ss.kiosk_id, ss.woy) t5
		group by t5.kiosk_id
		order by t5.kiosk_id asc
	) t6 on t4.kiosk_id=t6.kiosk_id) t7;

			
end;

$$;


ALTER FUNCTION inm_backup.pick_get_demand_weekly_wo_min_20190108() OWNER TO dbservice;

--
-- Name: pick_get_order_with_sales_ratio(timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: inm_backup; Owner: dbservice
--

CREATE FUNCTION inm_backup.pick_get_order_with_sales_ratio(start_ts timestamp with time zone, end_ts timestamp with time zone) RETURNS TABLE(kiosk_id integer, route_date_time timestamp with time zone, sku_group_id integer, fc_title text, week_demand_qty integer, plan_demand_qty numeric, plan_order_qty numeric)
    LANGUAGE plpgsql
    AS $$
  /*
  Purpose - return INM order based on sales ratio for pick sales period (time between deliveries)
  Input -
    start_ts: plan window start date time with time zone
    end_ts: plan window end date time with time zone
  Return -
    kiosk_id: together with route_date_time is unique for the plan window
    route_date_time: route starting date time
    fc_title: sku group name
    week_demand_qty: demand based on once a week delivery (without minimum)
    plan_demand_qty: demand based on sales ratio for pick sales period (without minimum)
    plan_order_qty: order based on sales ratio for pick sales period
  */

declare latest_import_ts_for_pick_window timestamp with time zone;
begin
  -- get the latest import_ts for the same day as start_ts
  select max(import_ts) from mixalot.inm_data i
  where import_ts::date = start_ts::date and data_type = 'Par Unconstrained wo Min' -- make sure import contain this data_type
    into latest_import_ts_for_pick_window;
  return query
    --  Given
    --		sales period = time between this pick delivery and next pick delivery (may be changed to pick times in the future)
    --		inm.qty = week demand
    --		sr.sales_ratio = sale ratio for this sum items sold for pick sales period for the last 4 weeks vs items sold for the last 4 weeks 
    -- 	if item is restricted (inm_qty=0), then set demand to 0. 
    --  else 
    --		if item doesn't exist in the kiosk (inv.count is null), set its inv count to 0
    -- 		order_before_min_max = 1.4 * sr.sales_ratio * inm.qty - inv.count
    -- 		final_order = min + order_before_min_max, capped by max as defined for each sku group

    -- FIXME: temp increase for after Thanksgiving. Change mutiplier from 1.52 (in 2 places below) to 1.4 on 2018-12-17
    select sr.kiosk_id, sr.route_date_time, sga.id, inm.fc_title, inm.qty week_demand_qty,
           cast(1.52 * sr.sales_ratio * inm.qty as numeric (8,2)) plan_demand_qty,
           case
             -- restricted item
             when inm.qty = 0 then 0
             else
               -- cap at week_qty
               least(
                 -- change minimum is 0 (don't remove from a kiosk)
                   least(greatest(ceiling(1.52 * sr.sales_ratio * inm.qty) + sga.minimum_kiosk_qty - coalesce(inv.count, 0),
                                  0) /* change negative demand to 0 */
                     , sga.maximum_kiosk_qty),
                   inm.qty)
             end as plan_order_qty -- end case

    from inm.pick_get_sales_period_ratio(start_ts, end_ts) sr
           join mixalot.inm_data inm
                on sr.kiosk_id = inm.kiosk_id
                  and inm.data_type = 'Par Unconstrained wo Min'
                  and inm.import_ts = latest_import_ts_for_pick_window
           join inm.sku_group_attribute sga
                on sga.title = inm.fc_title
           left join mixalot.inm_kiosk_projected_stock inv
                     on inm.kiosk_id = inv.kiosk_id and inm.fc_title = inv.fc_title;
end;

$$;


ALTER FUNCTION inm_backup.pick_get_order_with_sales_ratio(start_ts timestamp with time zone, end_ts timestamp with time zone) OWNER TO dbservice;

--
-- Name: pick_get_order_with_velocity(timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: inm_backup; Owner: dbservice
--

CREATE FUNCTION inm_backup.pick_get_order_with_velocity(start_ts timestamp with time zone, end_ts timestamp with time zone) RETURNS TABLE(kiosk_id integer, route_date_time timestamp with time zone, sku_group_id integer, fc_title text, week_demand_qty numeric, plan_demand_qty numeric, plan_order_qty numeric)
    LANGUAGE plpgsql
    AS $$

/*
Purpose - return INM order based on sales ratio for pick sales period (time between deliveries)
Input -
  start_ts: plan window start date time with time zone
  end_ts: plan window end date time with time zone
Return -
  kiosk_id: together with route_date_time is unique for the plan window
  route_date_time: route starting date time
  fc_title: sku group name
  week_demand_qty: demand based on once a week delivery (without minimum)
  plan_demand_qty: demand based on sales ratio for pick sales period (without minimum)
  plan_order_qty: order based on sales ratio for pick sales period
*/

begin
	return query
		--  Given
		--		sales period = time between this pick delivery and next pick delivery (may be changed to pick times in the future)
		--		inm.demand_weekly = week demand
		--		sr.sales_ratio = sale ratio for this sum items sold for pick sales period for the last 4 weeks vs items sold for the last 4 weeks 
		-- 	if item is restricted (inm_qty=0), then set demand to 0. 
		--  else 
		--		if item doesn't exist in the kiosk (inv.count is null), set its inv count to 0
		-- 		order_before_min_max = 1.4 * sr.sales_ratio * inm.demand_weekly - inv.count
		-- 		final_order = min + order_before_min_max, capped by max as defined for each sku group
		
		select sr.kiosk_id, sr.route_date_time, sga.id, dwbv.fc_title, dwbv.demand_weekly as week_demand_qty, 
			cast(1.4 * sr.sales_ratio * dwbv.demand_weekly as numeric (8,2)) plan_demand_qty,
			case 
				-- restricted item if demand_weekly is 0 or kiosk_sku_group manual scale is zero
				when dwbv.demand_weekly = 0 or ksms.scale = 0.0 then 0 
				else
					-- cap at week_qty
					least(
						-- change minimum is 0 (don't remove from a kiosk)
						least(greatest(ceiling(1.4 * sr.sales_ratio * dwbv.demand_weekly) + sga.minimum_kiosk_qty - coalesce(inv.count, 0),
											  0) /* change negative demand to 0 */
								   , sga.maximum_kiosk_qty),
						dwbv.demand_weekly)
			end as plan_order_qty -- end case
					   
			from inm.pick_get_sales_period_ratio(start_ts, end_ts) sr
			
				join inm.pick_get_demand_weekly_by_velocity() dwbv
					on sr.kiosk_id = dwbv.kiosk_id 
												
				join inm.sku_group_attribute sga
					on sga.title = dwbv.fc_title			
				left join mixalot.inm_kiosk_projected_stock inv
					on dwbv.kiosk_id = inv.kiosk_id and dwbv.fc_title = inv.fc_title
				left join inm.kiosk_sku_group_manual_scale ksms
					on sr.kiosk_id = ksms.kiosk_id and sga.id = ksms.sku_group_id;				
	end;

$$;


ALTER FUNCTION inm_backup.pick_get_order_with_velocity(start_ts timestamp with time zone, end_ts timestamp with time zone) OWNER TO dbservice;

--
-- Name: pick_get_plan_kiosk_bringg(timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: inm_backup; Owner: dbservice
--

CREATE FUNCTION inm_backup.pick_get_plan_kiosk_bringg(plan_window_start timestamp with time zone, plan_window_stop timestamp with time zone) RETURNS TABLE(kiosk_id integer, route_date_time timestamp with time zone, driver_name character varying, location_name character varying, next_delivery_ts timestamp with time zone, time_to_next_delivery interval, days_to_next_delivery double precision, delivery_order bigint)
    LANGUAGE plpgsql
    AS $$

/*
Purpose: return INM plan kiosks for a pick window.
*/

begin
	return query
		select ds.kiosk_id, ds.route_date_time, ds.driver_name, k.title, ps.next_delivery_ts,
		ps.next_delivery_ts - ds.route_date_time as time_to_next_delivery,		
		  case 
		  	when ps.next_delivery_ts - ds.route_date_time between interval '12 hours' and interval '24 hours' then 1
			else extract(day from ps.next_delivery_ts - ds.route_date_time)
			end as days_to_next_delivery,
		  row_number() over (order by ds.route_date_time asc) as delivery_order
		 		
		from
		-- kiosk_id, delivery_date
		(select t.kiosk_id, t.route_date_time, t.driver_name from
			(select cast(kid as integer) as kiosk_id, rs.route_date_time, rs.driver_name,
				rank() over (partition by kid, rs.route_date_time order by rs.route_date_time) as r
				from bringg.order rs
				where rs.route_date_time >= plan_window_start -- look at routes starting at plan winddow start
			 	and rs.status <> 7
				) t
				where r = 1) ds

		left join 
		-- kiosk_id, pull_date
		(select t.kiosk_id, t.route_date_time next_delivery_ts from
			(select cast(kid as integer) as kiosk_id, rs.route_date_time,
				rank() over (partition by kid order by rs.route_date_time) as r
				from bringg.order rs
				where rs.route_date_time >= plan_window_start -- look at routes starting at plan window start
			 	and rs.status <> 7
				) t
				where r = 2) ps

			on ds.kiosk_id = ps.kiosk_id
			join pantry.kiosk k on ds.kiosk_id = k.id
			where ds.route_date_time between plan_window_start and plan_window_stop
			and k.campus_id= 87;	
end;

$$;


ALTER FUNCTION inm_backup.pick_get_plan_kiosk_bringg(plan_window_start timestamp with time zone, plan_window_stop timestamp with time zone) OWNER TO dbservice;

--
-- Name: pick_get_ticket(date); Type: FUNCTION; Schema: inm_backup; Owner: dbservice
--

CREATE FUNCTION inm_backup.pick_get_ticket(target_date date) RETURNS TABLE(pick_station bigint, vendor character varying, item_code bigint, item_name character varying, site_code bigint, site_name character varying, proposed_supply integer, total_pick_qty bigint, total_pick_sku integer, driver_name character varying, route_date date, route_time time without time zone, route_date_time timestamp without time zone, route_number character varying, restrictions text, address character varying, pull_date date, delivery_order integer, pick_order integer)
    LANGUAGE plpgsql
    AS $$

	declare latest_import_ts timestamp;
	declare plan_window_start timestamp;
	declare plan_window_stop timestamp;
begin
	-- return pick ticket data for the latest pick
	
	-- calculate various date params
	select max(import_ts) from mixalot.inm_data into latest_import_ts;
	select i.route_date from mixalot.inm_data i
		where import_ts = latest_import_ts and data_type = 'Plan Window Start'
		into plan_window_start;
	select i.route_date from mixalot.inm_data i
		where import_ts = latest_import_ts and data_type = 'Plan Window Stop'
		into plan_window_stop;
	
	if target_date is null
		then target_date = plan_window_start::date;
	end if;
		
	return query
		select 
				p.pick_station, p.vendor, p.id, p.title ItemName,
				k.id sitecode, k.title sitename, a.qty proposed_supply, 
				sum(a.qty) over(partition by k.id, route.route_date) total_pick_qty,
				-1 total_pick_sku, route.driver_name DriverName,
				route.route_date RouteDate, route.route_time RouteTime,
				route.route_date + route.route_time route_date_time, route.route_number,
				r.restrictions,
				k.address,
				pd.pull_date,
				cast(route.delivery_order as integer),
				spo.pick_order
			from inm.pick_allocation a 
				left join pantry.kiosk k on a.kiosk_id = k.id
				-- left join mixalot.inm_kiosk_restriction_list r on k.id = r.kiosk_id
				left join inm.kiosk_restriction_list r on k.id = r.kiosk_id
				join pantry.product p on a.sku_id = p.id
				
				-- FIXME remove all following comments after verify 2018-12-05
				-- Actually, need to compare both route_date and route_time so the next line is not correct
				-- join inm.pick_route route on a.route_date=route.route_date and a.kiosk_id = route.kiosk_id 
				-- so instead use this line:
				join inm.pick_route route on a.pick_date=route.pick_date and a.route_date = route.route_date and a.kiosk_id = route.kiosk_id
				
				left join inm.get_pull_date(plan_window_start, plan_window_stop) pd on a.kiosk_id = pd.kiosk_id
				left join mixalot.sku_pick_order(latest_import_ts) spo on p.id = spo.sku_id
			where k.campus_id = 87
			and a.pick_date = target_date;
end

$$;


ALTER FUNCTION inm_backup.pick_get_ticket(target_date date) OWNER TO dbservice;

--
-- Name: pick_get_demand_weekly_by_velocity(); Type: FUNCTION; Schema: inm_beta; Owner: dbservice
--

CREATE FUNCTION inm_beta.pick_get_demand_weekly_by_velocity() RETURNS TABLE(kiosk_id bigint, sku_group_id integer, fc_title text, demand_weekly numeric, kc_start_level numeric, kc_min_level numeric, kc_scale numeric, kc_manual_multiplier numeric, sgc_default_level numeric, sgc_scale numeric, ksms_scale numeric, ws_live bigint, velocity_demand numeric)
    LANGUAGE plpgsql
    AS $$

/*
Purpose: return INM weekly demand by velocity
*/

begin
	return query
		select cast(kc.kiosk_id as bigint) , sg.id, cast(sg.fc_title as text),
			cast(
				-- kiosk live less than 4 week
				case when coalesce(dwwom.ws_live, 0) < 4
				then greatest(
					coalesce (demand_weekly_wo_min, 0),
					kc.start_level * sgc.default_level * coalesce(ksms.scale, 1.0) * kc.manual_multiplier * sgc.scale
					)
				-- kiosk live longer than 4 week
				else greatest(
					coalesce (demand_weekly_wo_min, 0),
					kc.min_level * sgc.default_level * coalesce(ksms.scale, 1.0) * kc.scale * kc.manual_multiplier * sgc.scale
					)
				end as decimal(4,2)) as wk_demand,
				
				kc.start_level, kc.min_level, kc.scale, kc.manual_multiplier, sgc.default_level, sgc.scale, coalesce(ksms.scale, 1.0) , coalesce(dwwom.ws_live, 0),
				dwwom.demand_weekly_wo_min
				
			from inm.sku_group sg
				cross join inm.kiosk_control kc
				left join inm.kiosk_sku_group_manual_scale ksms on ksms.kiosk_id=kc.kiosk_id and ksms.sku_group_id=sg.id
				left join inm.sku_group_control sgc on sgc.sku_group_id = sg.id
				left join inm.pick_get_demand_weekly_wo_min() dwwom on dwwom.kiosk_id = kc.kiosk_id and dwwom.sku_group = sg.fc_title;
end;

$$;


ALTER FUNCTION inm_beta.pick_get_demand_weekly_by_velocity() OWNER TO dbservice;

--
-- Name: pick_get_demand_weekly_wo_min(); Type: FUNCTION; Schema: inm_beta; Owner: dbservice
--

CREATE FUNCTION inm_beta.pick_get_demand_weekly_wo_min() RETURNS TABLE(kiosk_id bigint, sku_group character varying, sample_size bigint, dt_avg numeric, dt_std numeric, w_departure_time numeric, preference numeric, pref_total numeric, ws_avg numeric, ws_std numeric, ws_live bigint, demand_weekly_wo_min numeric)
    LANGUAGE plpgsql
    AS $$

/*
Purpose: return INM weekly demand without min by velocity
*/

begin
	return query
			select *,
	round((t7.preference/t7.pref_total)*(t7.ws_avg+t7.ws_std), 2) as demand_weekly_wo_min
from (
	select t4.kiosk_id,
		t4.sku_group,
		t4.sample_size,
		t4.dt_avg,
		t4.dt_std,
		t4.w_departure_time,
		t4.preference,
		sum(t4.preference) over (partition by t4.kiosk_id) as pref_total,
		t6.ws_avg,
		t6.ws_std,
		t6.ws_live
	from (
		select t3.kiosk_id, 
			t3.sku_group, 
			count(t3.purchase_index) as sample_size,
			round((avg(t3.departure_time))::numeric, 2) as dt_avg,
			coalesce(round((stddev(t3.departure_time))::numeric, 2), 0) as dt_std,
			round(sum(t3.departure_time*t3.w)/sum(t3.w)::numeric, 2) as w_departure_time,
			least(round(1.00/(sum(t3.departure_time*t3.w)/sum(t3.w))::numeric, 2), 0.20) as preference
		from (
			select *,
				greatest(coalesce(round((t2.time_sold - greatest(t2.last_sale, t2.time_stocked))::numeric/3600, 2), 50.00), 1.00) as departure_time,
				0 as qty_sold,
				1 as w
				--(t2.purchase_index - t2.last_purchase_index) as qty_sold,
				--coalesce(round((t2.purchase_index - t2.last_purchase_index)::numeric/greatest(coalesce((t2.time_sold - greatest(t2.last_sale, t2.time_stocked))::numeric/3600, 100.00), 1.00), 2), 1.00) as w
			from (
				select *,
					lag(t1.time_sold, 1) over (partition by t1.kiosk_id, t1.sku_group order by t1.time_sold) as last_sale,
					lag(t1.purchase_index, 1) over (partition by t1.kiosk_id, t1.sku_group order by t1.time_sold) as last_purchase_index
				from (
					select k.kiosk_id,
						p.sku_group,
						l.time_stocked,
						l.time_sold,
						l.purchase_index
					from (
						select k.id as kiosk_id
						from pantry.kiosk k
						where k.campus_id=87
							and k.archived=0
							and k.enable_reporting=1
							--and k.id=1274
					) k
					cross join (
						select distinct fc_title as sku_group
						from pantry.product p
						where p.campus_id=87
							and p.archived=0
							and p.fc_title is not null
							and p.fc_title!='N/A'
						order by p.fc_title asc
					) p
					left outer join (
						select l.kiosk_id as kiosk_id,
							p.fc_title as sku_group,
							l.time_created as time_stocked, 
							l.time_updated as time_sold,
							row_number() over (partition by l.kiosk_id order by l.time_updated) as purchase_index
						from pantry.label l
							join pantry.product p on l.product_id=p.id
						where l.kiosk_id is not null
							and l.status='sold'
							and to_timestamp(l.time_updated) at time zone 'US/Pacific' > date_trunc('week', current_timestamp) - interval '24 weeks'
							and p.campus_id=87
							and p.archived=0
							and p.fc_title is not null
					) l on k.kiosk_id=l.kiosk_id and p.sku_group=l.sku_group
					order by k.kiosk_id, p.sku_group, l.purchase_index
				) t1
			) t2
		) t3
		group by t3.kiosk_id, t3.sku_group
	) t4
	join 
	(select t5.kiosk_id, round(avg(units_sold), 2) ws_avg, round(stddev(units_sold), 2) ws_std, count(units_sold) ws_live
		from (
			SELECT concat(kk.kiosk_id::character varying(4), ' ', kk.woy) AS key,
				kk.kiosk_id,
				kk.woy,
				ss.units_sold
			FROM (
				SELECT k.id AS kiosk_id,
					generate_series(1, 52) AS woy
				FROM pantry.kiosk k
				WHERE k.campus_id = 87 AND k.archived = 0 AND k.enable_reporting = 1 AND k.enable_monitoring = 1) kk
			LEFT JOIN ( 
				SELECT s.kiosk_id,
					date_part('week'::text, s.ts) AS woy,
					count(*) AS units_sold
				FROM byte_epcssold_3months s
				GROUP BY s.kiosk_id, (date_part('week'::text, s.ts))) ss ON kk.kiosk_id = ss.kiosk_id AND kk.woy::double precision = ss.woy
			ORDER BY ss.kiosk_id, ss.woy) t5
		group by t5.kiosk_id
		order by t5.kiosk_id asc
	) t6 on t4.kiosk_id=t6.kiosk_id) t7;

			
end;

$$;


ALTER FUNCTION inm_beta.pick_get_demand_weekly_wo_min() OWNER TO dbservice;

--
-- Name: pick_get_order(timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: inm_beta; Owner: dbservice
--

CREATE FUNCTION inm_beta.pick_get_order(start_ts timestamp with time zone, end_ts timestamp with time zone) RETURNS TABLE(kiosk_id integer, route_date_time timestamp with time zone, sku_group_id integer, fc_title text, week_qty integer, plan_qty integer)
    LANGUAGE plpgsql ROWS 10000
    AS $$

/*
Purpose - return INM order for the next sale period which is the time between the deliveries of this pick and the next pick
Comment - Why go through this function and not call pick_get_order_with_velocity(start_date, end_date) directly? There are 2 reasons:
	1. We can replace pick_get_order_with_velocity with a newer fucntion here and not having to change the client code to test the new function.
	2. pick_get_order_with_velocity returns richer data that can be used for troubleshooting which is not necessary for production.

Input -
  start_ts: plan window start date time with time zone
  end_ts: plan window end date time with time zone
Return -
  kiosk_id: together with route_date_time is unique for the plan window
  route_date_time: route starting date time
  fc_title: sku group name
  plan_qty: order quantity for the above fc_title for the next sale period
*/

begin
	return query
		-- with sales ratio and velocity
		select ov.kiosk_id, ov.route_date_time, ov.sku_group_id, ov.fc_title, cast(ov.week_demand_qty as integer), cast(ov.plan_order_qty as integer) from inm_beta.pick_get_order_with_velocity(start_ts, end_ts) ov;
		
end;

$$;


ALTER FUNCTION inm_beta.pick_get_order(start_ts timestamp with time zone, end_ts timestamp with time zone) OWNER TO dbservice;

--
-- Name: pick_get_order_with_velocity(timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: inm_beta; Owner: dbservice
--

CREATE FUNCTION inm_beta.pick_get_order_with_velocity(start_ts timestamp with time zone, end_ts timestamp with time zone) RETURNS TABLE(kiosk_id integer, route_date_time timestamp with time zone, sku_group_id integer, fc_title text, week_demand_qty numeric, plan_demand_qty numeric, plan_order_qty numeric)
    LANGUAGE plpgsql
    AS $$

/*
Purpose - return INM order based on sales ratio for pick sales period (time between deliveries)
Input -
  start_ts: plan window start date time with time zone
  end_ts: plan window end date time with time zone
Return -
  kiosk_id: together with route_date_time is unique for the plan window
  route_date_time: route starting date time
  fc_title: sku group name
  week_demand_qty: demand based on once a week delivery (without minimum)
  plan_demand_qty: demand based on sales ratio for pick sales period (without minimum)
  plan_order_qty: order based on sales ratio for pick sales period
*/

begin
	return query
		--  Given
		--		sales period = time between this pick delivery and next pick delivery (may be changed to pick times in the future)
		--		inm.demand_weekly = week demand
		--		sr.sales_ratio = sale ratio for this sum items sold for pick sales period for the last 4 weeks vs items sold for the last 4 weeks 
		-- 	if item is restricted (inm_qty=0), then set demand to 0. 
		--  else 
		--		if item doesn't exist in the kiosk (inv.count is null), set its inv count to 0
		-- 		order_before_min_max = 1.4 * sr.sales_ratio * inm.demand_weekly - inv.count
		-- 		final_order = min + order_before_min_max, capped by max as defined for each sku group
		
		select sr.kiosk_id, sr.route_date_time, sgc.sku_group_id, dwbv.fc_title, dwbv.demand_weekly as week_demand_qty, 
			cast(1.4 * sr.sales_ratio * dwbv.demand_weekly as numeric (8,2)) plan_demand_qty,
			case 
				-- restricted item if demand_weekly is 0 or kiosk_sku_group manual scale is zero
				when dwbv.demand_weekly = 0 or ksms.scale = 0.0 then 0 
				else
					ceiling(
						-- change minimum is 0 (don't remove from a kiosk)
						least(greatest(least(1.4 * sr.sales_ratio * dwbv.demand_weekly, dwbv.demand_weekly) + sgc.min_qty - coalesce(inv.count, 0),
											  0) /* change negative demand to 0 */
								   , sgc.max_qty))
			end as plan_order_qty -- end case
					   
			from inm_beta.pick_get_sales_period_ratio(start_ts, end_ts) sr
			
				join inm_beta.pick_get_demand_weekly_by_velocity() dwbv
					on sr.kiosk_id = dwbv.kiosk_id 											
				join inm_beta.sku_group_control sgc
					on sgc.sku_group_id = dwbv.sku_group_id			
				left join mixalot.inm_kiosk_projected_stock inv
					on dwbv.kiosk_id = inv.kiosk_id and dwbv.fc_title = inv.fc_title
				left join inm_beta.kiosk_sku_group_manual_scale ksms
					on sr.kiosk_id = ksms.kiosk_id and sgc.sku_group_id = ksms.sku_group_id;				
	end;

$$;


ALTER FUNCTION inm_beta.pick_get_order_with_velocity(start_ts timestamp with time zone, end_ts timestamp with time zone) OWNER TO dbservice;

--
-- Name: pick_get_plan_kiosk(date); Type: FUNCTION; Schema: inm_beta; Owner: dbservice
--

CREATE FUNCTION inm_beta.pick_get_plan_kiosk(pick_date date) RETURNS TABLE(kiosk_id integer, route_date_time timestamp with time zone, driver_name character varying, location_name character varying, next_delivery_ts timestamp with time zone, time_to_next_delivery interval, days_to_next_delivery double precision, delivery_order bigint)
    LANGUAGE plpgsql
    AS $$

declare
	pst_plan_window_start_str text;
	plan_window_start timestamp with time zone;
	plan_window_stop timestamp with time zone;
/*
Purpose: return INM plan kiosks for a pick date.
*/

begin
	-- compose US/Pacific start window timestamp string
	pst_plan_window_start_str = cast(pick_date as text) || ' 13:00 -8';
	
	select into plan_window_start cast(pst_plan_window_start_str as timestamp with time zone);
	plan_window_stop = plan_window_start + interval '22 hours';
	return query
		select * from inm_beta.pick_get_plan_kiosk(plan_window_start, plan_window_stop);
end;

$$;


ALTER FUNCTION inm_beta.pick_get_plan_kiosk(pick_date date) OWNER TO dbservice;

--
-- Name: pick_get_plan_kiosk(timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: inm_beta; Owner: dbservice
--

CREATE FUNCTION inm_beta.pick_get_plan_kiosk(plan_window_start timestamp with time zone, plan_window_stop timestamp with time zone) RETURNS TABLE(kiosk_id integer, route_date_time timestamp with time zone, driver_name character varying, location_name character varying, next_delivery_ts timestamp with time zone, time_to_next_delivery interval, days_to_next_delivery double precision, delivery_order bigint)
    LANGUAGE plpgsql
    AS $$

/*
Purpose: return INM plan kiosks for a pick window.
*/

begin
	return query
		select ds.kiosk_id, ds.route_date_time, ds.driver_name, ds.location_name, ps.next_delivery_ts,
		ps.next_delivery_ts - ds.route_date_time as time_to_next_delivery,		
		  case 
		  	when ps.next_delivery_ts - ds.route_date_time between interval '12 hours' and interval '24 hours' then 1
			else extract(day from ps.next_delivery_ts - ds.route_date_time)
			end as days_to_next_delivery,
		  row_number() over (order by ds.route_date_time asc) as delivery_order
		  
		
		from
		-- kiosk_id, delivery_date
		(select t.kiosk_id, t.route_date_time, t.driver_name, t.location_name from
			(select location_number as kiosk_id, rs.route_date_time, rs.driver_name, rs.location_name,
				rank() over (partition by location_number, rs.route_date_time order by rs.route_date_time) as r
				from mixalot.route_stop rs
				where rs.route_date_time >= plan_window_start -- look at routes starting at plan winddow start
				and location_number > 0) t
				where r = 1) ds

		left join 
		-- kiosk_id, pull_date
		(select t.kiosk_id, t.route_date_time next_delivery_ts from
			(select location_number as kiosk_id, rs.route_date_time,
				rank() over (partition by location_number order by rs.route_date_time) as r
				from mixalot.route_stop rs
				where rs.route_date_time >= plan_window_start -- look at routes starting at plan window start
				and location_number > 0) t
				where r = 2) ps

			on ds.kiosk_id = ps.kiosk_id
			join pantry.kiosk k on ds.kiosk_id = k.id
			where ds.route_date_time between plan_window_start and plan_window_stop
			and k.campus_id= 87;	
end;

$$;


ALTER FUNCTION inm_beta.pick_get_plan_kiosk(plan_window_start timestamp with time zone, plan_window_stop timestamp with time zone) OWNER TO dbservice;

--
-- Name: pick_get_plan_kiosk_disabled_product(date); Type: FUNCTION; Schema: inm_beta; Owner: dbservice
--

CREATE FUNCTION inm_beta.pick_get_plan_kiosk_disabled_product(pick_date date) RETURNS TABLE(kiosk_id bigint, product_id integer)
    LANGUAGE plpgsql
    AS $$

/*
Purpose: return disabled products for kiosks on the pick for a pick date.
*/

begin
	return query
		select dp.kiosk_id, dp.product_id
		from inm.pick_get_plan_kiosk(pick_date) pk
			join inm.kiosk_product_disabled dp on pk.kiosk_id = dp.kiosk_id;
end;

$$;


ALTER FUNCTION inm_beta.pick_get_plan_kiosk_disabled_product(pick_date date) OWNER TO dbservice;

--
-- Name: pick_get_plan_kiosk_projected_stock(timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: inm_beta; Owner: dbservice
--

CREATE FUNCTION inm_beta.pick_get_plan_kiosk_projected_stock(plan_window_start timestamp with time zone, plan_window_stop timestamp with time zone) RETURNS TABLE(kiosk_id integer, fc_title character varying, qty integer)
    LANGUAGE plpgsql
    AS $$

/*
Purpose: return projected stock for plan kiosks for a pick window.
*/

begin
	return query
		select pk.kiosk_id, kps.fc_title, cast(kps.count as integer) from inm_beta.pick_get_plan_kiosk(plan_window_start, plan_window_stop) pk			
		left join inm_beta.kiosk_projected_stock kps on pk.kiosk_id = kps.kiosk_id
			where kps.fc_title is not null;
end;

$$;


ALTER FUNCTION inm_beta.pick_get_plan_kiosk_projected_stock(plan_window_start timestamp with time zone, plan_window_stop timestamp with time zone) OWNER TO dbservice;

--
-- Name: pick_get_sales_period_ratio(timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: inm_beta; Owner: dbservice
--

CREATE FUNCTION inm_beta.pick_get_sales_period_ratio(start_ts timestamp with time zone, end_ts timestamp with time zone) RETURNS TABLE(kiosk_id integer, route_date_time timestamp with time zone, sales_ratio numeric)
    LANGUAGE plpgsql ROWS 10000
    AS $$
  /*
  Purpose - return INM the ratio of the next sale period(time between the deliveries of this pick and the next pick) vs sales for the week using 12 week history
  Input -
    start_ts: plan window start date time with time zone
    end_ts: plan window end date time with time zone
  Return -
    kiosk_id: together with route_date_time is unique for the plan window
    route_date_time: route starting date time
    fc_title: sku group name
    plan_qty: order quantity for the above fc_title for the next sale period
  */

  -- FIX ME:
  -- handle missing past data
  -- check kid with multiple deliveries
begin
  return query
    select scheduled_kiosks.kiosk_id, scheduled_kiosks.route_date_time, coalesce(existing_kiosk_with_sales_ratio.ratio, 1.0/3.0)
    from inm.pick_get_plan_kiosk(start_ts, end_ts) scheduled_kiosks -- all the kiosks on route
           left join -- kiosks with sales history
      (
        select whole_12_weeks.kiosk_id, whole_12_weeks.route_date_time,
               case when whole_12_weeks.qty < 5 then 1.0/3.0 -- new kiosk, assume period sale is 1/3 of total week
                    else cast(period_12_weeks.qty as decimal)/cast(whole_12_weeks.qty as decimal)
                 end ratio
        from
          -- count of sales for the whole previous 12 weeks
          (select pk.kiosk_id, pk.route_date_time, count(*) qty
           from inm.pick_get_plan_kiosk(start_ts, end_ts) pk
                  join pantry.label l on pk.kiosk_id=l.kiosk_id
           where l.status in ('sold')
             and to_timestamp(l.time_updated) between
               pk.next_delivery_ts - interval '91 days'
             and pk.next_delivery_ts - interval '7 days'
           group by 1, 2
          ) whole_12_weeks

            join

          -- count of sales for the sales peiod of previous 4 weeks
            (
              select pk.kiosk_id, pk.route_date_time, count(*) qty
              from inm.pick_get_plan_kiosk(start_ts, end_ts) pk
                     join pantry.label l on pk.kiosk_id=l.kiosk_id
              where l.status in ('sold') and
                (
                    to_timestamp(l.time_updated) between pk.route_date_time - interval '7 days' + interval '4 hours' and pk.next_delivery_ts - interval '7 days'  + interval '4 hours' or
                    to_timestamp(l.time_updated) between pk.route_date_time - interval '14 days'  + interval '4 hours' and pk.next_delivery_ts - interval '14 days'  + interval '4 hours' or
                    to_timestamp(l.time_updated) between pk.route_date_time - interval '21 days'  + interval '4 hours' and pk.next_delivery_ts - interval '21 days'  + interval '4 hours' or
                    to_timestamp(l.time_updated) between pk.route_date_time - interval '28 days'  + interval '4 hours' and pk.next_delivery_ts - interval '28 days' + interval '4 hours' or

                    to_timestamp(l.time_updated) between pk.route_date_time - interval '35 days' + interval '4 hours' and pk.next_delivery_ts - interval '35 days'  + interval '4 hours' or
                    to_timestamp(l.time_updated) between pk.route_date_time - interval '42 days' + interval '4 hours' and pk.next_delivery_ts - interval '42 days'  + interval '4 hours' or
                    to_timestamp(l.time_updated) between pk.route_date_time - interval '49 days' + interval '4 hours' and pk.next_delivery_ts - interval '49 days'  + interval '4 hours' or
                    to_timestamp(l.time_updated) between pk.route_date_time - interval '56 days' + interval '4 hours' and pk.next_delivery_ts - interval '56 days'  + interval '4 hours' or

                    to_timestamp(l.time_updated) between pk.route_date_time - interval '63 days' + interval '4 hours' and pk.next_delivery_ts - interval '63 days'  + interval '4 hours' or
                    to_timestamp(l.time_updated) between pk.route_date_time - interval '70 days' + interval '4 hours' and pk.next_delivery_ts - interval '70 days'  + interval '4 hours' or
                    to_timestamp(l.time_updated) between pk.route_date_time - interval '77 days' + interval '4 hours' and pk.next_delivery_ts - interval '77 days'  + interval '4 hours' or
                    to_timestamp(l.time_updated) between pk.route_date_time - interval '84 days' + interval '4 hours' and pk.next_delivery_ts - interval '84 days'  + interval '4 hours'
                  )
              group by 1, 2
            ) period_12_weeks

          on whole_12_weeks.kiosk_id = period_12_weeks.kiosk_id
      ) existing_kiosk_with_sales_ratio

                     on scheduled_kiosks.kiosk_id = existing_kiosk_with_sales_ratio.kiosk_id and scheduled_kiosks.route_date_time = existing_kiosk_with_sales_ratio.route_date_time;

end;

$$;


ALTER FUNCTION inm_beta.pick_get_sales_period_ratio(start_ts timestamp with time zone, end_ts timestamp with time zone) OWNER TO dbservice;

--
-- Name: pick_get_sales_period_ratio_4wks(timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: inm_beta; Owner: dbservice
--

CREATE FUNCTION inm_beta.pick_get_sales_period_ratio_4wks(start_ts timestamp with time zone, end_ts timestamp with time zone) RETURNS TABLE(kiosk_id integer, route_date_time timestamp with time zone, sales_ratio numeric)
    LANGUAGE plpgsql ROWS 10000
    AS $$

/*
Purpose - return INM the ratio of the next sale period(time between the deliveries of this pick and the next pick) vs sales for the week
Input -
  start_ts: plan window start date time with time zone
  end_ts: plan window end date time with time zone
Return -
  kiosk_id: together with route_date_time is unique for the plan window
  route_date_time: route starting date time
  fc_title: sku group name
  plan_qty: order quantity for the above fc_title for the next sale period
*/

-- FIX ME: 
-- handle missing past data
-- check kid with multiple deliveries
begin	
	return query
		select scheduled_kiosks.kiosk_id, scheduled_kiosks.route_date_time, coalesce(existing_kiosk_with_sales_ratio.ratio, 1.0/3.0)
			from inm.pick_get_plan_kiosk(start_ts, end_ts) scheduled_kiosks -- all the kiosks on route
				left join -- kiosks with sales history
					(
					select whole_4_weeks.kiosk_id, whole_4_weeks.route_date_time, 
						case when whole_4_weeks.qty < 5 then 1.0/3.0 -- new kiosk, assume period sale is 1/3 of total week
							else cast(period_4_weeks.qty as decimal)/cast(whole_4_weeks.qty as decimal)
							end ratio		
					from
						-- count of sales for the whole previous 4 weeks 
						(select pk.kiosk_id, pk.route_date_time, count(*) qty 
							from inm.pick_get_plan_kiosk(start_ts, end_ts) pk
								join pantry.label l on pk.kiosk_id=l.kiosk_id
								where l.status in ('out', 'sold')
									and to_timestamp(l.time_updated) between
										pk.next_delivery_ts - interval '35 days'
										and pk.next_delivery_ts - interval '7 days'
							group by 1, 2
						 ) whole_4_weeks

						join 

						-- count of sales for the sales peiod of previous 4 weeks 
						(
						select pk.kiosk_id, pk.route_date_time, count(*) qty
							from inm.pick_get_plan_kiosk(start_ts, end_ts) pk
								join pantry.label l on pk.kiosk_id=l.kiosk_id
								where l.status in ('out', 'sold') and 
									(to_timestamp(l.time_updated) between pk.route_date_time - interval '7 days' + interval '4 hours' and pk.next_delivery_ts - interval '7 days'  + interval '4 hours' or
									 to_timestamp(l.time_updated) between pk.route_date_time - interval '14 days'  + interval '4 hours' and pk.next_delivery_ts - interval '14 days'  + interval '4 hours' or
									 to_timestamp(l.time_updated) between pk.route_date_time - interval '21 days'  + interval '4 hours' and pk.next_delivery_ts - interval '21 days'  + interval '4 hours' or
									 to_timestamp(l.time_updated) between pk.route_date_time - interval '28 days'  + interval '4 hours' and pk.next_delivery_ts - interval '28 days' + interval '4 hours')
								group by 1, 2
							) period_4_weeks

						on whole_4_weeks.kiosk_id = period_4_weeks.kiosk_id
					 ) existing_kiosk_with_sales_ratio 
					 
				on scheduled_kiosks.kiosk_id = existing_kiosk_with_sales_ratio.kiosk_id and scheduled_kiosks.route_date_time = existing_kiosk_with_sales_ratio.route_date_time;
					
	end;

$$;


ALTER FUNCTION inm_beta.pick_get_sales_period_ratio_4wks(start_ts timestamp with time zone, end_ts timestamp with time zone) OWNER TO dbservice;

--
-- Name: compare_pick_vs_delivery(date, date); Type: FUNCTION; Schema: inm_test; Owner: dbservice
--

CREATE FUNCTION inm_test.compare_pick_vs_delivery(start_date date, end_date date DEFAULT NULL::date) RETURNS TABLE(kiosk_id integer, route_date date, kiosk_title character varying, product_id integer, pick_qty bigint, restock_qty bigint, discrepancy bigint)
    LANGUAGE plpgsql
    AS $$

/*
Purpose - compare pick to restock
Input - 
	start_date: first pick date to consider
	end_date: last pick date to consider. If not given, compute the result for only start_date
Output - 
	kiosk_id: id for kiosk
	route_date: delivery date
	kiosk_title: kiosk name
	product_id: what picked/allocated
	pick_qty: quantity above product_id picked
	restock_qty: quantity above product_id restocked between target_date and the following delivery date_time for the kiosk
	discrepancy: restock_qty - pick_quantity for target_date  
*/

declare target_date date;
declare pick_window_start timestamp with time zone;
declare pick_window_end timestamp with time zone;
begin
	if end_date is null
		then end_date = start_date;
	end if;
	for target_date in select * from generate_series(start_date, end_date, interval '1 days') loop
		pick_window_start = cast(target_date as timestamp with time zone) + interval '13 hours';
		pick_window_end = pick_window_start + interval '22 hours';

		return query
			select
				a.kiosk_id, a.route_date, k.title, a.sku_id, a.pick_qty, rs.restock_qty, coalesce(rs.restock_qty, 0) - a.pick_qty discrepancy
				from
					-- next 2 delivery schedules for each kiosks
					(select t1.kiosk_id, t1.route_date_time, t1.next_delivery_ts from inm.pick_get_plan_kiosk(pick_window_start, pick_window_end) t1) d
				join
					-- allocation
					(select t2.kiosk_id, t2.route_date, t2.sku_id, sum(t2.qty) pick_qty
						from inm.pick_allocation t2
						where pick_date = target_date
						group by 1,2,3) a
					on d.kiosk_id = a.kiosk_id and d.route_date_time::date = a.route_date

				left join
					(select t3.kiosk_id, to_timestamp(time_added)::date restock_date, t3.product_id, count(*) restock_qty
					  from pantry.label t3
					  where to_timestamp(time_added) between pick_window_start and cast(pick_window_start as timestamp) + interval '2 days' -- limit to potential pick time frame
					  group by 1,2,3 having count(*) >= 1) rs

				on a.kiosk_id = rs.kiosk_id and a.route_date = rs.restock_date and a.sku_id = rs.product_id

				join pantry.kiosk k on a.kiosk_id = k.id
				order by a.kiosk_id;
		end loop;
end;

$$;


ALTER FUNCTION inm_test.compare_pick_vs_delivery(start_date date, end_date date) OWNER TO dbservice;

--
-- Name: pick_check_restriction(date); Type: FUNCTION; Schema: inm_test; Owner: dbservice
--

CREATE FUNCTION inm_test.pick_check_restriction(_pick_date date) RETURNS TABLE(kiosk_id integer, product_id integer)
    LANGUAGE plpgsql
    AS $$

/*
Purpose: return restricted products found in allocation
*/

begin
	return query
		select a.kiosk_id, a.sku_id
			from (select * from inm_test.pick_allocation a where a.pick_date = _pick_date) a
				join inm.kiosk_product_disabled d on a.kiosk_id = d.kiosk_id and a.sku_id = d.product_id;
end;

$$;


ALTER FUNCTION inm_test.pick_check_restriction(_pick_date date) OWNER TO dbservice;

--
-- Name: pick_get_order_with_sales_ratio(timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: inm_test; Owner: dbservice
--

CREATE FUNCTION inm_test.pick_get_order_with_sales_ratio(start_ts timestamp with time zone, end_ts timestamp with time zone) RETURNS TABLE(kiosk_id integer, route_date_time timestamp with time zone, sku_group_id integer, fc_title text, week_demand_qty integer, plan_demand_qty numeric, plan_order_qty numeric)
    LANGUAGE plpgsql
    AS $$

/*
Purpose - return INM order based on sales ratio for pick sales period (time between deliveries)
Input -
  start_ts: plan window start date time with time zone
  end_ts: plan window end date time with time zone
Return -
  kiosk_id: together with route_date_time is unique for the plan window
  route_date_time: route starting date time
  fc_title: sku group name
  week_demand_qty: demand based on once a week delivery (without minimum)
  plan_demand_qty: demand based on sales ratio for pick sales period (without minimum)
  plan_order_qty: order based on sales ratio for pick sales period
*/

declare latest_import_ts_for_pick_window timestamp with time zone;
begin
	-- get the latest import_ts for the same day as start_ts
	select max(import_ts) from mixalot.inm_data i
		where import_ts::date = start_ts::date and data_type = 'Par Unconstrained wo Min' -- make sure import contain this data_type
		into latest_import_ts_for_pick_window;
	return query
		--  Given
		--		sales period = time between this pick delivery and next pick delivery (may be changed to pick times in the future)
		--		inm.qty = week demand
		--		sr.sales_ratio = sale ratio for this sum items sold for pick sales period for the last 4 weeks vs items sold for the last 4 weeks 
		-- 	if item is restricted (inm_qty=0), then set demand to 0. 
		--  else 
		--		if item doesn't exist in the kiosk (inv.count is null), set its inv count to 0
		-- 		order_before_min_max = 1.4 * sr.sales_ratio * inm.qty - inv.count
		-- 		final_order = min + order_before_min_max, capped by max as defined for each sku group
		select sr.kiosk_id, sr.route_date_time, sga.id, inm.fc_title, inm.qty week_demand_qty, 
			cast(1.4 * sr.sales_ratio * inm.qty as numeric (8,2)) plan_demand_qty,
			case 
				when inm.qty = 0 then 0 -- restricted item
				else
					-- cap at week_qty
					least(
						-- change minimum is 0 (don't remove from a kiosk)
						least(greatest(ceiling(1.4 * sr.sales_ratio * inm.qty) + sga.minimum_kiosk_qty - coalesce(inv.count, 0),
											  0) /* change negative demand to 0 */
								   , sga.maximum_kiosk_qty),
						inm.qty)
			end as plan_order_qty -- end case
					   
			from inm.pick_get_sales_period_ratio(start_ts, end_ts) sr
				join mixalot.inm_data inm
					on sr.kiosk_id = inm.kiosk_id
						and inm.data_type = 'Par Unconstrained wo Min'					
						and inm.import_ts = latest_import_ts_for_pick_window						
				join inm.sku_group_attribute sga
					on sga.title = inm.fc_title			
				left join mixalot.inm_kiosk_projected_stock inv
					on inm.kiosk_id = inv.kiosk_id and inm.fc_title = inv.fc_title;
	end;

$$;


ALTER FUNCTION inm_test.pick_get_order_with_sales_ratio(start_ts timestamp with time zone, end_ts timestamp with time zone) OWNER TO dbservice;

--
-- Name: pick_get_plan_demand(timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: inm_test; Owner: dbservice
--

CREATE FUNCTION inm_test.pick_get_plan_demand(start_ts timestamp with time zone, end_ts timestamp with time zone) RETURNS TABLE(kiosk_id integer, route_date_time timestamp with time zone, sku_group_id integer, fc_title text, week_qty integer, plan_qty integer)
    LANGUAGE plpgsql
    AS $$

/*
Purpose - return INM plan demand for a pick window.
Input -
  start_ts: plan window start date time with time zone
  end_ts: plan window end date time with time zone
Return -
  kiosk_id: together with route_date_time is unique for the plan window
  route_date_time: route starting date time
  fc_title: sku group name
  week_qty: demand based on once a week delivery
  plan_qty: demand based on time to next delivery
*/

declare latest_import_ts_for_pick_window timestamp with time zone;
begin
	-- get the latest import_ts for the same day as start_ts
	select max(import_ts) from mixalot.inm_data i
		where import_ts::date = start_ts::date and data_type = 'Par Unconstrained wo Min' -- make sure import contain this data_type
		into latest_import_ts_for_pick_window;
	return query
		-- Given
		-- 		default 3 days if days_to_next_delivery is not known: coalesce(days_to_next_delivery, 3)
		-- 		if item doesn't exist in the kiosk (inv.count is null), set its inv count to 0: coalesce(inv.count, 0)
		-- 		inm.qty is weekly demand
		-- bring 1.8 times the total demand until the next delivery plus the minimum, capped by min and max as defined for each sku group, 
		select pk.kiosk_id, pk.route_date_time, sga.id, inm.fc_title, inm.qty week_qty,
			case 
				when inm.qty = 0 then 0
				else 	
					least(cast(greatest(ceiling(1.8 * inm.qty * coalesce(days_to_next_delivery, 3)/7) + sga.minimum_kiosk_qty - coalesce(inv.count, 0),
										  sga.minimum_kiosk_qty - inv.count, /* ensure minimum quantity */
										  0) /* change negative demand to 0 */
							   as integer), sga.maximum_kiosk_qty) 
			end as plan_qty -- case
					   
			  from mixalot.plan_kiosk(start_ts, end_ts) pk
			  
			join mixalot.inm_data inm
				on pk.kiosk_id = inm.kiosk_id
					and inm.data_type = 'Par Unconstrained wo Min'					
					and inm.import_ts = latest_import_ts_for_pick_window
					
			join mixalot.sku_group_attribute sga
				on sga.title = inm.fc_title
			
			--fixme: use this block and remove next block after testing
 			left join mixalot.inm_kiosk_projected_stock inv
			
			-- use the next block of inv to test rerun to keep inv level at given date.
-- 			left join
-- 				(select i.kiosk_id, s.title fc_title, i.qty count
-- 					from mixalot.pick_inventory i join mixalot.sku_group_def s on i.sku_group_id = s.id
-- 					where pick_date = '2018-09-16') inv
			
 				on inm.kiosk_id = inv.kiosk_id and inm.fc_title = inv.fc_title;
end;

$$;


ALTER FUNCTION inm_test.pick_get_plan_demand(start_ts timestamp with time zone, end_ts timestamp with time zone) OWNER TO dbservice;

--
-- Name: pick_get_plan_demand(numeric, timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: inm_test; Owner: dbservice
--

CREATE FUNCTION inm_test.pick_get_plan_demand(allocation_factor numeric, start_ts timestamp with time zone, end_ts timestamp with time zone) RETURNS TABLE(kiosk_id integer, route_date_time timestamp with time zone, fc_title text, week_qty integer, plan_qty integer)
    LANGUAGE plpgsql
    AS $$

/*
Purpose - return INM plan demand for a pick window.
Input -
  start_ts: plan window start date time with time zone
  end_ts: plan window end date time with time zone
Return -
  kiosk_id: together with route_date_time is unique for the plan window
  route_date_time: route starting date time
  fc_title: sku group name
  week_qty: demand based on once a week delivery
  plan_qty: demand based on time to next delivery
*/

declare latest_import_ts_for_pick_window timestamp with time zone;
begin
	-- get the latest import_ts for the same day as start_ts
	select max(import_ts) from mixalot.inm_data i
		where import_ts::date = start_ts::date and data_type = 'Par Unconstrained wo Min' -- make sure import contain this data_type
		into latest_import_ts_for_pick_window;
	return query
		-- Given
		-- 		default 3 days if days_to_next_delivery is not known: coalesce(days_to_next_delivery, 3)
		-- 		if item doesn't exist in the kiosk (inv.count is null), set its inv count to 0: coalesce(inv.count, 0)
		-- 		inm.qty is weekly demand
		-- bring 1.8 times the total demand until the next delivery plus the minimum, capped by min and max as defined for each sku group, 
		select pk.kiosk_id, pk.route_date_time, inm.fc_title, inm.qty week_qty,
			least(cast(greatest(ceiling(allocation_factor * inm.qty * coalesce(days_to_next_delivery, 3)/7) + sga.minimum_kiosk_qty - coalesce(inv.count, 0),
								  sga.minimum_kiosk_qty - inv.count, /* ensure minimum quantity */
							   	  0) /* change negative demand to 0 */
					   as integer), sga.maximum_kiosk_qty) plan_qty
			  from mixalot.plan_kiosk(start_ts, end_ts) pk
			join mixalot.inm_data inm
				on pk.kiosk_id = inm.kiosk_id
					and inm.data_type = 'Par Unconstrained wo Min'					
					and inm.import_ts = latest_import_ts_for_pick_window
					
			join mixalot.sku_group_attribute sga
				on sga.title = inm.fc_title
			
 			left join mixalot.inm_kiosk_projected_stock inv
			
			-- use the next block of inv to test rerun to keep inv level at given date.
-- 			left join
-- 				(select i.kiosk_id, s.title fc_title, i.qty count
-- 					from mixalot.pick_inventory i join mixalot.sku_group_def s on i.sku_group_id = s.id
-- 					where pick_date = '2018-09-13') inv
			
 				on inm.kiosk_id = inv.kiosk_id and inm.fc_title = inv.fc_title;
end;

$$;


ALTER FUNCTION inm_test.pick_get_plan_demand(allocation_factor numeric, start_ts timestamp with time zone, end_ts timestamp with time zone) OWNER TO dbservice;

--
-- Name: pick_get_plan_demand_w_manual(timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: inm_test; Owner: dbservice
--

CREATE FUNCTION inm_test.pick_get_plan_demand_w_manual(start_ts timestamp with time zone, end_ts timestamp with time zone) RETURNS TABLE(kiosk_id integer, route_date_time timestamp with time zone, sku_group_id integer, fc_title text, week_qty integer, plan_qty integer)
    LANGUAGE plpgsql
    AS $$

/*
Purpose - return INM plan demand for a pick window.
Input -
  start_ts: plan window start date time with time zone
  end_ts: plan window end date time with time zone
Return -
  kiosk_id: together with route_date_time is unique for the plan window
  route_date_time: route starting date time
  fc_title: sku group name
  week_qty: demand based on once a week delivery
  plan_qty: demand based on time to next delivery
*/

declare latest_import_ts_for_pick_window timestamp with time zone;
begin
	-- get the latest import_ts for the same day as start_ts
	select max(import_ts) from mixalot.inm_data i
		where import_ts::date = start_ts::date and data_type = 'Par Unconstrained wo Min' -- make sure import contain this data_type
		into latest_import_ts_for_pick_window;
	return query
		-- Given
		-- 		default 3 days if days_to_next_delivery is not known: coalesce(days_to_next_delivery, 3)
		-- 		if item doesn't exist in the kiosk (inv.count is null), set its inv count to 0: coalesce(inv.count, 0)
		-- 		inm.qty is weekly demand
		-- bring 1.8 times the total demand until the next delivery plus the minimum, capped by min and max as defined for each sku group, 
		select pk.kiosk_id, pk.route_date_time, sga.id, inm.fc_title, inm.qty week_qty,
			case 
				when inm.qty = 0 then 0
				else 	
					least(cast(greatest(ceiling(1.8 * inm.qty * coalesce(days_to_next_delivery, 3)/7) + sga.minimum_kiosk_qty - coalesce(inv.count, 0),
										  sga.minimum_kiosk_qty - inv.count, /* ensure minimum quantity */
										  0) /* change negative demand to 0 */
							   as integer), sga.maximum_kiosk_qty) 
			end as plan_qty -- case
					   
			  from mixalot.plan_kiosk(start_ts, end_ts) pk
			  
			join mixalot.inm_data inm
				on pk.kiosk_id = inm.kiosk_id
					and inm.data_type = 'Par Unconstrained wo Min'					
					and inm.import_ts = latest_import_ts_for_pick_window
					
			join mixalot.sku_group_attribute sga
				on sga.title = inm.fc_title
			
			--fixme: use this block and remove next block after testing
 			left join mixalot.inm_kiosk_projected_stock inv
			
			-- use the next block of inv to test rerun to keep inv level at given date.
-- 			left join
-- 				(select i.kiosk_id, s.title fc_title, i.qty count
-- 					from mixalot.pick_inventory i join mixalot.sku_group_def s on i.sku_group_id = s.id
-- 					where pick_date = '2018-09-16') inv
			
 				on inm.kiosk_id = inv.kiosk_id and inm.fc_title = inv.fc_title;
end;

$$;


ALTER FUNCTION inm_test.pick_get_plan_demand_w_manual(start_ts timestamp with time zone, end_ts timestamp with time zone) OWNER TO dbservice;

--
-- Name: pick_get_sales_period_ratio(timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: inm_test; Owner: dbservice
--

CREATE FUNCTION inm_test.pick_get_sales_period_ratio(start_ts timestamp with time zone, end_ts timestamp with time zone) RETURNS TABLE(kiosk_id integer, route_date_time timestamp with time zone, sales_ratio numeric)
    LANGUAGE plpgsql ROWS 10000
    AS $$

/*
Purpose - return INM the ratio of the next sale period(time between the deliveries of this pick and the next pick) vs sales for the week
Input -
  start_ts: plan window start date time with time zone
  end_ts: plan window end date time with time zone
Return -
  kiosk_id: together with route_date_time is unique for the plan window
  route_date_time: route starting date time
  fc_title: sku group name
  plan_qty: order quantity for the above fc_title for the next sale period
*/

-- FIX ME: 
-- handle missing past data
-- check kid with multiple deliveries
begin	
	return query
		select scheduled_kiosks.kiosk_id, scheduled_kiosks.route_date_time, coalesce(existing_kiosk_with_sales_ratio.ratio, 1.0/3.0)
			from inm.pick_get_plan_kiosk(start_ts, end_ts) scheduled_kiosks
				left join
					(
					select whole_4_weeks.kiosk_id, whole_4_weeks.route_date_time, 
						case when whole_4_weeks.qty < 5 then 1.0/3.0 -- new kiosk, assume period sale is 1/3 of total week
							else cast(period_4_weeks.qty as decimal)/cast(whole_4_weeks.qty as decimal)
							end ratio		
					from
						-- count of sales for the whole previous 4 weeks 
						(select pk.kiosk_id, pk.route_date_time, count(*) qty 
							from inm.pick_get_plan_kiosk(start_ts, end_ts) pk
								join pantry.label l on pk.kiosk_id=l.kiosk_id
								where l.status in ('out', 'sold')
									and to_timestamp(l.time_updated) between
										pk.next_delivery_ts - interval '35 days'
										and pk.next_delivery_ts - interval '7 days'
							group by 1, 2
						 ) whole_4_weeks

						join 

						-- count of sales for the sales peiod of previous 4 weeks 
						(
						select pk.kiosk_id, pk.route_date_time, count(*) qty
							from inm.pick_get_plan_kiosk(start_ts, end_ts) pk
								join pantry.label l on pk.kiosk_id=l.kiosk_id
								where l.status in ('out', 'sold') and 
									(to_timestamp(l.time_updated) between pk.route_date_time - interval '7 days' + interval '4 hours' and pk.next_delivery_ts - interval '7 days'  + interval '4 hours' or
									 to_timestamp(l.time_updated) between pk.route_date_time - interval '14 days'  + interval '4 hours' and pk.next_delivery_ts - interval '14 days'  + interval '4 hours' or
									 to_timestamp(l.time_updated) between pk.route_date_time - interval '21 days'  + interval '4 hours' and pk.next_delivery_ts - interval '21 days'  + interval '4 hours' or
									 to_timestamp(l.time_updated) between pk.route_date_time - interval '28 days'  + interval '4 hours' and pk.next_delivery_ts - interval '28 days' + interval '4 hours')
								group by 1, 2
							) period_4_weeks

						on whole_4_weeks.kiosk_id = period_4_weeks.kiosk_id
					 ) existing_kiosk_with_sales_ratio
				on scheduled_kiosks.kiosk_id = existing_kiosk_with_sales_ratio.kiosk_id and scheduled_kiosks.route_date_time = existing_kiosk_with_sales_ratio.route_date_time;
					
	end;

$$;


ALTER FUNCTION inm_test.pick_get_sales_period_ratio(start_ts timestamp with time zone, end_ts timestamp with time zone) OWNER TO dbservice;

--
-- Name: pick_inventory_insert(); Type: FUNCTION; Schema: inm_test; Owner: dbservice
--

CREATE FUNCTION inm_test.pick_inventory_insert() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
  begin
  	new.route_date = new.pick_date;
  	return new;
  end;
	
$$;


ALTER FUNCTION inm_test.pick_inventory_insert() OWNER TO dbservice;

--
-- Name: sales_ratio_debug(timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: inm_test; Owner: dbservice
--

CREATE FUNCTION inm_test.sales_ratio_debug(start_ts timestamp with time zone, end_ts timestamp with time zone) RETURNS TABLE(kiosk_id integer, route_date_time timestamp with time zone, sales_ratio numeric, whole_qty bigint, period_qty bigint)
    LANGUAGE plpgsql ROWS 10000
    AS $$
  /*
  Purpose - return INM the ratio of the next sale period(time between the deliveries of this pick and the next pick) vs sales for the week using 12 week history
  Input -
    start_ts: plan window start date time with time zone
    end_ts: plan window end date time with time zone
  Return -
    kiosk_id: together with route_date_time is unique for the plan window
    route_date_time: route starting date time
    fc_title: sku group name
    plan_qty: order quantity for the above fc_title for the next sale period
  */

  -- FIX ME:
  -- handle missing past data
  -- check kid with multiple deliveries
begin
  return query
    select scheduled_kiosks.kiosk_id, scheduled_kiosks.route_date_time, coalesce(existing_kiosk_with_sales_ratio.ratio, 1.0/3.0),
           existing_kiosk_with_sales_ratio.whole_qty, existing_kiosk_with_sales_ratio.period_qty
    from inm.pick_get_plan_kiosk(start_ts, end_ts) scheduled_kiosks -- all the kiosks on route
           left join -- kiosks with sales history
      (
        select whole_12_weeks.kiosk_id, whole_12_weeks.route_date_time,
               case when whole_12_weeks.qty < 5 then 1.0/3.0 -- new kiosk, assume period sale is 1/3 of total week
                    else cast(period_12_weeks.qty as decimal)/cast(whole_12_weeks.qty as decimal)
                 end ratio, whole_12_weeks.qty whole_qty, period_12_weeks.qty period_qty
        from
          -- count of sales for the whole previous 12 weeks
          (select pk.kiosk_id, pk.route_date_time, count(*) qty
           from inm.pick_get_plan_kiosk(start_ts, end_ts) pk
                  join pantry.label l on pk.kiosk_id=l.kiosk_id
           where l.status in ('out', 'sold')
             and to_timestamp(l.time_updated) between
               pk.next_delivery_ts - interval '91 days'
             and pk.next_delivery_ts - interval '7 days'
           group by 1, 2
          ) whole_12_weeks

            join

          -- count of sales for the sales peiod of previous 4 weeks
            (
              select pk.kiosk_id, pk.route_date_time, count(*) qty
              from inm.pick_get_plan_kiosk(start_ts, end_ts) pk
                     join pantry.label l on pk.kiosk_id=l.kiosk_id
              where l.status in ('out', 'sold') and
                (
                    to_timestamp(l.time_updated) between pk.route_date_time - interval '7 days' + interval '4 hours' and pk.next_delivery_ts - interval '7 days'  + interval '4 hours' or
                    to_timestamp(l.time_updated) between pk.route_date_time - interval '14 days'  + interval '4 hours' and pk.next_delivery_ts - interval '14 days'  + interval '4 hours' or
                    to_timestamp(l.time_updated) between pk.route_date_time - interval '21 days'  + interval '4 hours' and pk.next_delivery_ts - interval '21 days'  + interval '4 hours' or
                    to_timestamp(l.time_updated) between pk.route_date_time - interval '28 days'  + interval '4 hours' and pk.next_delivery_ts - interval '28 days' + interval '4 hours' or

                    to_timestamp(l.time_updated) between pk.route_date_time - interval '35 days' + interval '4 hours' and pk.next_delivery_ts - interval '35 days'  + interval '4 hours' or
                    to_timestamp(l.time_updated) between pk.route_date_time - interval '42 days' + interval '4 hours' and pk.next_delivery_ts - interval '42 days'  + interval '4 hours' or
                    to_timestamp(l.time_updated) between pk.route_date_time - interval '49 days' + interval '4 hours' and pk.next_delivery_ts - interval '49 days'  + interval '4 hours' or
                    to_timestamp(l.time_updated) between pk.route_date_time - interval '56 days' + interval '4 hours' and pk.next_delivery_ts - interval '56 days'  + interval '4 hours' or

                    to_timestamp(l.time_updated) between pk.route_date_time - interval '63 days' + interval '4 hours' and pk.next_delivery_ts - interval '63 days'  + interval '4 hours' or
                    to_timestamp(l.time_updated) between pk.route_date_time - interval '70 days' + interval '4 hours' and pk.next_delivery_ts - interval '70 days'  + interval '4 hours' or
                    to_timestamp(l.time_updated) between pk.route_date_time - interval '77 days' + interval '4 hours' and pk.next_delivery_ts - interval '77 days'  + interval '4 hours' or
                    to_timestamp(l.time_updated) between pk.route_date_time - interval '84 days' + interval '4 hours' and pk.next_delivery_ts - interval '84 days'  + interval '4 hours'
                  )
              group by 1, 2
            ) period_12_weeks

          on whole_12_weeks.kiosk_id = period_12_weeks.kiosk_id
      ) existing_kiosk_with_sales_ratio

                     on scheduled_kiosks.kiosk_id = existing_kiosk_with_sales_ratio.kiosk_id and scheduled_kiosks.route_date_time = existing_kiosk_with_sales_ratio.route_date_time;

end;

$$;


ALTER FUNCTION inm_test.sales_ratio_debug(start_ts timestamp with time zone, end_ts timestamp with time zone) OWNER TO dbservice;

--
-- Name: test_demand(timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: inm_test; Owner: dbservice
--

CREATE FUNCTION inm_test.test_demand(start_ts timestamp with time zone, end_ts timestamp with time zone) RETURNS TABLE(kiosk_id integer, route_date_time timestamp with time zone, fc_title text, week_qty integer, plan_qty integer, loopback_start_ts timestamp with time zone, loopback_end_ts timestamp with time zone)
    LANGUAGE plpgsql
    AS $$

/*
Purpose - return INM plan demand for a pick window.
Input -
  start_ts: plan window start date time with time zone
  end_ts: plan window end date time with time zone
Return -
  kiosk_id: together with route_date_time is unique for the plan window
  route_date_time: route starting date time
  fc_title: sku group name
  week_qty: demand based on once a week delivery
  plan_qty: demand based on time to next delivery
*/

declare latest_import_ts_for_pick_window timestamp with time zone;
begin	
	select max(import_ts) from mixalot.inm_data
		where import_ts >= start_ts::date
		into latest_import_ts_for_pick_window;
	return query
		select pk.kiosk_id, pk.route_date_time, demand.fc_title, demand.qty week_qty,
			demand.qty/2 plan_qty, -- test
			start_ts, end_ts
			  from mixalot.plan_kiosk(start_ts, end_ts) pk
			join (select d.kiosk_id, d.route_date, cast(s.title as text) fc_title, d.qty qty
					from mixalot.pick_demand d join mixalot.sku_group_def s on d.sku_group_id = s.id
					where pick_date = latest_import_ts_for_pick_window::date
					) demand
			
 				on pk.kiosk_id = demand.kiosk_id and pk.route_date_time::date = demand.route_date;
end;

$$;


ALTER FUNCTION inm_test.test_demand(start_ts timestamp with time zone, end_ts timestamp with time zone) OWNER TO dbservice;

--
-- Name: backup_pick_allocation(date); Type: FUNCTION; Schema: mixalot; Owner: dbservice
--

CREATE FUNCTION mixalot.backup_pick_allocation(target_pick_date date) RETURNS void
    LANGUAGE plpgsql
    AS $$

declare today_date date;
begin
  delete from mixalot_backup.pick_inventory where pick_date = target_pick_date;
  insert into mixalot_backup.pick_inventory select * from mixalot.pick_inventory
  	where pick_date = target_pick_date;
	
  delete from mixalot_backup.pick_demand where pick_date = target_pick_date;
  insert into mixalot_backup.pick_demand select * from mixalot.pick_demand
  	where pick_date = target_pick_date;
	
  delete from mixalot_backup.pick_allocation where pick_date = target_pick_date;
  insert into mixalot_backup.pick_allocation select * from mixalot.pick_allocation
  	where pick_date = target_pick_date;
	
delete from mixalot_backup.pick_substitution where pick_date = target_pick_date;
  insert into mixalot_backup.pick_substitution select * from mixalot.pick_substitution
	where pick_date = target_pick_date;
	
delete from mixalot_backup.pick_route where pick_date = target_pick_date;
  insert into mixalot_backup.pick_route select * from mixalot.pick_route
	where pick_date = target_pick_date;
	
end;

$$;


ALTER FUNCTION mixalot.backup_pick_allocation(target_pick_date date) OWNER TO dbservice;

--
-- Name: pick_allocation_insert(); Type: FUNCTION; Schema: mixalot; Owner: dbservice
--

CREATE FUNCTION mixalot.pick_allocation_insert() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
	new.route_date = new.pick_date;
	return new;
end;
$$;


ALTER FUNCTION mixalot.pick_allocation_insert() OWNER TO dbservice;

--
-- Name: pick_demand_insert(); Type: FUNCTION; Schema: mixalot; Owner: dbservice
--

CREATE FUNCTION mixalot.pick_demand_insert() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
	new.route_date = new.pick_date;
	return new;
end;
$$;


ALTER FUNCTION mixalot.pick_demand_insert() OWNER TO dbservice;

--
-- Name: pick_get_delivery_schedule(timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: mixalot; Owner: dbservice
--

CREATE FUNCTION mixalot.pick_get_delivery_schedule(start_ts timestamp with time zone, end_ts timestamp with time zone) RETURNS TABLE(kiosk_id integer, driver_name character varying, route_date_time timestamp with time zone, location_name character varying, delivery_order bigint)
    LANGUAGE plpgsql
    AS $$
/*
Purpose: return INM delivery schedule for a pick window.
*/
begin
	return query
		select pk.kiosk_id, r.driver_name, r.route_date_time, pk.location_name, pk.delivery_order
			from mixalot.route r join mixalot.pick_get_plan_kiosks(start_ts, end_ts) pk
				on r.route_date_time = pk.route_date_time and r.driver_name = pk.driver_name
				where r.route_date_time between start_ts and end_ts;
end;

$$;


ALTER FUNCTION mixalot.pick_get_delivery_schedule(start_ts timestamp with time zone, end_ts timestamp with time zone) OWNER TO dbservice;

--
-- Name: pick_get_gsheets_plan_demand(timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: mixalot; Owner: dbservice
--

CREATE FUNCTION mixalot.pick_get_gsheets_plan_demand(start_ts timestamp with time zone, end_ts timestamp with time zone) RETURNS TABLE(kiosk_id integer, route_date_time timestamp with time zone, fc_title text, week_qty integer, plan_qty integer)
    LANGUAGE plpgsql
    AS $$

/*
Purpose - return INM plan demand from gsheets for a pick window.
Input -
  start_ts: plan window start date time with time zone
  end_ts: plan window end date time with time zone
Return -
  kiosk_id: together with route_date_time is unique for the plan window
  route_date_time: route starting date time
  fc_title: sku group name
  week_qty: demand based on once a week delivery
  plan_qty: demand based on time to next delivery
*/

declare latest_import_ts_for_pick_window timestamp with time zone;
begin	
	select max(import_ts) from mixalot.inm_data
		where import_ts >= start_ts::date
		into latest_import_ts_for_pick_window;
	return query
		select pk.kiosk_id, pk.route_date_time, inm.fc_title, inm.qty, 
			cast(ceiling(1.4 * inm.qty * days_to_next_delivery/7) as integer)
			  from mixalot.pick_get_plan_kiosks(start_ts, end_ts) pk
			join mixalot.inm_data inm
			on pk.kiosk_id = inm.kiosk_id
			and inm.data_type = 'Plan Demand'
			and inm.import_ts = latest_import_ts_for_pick_window;
end;

$$;


ALTER FUNCTION mixalot.pick_get_gsheets_plan_demand(start_ts timestamp with time zone, end_ts timestamp with time zone) OWNER TO dbservice;

--
-- Name: pick_get_plan_demand(timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: mixalot; Owner: dbservice
--

CREATE FUNCTION mixalot.pick_get_plan_demand(start_ts timestamp with time zone, end_ts timestamp with time zone) RETURNS TABLE(kiosk_id integer, route_date_time timestamp with time zone, sku_group_id integer, fc_title text, plan_qty integer)
    LANGUAGE plpgsql
    AS $$

/*
Purpose - return INM plan demand for a pick window.
Input -
  start_ts: plan window start date time with time zone
  end_ts: plan window end date time with time zone
Return -
  kiosk_id: together with route_date_time is unique for the plan window
  route_date_time: route starting date time
  fc_title: sku group name
  week_qty: demand based on once a week delivery
  plan_qty: demand based on time to next delivery
*/

declare latest_import_ts_for_pick_window timestamp with time zone;
begin
	-- get the latest import_ts for the same day as start_ts
	select max(import_ts) from mixalot.inm_data i
		where import_ts::date = start_ts::date
		into latest_import_ts_for_pick_window;
	return query
		select pk.kiosk_id, pk.route_date_time, sga.id, inm.fc_title, least(inm.qty, sga.maximum_kiosk_qty) plan_qty
			  from mixalot.plan_kiosk(start_ts, end_ts) pk
			join mixalot.inm_data inm
				on pk.kiosk_id = inm.kiosk_id
					and inm.data_type = 'Plan Demand'					
					and inm.import_ts = latest_import_ts_for_pick_window
					
			join mixalot.sku_group_attribute sga
				on sga.title = inm.fc_title;		
end;

$$;


ALTER FUNCTION mixalot.pick_get_plan_demand(start_ts timestamp with time zone, end_ts timestamp with time zone) OWNER TO dbservice;

--
-- Name: pick_get_summary(date); Type: FUNCTION; Schema: mixalot; Owner: dbservice
--

CREATE FUNCTION mixalot.pick_get_summary(target_date date) RETURNS TABLE(property text, name text, value text)
    LANGUAGE plpgsql
    AS $$

declare pick_tickets_generated integer;

-- one-based arrays of 3 numbers, 1 for target date and 2 for the same weekday one and two weeks ago
declare ticket integer ARRAY;
declare demand integer ARRAY;
declare allocation integer ARRAY;

declare property text;
declare name text;
declare value text;
declare total integer;
declare result_row record;

declare kiosks_added text;
declare kiosks_removed text;

begin
	
	FOR i IN 0..2 LOOP
 		select count(*) from inm.pick_route where pick_date = target_date - 7*i  into total;
		ticket[i+1] = total; -- convert to one-based index
		select sum(qty) from inm.pick_demand where pick_date = target_date - 7*i into total;
		demand[i+1] = total;
		select sum(qty) from inm.pick_allocation where pick_date = target_date - 7*i into total;
		allocation[i+1] = total;
   	END LOOP;
	
	select array_to_string(array_agg(cast (kiosk_id as varchar) order by kiosk_id), ',') from inm.pick_route 
		where pick_date = target_date and kiosk_id not in
			(select kiosk_id from inm.pick_route where pick_date = target_date - 7)
	into kiosks_added;
	
	select array_to_string(array_agg(cast (kiosk_id as varchar) order by kiosk_id), ',') from inm.pick_route 
		where pick_date = target_date - 7  and kiosk_id not in
			(select kiosk_id from inm.pick_route where pick_date = target_date)
	into kiosks_removed;
		
	property = 'stats';
	name = 'pick tickets today/ -7 days/ -14 days: ';
	value = ticket[1] || '/' || ticket[2] || '/' || ticket[3];
	return query select property, name, value;
	
	property = 'stats';
	name = 'demand qty today/ -7 days/ -14 days: ';
	value = demand[1] || '/' || demand[2] || '/' || demand[3];
	return query select property, name, value;
	
	property = 'stats';
	name = 'allocation qty today/ -7 days/ -14 days: ';
	value = allocation[1] || '/' || allocation[2] || '/' || allocation[3];
	return query select property, name, value;
	
	property = 'stats';
	name = 'kiosks added';
	value = kiosks_added;
	return query select property, name, value;
	
	property = 'stats';
	name = 'kiosks removed';
	value = kiosks_removed;
	return query select property, name, value;
	
	property = 'stats';
	name = 'allocation summary';
	value = 'allocation: ' || allocation[1] || ', demand: ' || demand[1] || ', allocation percentage: ' ||  cast(100*demand[1]/allocation[1] as integer);
	return query select property, name, value;
end

$$;


ALTER FUNCTION mixalot.pick_get_summary(target_date date) OWNER TO dbservice;

--
-- Name: pick_inventory_insert(); Type: FUNCTION; Schema: mixalot; Owner: dbservice
--

CREATE FUNCTION mixalot.pick_inventory_insert() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
  begin
  	new.route_date = new.pick_date;
  	return new;
  end;
  $$;


ALTER FUNCTION mixalot.pick_inventory_insert() OWNER TO dbservice;

--
-- Name: pick_summary(date); Type: FUNCTION; Schema: mixalot; Owner: dbservice
--

CREATE FUNCTION mixalot.pick_summary(target_date date) RETURNS TABLE(property text, name text, value text)
    LANGUAGE plpgsql
    AS $$

declare pick_tickets_generated integer;

-- one-based arrays of 3 numbers, 1 for target date and 2 for the same weekday one and two weeks ago
declare ticket integer ARRAY;
declare demand integer ARRAY;
declare allocation integer ARRAY;

declare property text;
declare name text;
declare value text;
declare total integer;
declare result_row record;

declare kiosks_added text;
declare kiosks_removed text;

begin
	
	FOR i IN 0..2 LOOP
 		select count(*) from inm.pick_route where pick_date = target_date - 7*i  into total;
		ticket[i+1] = total; -- convert to one-based index
		select sum(qty) from inm.pick_demand where pick_date = target_date - 7*i into total;
		demand[i+1] = total;
		select sum(qty) from inm.pick_allocation where pick_date = target_date - 7*i into total;
		allocation[i+1] = total;
   	END LOOP;
	
	select array_to_string(array_agg(cast (kiosk_id as varchar) order by kiosk_id), ',') from inm.pick_route 
		where pick_date = target_date and kiosk_id not in
			(select kiosk_id from inm.pick_route where pick_date = target_date - 7)
	into kiosks_added;
	
	select array_to_string(array_agg(cast (kiosk_id as varchar) order by kiosk_id), ',') from inm.pick_route 
		where pick_date = target_date - 7  and kiosk_id not in
			(select kiosk_id from inm.pick_route where pick_date = target_date)
	into kiosks_removed;
		
	property = 'stats';
	name = 'pick tickets today/ -7 days/ -14 days: ';
	value = ticket[1] || '/' || ticket[2] || '/' || ticket[3];
	return query select property, name, value;
	
	property = 'stats';
	name = 'demand qty today/ -7 days/ -14 days: ';
	value = demand[1] || '/' || demand[2] || '/' || demand[3];
	return query select property, name, value;
	
	property = 'stats';
	name = 'allocation qty today/ -7 days/ -14 days: ';
	value = allocation[1] || '/' || allocation[2] || '/' || allocation[3];
	return query select property, name, value;
	
	property = 'stats';
	name = 'kiosks added';
	value = kiosks_added;
	return query select property, name, value;
	
	property = 'stats';
	name = 'kiosks removed';
	value = kiosks_removed;
	return query select property, name, value;
	
end

$$;


ALTER FUNCTION mixalot.pick_summary(target_date date) OWNER TO dbservice;

--
-- Name: pick_ticket(date); Type: FUNCTION; Schema: mixalot; Owner: dbservice
--

CREATE FUNCTION mixalot.pick_ticket(target_date date) RETURNS TABLE(pick_station bigint, vendor character varying, item_code bigint, item_name character varying, site_code bigint, site_name character varying, proposed_supply integer, total_pick_qty bigint, total_pick_sku integer, driver_name character varying, route_date date, route_time time without time zone, route_date_time timestamp without time zone, route_number character varying, restrictions text, address character varying, pull_date date, delivery_order integer, pick_order integer)
    LANGUAGE plpgsql
    AS $$

	declare latest_import_ts timestamp;
	declare plan_window_start timestamp;
	declare plan_window_stop timestamp;
begin
	-- return pick ticket data for the latest pick
	
	-- calculate various date params
	select max(import_ts) from mixalot.inm_data into latest_import_ts;
	select i.route_date from mixalot.inm_data i
		where import_ts = latest_import_ts and data_type = 'Plan Window Start'
		into plan_window_start;
	select i.route_date from mixalot.inm_data i
		where import_ts = latest_import_ts and data_type = 'Plan Window Stop'
		into plan_window_stop;
	
	if target_date is null
		then target_date = plan_window_start::date;
	end if;
		
	return query
		select 
				p.pick_station, p.vendor, p.id, p.title ItemName,
				k.id sitecode, k.title sitename, a.qty proposed_supply, 
				sum(a.qty) over(partition by k.id, route.route_date) total_pick_qty,
				-1 total_pick_sku, 
				route.driver_name DriverName, route.route_date RouteDate, route.route_time RouteTime,
				route.route_date + route.route_time route_date_time, route.route_number,
				r.restrictions,
				k.address,
				pd.pull_date,
				cast(route.delivery_order as integer),
				spo.pick_order
			from mixalot.pick_allocation a 
				left join pantry.kiosk k on a.kiosk_id = k.id
				left join mixalot.inm_kiosk_restriction_list r on k.id = r.kiosk_id
				join pantry.product p on a.sku_id = p.id
				join mixalot.pick_route route on a.route_date=route.route_date and a.kiosk_id = route.kiosk_id
				left join mixalot.pull_date(plan_window_start, plan_window_stop) pd on a.kiosk_id = pd.kiosk_id
				left join mixalot.sku_pick_order(latest_import_ts) spo on p.id = spo.sku_id
			where k.campus_id = 87
			and a.pick_date = target_date;
end

$$;


ALTER FUNCTION mixalot.pick_ticket(target_date date) OWNER TO dbservice;

--
-- Name: plan_kiosk(timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: mixalot; Owner: dbservice
--

CREATE FUNCTION mixalot.plan_kiosk(plan_window_start timestamp with time zone, plan_window_stop timestamp with time zone) RETURNS TABLE(kiosk_id integer, route_date_time timestamp with time zone, driver_name character varying, location_name character varying, next_delivery_ts timestamp with time zone, time_to_next_delivery interval, days_to_next_delivery double precision, delivery_order bigint)
    LANGUAGE plpgsql
    AS $$

/*
Purpose: return INM plan kiosks for a pick window.
*/

begin
	return query
		select ds.kiosk_id, ds.route_date_time, ds.driver_name, ds.location_name, ps.next_delivery_ts,
		ps.next_delivery_ts - ds.route_date_time as time_to_next_delivery,		
		  case 
		  	when ps.next_delivery_ts - ds.route_date_time between interval '12 hours' and interval '24 hours' then 1
			else extract(day from ps.next_delivery_ts - ds.route_date_time)
			end as days_to_next_delivery,
		  row_number() over (order by ds.route_date_time asc) as delivery_order
		  
		
		from
		-- kiosk_id, delivery_date
		(select t.kiosk_id, t.route_date_time, t.driver_name, t.location_name from
			(select location_number as kiosk_id, rs.route_date_time, rs.driver_name, rs.location_name,
				rank() over (partition by location_number order by rs.route_date_time) as r
				from mixalot.route_stop rs
				where rs.route_date_time >= plan_window_start -- look at routes starting at plan winddow start
				and location_number > 0) t
				where r = 1) ds

		left join 
		-- kiosk_id, pull_date
		(select t.kiosk_id, t.route_date_time next_delivery_ts from
			(select location_number as kiosk_id, rs.route_date_time,
				rank() over (partition by location_number order by rs.route_date_time) as r
				from mixalot.route_stop rs
				where rs.route_date_time >= plan_window_start -- look at routes starting at plan window start
				and location_number > 0) t
				where r = 2) ps

			on ds.kiosk_id = ps.kiosk_id
			join pantry.kiosk k on ds.kiosk_id = k.id
			where ds.route_date_time between plan_window_start and plan_window_stop
			and k.campus_id= 87;	
end;

$$;


ALTER FUNCTION mixalot.plan_kiosk(plan_window_start timestamp with time zone, plan_window_stop timestamp with time zone) OWNER TO dbservice;

--
-- Name: set_sequence_val_max(name, name, boolean); Type: FUNCTION; Schema: mixalot; Owner: dbservice
--

CREATE FUNCTION mixalot.set_sequence_val_max(schema_name name, table_name name DEFAULT NULL::name, raise_notice boolean DEFAULT false) RETURNS void
    LANGUAGE plpgsql
    AS $$

-- Sets all the sequences in the schema "schema_name" to the max(id) of every table (or a specific table, if name is supplied)
-- Examples:
--  SELECT setval_max('public');
--  SELECT setval_max('public','mytable');
--  SELECT setval_max('public',null,true);
--  SELECT setval_max('public','mytable',true);

DECLARE
    row_data RECORD;
    sql_code TEXT;

BEGIN
    IF ((SELECT COUNT(*) FROM pg_namespace WHERE nspname = schema_name) = 0) THEN
        RAISE EXCEPTION 'The schema "%" does not exist', schema_name;
    END IF;

    FOR sql_code IN
        SELECT 'SELECT SETVAL(' ||quote_literal(N.nspname || '.' || S.relname)|| ', MAX(' ||quote_ident(C.attname)|| ') ) FROM ' || quote_ident(N.nspname) || '.' || quote_ident(T.relname)|| ';' AS sql_code
            FROM pg_class AS S
            INNER JOIN pg_depend AS D ON S.oid = D.objid
            INNER JOIN pg_class AS T ON D.refobjid = T.oid
            INNER JOIN pg_attribute AS C ON D.refobjid = C.attrelid AND D.refobjsubid = C.attnum
            INNER JOIN pg_namespace N ON N.oid = S.relnamespace
            WHERE S.relkind = 'S' AND N.nspname = schema_name AND (table_name IS NULL OR T.relname = table_name)
            ORDER BY S.relname
    LOOP
        IF (raise_notice) THEN
            RAISE NOTICE 'sql_code: %', sql_code;
        END IF;
        EXECUTE sql_code;
    END LOOP;
END;
$$;


ALTER FUNCTION mixalot.set_sequence_val_max(schema_name name, table_name name, raise_notice boolean) OWNER TO dbservice;

--
-- Name: sku_pick_order(timestamp with time zone); Type: FUNCTION; Schema: mixalot; Owner: dbservice
--

CREATE FUNCTION mixalot.sku_pick_order(target_ts timestamp with time zone) RETURNS TABLE(sku_id integer, pick_order integer)
    LANGUAGE plpgsql
    AS $$

declare latest_import_ts timestamp with time zone;

/*
Purpose: return a sku pick_order for the most recent import data for a given date
*/
begin
	select max(import_ts) from mixalot.inm_data
		where import_ts <= target_ts and data_type = 'Warehouse SKU Inventory'
		into latest_import_ts;
	
	return query
		select distinct product_id, d.sort_order
		  from mixalot.inm_data d
		  where import_ts = latest_import_ts and data_type = 'Warehouse SKU Inventory';	
end;

$$;


ALTER FUNCTION mixalot.sku_pick_order(target_ts timestamp with time zone) OWNER TO dbservice;

--
-- Name: fn_add_to_watch(bigint, character varying); Type: FUNCTION; Schema: pantry; Owner: dbservice
--

CREATE FUNCTION pantry.fn_add_to_watch(label_id bigint, order_id character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$ 
BEGIN 
  INSERT INTO pantry.tmp_watcher
              ( 
                          label_id,
                          order_id,                           
                          created
              ) 
  VALUES (
  		label_id, order_id, (SELECT date_part('epoch',CURRENT_TIMESTAMP)::int)
  	);
END
$$;


ALTER FUNCTION pantry.fn_add_to_watch(label_id bigint, order_id character varying) OWNER TO dbservice;

--
-- Name: fn_audit_campus_attribute(); Type: FUNCTION; Schema: pantry; Owner: dbservice
--

CREATE FUNCTION pantry.fn_audit_campus_attribute() RETURNS trigger
    LANGUAGE plpgsql
    AS $$

   BEGIN
   IF (TG_OP = 'INSERT') THEN
       INSERT INTO pantry.history_campus_attribute(campus_id,gad_id,value,time_modified,action)
       VALUES(NEW.campus_id, NEW.key_id, NEW.value, now(),'INSERT');
       RETURN NEW;
   ELSEIF (TG_OP = 'UPDATE') THEN
       INSERT INTO pantry.history_campus_attribute(campus_id,gad_id,value,time_modified,action)
       VALUES(NEW.campus_id, NEW.key_id, NEW.value, now(),'UPDATE');
       RETURN NEW;
   ELSEIF (TG_OP = 'DELETE') THEN
       INSERT INTO pantry.history_campus_attribute(campus_id,gad_id,value,time_modified,action)
       VALUES(OLD.campus_id, OLD.key_id, OLD.value, now(),'DELETE');
       RETURN OLD;
   END IF;
   RETURN NULL; -- result is ignored since this is an AFTER trigger
END;
$$;


ALTER FUNCTION pantry.fn_audit_campus_attribute() OWNER TO dbservice;

--
-- Name: fn_audit_global_attribute_def(); Type: FUNCTION; Schema: pantry; Owner: dbservice
--

CREATE FUNCTION pantry.fn_audit_global_attribute_def() RETURNS trigger
    LANGUAGE plpgsql
    AS $$

   BEGIN
   IF (TG_OP = 'INSERT') THEN
       INSERT INTO pantry.history_global_attribute_def(key,value,time_modified,action)
       VALUES(NEW.key,NEW.default_value, now(),'INSERT');
       RETURN NEW;
   ELSEIF (TG_OP = 'UPDATE') THEN
       INSERT INTO pantry.history_global_attribute_def(key,value,time_modified,action)
       VALUES(NEW.key,NEW.default_value,now(),'UPDATE');
       RETURN NEW;
   ELSEIF (TG_OP = 'DELETE') THEN
       INSERT INTO pantry.history_global_attribute_def(key,value,time_modified,action)
       VALUES(OLD.key,OLD.default_value,now(),'DELETE');
       RETURN OLD;
   END IF;
   RETURN NULL; -- result is ignored since this is an AFTER trigger
END;
$$;


ALTER FUNCTION pantry.fn_audit_global_attribute_def() OWNER TO dbservice;

--
-- Name: fn_audit_kiosk_attribute(); Type: FUNCTION; Schema: pantry; Owner: dbservice
--

CREATE FUNCTION pantry.fn_audit_kiosk_attribute() RETURNS trigger
    LANGUAGE plpgsql
    AS $$

   BEGIN
   IF (TG_OP = 'INSERT') THEN
       INSERT INTO pantry.history_kiosk_attribute(kiosk_id,gad_id,value,time_modified,action)
       VALUES(NEW.kiosk_id, NEW.key_id, NEW.value, now(),'INSERT');
       RETURN NEW;
   ELSEIF (TG_OP = 'UPDATE') THEN
       INSERT INTO pantry.history_kiosk_attribute(kiosk_id,gad_id,value,time_modified,action)
       VALUES(NEW.kiosk_id, NEW.key_id, NEW.value, now(),'UPDATE');
       RETURN NEW;
   ELSEIF (TG_OP = 'DELETE') THEN
       INSERT INTO pantry.history_kiosk_attribute(kiosk_id,gad_id,value,time_modified,action)
       VALUES(OLD.kiosk_id, OLD.key_id, OLD.value, now(),'DELETE');
       RETURN OLD;
   END IF;
   RETURN NULL; -- result is ignored since this is an AFTER trigger
END;
$$;


ALTER FUNCTION pantry.fn_audit_kiosk_attribute() OWNER TO dbservice;

--
-- Name: fn_audit_kiosk_device(); Type: FUNCTION; Schema: pantry; Owner: dbservice
--

CREATE FUNCTION pantry.fn_audit_kiosk_device() RETURNS trigger
    LANGUAGE plpgsql
    AS $$

   BEGIN
   IF (TG_OP = 'INSERT') THEN
       INSERT INTO pantry.history_kiosk_device(kiosk_id,payload,time_modified,action)
       VALUES(NEW.kiosk_id, NEW.payload, now(),'INSERT');
       RETURN NEW;
   ELSEIF (TG_OP = 'UPDATE') THEN
       INSERT INTO pantry.history_kiosk_device(kiosk_id,payload,time_modified,action)
       VALUES(NEW.kiosk_id, NEW.payload, now(),'UPDATE');
       RETURN NEW;
   ELSEIF (TG_OP = 'DELETE') THEN
       INSERT INTO pantry.history_kiosk_device(kiosk_id,payload,time_modified,action)
       VALUES(OLD.kiosk_id, OLD.payload, now(),'DELETE');
       RETURN OLD;
   END IF;
   RETURN NULL; -- result is ignored since this is an AFTER trigger
END;
$$;


ALTER FUNCTION pantry.fn_audit_kiosk_device() OWNER TO dbservice;

--
-- Name: fn_audit_kiosk_service_version(); Type: FUNCTION; Schema: pantry; Owner: dbservice
--

CREATE FUNCTION pantry.fn_audit_kiosk_service_version() RETURNS trigger
    LANGUAGE plpgsql
    AS $$

   BEGIN
   IF (TG_OP = 'INSERT') THEN
       INSERT INTO pantry.history_kiosk_service_version(kiosk_id,service,version,time_modified,action)
       VALUES(NEW.kiosk_id, NEW.service, NEW.version, now(),'INSERT');
       RETURN NEW;
   ELSEIF (TG_OP = 'UPDATE') THEN
       INSERT INTO pantry.history_kiosk_service_version(kiosk_id,service,version,time_modified,action)
       VALUES(NEW.kiosk_id, NEW.service, NEW.version, now(),'UPDATE');
       RETURN NEW;
   ELSEIF (TG_OP = 'DELETE') THEN
       INSERT INTO pantry.history_kiosk_service_version(kiosk_id,service,version,time_modified,action)
       VALUES(OLD.kiosk_id, OLD.service, OLD.version, now(),'DELETE');
       RETURN OLD;
   END IF;
   RETURN NULL; -- result is ignored since this is an AFTER trigger
END;
$$;


ALTER FUNCTION pantry.fn_audit_kiosk_service_version() OWNER TO dbservice;

--
-- Name: fn_campus_insert(); Type: FUNCTION; Schema: pantry; Owner: dbservice
--

CREATE FUNCTION pantry.fn_campus_insert() RETURNS trigger
    LANGUAGE plpgsql
    AS $$ 
BEGIN 
   INSERT INTO pantry.group_campus (group_id, campus_id)
    VALUES(1, NEW.id);		
  RETURN NEW; 
END; 
$$;


ALTER FUNCTION pantry.fn_campus_insert() OWNER TO dbservice;

--
-- Name: fn_card_insert(); Type: FUNCTION; Schema: pantry; Owner: dbservice
--

CREATE FUNCTION pantry.fn_card_insert() RETURNS trigger
    LANGUAGE plpgsql
    AS $$ 
BEGIN 
 	UPDATE pantry.ro_order 
	SET    customer_full_name = concat_ws(' ', coalesce(trim(NEW.first_name), o.payment_system), coalesce(trim(NEW.last_name), substring(NEW.number, -8)))
	FROM pantry.order o 
	WHERE pantry.ro_order.order_id = o.order_id AND o.card_hash = NEW.hash;
  RETURN NEW; 
END; 
$$;


ALTER FUNCTION pantry.fn_card_insert() OWNER TO dbservice;

--
-- Name: fn_discount_delete(); Type: FUNCTION; Schema: pantry; Owner: dbservice
--

CREATE FUNCTION pantry.fn_discount_delete() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
UPDATE pantry.discount_history 
SET end_time = (SELECT date_part('epoch',CURRENT_TIMESTAMP)::int) 
WHERE discount_id = OLD.id AND end_time IS NULL;
RETURN NEW;
END;
$$;


ALTER FUNCTION pantry.fn_discount_delete() OWNER TO dbservice;

--
-- Name: fn_discount_insert(); Type: FUNCTION; Schema: pantry; Owner: dbservice
--

CREATE FUNCTION pantry.fn_discount_insert() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
 BEGIN
        INSERT INTO pantry.discount_history (kiosk_id, product_id, value, start_time, end_time, discount_id)
    VALUES(NEW.kiosk_id, NEW.product_id, NEW.value,  EXTRACT(epoch FROM NOW()) , NULL, NEW.id);
RETURN NEW;
END;
$$;


ALTER FUNCTION pantry.fn_discount_insert() OWNER TO dbservice;

--
-- Name: fn_discount_update(); Type: FUNCTION; Schema: pantry; Owner: dbservice
--

CREATE FUNCTION pantry.fn_discount_update() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
	UPDATE pantry.discount_history SET end_time = EXTRACT(epoch FROM NOW()) WHERE discount_id = OLD.id AND end_time IS NULL;
	INSERT INTO pantry.discount_history (kiosk_id, product_id, value, start_time, end_time, discount_id)
    VALUES(NEW.kiosk_id, NEW.product_id, NEW.value, EXTRACT(epoch FROM NOW()) + 1, NULL, NEW.id);
RETURN NEW;
END;


$$;


ALTER FUNCTION pantry.fn_discount_update() OWNER TO dbservice;

--
-- Name: fn_kiosk_audit_log_insert(); Type: FUNCTION; Schema: pantry; Owner: dbservice
--

CREATE FUNCTION pantry.fn_kiosk_audit_log_insert() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
INSERT INTO pantry.kiosk_audit_log (
    kiosk_id, archived, enable_reporting, enable_monitoring
) VALUES (
    NEW.id, NEW.archived, NEW.enable_reporting, NEW.enable_monitoring
);
RETURN NEW;
END;
$$;


ALTER FUNCTION pantry.fn_kiosk_audit_log_insert() OWNER TO dbservice;

--
-- Name: fn_kiosk_audit_log_update(); Type: FUNCTION; Schema: pantry; Owner: dbservice
--

CREATE FUNCTION pantry.fn_kiosk_audit_log_update() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
IF (
 NEW.archived != OLD.archived
 OR
 NEW.enable_reporting != OLD.enable_reporting
 OR
 NEW.enable_monitoring != OLD.enable_monitoring
) THEN
 INSERT INTO pantry.kiosk_audit_log (
    kiosk_id, archived, enable_reporting, enable_monitoring
 ) VALUES (
    OLD.id, NEW.archived, NEW.enable_reporting, NEW.enable_monitoring
);
END IF;
RETURN NEW;
END;
$$;


ALTER FUNCTION pantry.fn_kiosk_audit_log_update() OWNER TO dbservice;

--
-- Name: fn_kiosk_status_insert(); Type: FUNCTION; Schema: pantry; Owner: dbservice
--

CREATE FUNCTION pantry.fn_kiosk_status_insert() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  last_kiosk_status_time BIGINT;
  status_is_newer BOOLEAN;
BEGIN

  -- calculate if status about to be inserted is newer than that in last_kiosk_status
  SELECT time from pantry.last_kiosk_status WHERE kiosk_id = new.kiosk_id
         INTO last_kiosk_status_time;
  status_is_newer =  (last_kiosk_status_time is null) or new.time > last_kiosk_status_time;

  IF status_is_newer
    THEN
      INSERT INTO pantry.last_kiosk_status
        (kiosk_id, kiosk_temperature, kit_temperature, power, battery_level, rfid_0, rfid_1, rfid_2, rfid_3, rfid_4,
         rfid_5, rfid_6, rfid_7, time, modem_signal_percentage, modem_signal_type, ip, temperature_tags,
         kiosk_temperature_source, kiosk_temperature_count, app_uptime, system_uptime, is_locked,
         num_payment_messages_pending_sync)
        VALUES (NEW.kiosk_id, NEW.kiosk_temperature, NEW.kit_temperature, NEW.power, NEW.battery_level, NEW.rfid_0,
                NEW.rfid_1, NEW.rfid_2, NEW.rfid_3, NEW.rfid_4, NEW.rfid_5, NEW.rfid_6, NEW.rfid_7, NEW.time,
                NEW.modem_signal_percentage, NEW.modem_signal_type, NEW.ip, NEW.temperature_tags,
                NEW.kiosk_temperature_source, NEW.kiosk_temperature_count, NEW.app_uptime, NEW.system_uptime,
                NEW.is_locked, NEW.num_payment_messages_pending_sync)
        ON conflict (kiosk_id) DO
        UPDATE
        SET
          kiosk_id = excluded.kiosk_id,
          kiosk_temperature = excluded.kiosk_temperature,
          kit_temperature = excluded.kit_temperature,
          power = excluded.power,
          battery_level = excluded.battery_level,
          rfid_0 = excluded.rfid_0,
          rfid_1 = excluded.rfid_1,
          rfid_2 = excluded.rfid_2,
          rfid_3 = excluded.rfid_3,
          rfid_4 = excluded.rfid_4,
          rfid_5 = excluded.rfid_5,
          rfid_6 = excluded.rfid_6,
          rfid_7 = excluded.rfid_7,
          time = excluded.time,
          modem_signal_percentage = excluded.modem_signal_percentage,
          modem_signal_type = excluded.modem_signal_type,
          ip = excluded.ip,
          temperature_tags = excluded.temperature_tags,
          kiosk_temperature_source = excluded.kiosk_temperature_source,
          kiosk_temperature_count = excluded.kiosk_temperature_count,
          app_uptime = excluded.app_uptime,
          system_uptime = excluded.system_uptime,
          is_locked = excluded.is_locked,
          num_payment_messages_pending_sync = excluded.num_payment_messages_pending_sync;
  END IF;

RETURN NEW;
END;
$$;


ALTER FUNCTION pantry.fn_kiosk_status_insert() OWNER TO dbservice;

--
-- Name: fn_kiosk_update(); Type: FUNCTION; Schema: pantry; Owner: dbservice
--

CREATE FUNCTION pantry.fn_kiosk_update() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
IF (NEW.archived <> OLD.archived OR NEW.campus_id <> OLD.campus_id) THEN
      UPDATE pantry.ro_order roo        
      SET campus_id = k.campus_id, 
      archived = 
      	CASE WHEN (k.archived = 1 OR o.archived = 1) 
      		THEN 1 
      		ELSE 0 
      	END
      FROM pantry.kiosk k, pantry.order o
      WHERE k.id = NEW.id AND roo.order_id = o.order_id AND k.id = roo.kiosk_id;
    END IF;
RETURN NEW;
END;
$$;


ALTER FUNCTION pantry.fn_kiosk_update() OWNER TO dbservice;

--
-- Name: fn_label_delete(); Type: FUNCTION; Schema: pantry; Owner: dbservice
--

CREATE FUNCTION pantry.fn_label_delete() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    IF OLD.order_id IS NOT NULL THEN
      SELECT pantry.fn_add_to_watch(OLD.id, OLD.order_id);
    END IF;
RETURN NEW;
END;
$$;


ALTER FUNCTION pantry.fn_label_delete() OWNER TO dbservice;

--
-- Name: fn_label_insert(); Type: FUNCTION; Schema: pantry; Owner: dbservice
--

CREATE FUNCTION pantry.fn_label_insert() RETURNS trigger
    LANGUAGE plpgsql
    AS $$ 
BEGIN
   IF NEW.order_id is NOT NULL THEN 
   	PERFORM pantry.fn_add_to_watch(NEW.id, NEW.order_id);		
   END IF;	
  RETURN NEW; 
END; 
$$;


ALTER FUNCTION pantry.fn_label_insert() OWNER TO dbservice;

--
-- Name: fn_label_update(); Type: FUNCTION; Schema: pantry; Owner: dbservice
--

CREATE FUNCTION pantry.fn_label_update() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  IF (OLD.order_id IS NOT NULL OR NEW.order_id IS NOT NULL) THEN
      IF NEW.order_id = OLD.order_id THEN
        IF NEW.price <> OLD.price THEN
          PERFORM pantry.fn_add_to_watch(NEW.id, NEW.order_id);
        END IF;
      ELSE
        IF NEW.order_id IS NOT NULL THEN
          PERFORM pantry.fn_add_to_watch(NEW.id, NEW.order_id);
        END IF;
        IF OLD.order_id IS NOT NULL THEN
          PERFORM pantry.fn_add_to_watch(NEW.id, OLD.order_id);
        END IF;
      END IF;
    END IF;
RETURN NEW;
END;
$$;


ALTER FUNCTION pantry.fn_label_update() OWNER TO dbservice;

--
-- Name: fn_order_insert(); Type: FUNCTION; Schema: pantry; Owner: dbservice
--

CREATE FUNCTION pantry.fn_order_insert() RETURNS trigger
    LANGUAGE plpgsql
    AS $$ 
BEGIN 
   PERFORM pantry.fn_ro_order_set_order(NEW.order_id);		
  RETURN NEW; 
END; 
$$;


ALTER FUNCTION pantry.fn_order_insert() OWNER TO dbservice;

--
-- Name: fn_order_update(); Type: FUNCTION; Schema: pantry; Owner: dbservice
--

CREATE FUNCTION pantry.fn_order_update() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
IF (NEW.kiosk_id <> OLD.kiosk_id OR NEW.kiosk_title <> OLD.kiosk_title 
    OR NEW.created <> OLD.created OR NEW.state <> OLD.state 
    OR NEW.archived <> OLD.archived 
    OR NEW.amount_list_price IS DISTINCT FROM OLD.amount_list_price) THEN
      PERFORM pantry.fn_ro_order_set_order(NEW.order_id);
    END IF;
RETURN NEW;
END;
$$;


ALTER FUNCTION pantry.fn_order_update() OWNER TO dbservice;

--
-- Name: fn_product_delete(); Type: FUNCTION; Schema: pantry; Owner: dbservice
--

CREATE FUNCTION pantry.fn_product_delete() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
	UPDATE pantry.product_history SET end_time = EXTRACT(epoch FROM NOW()) WHERE product_id = OLD.id AND end_time IS NULL;
RETURN NEW;
END;
$$;


ALTER FUNCTION pantry.fn_product_delete() OWNER TO dbservice;

--
-- Name: fn_product_insert(); Type: FUNCTION; Schema: pantry; Owner: dbservice
--

CREATE FUNCTION pantry.fn_product_insert() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
 BEGIN
    INSERT INTO pantry.product_history (price, cost, start_time, end_time, product_id, campus_id)
    VALUES(NEW.price, NEW.cost, (SELECT date_part('epoch',CURRENT_TIMESTAMP)::int), NULL, NEW.id, NEW.campus_id);
      
RETURN NEW;
END;
$$;


ALTER FUNCTION pantry.fn_product_insert() OWNER TO dbservice;

--
-- Name: fn_product_stats_by_kiosk(); Type: FUNCTION; Schema: pantry; Owner: dbservice
--

CREATE FUNCTION pantry.fn_product_stats_by_kiosk() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
        IF NEW.timestamp IS NULL THEN				
                NEW.timestamp = EXTRACT(epoch FROM NOW());
        END IF;
RETURN NEW;		
END;
$$;


ALTER FUNCTION pantry.fn_product_stats_by_kiosk() OWNER TO dbservice;

--
-- Name: fn_product_update(); Type: FUNCTION; Schema: pantry; Owner: dbservice
--

CREATE FUNCTION pantry.fn_product_update() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN

    IF NEW.price <> OLD.price OR NEW.cost <> OLD.cost THEN
		UPDATE pantry.product_history SET end_time = EXTRACT(epoch FROM NOW()) WHERE product_id = OLD.id AND end_time IS NULL;
		INSERT INTO pantry.product_history (price, cost, start_time, end_time, product_id, campus_id)
		VALUES(NEW.price, NEW.cost, EXTRACT(epoch FROM NOW()) + 1, NULL, NEW.id, NEW.campus_id);
    END IF;

RETURN NEW;
END;
$$;


ALTER FUNCTION pantry.fn_product_update() OWNER TO dbservice;

--
-- Name: fn_ro_order_set_order(character varying); Type: FUNCTION; Schema: pantry; Owner: dbservice
--

CREATE FUNCTION pantry.fn_ro_order_set_order(orderid character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$ 
BEGIN 
  INSERT INTO pantry.ro_order 
              ( 
                          order_id, 
                          campus_id, 
                          kiosk_id, 
                          kiosk_title, 
                          created, 
                          state, 
                          customer_full_name, 
                          archived 
              ) 
  SELECT    o.order_id, 
            k.campus_id, 
            o.kiosk_id, 
            o.kiosk_title, 
            o.created, 
            o.state, 
            concat_ws(' ', coalesce(trim(c.first_name), o.payment_system), coalesce(trim(c.last_name), substring(c.NUMBER, -8))) customer_full_name,
            cast( 
            CASE 
                      WHEN( 
                                          k.archived = 1 
                                OR        o.archived = 1) THEN 1::bigint 
                      ELSE 0::                                    bigint 
            END AS                                                bigint) 
  FROM      pantry.ORDER o 
  left join pantry.kiosk k 
  ON        k.id = o.kiosk_id 
  left join pantry.card c 
  ON        c.hash = o.card_hash 
  WHERE     o.order_id = orderid
  LIMIT 1
  ON conflict (order_id) DO 
  UPDATE 
  SET    campus_id = excluded.campus_id, 
         kiosk_id = excluded.kiosk_id, 
         kiosk_title = excluded.kiosk_title, 
         created = excluded.created, 
         state = excluded.state, 
         customer_full_name = excluded.customer_full_name;
PERFORM pantry.fn_ro_order_update_full_price(orderId);                                                                                                                                                                                                                                 
END
$$;


ALTER FUNCTION pantry.fn_ro_order_set_order(orderid character varying) OWNER TO dbservice;

--
-- Name: fn_ro_order_update_full_price(character varying); Type: FUNCTION; Schema: pantry; Owner: dbservice
--

CREATE FUNCTION pantry.fn_ro_order_update_full_price(orderid character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
UPDATE pantry.ro_order
    SET
      real_full_price = (
        SELECT                   
                        CASE WHEN (o.state <> 'NonTrans')
                          THEN
                                  COALESCE(SUM(l.price), 0)
                          ELSE
                                  0
                          END
        FROM pantry.label l
          JOIN pantry.order o ON o.order_id = l.order_id
        WHERE l.order_id = orderId
                GROUP BY o.state  
      ),
      full_price = (
        SELECT                   
                        CASE WHEN (o.state <> 'NonTrans')
                          THEN
                                  COALESCE(SUM(l.price), 0)
                          ELSE
                                  0
                          END
        FROM pantry.label l
          JOIN pantry.order o ON o.order_id = l.order_id
          JOIN pantry.kiosk k ON k.id = o.kiosk_id
          JOIN pantry.product p ON p.id = l.product_id
          JOIN pantry.group_campus gc1 ON gc1.campus_id = k.campus_id AND gc1.owner = 1
          JOIN pantry.group_campus gc2 ON gc2.campus_id = p.campus_id AND gc2.owner = 1
        WHERE l.order_id = orderId
              AND gc1.group_id = gc2.group_id
                GROUP BY o.state  
      ),
      time_updated = (SELECT date_part('epoch',CURRENT_TIMESTAMP)::int)
    WHERE ro_order.order_id = orderId;
END
$$;


ALTER FUNCTION pantry.fn_ro_order_update_full_price(orderid character varying) OWNER TO dbservice;

--
-- Name: fn_spoilage_insert(); Type: FUNCTION; Schema: pantry; Owner: dbservice
--

CREATE FUNCTION pantry.fn_spoilage_insert() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
        IF NEW.timestamp IS NULL THEN				
                NEW.timestamp = EXTRACT(epoch FROM NOW());
        END IF;
RETURN NEW;		
END;
$$;


ALTER FUNCTION pantry.fn_spoilage_insert() OWNER TO dbservice;

--
-- Name: get_permissions(integer); Type: FUNCTION; Schema: pantry; Owner: dbservice
--

CREATE FUNCTION pantry.get_permissions(a integer) RETURNS TABLE(role_id integer, permission character varying, api character varying, isfrontend integer)
    LANGUAGE plpgsql
    AS $$ 
BEGIN
    RETURN QUERY SELECT h.role_id, h.permission, h.api, h.isFrontend FROM pantry.HIERARCHY(a, 1) h; 
END;
$$;


ALTER FUNCTION pantry.get_permissions(a integer) OWNER TO dbservice;

--
-- Name: hierarchy(integer, integer); Type: FUNCTION; Schema: pantry; Owner: dbservice
--

CREATE FUNCTION pantry.hierarchy(givenid integer, initial integer) RETURNS TABLE(role_id integer, permission character varying, api character varying, isfrontend integer)
    LANGUAGE plpgsql
    AS $$ 
    DECLARE next_id INT;

    DECLARE cur1 REFCURSOR;
    DECLARE cur2 REFCURSOR;
BEGIN
    IF initial=1 THEN
 DROP TABLE IF EXISTS OUT_TEMP;
        CREATE TEMPORARY TABLE OUT_TEMP (role_id int, permission varchar(255), api varchar(255), isFrontend int);
    END IF;

    IF GivenID IS NULL then
        OPEN cur2 FOR SELECT id FROM pantry.role;
        LOOP
            FETCH cur2 INTO next_id;

     EXIT WHEN NOT FOUND;

            PERFORM pantry.Hierarchy(next_id, -1);
        END LOOP;

        CLOSE cur2;
    ELSE
        INSERT INTO OUT_TEMP(role_id, permission, api, isFrontend) (SELECT null, p.permission, p.api, p."isFrontend" FROM pantry.permission_mapping pm JOIN pantry.permission p ON p.id =pm.permission_id WHERE pm.role_id = GivenID);
        OPEN cur1 FOR SELECT rm.role_id FROM pantry.role_mapping rm WHERE parent_id = GivenID;
        LOOP
            FETCH cur1 INTO next_id;

            EXIT WHEN NOT FOUND;

            PERFORM pantry.Hierarchy(next_id, 0);
        END LOOP;

        CLOSE cur1;
    END IF;

    IF initial=-1 THEN
        UPDATE OUT_TEMP ot SET role_id = GivenID WHERE ot.role_id IS NULL;
    ELSEIF GivenID IS NULL THEN
        RETURN QUERY SELECT DISTINCT ot.role_id, ot.permission, ot.api, ot.isFrontend FROM OUT_TEMP ot;
 DROP TABLE OUT_TEMP;
    ELSEIF initial = 1 THEN
        RETURN QUERY SELECT DISTINCT ot.permission, ot.api, ot.isFrontend FROM OUT_TEMP;
 DROP TABLE OUT_TEMP;
    END IF;
END;
$$;


ALTER FUNCTION pantry.hierarchy(givenid integer, initial integer) OWNER TO dbservice;

--
-- Name: key_loc_lookup(bigint, character varying); Type: FUNCTION; Schema: pantry; Owner: dbservice
--

CREATE FUNCTION pantry.key_loc_lookup(param_kiosk_id bigint, key_name character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
    gad_val varchar;
    campus_val varchar;
    kiosk_val varchar;
    lookup_campus_id int;

BEGIN
  select campus_id from pantry.kiosk where id = param_kiosk_id into lookup_campus_id;
  select subquery.gad, subquery.campus, subquery.kiosk  from
(
    SELECT
           gad.default_value AS gad,
           ca.value AS campus,
           ka.value  AS kiosk

    FROM pantry.global_attribute_def gad
             LEFT JOIN pantry.campus_attribute ca ON gad.id = ca.key_id and ca.campus_id = lookup_campus_id
             LEFT JOIN pantry.kiosk_attribute ka ON gad.id = ka.key_id and ka.kiosk_id = param_kiosk_id
    WHERE gad.key = key_name
) subquery into gad_val, campus_val, kiosk_val;

IF kiosk_val is not null THEN
  return 'kiosk';
ELSIF campus_val is not null THEN
    return 'campus';
ELSEIF gad_val is not null THEN
    return 'gad';
ELSE
    return 'none';
END IF;

END
$$;


ALTER FUNCTION pantry.key_loc_lookup(param_kiosk_id bigint, key_name character varying) OWNER TO dbservice;

--
-- Name: kiosk_guardrails_ssl_cert_bytetech_co(); Type: FUNCTION; Schema: pantry; Owner: dbservice
--

CREATE FUNCTION pantry.kiosk_guardrails_ssl_cert_bytetech_co() RETURNS trigger
    LANGUAGE plpgsql
    AS $$

declare
  -- create a constant min version 4.4.4
  min_app_version text = '4.4.4';
begin
  if
    -- new record or server_url is changing (use `is distinct` to handle null)
    (tg_op = 'INSERT' or (tg_op = 'UPDATE' and old.server_url is distinct from new.server_url))
    and new.app_vname is not null
    and public.is_older_software_version(new.app_vname::text, min_app_version)
    and trim(new.server_url) ilike '%.bytetech.co'
  then new.server_url = null;
  end if;

  return new;
end;
$$;


ALTER FUNCTION pantry.kiosk_guardrails_ssl_cert_bytetech_co() OWNER TO dbservice;

--
-- Name: awsdms_intercept_ddl(); Type: FUNCTION; Schema: public; Owner: dbservice
--

CREATE FUNCTION public.awsdms_intercept_ddl() RETURNS event_trigger
    LANGUAGE plpgsql
    AS $$
  declare _qry text;
BEGIN
  if (tg_tag='CREATE TABLE' or tg_tag='ALTER TABLE' or tg_tag='DROP TABLE') then
	    SELECT current_query() into _qry;
	    insert into public.awsdms_ddl_audit
	    values
	    (
	    default,current_timestamp,current_user,cast(TXID_CURRENT()as varchar(16)),tg_tag,0,'',current_schema,_qry
	    );
	    delete from public.awsdms_ddl_audit;
 end if;
END;
$$;


ALTER FUNCTION public.awsdms_intercept_ddl() OWNER TO dbservice;

--
-- Name: checkpoint(timestamp without time zone, timestamp without time zone, bigint); Type: FUNCTION; Schema: public; Owner: dbservice
--

CREATE FUNCTION public.checkpoint(receiving_start timestamp without time zone, receiving_stop timestamp without time zone, location_id bigint) RETURNS TABLE(product_source character varying, vendor character varying, sku bigint, product_name character varying, item_count bigint, receiving_date timestamp without time zone)
    LANGUAGE plpgsql
    AS $$
BEGIN
	RETURN query 
    	SELECT o.source,
			o.vendor,
			l.product_id,
			o.title,
    		count(l.epc),
    		to_timestamp(max(l.time_updated)) at TIME zone 'US/Pacific'
		FROM pantry.label l
		JOIN pantry.product o ON l.product_id = o.id
		WHERE to_timestamp(l.time_updated) at TIME zone 'US/Pacific' between receiving_start AND receiving_stop
    		AND kiosk_id = location_id
		GROUP BY o.source, o.vendor, l.product_id, o.title;
END; $$;


ALTER FUNCTION public.checkpoint(receiving_start timestamp without time zone, receiving_stop timestamp without time zone, location_id bigint) OWNER TO dbservice;

--
-- Name: date_round(timestamp with time zone, interval); Type: FUNCTION; Schema: public; Owner: dbservice
--

CREATE FUNCTION public.date_round(base_date timestamp with time zone, round_interval interval) RETURNS timestamp with time zone
    LANGUAGE sql IMMUTABLE
    AS $_$
  SELECT TO_TIMESTAMP((EXTRACT(epoch FROM $1)::INTEGER + EXTRACT(epoch FROM $2)::INTEGER / 2)
                     / EXTRACT(epoch FROM $2)::INTEGER * EXTRACT(epoch FROM $2)::INTEGER)
$_$;


ALTER FUNCTION public.date_round(base_date timestamp with time zone, round_interval interval) OWNER TO dbservice;

--
-- Name: div(numeric, numeric); Type: FUNCTION; Schema: public; Owner: dbservice
--

CREATE FUNCTION public.div(numeric, numeric) RETURNS double precision
    LANGUAGE sql IMMUTABLE
    AS $_$
  SELECT CASE WHEN ($2::float > 0.0) THEN ($1::float / $2::float) ELSE (0.0::float) END
$_$;


ALTER FUNCTION public.div(numeric, numeric) OWNER TO dbservice;

--
-- Name: dowhour(timestamp with time zone); Type: FUNCTION; Schema: public; Owner: dbservice
--

CREATE FUNCTION public.dowhour(timestamp with time zone) RETURNS integer
    LANGUAGE sql IMMUTABLE
    AS $_$
 SELECT ((1+extract(DOW FROM $1))*100 + extract(hour from $1))::int
$_$;


ALTER FUNCTION public.dowhour(timestamp with time zone) OWNER TO dbservice;

--
-- Name: epoch_round(bigint, interval); Type: FUNCTION; Schema: public; Owner: dbservice
--

CREATE FUNCTION public.epoch_round(bigint, round_interval interval) RETURNS timestamp with time zone
    LANGUAGE sql IMMUTABLE
    AS $_$
  SELECT TO_TIMESTAMP((EXTRACT(epoch FROM to_timestamp($1))::INTEGER + EXTRACT(epoch FROM $2)::INTEGER / 2)
                / EXTRACT(epoch FROM $2)::INTEGER * EXTRACT(epoch FROM $2)::INTEGER)
$_$;


ALTER FUNCTION public.epoch_round(bigint, round_interval interval) OWNER TO dbservice;

--
-- Name: f_nr_stockout_minutes(timestamp with time zone, timestamp with time zone, timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: dbservice
--

CREATE FUNCTION public.f_nr_stockout_minutes(ts timestamp with time zone, kiosk_restock_ts timestamp with time zone, hour_start timestamp with time zone, hour_end timestamp with time zone) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
begin

case when kiosk_restock_ts is not null
    and (
      ts between hour_start and hour_end
      or kiosk_restock_ts between hour_start and hour_end
      or (
        hour_start > ts
        and hour_end < kiosk_restock_ts
      )
    )
  then 
    return ((3600.0 -
    -- difference or hour_start and greatest of ts or hour_start
    (extract(epoch from greatest(hour_start, ts)) - extract(epoch from hour_start)) -
    -- difference or hour_end and least of kiosk_restock_ts or hour_end
    (extract(epoch from hour_end) - extract(epoch from least(hour_end, kiosk_restock_ts))))) / 60.0;
  when kiosk_restock_ts is null and date_trunc('hour', ts) <= hour_start
  then
    return (3600.0 - (extract(epoch from greatest(hour_start, ts)) - extract(epoch from hour_start))) / 60.0;
  else
    return 0.0;
  end case;

end
$$;


ALTER FUNCTION public.f_nr_stockout_minutes(ts timestamp with time zone, kiosk_restock_ts timestamp with time zone, hour_start timestamp with time zone, hour_end timestamp with time zone) OWNER TO dbservice;

--
-- Name: fmt_ts(timestamp with time zone); Type: FUNCTION; Schema: public; Owner: dbservice
--

CREATE FUNCTION public.fmt_ts(timestamp with time zone) RETURNS text
    LANGUAGE sql IMMUTABLE
    AS $_$
  SELECT to_char($1, 'YYYY-MM-DD HH24:MI');
$_$;


ALTER FUNCTION public.fmt_ts(timestamp with time zone) OWNER TO dbservice;

--
-- Name: fmt_ts_mmdd(timestamp with time zone); Type: FUNCTION; Schema: public; Owner: dbservice
--

CREATE FUNCTION public.fmt_ts_mmdd(timestamp with time zone) RETURNS text
    LANGUAGE sql IMMUTABLE
    AS $_$
  SELECT to_char($1, 'MM-DD HH24:MI');
$_$;


ALTER FUNCTION public.fmt_ts_mmdd(timestamp with time zone) OWNER TO dbservice;

--
-- Name: frac(numeric, numeric); Type: FUNCTION; Schema: public; Owner: dbservice
--

CREATE FUNCTION public.frac(numeric, numeric) RETURNS double precision
    LANGUAGE sql IMMUTABLE
    AS $_$
 SELECT if( $1::float + $2::float > 0.0, $1::float / ($1::float + $2::float), 0.0::float)
$_$;


ALTER FUNCTION public.frac(numeric, numeric) OWNER TO dbservice;

--
-- Name: get_sum(numeric, numeric); Type: FUNCTION; Schema: public; Owner: dbservice
--

CREATE FUNCTION public.get_sum(a numeric, b numeric) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
BEGIN
 RETURN a + b;
END; $$;


ALTER FUNCTION public.get_sum(a numeric, b numeric) OWNER TO dbservice;

--
-- Name: hash_to_bigint(character varying); Type: FUNCTION; Schema: public; Owner: dbservice
--

CREATE FUNCTION public.hash_to_bigint(hexval character varying) RETURNS bigint
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $$
DECLARE
    result  bigint;
BEGIN
    EXECUTE 'SELECT x''' || hexval || '''::bigint' INTO result;
    RETURN result;
END;
$$;


ALTER FUNCTION public.hash_to_bigint(hexval character varying) OWNER TO dbservice;

--
-- Name: hex_to_int(character varying); Type: FUNCTION; Schema: public; Owner: dbservice
--

CREATE FUNCTION public.hex_to_int(hexval character varying) RETURNS integer
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $$
DECLARE
    result  int;
BEGIN
    EXECUTE 'SELECT x''' || hexval || '''::int' INTO result;
    RETURN result;
END;
$$;


ALTER FUNCTION public.hex_to_int(hexval character varying) OWNER TO dbservice;

--
-- Name: if(boolean, anyelement, anyelement); Type: FUNCTION; Schema: public; Owner: dbservice
--

CREATE FUNCTION public.if(boolean, anyelement, anyelement) RETURNS anyelement
    LANGUAGE sql IMMUTABLE
    AS $_$
  SELECT CASE WHEN ($1) THEN ($2) ELSE ($3) END
$_$;


ALTER FUNCTION public.if(boolean, anyelement, anyelement) OWNER TO dbservice;

--
-- Name: int_hash(text); Type: FUNCTION; Schema: public; Owner: dbservice
--

CREATE FUNCTION public.int_hash(text) RETURNS integer
    LANGUAGE sql IMMUTABLE
    AS $_$
 SELECT abs(('x'||substr(md5($1),1,8))::bit(32)::int);
$_$;


ALTER FUNCTION public.int_hash(text) OWNER TO dbservice;

--
-- Name: interval_hours(interval); Type: FUNCTION; Schema: public; Owner: dbservice
--

CREATE FUNCTION public.interval_hours(interval) RETURNS numeric
    LANGUAGE sql IMMUTABLE
    AS $_$
  SELECT ((extract(hour from (60 * $1))+extract(day from 24 * 60 * $1))/60.0)::numeric(6,2);
$_$;


ALTER FUNCTION public.interval_hours(interval) OWNER TO dbservice;

--
-- Name: is_older_software_version(text, text); Type: FUNCTION; Schema: public; Owner: dbservice
--

CREATE FUNCTION public.is_older_software_version(source_version text, target_version text) RETURNS boolean
    LANGUAGE sql
    AS $$
  select string_to_array(source_version, '.')::int[] < string_to_array(target_version, '.')::int[];
$$;


ALTER FUNCTION public.is_older_software_version(source_version text, target_version text) OWNER TO dbservice;

--
-- Name: make_odd_or_even_sequence(text, text, text); Type: FUNCTION; Schema: public; Owner: dbservice
--

CREATE FUNCTION public.make_odd_or_even_sequence(table_name text, sequence_field_name text, odd_or_even text) RETURNS text
    LANGUAGE plpgsql
    AS $$
declare
  sequence_name text;
  max_id integer;

  -- Modify table sequence to generate only odd or even id
begin
  if odd_or_even not in ('odd', 'even')
  then return 'error: last param has to be either `odd` or `even`';
  end if;

  execute concat('select max(', sequence_field_name, ') from ', table_name) into max_id;
  select pg_get_serial_sequence(table_name, sequence_field_name) into sequence_name;

  execute 'alter sequence ' || sequence_name || ' increment by 2';

  case odd_or_even
    when 'odd' then
      return setval(sequence_name, max_id + mod(max_id + 1, 2));
    when 'even' then
      return setval(sequence_name, max_id + mod(max_id, 2));
    end case;
end;

$$;


ALTER FUNCTION public.make_odd_or_even_sequence(table_name text, sequence_field_name text, odd_or_even text) OWNER TO dbservice;

--
-- Name: monthly_infographic_data(text); Type: FUNCTION; Schema: public; Owner: dbservice
--

CREATE FUNCTION public.monthly_infographic_data(yyyy_mm text) RETURNS TABLE(record_type text, customer_or_kiosk text, kiosks text, transactions bigint, unique_users bigint, vendors_supported bigint, salads_eaten bigint)
    LANGUAGE sql STABLE
    AS $$
SELECT * FROM (
   SELECT 'customer' as record_type,
          client_name AS customer_or_kiosk,
          string_agg(distinct(kiosk_title), '; ') AS kiosks,
          count(distinct(order_id)) AS transactions,
   	  count(distinct(card_hash)) AS unique_users,
	  count(distinct(product_vendor)) AS vendors_supported,
	  sum(if(product_title ilike '%salad%',1,0)) AS salads_eaten
     FROM byte_epcssold
    WHERE ts BETWEEN cast(yyyy_mm AS timestamp) and cast(yyyy_mm AS timestamp) + interval '1' month
 GROUP BY customer_or_kiosk

UNION ALL

   SELECT 'kiosk' as record_type,
          kiosk_title||' (KID '||kiosk_id||')' AS customer_or_kiosk,
          string_agg(distinct(kiosk_title), '; ') AS kiosks,
          count(distinct(order_id)) AS transactions,
   	  count(distinct(card_hash)) AS unique_users,
	  count(distinct(product_vendor)) AS vendors_supported,
	  sum(if(product_title ilike '%salad%',1,0)) AS salads_eaten
     FROM byte_epcssold
    WHERE ts BETWEEN cast(yyyy_mm AS timestamp) and cast(yyyy_mm AS timestamp) + interval '1' month
 GROUP BY customer_or_kiosk
) t ORDER BY record_type, customer_or_kiosk;

$$;


ALTER FUNCTION public.monthly_infographic_data(yyyy_mm text) OWNER TO dbservice;

--
-- Name: path_check(text[]); Type: FUNCTION; Schema: public; Owner: dbservice
--

CREATE FUNCTION public.path_check(VARIADIC kiosk_path text[]) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
	i TEXT;
BEGIN
	FOREACH i IN ARRAY kiosk_path
LOOP 
	RAISE NOTICE '%', i;
END LOOP;
END; $$;


ALTER FUNCTION public.path_check(VARIADIC kiosk_path text[]) OWNER TO dbservice;

--
-- Name: path_check_1_2_3(timestamp without time zone, timestamp without time zone); Type: FUNCTION; Schema: public; Owner: dbservice
--

CREATE FUNCTION public.path_check_1_2_3(receiving_start timestamp without time zone, receiving_stop timestamp without time zone) RETURNS TABLE(epc character varying, stops_count bigint, receiving_date timestamp without time zone)
    LANGUAGE plpgsql
    AS $$
DECLARE
	receiving BIGINT := 522;
	pickpack BIGINT := 523;
	spoilage BIGINT := 524;
BEGIN
	RETURN query
		SELECT *
		FROM 
			(SELECT x.epc, 
    			sum(x.stop_count) AS stops_count, 
    			max(x.time_created) AS time_created
			FROM 
        		(SELECT l.epc,
            		1 AS stop_count,
            		to_timestamp(max(l.time_created)) at TIME zone 'US/Pacific' AS time_created
        		FROM pantry.label l
        		JOIN pantry.product o ON l.product_id = o.id
       			WHERE to_timestamp(l.time_created) at TIME zone 'US/Pacific' between receiving_start AND receiving_stop
           			AND kiosk_id = receiving
       			GROUP BY l.epc
    			UNION
    			SELECT l.epc,
        			1 AS stop_count,
        			to_timestamp(max(l.time_created)) at TIME zone 'US/Pacific' AS time_created
    			FROM pantry.label l
    			JOIN pantry.product o ON l.product_id = o.id
    			WHERE to_timestamp(l.time_created) at TIME zone 'US/Pacific' between receiving_start AND receiving_stop
        			AND kiosk_id = pickpack
    			GROUP BY l.epc
    			UNION
    			SELECT l.epc,
        			1 AS stop_count,
        			to_timestamp(max(l.time_created)) at TIME zone 'US/Pacific' AS time_created
    			FROM pantry.label l
    			JOIN pantry.product o ON l.product_id = o.id
    			WHERE to_timestamp(l.time_created) at TIME zone 'US/Pacific' between receiving_start AND receiving_stop
        			AND kiosk_id != receiving
        			AND kiosk_id != pickpack
					AND kiosk_id != spoilage
    			GROUP BY l.epc) AS x
    		GROUP BY x.epc) as y
		WHERE y.stops_count = 3;
END; $$;


ALTER FUNCTION public.path_check_1_2_3(receiving_start timestamp without time zone, receiving_stop timestamp without time zone) OWNER TO dbservice;

--
-- Name: pct(numeric, numeric); Type: FUNCTION; Schema: public; Owner: dbservice
--

CREATE FUNCTION public.pct(numeric, numeric) RETURNS double precision
    LANGUAGE sql IMMUTABLE
    AS $_$
 SELECT if( $1::float + $2::float > 0.0, 100.0 * $1::float / ($1::float + $2::float), 0.0::float)
$_$;


ALTER FUNCTION public.pct(numeric, numeric) OWNER TO dbservice;

--
-- Name: pick_get_next_delivery(date); Type: FUNCTION; Schema: public; Owner: dbservice
--

CREATE FUNCTION public.pick_get_next_delivery(target_date date) RETURNS TABLE(kiosk_id integer, delivery_ts timestamp with time zone)
    LANGUAGE plpgsql
    AS $$
begin
	return query
		select location_number, schedule_at from
		(select location_number, schedule_at , rank() over (PARTITION BY location_number order by schedule_at) as num
			from mixalot.route_stop where location_number <> -1) ds
		where num = 1;
		-- into kiosk_id, delivery_ts;
end;
$$;


ALTER FUNCTION public.pick_get_next_delivery(target_date date) OWNER TO dbservice;

--
-- Name: pickpack(timestamp without time zone, timestamp without time zone, bigint); Type: FUNCTION; Schema: public; Owner: dbservice
--

CREATE FUNCTION public.pickpack(receiving_start timestamp without time zone, receiving_stop timestamp without time zone, location_id bigint) RETURNS TABLE(product_source character varying, vendor character varying, sku bigint, product_name character varying, item_count bigint, receiving_date timestamp without time zone)
    LANGUAGE plpgsql
    AS $$
BEGIN
	RETURN query 
    	SELECT o.source,
			o.vendor,
			l.product_id,
			o.title,
    		count(l.epc),
    		to_timestamp(max(l.time_created)) at time zone 'US/Pacific'
		FROM pantry.label l
		JOIN pantry.product o on l.product_id = o.id
		WHERE to_timestamp(l.time_created) at time zone 'US/Pacific' between receiving_start and receiving_stop
    		and kiosk_id = location_id
		GROUP BY o.source, o.vendor, l.product_id, o.title;
END; $$;


ALTER FUNCTION public.pickpack(receiving_start timestamp without time zone, receiving_stop timestamp without time zone, location_id bigint) OWNER TO dbservice;

--
-- Name: receiving(timestamp without time zone, timestamp without time zone); Type: FUNCTION; Schema: public; Owner: dbservice
--

CREATE FUNCTION public.receiving(receiving_start timestamp without time zone DEFAULT '2017-11-01 00:00:00'::timestamp without time zone, receiving_stop timestamp without time zone DEFAULT '2017-11-01 23:59:59'::timestamp without time zone) RETURNS TABLE(product_source character varying, vendor character varying, sku bigint, product_name character varying, item_count bigint, receiving_date timestamp without time zone)
    LANGUAGE plpgsql
    AS $$
BEGIN
	RETURN query 
    	SELECT o.source,
			o.vendor,
			l.product_id,
			o.title,
    		count(l.epc),
    		to_timestamp(max(l.time_created)) at time zone 'US/Pacific'
		FROM pantry.label l
		JOIN pantry.product o on l.product_id = o.id
		WHERE to_timestamp(l.time_created) at time zone 'US/Pacific' between receiving_start and receiving_stop
    		and kiosk_id = 790
		GROUP BY o.source, o.vendor, l.product_id, o.title;
END; $$;


ALTER FUNCTION public.receiving(receiving_start timestamp without time zone, receiving_stop timestamp without time zone) OWNER TO dbservice;

--
-- Name: set_sequence_val_max(name, name, boolean); Type: FUNCTION; Schema: public; Owner: dbservice
--

CREATE FUNCTION public.set_sequence_val_max(schema_name name, table_name name DEFAULT NULL::name, raise_notice boolean DEFAULT false) RETURNS void
    LANGUAGE plpgsql
    AS $$

-- Sets all the sequences in the schema "schema_name" to the max(id) of every table (or a specific table, if name is supplied)
-- Examples:
--  SELECT setval_max('public');
--  SELECT setval_max('public','mytable');
--  SELECT setval_max('public',null,true);
--  SELECT setval_max('public','mytable',true);

DECLARE
    row_data RECORD;
    sql_code TEXT;

BEGIN
    IF ((SELECT COUNT(*) FROM pg_namespace WHERE nspname = schema_name) = 0) THEN
        RAISE EXCEPTION 'The schema "%" does not exist', schema_name;
    END IF;

    FOR sql_code IN
        SELECT 'SELECT SETVAL(' ||quote_literal(N.nspname || '.' || S.relname)|| ', MAX(' ||quote_ident(C.attname)|| ') ) FROM ' || quote_ident(N.nspname) || '.' || quote_ident(T.relname)|| ';' AS sql_code
            FROM pg_class AS S
            INNER JOIN pg_depend AS D ON S.oid = D.objid
            INNER JOIN pg_class AS T ON D.refobjid = T.oid
            INNER JOIN pg_attribute AS C ON D.refobjid = C.attrelid AND D.refobjsubid = C.attnum
            INNER JOIN pg_namespace N ON N.oid = S.relnamespace
            WHERE S.relkind = 'S' AND N.nspname = schema_name AND (table_name IS NULL OR T.relname = table_name)
            ORDER BY S.relname
    LOOP
        IF (raise_notice) THEN
            RAISE NOTICE 'sql_code: %', sql_code;
        END IF;
        EXECUTE sql_code;
    END LOOP;
END;
$$;


ALTER FUNCTION public.set_sequence_val_max(schema_name name, table_name name, raise_notice boolean) OWNER TO dbservice;

--
-- Name: shelf_life_bucket(integer); Type: FUNCTION; Schema: public; Owner: dbservice
--

CREATE FUNCTION public.shelf_life_bucket(integer) RETURNS text
    LANGUAGE sql IMMUTABLE
    AS $_$
  SELECT CASE WHEN ($1 <= 10) THEN ($1::text)
              WHEN ($1 <= 14) THEN ('11-14')
              WHEN ($1 <= 21) THEN ('15-21')
              ELSE ('21+') END
$_$;


ALTER FUNCTION public.shelf_life_bucket(integer) OWNER TO dbservice;

--
-- Name: stockout_hours(text, text); Type: FUNCTION; Schema: public; Owner: dbservice
--

CREATE FUNCTION public.stockout_hours(text, text) RETURNS double precision
    LANGUAGE plperl IMMUTABLE
    AS $$
 return 10.5;
$$;


ALTER FUNCTION public.stockout_hours(text, text) OWNER TO dbservice;

--
-- Name: user_retention_by_month(integer); Type: FUNCTION; Schema: public; Owner: dbservice
--

CREATE FUNCTION public.user_retention_by_month(n integer) RETURNS TABLE(month timestamp with time zone, num_consumers bigint, repeat_consumers bigint, num_tickets bigint, sum_amount_list_price numeric, sum_amount_paid numeric, num_repeat_tickets bigint, sum_repeat_amount_list_price numeric, sum_repeat_amount_paid numeric, frac_users_retained numeric, frac_tickets_retained numeric, frac_listprice_retained numeric, frac_amountpaid_retained numeric, old_month timestamp with time zone, old_num_consumers bigint, old_repeat_consumers bigint, old_num_tickets bigint, old_sum_amount_list_price numeric, old_sum_amount_paid numeric)
    LANGUAGE sql STABLE
    AS $$
  -- note: options carefully chosen to support inlining
  -- https://wiki.postgresql.org/wiki/Inlining_of_SQL_functions
  -- (run EXPLAIN on a query and you should see the full expansion, not just
  -- Function Scan .. Function Call:
  WITH consumer_stats AS (
     SELECT consumer_id
           ,month
           ,count(*) AS num_tickets
           ,sum(amount_list_price)::numeric(10,2) AS sum_amount_list_price
           ,sum(amount_paid)::numeric(10,2) AS sum_amount_paid
           ,lag(month, n) OVER (PARTITION BY consumer_id ORDER BY month)
            = month - (n * interval '1 month') OR NULL AS repeat_transaction
     FROM   user_retention_tickets
     GROUP  BY 1, 2
  ), stats AS (
     SELECT month
           ,count(*) AS num_consumers
           ,count(repeat_transaction) AS repeat_consumers
           ,sum(num_tickets)::bigint AS num_tickets
           ,sum(sum_amount_list_price)::numeric(10,2) AS sum_amount_list_price
           ,sum(sum_amount_paid)::numeric(10,2) AS sum_amount_paid
           ,sum(if(repeat_transaction,num_tickets::bigint,0::bigint))::bigint AS num_repeat_tickets
           ,sum(if(repeat_transaction,sum_amount_list_price,0::numeric(10,2)))::numeric(10,2) AS sum_repeat_amount_list_price
           ,sum(if(repeat_transaction,sum_amount_paid,0::numeric(10,2)))::numeric(10,2) AS sum_repeat_amount_paid
     FROM   consumer_stats
     GROUP  BY 1
     ORDER  BY 1
  )
  SELECT t1.*, (t1.repeat_consumers::float / t2.num_consumers)::numeric(10,4) as frac_users_retained,
         (t1.num_repeat_tickets::float / t2.num_tickets)::numeric(10,4) as frac_tickets_retained,
         (t1.sum_repeat_amount_list_price::float / t2.sum_amount_list_price)::numeric(10,4) as frac_listprice_retained,
         (t1.sum_repeat_amount_paid::float / t2.sum_amount_paid)::numeric(10,4) as frac_amountpaid_retained,
         t2.month as old_month, t2.num_consumers as old_num_consumers, t2.repeat_consumers as old_repeat_consumers,
         t2.num_tickets as old_num_tickets, t2.sum_amount_list_price as old_sum_amount_list_price, t2.sum_amount_paid as old_sum_amount_paid
    FROM stats t1 LEFT OUTER JOIN stats t2 ON (t1.month - n * interval '1 month') = t2.month
$$;


ALTER FUNCTION public.user_retention_by_month(n integer) OWNER TO dbservice;

--
-- Name: user_retention_by_week(integer); Type: FUNCTION; Schema: public; Owner: dbservice
--

CREATE FUNCTION public.user_retention_by_week(n integer) RETURNS TABLE(week timestamp with time zone, num_consumers bigint, repeat_consumers bigint, num_tickets bigint, sum_amount_list_price numeric, sum_amount_paid numeric, num_repeat_tickets bigint, sum_repeat_amount_list_price numeric, sum_repeat_amount_paid numeric, frac_users_retained numeric, frac_tickets_retained numeric, frac_listprice_retained numeric, frac_amountpaid_retained numeric, old_week timestamp with time zone, old_num_consumers bigint, old_repeat_consumers bigint, old_num_tickets bigint, old_sum_amount_list_price numeric, old_sum_amount_paid numeric)
    LANGUAGE sql STABLE
    AS $$
  -- note: options carefully chosen to support inlining
  -- https://wiki.postgresql.org/wiki/Inlining_of_SQL_functions
  -- (run EXPLAIN on a query and you should see the full expansion, not just
  -- Function Scan .. Function Call:
  WITH consumer_stats AS (
     SELECT consumer_id
           ,week
           ,count(*) AS num_tickets
           ,sum(amount_list_price)::numeric(10,2) AS sum_amount_list_price
           ,sum(amount_paid)::numeric(10,2) AS sum_amount_paid
           ,lag(week, n) OVER (PARTITION BY consumer_id ORDER BY week)
            = week - (n * 7 * interval '1 day') OR NULL AS repeat_transaction
     FROM   user_retention_tickets
     GROUP  BY 1, 2
  ), stats AS (
     SELECT week
           ,count(*) AS num_consumers
           ,count(repeat_transaction) AS repeat_consumers
           ,sum(num_tickets)::bigint AS num_tickets
           ,sum(sum_amount_list_price)::numeric(10,2) AS sum_amount_list_price
           ,sum(sum_amount_paid)::numeric(10,2) AS sum_amount_paid
           ,sum(if(repeat_transaction,num_tickets::bigint,0::bigint))::bigint AS num_repeat_tickets
           ,sum(if(repeat_transaction,sum_amount_list_price,0::numeric(10,2)))::numeric(10,2) AS sum_repeat_amount_list_price
           ,sum(if(repeat_transaction,sum_amount_paid,0::numeric(10,2)))::numeric(10,2) AS sum_repeat_amount_paid
     FROM   consumer_stats
     GROUP  BY 1
     ORDER  BY 1
  )
  SELECT t1.*, (t1.repeat_consumers::float / t2.num_consumers)::numeric(10,4) as frac_users_retained,
         (t1.num_repeat_tickets::float / t2.num_tickets)::numeric(10,4) as frac_tickets_retained,
         (t1.sum_repeat_amount_list_price::float / t2.sum_amount_list_price)::numeric(10,4) as frac_listprice_retained,
         (t1.sum_repeat_amount_paid::float / t2.sum_amount_paid)::numeric(10,4) as frac_amountpaid_retained,
         t2.week as old_week, t2.num_consumers as old_num_consumers, t2.repeat_consumers as old_repeat_consumers,
         t2.num_tickets as old_num_tickets, t2.sum_amount_list_price as old_sum_amount_list_price, t2.sum_amount_paid as old_sum_amount_paid
    FROM stats t1 LEFT OUTER JOIN stats t2 ON (t1.week - n * 7 * interval '1 day') = t2.week
$$;


ALTER FUNCTION public.user_retention_by_week(n integer) OWNER TO dbservice;

--
-- Name: dependency_tree(oid[]); Type: FUNCTION; Schema: report; Owner: dbservice
--

CREATE FUNCTION report.dependency_tree(object_ids oid[]) RETURNS TABLE(dependency_tree text)
    LANGUAGE sql SECURITY DEFINER
    AS $$
WITH target AS (
  SELECT objid, dependency_chain
  FROM report.dependency
  JOIN unnest(object_ids) AS target(objid) USING (objid)
)
, list AS (
  SELECT DISTINCT
    format('%*s%s %s', -4*level
          , CASE WHEN report.objid = ANY(object_ids) THEN '*' END
          , object_type, object_identity
    ) AS dependency_tree
  , dependency_sort_chain
  FROM target
  JOIN report.dependency report
    ON report.objid = ANY(target.dependency_chain) -- root-bound chain
    OR target.objid = ANY(report.dependency_chain) -- leaf-bound chain
)
SELECT dependency_tree FROM list
ORDER BY dependency_sort_chain;
$$;


ALTER FUNCTION report.dependency_tree(object_ids oid[]) OWNER TO dbservice;

--
-- Name: dependency_tree(text[]); Type: FUNCTION; Schema: report; Owner: dbservice
--

CREATE FUNCTION report.dependency_tree(object_names text[]) RETURNS TABLE(dependency_tree text)
    LANGUAGE sql SECURITY DEFINER
    AS $$
WITH target AS (
  SELECT objid, dependency_chain
  FROM report.dependency
  JOIN unnest(object_names) AS target(objname) ON objid = objname::regclass
)
, list AS (
  SELECT DISTINCT
    format('%*s%s %s', -4*level
          , CASE WHEN object_identity = ANY(object_names) THEN '*' END
          , object_type, object_identity
    ) AS dependency_tree
  , dependency_sort_chain
  FROM target
  JOIN report.dependency report
    ON report.objid = ANY(target.dependency_chain) -- root-bound chain
    OR target.objid = ANY(report.dependency_chain) -- leaf-bound chain
)
SELECT dependency_tree FROM list
ORDER BY dependency_sort_chain;
$$;


ALTER FUNCTION report.dependency_tree(object_names text[]) OWNER TO dbservice;

--
-- Name: dependency_tree(text); Type: FUNCTION; Schema: report; Owner: dbservice
--

CREATE FUNCTION report.dependency_tree(search_pattern text) RETURNS TABLE(dependency_tree text)
    LANGUAGE sql SECURITY DEFINER
    AS $$
WITH target AS (
  SELECT objid, dependency_chain
  FROM report.dependency
  WHERE object_identity ~ search_pattern
)
, list AS (
  SELECT
    format('%*s%s %s', -4*level
          , CASE WHEN object_identity ~ search_pattern THEN '*' END
          , object_type, object_identity
    ) AS dependency_tree
  , dependency_sort_chain
  FROM target
  JOIN report.dependency report
    ON report.objid = ANY(target.dependency_chain) -- root-bound chain
    OR target.objid = ANY(report.dependency_chain) -- leaf-bound chain
  WHERE LENGTH(search_pattern) > 0
  -- Do NOT waste search time on blank/null search_pattern.
  UNION
  -- Query the entire dependencies instead.
  SELECT
    format('%*s%s %s', 4*level, '', object_type, object_identity) AS depedency_tree
  , dependency_sort_chain
  FROM report.dependency
  WHERE LENGTH(COALESCE(search_pattern,'')) = 0
)
SELECT dependency_tree FROM list
ORDER BY dependency_sort_chain;
$$;


ALTER FUNCTION report.dependency_tree(search_pattern text) OWNER TO dbservice;

--
-- Name: byte_losses(date, date); Type: FUNCTION; Schema: rptg; Owner: dbservice
--

CREATE FUNCTION rptg.byte_losses(beginning_date date, ending_date date) RETURNS TABLE(epc character varying, kiosk_id bigint, product_id bigint, time_updated timestamp with time zone, cost numeric, price numeric)
    LANGUAGE plpgsql
    AS $$
    BEGIN
        RETURN QUERY
/*
The following query is used to get non free kiosks and free kiosks lost. SEE
ENG-708. Non free kiosks losses = lost items. Since lost items are always counted as sold for free
free kiosks, Free kiosks losses = 0.
*/
SELECT epc_ as epc,
    kiosk_id_ as kiosk_id,
    product_id_ as product_id,
    time_updated_ as time_updated,
    cost_ as cost,
    price_ as price
    FROM rptg.losses(beginning_date, ending_date) gl
    JOIN pantry.kiosk k
    ON gl.kiosk_id_ = k.id
    WHERE subsidy_info != '100%'
    AND enable_reporting_ = 1
    AND kiosk_campus_id_ = 87
    AND product_campus_id_ = 87;
 END;
$$;


ALTER FUNCTION rptg.byte_losses(beginning_date date, ending_date date) OWNER TO dbservice;

--
-- Name: byte_sales(date, date); Type: FUNCTION; Schema: rptg; Owner: dbservice
--

CREATE FUNCTION rptg.byte_sales(beginning_date date, ending_date date) RETURNS TABLE(epc character varying, order_id character varying, kiosk_id bigint, product_id bigint, time_bought timestamp with time zone, cost numeric, price numeric)
    LANGUAGE plpgsql
    AS $$
    BEGIN
        RETURN QUERY
/*
The following query is used to get all non free kiosks and free kiosks sales. SEE
ENG-708. Byte kiosks sales = non free kiosks sale + free kiosk sales + free kiosk losses.
*/
SELECT epc_ as epc,
    order_id_ as order_id,
    kiosk_id_ as kiosk_id,
    product_id_ as product_id,
    time_bought_ as time_bought,
    cost_ as cost,
    price_ as price
    --- This subquery is used to get the sum price of sold items in free kiosks
    FROM (SELECT epc_,
        order_id_,
        kiosk_id_,
        product_id_,
        time_bought_,
        cost_,
        price_
        FROM rptg.sales(beginning_date, ending_date)  gs
        JOIN pantry.kiosk k
        ON gs.kiosk_id_ = k.id
        WHERE subsidy_info = '100%'
        AND enable_reporting_ = 1
        AND kiosk_campus_id_ = 87
        AND product_campus_id_ = 87
    UNION ALL
    --- This subquery is used to get all lost items in free kiosks
    SELECT epc_,
        NULL as order_id_,
        kiosk_id_,
        product_id_,
        time_updated_ as time_bought_,
        cost_ ,
        price_
        FROM rptg.losses(beginning_date, ending_date)  gl
        JOIN pantry.kiosk k
        ON gl.kiosk_id_ = k.id
        WHERE subsidy_info = '100%'
        AND enable_reporting_ = 1
        AND kiosk_campus_id_ = 87
        AND product_campus_id_ = 87
    UNION ALL
    --- This subquery is used to get all sold items in non-free kiosks
    SELECT epc_,
        order_id_,
        kiosk_id_,
        product_id_,
        time_bought_,
        cost_,
        price_
        FROM rptg.sales(beginning_date, ending_date)  gs
        JOIN pantry.kiosk k
        ON gs.kiosk_id_ = k.id
        WHERE subsidy_info != '100%'
        AND enable_reporting_ = 1
        AND kiosk_campus_id_ = 87
        AND product_campus_id_ = 87
    ) as all_kiosk_sale;
END;
$$;


ALTER FUNCTION rptg.byte_sales(beginning_date date, ending_date date) OWNER TO dbservice;

--
-- Name: losses(date, date); Type: FUNCTION; Schema: rptg; Owner: dbservice
--

CREATE FUNCTION rptg.losses(beginning_date date, ending_date date) RETURNS TABLE(epc_ character varying, kiosk_id_ bigint, product_id_ bigint, time_updated_ timestamp with time zone, cost_ numeric, price_ numeric, kiosk_campus_id_ bigint, product_campus_id_ bigint, enable_reporting_ bigint)
    LANGUAGE plpgsql
    AS $$
    BEGIN
        RETURN QUERY
/*
LOST QUERY From Art's logic: ENG-834
For a given time window W1 (e.g. from beginning_date through ending_date) and an extended time
window W2, with W1 being a subset of W2 (e.g. W1 +1 and -1 month from beginning_date through
ending_date)
Loss: count of unique epcs which have at least one out label record within W1 and have no sale,
spoil, or inventory records within W2.
An out label record has no order id and has a status of out. For a out label record to be within
time window W1, the label update time needs to be within W1.
*/
SELECT epc as epc_,
        kiosk_id as kiosk_id_,
        product_id as product_id_,
        time_updated as time_updated_,
        cost as cost_,
        price as price_,
        kiosk_campus_id as kiosk_campus_id_,
        product_campus_id as product_campus_id_,
        enable_reporting as enable_reporting_
        FROM (SELECT unique_epcs.epc,
        to_timestamp(all_epc_data.time_updated) as time_updated,
        cost,
        price,
        kiosk_id,
        product_id,
        kiosk_campus_id,
        product_campus_id,
        enable_reporting
        --- There are duplicated EPCs. This subquery selects the most recent distinct out EPC
        FROM(SELECT epc,
            max(time_updated) as time_updated
            FROM pantry.label l
            JOIN pantry.kiosk k
            ON k.id = l.kiosk_id
            JOIN pantry.product p
            ON p.id = l.product_id
            WHERE to_timestamp(time_updated)::date >= beginning_date
            AND to_timestamp(time_updated)::date <= ending_date
            AND l.status = 'out'
            AND l.order_id IS NULL
            GROUP BY epc
        ) as unique_epcs
        /*
        This subquery is used to get the price and cost values for the distinct EPCs we selected
        in the subquery above.
        */
        LEFT JOIN (SELECT epc,
            l.product_id,
            l.time_updated as time_updated,
            --- Get the cost from label, if NULL, get cost from product_history, if NULL get cost
            --- from product, if NULL get 0. label has the most accurate cost info for
            --- the specific epc, then product_history, then product.
            COALESCE(l.cost, ph.cost, p.cost,0) as cost,
            --- Get the price from product_history, if NULL, get price from label, if NULL get price
            --- from product, if NULL get 0. product_history has the most accurate price info for
            --- that time, then label, then product.
            COALESCE(ph.price, l.price, p.price,0) as price,
            l.kiosk_id,
            k.campus_id as kiosk_campus_id,
            p.campus_id as product_campus_id,
            k.enable_reporting
            FROM pantry.label l
            JOIN pantry.kiosk k
            ON k.id = l.kiosk_id
            JOIN pantry.product p
            ON p.id = l.product_id
            LEFT JOIN pantry.product_history ph ON ph.product_id = p.id
            AND l.time_updated >= ph.start_time AND (ph.end_time IS NULL OR l.time_updated <
            ph.end_time)
            AND to_timestamp(time_updated)::date >= beginning_date
            AND to_timestamp(time_updated)::date <= ending_date
            AND l.status = 'out'
            AND l.order_id IS NULL
        ) as all_epc_data
        ON unique_epcs.epc = all_epc_data.epc
        AND unique_epcs.time_updated = all_epc_data.time_updated
    ) as lost_data
    /*
    This subquery is used to eliminate any EPCs that were sold in W2
    (View first comment above to get details on W2)
    */
    WHERE EPC NOT IN (SELECT epc
        FROM pantry.label l
        JOIN pantry.kiosk k
        ON k.id = l.kiosk_id
        JOIN pantry.product p
        ON p.id = l.product_id
        JOIN pantry.order o
        ON o.order_id = l.order_id
        WHERE to_timestamp(created)::date >= (SELECT beginning_date::date - INTERVAL '1 month')
        AND to_timestamp(created)::date <= (SELECT ending_date::date + INTERVAL '1 month')
        AND l.status = 'sold'
        AND l.order_id NOT LIKE 'RE%'
        AND l.order_id IS NOT NULL)
    /*
    This subquery is used to eliminate any EPCs that were spoiled in W2
    (View first comment above to get details on W2)
    */
    AND EPC NOT IN (SELECT epc
        FROM pantry.label l
        JOIN pantry.kiosk k
        ON k.id = l.kiosk_id
        JOIN pantry.product p
        ON p.id = l.product_id
        JOIN pantry.order o
        ON o.order_id = l.order_id
        WHERE to_timestamp(created)::date >= (SELECT beginning_date::date - INTERVAL '1 month')
        AND to_timestamp(created)::date <= (SELECT ending_date::date + INTERVAL '1 month')
        AND l.status = 'out'
        AND l.order_id LIKE 'RE%')
    /*
    This subquery is used to eliminate any EPCs that are currently in the kiosk
    */
    AND EPC NOT IN (SELECT epc
        FROM pantry.label l
        JOIN pantry.kiosk k
        ON k.id = l.kiosk_id
        JOIN pantry.product p
        ON p.id = l.product_id
        AND l.status = 'ok'
        AND l.order_id IS NULL);
 END;
$$;


ALTER FUNCTION rptg.losses(beginning_date date, ending_date date) OWNER TO dbservice;

--
-- Name: non_byte_losses(date, date); Type: FUNCTION; Schema: rptg; Owner: dbservice
--

CREATE FUNCTION rptg.non_byte_losses(beginning_date date, ending_date date) RETURNS TABLE(epc character varying, kiosk_id bigint, product_id bigint, time_updated timestamp with time zone, cost numeric, price numeric)
    LANGUAGE plpgsql
    AS $$
    BEGIN
        RETURN QUERY
/*
The following query is used to get non byte kiosks losses.SEE ENG-1272. Unlike byte looses that
is = free kiosk losses, non byte kiosks losses = all non byte kiosks losses.
*/
SELECT epc_ as epc,
    kiosk_id_ as kiosk_id,
    product_id_ as product_id,
    time_updated_ as time_updated,
    cost_ as cost,
    price_ as price
    FROM rptg.losses(beginning_date, ending_date) gl
    WHERE kiosk_campus_id_ != 87
    AND product_campus_id_ != 87;
 END;
$$;


ALTER FUNCTION rptg.non_byte_losses(beginning_date date, ending_date date) OWNER TO dbservice;

--
-- Name: non_byte_sales(date, date); Type: FUNCTION; Schema: rptg; Owner: dbservice
--

CREATE FUNCTION rptg.non_byte_sales(beginning_date date, ending_date date) RETURNS TABLE(epc character varying, order_id character varying, kiosk_id bigint, product_id bigint, time_bought timestamp with time zone, cost numeric, price numeric)
    LANGUAGE plpgsql
    AS $$
    BEGIN
        RETURN QUERY
/*
The following query is used to get all non byte kiosks. Unlike byte sales that is =
non free kiosks sale + free kiosk sales + free kiosk losses, non byte kiosks = all non byte kiosk
sales.
*/
SELECT  epc_ as epc,
    order_id_ as order_id,
    kiosk_id_ as kiosk_id,
    product_id_ as product_id,
    time_bought_ as time_bought,
    cost_ as cost,
    price_ as price
    FROM rptg.sales(beginning_date, ending_date)  gl
    WHERE kiosk_campus_id_ != 87
    AND product_campus_id_ != 87;
END;
$$;


ALTER FUNCTION rptg.non_byte_sales(beginning_date date, ending_date date) OWNER TO dbservice;

--
-- Name: pick_audit(date, date); Type: FUNCTION; Schema: rptg; Owner: dbservice
--

CREATE FUNCTION rptg.pick_audit(start_date date, end_date date DEFAULT NULL::date) RETURNS TABLE(kiosk_id integer, route_date date, restocker text, product_id integer, pick_qty integer, restock_qty integer, discrepancy integer)
    LANGUAGE plpgsql
    AS $$

/*
Purpose - compare pick to restock
Input - 
	start_date: first pick date to consider
	end_date: last pick date to consider. 
	Note: add feature: if end_date not given, compute the result for only start_date
Output - 
	kiosk_id: id for kiosk
	route_date: delivery date
	kiosk_title: kiosk name
	product_id: what picked/allocated
	pick_qty: quantity above product_id picked
	restock_qty: quantity of above product_id for the same route_date
	discrepancy: restock_qty - pick_quantity for target_date  
*/
begin
	if end_date is null
		then end_date = start_date;
	end if;
	
	return query
		select a.kiosk_id, a.route_date, r.restocker, a.sku_id, cast(sum(a.qty) as integer), 
			coalesce(cast(sum(l.total) as integer), 0), cast(coalesce(sum(l.total), 0) - sum(a.qty) as integer)
			from inm.pick_allocation a 
			left join 
				(select to_timestamp(time_created)::date restock_date, pantry.label.kiosk_id, pantry.label.product_id, count(*) total
					from pantry.label group by 1,2,3) l
					on a.route_date = l.restock_date and a.kiosk_id=l.kiosk_id and a.sku_id = l.product_id
			left join 
					-- restocker
					(select distinct to_timestamp(created)::date route_date, o.kiosk_id, first_name || ' ' || last_name restocker from pantry.order o
						where order_id like 'RE%' and to_timestamp(created)::date between start_date and end_date + 1 order by 1,2) r
					on r.route_date = a.route_date and r.kiosk_id = a.kiosk_id
			where a.route_date between start_date and end_date
		group by 1, 2, 3, 4;
end;

$$;


ALTER FUNCTION rptg.pick_audit(start_date date, end_date date) OWNER TO dbservice;

--
-- Name: restocks(date, date); Type: FUNCTION; Schema: rptg; Owner: dbservice
--

CREATE FUNCTION rptg.restocks(beginning_date date, ending_date date) RETURNS TABLE(epc_ character varying, kiosk_id_ bigint, product_id_ bigint, time_added_ timestamp with time zone, cost_ numeric, price_ numeric, kiosk_campus_id_ bigint, product_campus_id_ bigint, enable_reporting_ bigint)
    LANGUAGE plpgsql
    AS $$
    BEGIN
        RETURN QUERY
/* Restock is a count of unique epcs based on time_created*/
SELECT epc as epc_,
    kiosk_id as kiosk_id_,
    product_id as product_id_,
    time_added as time_added_ ,
    cost as cost_,
    price as price_,
    kiosk_campus_id as kiosk_campus_id_,
    product_campus_id as product_campus_id_,
    enable_reporting as enable_reporting_
    FROM (SELECT unique_epcs.epc,
        kiosk_id,
        product_id,
        to_timestamp(all_epc_data.time_created) as time_added,
        cost,
        price,
        kiosk_campus_id,
        product_campus_id,
        enable_reporting
        --- There are duplicated EPCs. This subquery selects the most recent distinct EPC
        FROM(SELECT epc,
            max(time_created) as time_created
            FROM pantry.label l
            JOIN pantry.kiosk k
            ON k.id = l.kiosk_id
            JOIN pantry.product p
            ON p.id = l.product_id
            WHERE to_timestamp(time_created)::date >= beginning_date
            AND to_timestamp(time_created)::date <= ending_date
            GROUP BY epc
        ) as unique_epcs
        /*
        This subquery is used to get the price and cost values for the distinct EPCs we selected
        in the subquery above.
        */
        LEFT JOIN (SELECT epc,
            l.product_id,
            l.time_created as time_created,
            p.cost,
            p.price,
            l.kiosk_id,
            k.campus_id as kiosk_campus_id,
            p.campus_id as product_campus_id,
            k.enable_reporting
            FROM pantry.label l
            JOIN pantry.kiosk k
            ON k.id = l.kiosk_id
            JOIN pantry.product p
            ON p.id = l.product_id
        ) as all_epc_data
        ON unique_epcs.epc = all_epc_data.epc
        AND unique_epcs. time_created = all_epc_data.time_created
    ) as restocks;
 END;
$$;


ALTER FUNCTION rptg.restocks(beginning_date date, ending_date date) OWNER TO dbservice;

--
-- Name: sales(date, date); Type: FUNCTION; Schema: rptg; Owner: dbservice
--

CREATE FUNCTION rptg.sales(beginning_date date, ending_date date) RETURNS TABLE(epc_ character varying, order_id_ character varying, kiosk_id_ bigint, product_id_ bigint, time_bought_ timestamp with time zone, cost_ numeric, price_ numeric, kiosk_campus_id_ bigint, product_campus_id_ bigint, enable_reporting_ bigint)
    LANGUAGE plpgsql
    AS $$
    BEGIN
        RETURN QUERY
/*
SALE QUERY From Art's logic: see ENG-834
For a given time window W1 (e.g. from beginning_date through ending_date) and an extended time
window W2, with W1 being a subset of W2 (e.g. W1 +1 and -1 month from beginning_date through
ending_date)
Sale: count of unique epcs which have at least one sale label record within W1.
A sale label record has an order id which does not start with RE and has a sold status.
For a sale label record to be within time window W1, the order creation time needs to be within W1.
*/
    SELECT unique_epcs.epc as epc_,
        order_id as order_id_,
        kiosk_id as kiosk_id_,
        product_id as product_id_,
        to_timestamp(all_epc_data.time_bought) as time_bought_,
        cost as cost_,
        price as price_,
        kiosk_campus_id as kiosk_campus_id_,
        product_campus_id as product_campus_id_,
        enable_reporting as enable_reporting_
        --- There are duplicated EPCs. This subquery selects the most recent distinct sold EPC
        FROM(SELECT epc,
            max(created) as time_bought
            FROM pantry.label l
            JOIN pantry.kiosk k
            ON k.id = l.kiosk_id
            JOIN pantry.product p
            ON p.id = l.product_id
            JOIN pantry.order o
            ON o.order_id = l.order_id
            AND to_timestamp(created)::date >= beginning_date
            AND to_timestamp(created)::date <= ending_date
            AND l.status = 'sold'
            AND l.order_id NOT LIKE 'RE%'
            AND l.order_id IS NOT NULL
            GROUP BY epc
        ) as unique_epcs
        /*
        This subquery is used to get the order_id, time the order was created, price and cost
        values for the distinct EPCs we selected in the subquery above.
        */
        LEFT JOIN (SELECT epc,
            l.product_id,
            l.order_id,
            o.created as time_bought,
            --- Get the cost from label, if NULL, get cost from product_history, if NULL get cost
            --- from product, if NULL get 0. label has the most accurate cost info for
            --- the specific epc, then product_history, then product.
            COALESCE(l.cost, ph.cost, p.cost,0) as cost,
            --- Get the price from product_history, if NULL, get price from label, if NULL get price
            --- from product, if NULL get 0. product_history has the most accurate price info for
            --- that time, then label, then product.
            COALESCE(ph.price, l.price, p.price,0) as price,
            l.kiosk_id,
            k.campus_id as kiosk_campus_id,
            p.campus_id as product_campus_id,
            k.enable_reporting
            FROM pantry.label l
            JOIN pantry.kiosk k
            ON k.id = l.kiosk_id
            JOIN pantry.product p
            ON p.id = l.product_id
            JOIN pantry.order o
            ON o.order_id = l.order_id
            AND to_timestamp(created)::date >= beginning_date
            AND to_timestamp(created)::date <= ending_date
            LEFT JOIN pantry.product_history ph ON ph.product_id = p.id
            AND o.created >= ph.start_time AND (ph.end_time IS NULL OR o.created <
            ph.end_time)
            AND l.status = 'sold'
            AND l.order_id NOT LIKE 'RE%'
            AND l.order_id IS NOT NULL
        ) as all_epc_data
        ON unique_epcs.epc = all_epc_data.epc
        AND unique_epcs.time_bought = all_epc_data.time_bought;

 END;
$$;


ALTER FUNCTION rptg.sales(beginning_date date, ending_date date) OWNER TO dbservice;

--
-- Name: spoils(date, date); Type: FUNCTION; Schema: rptg; Owner: dbservice
--

CREATE FUNCTION rptg.spoils(beginning_date date, ending_date date) RETURNS TABLE(epc_ character varying, order_id_ character varying, kiosk_id_ bigint, product_id_ bigint, time_updated_ timestamp with time zone, cost_ numeric, price_ numeric, kiosk_campus_id_ bigint, product_campus_id_ bigint, enable_reporting_ bigint)
    LANGUAGE plpgsql
    AS $$
    BEGIN
        RETURN QUERY
/*
SPOIL QUERY From Art's logic: see ENG-834
For a given time window W1 (e.g. from beginning_date through ending_date) and an extended time
window W2, with W1 being a subset of W2 (e.g. W1 +1 and -1 month from beginning_date through
ending_date)
Spoil: count of unique epcs which have at least one spoil label record within W1 and have no
sale record within W2.
A spoil label record has an order id which starts with RE and has an out status.
For a spoil label record to be within time window W1, the order creation time needs to be within W1.
*/

SELECT epc as epc_,
    order_id as order_id_,
    kiosk_id as kiosk_id_,
    product_id as product_id_,
    time_updated as time_updated_,
    cost as cost_,
    price as pice_,
    kiosk_campus_id as kiosk_campus_id_,
    product_campus_id as product_campus_id_,
    enable_reporting as enable_reporting_
    FROM (SELECT unique_epcs.epc as epc,
        order_id,
        kiosk_id,
        product_id,
        to_timestamp(all_epc_data. time_updated) as time_updated,
        cost,
        price,
        kiosk_campus_id,
        product_campus_id,
        enable_reporting
        --- There are duplicated EPCs. This subquery selects the most recent distinct spoiled EPC
        FROM(SELECT epc,
            max(created) as time_updated
            FROM pantry.label l
            JOIN pantry.kiosk k
            ON k.id = l.kiosk_id
            JOIN pantry.product p
            ON p.id = l.product_id
            JOIN pantry.order o
            ON o.order_id = l.order_id
            WHERE to_timestamp(created)::date >= beginning_date
            AND to_timestamp(created)::date <= ending_date
            AND l.status = 'out'
            AND l.order_id LIKE 'RE%'
            GROUP BY epc
        ) as unique_epcs
        /*
        This subquery is used to get the order_id, time the order was created, price and cost
        values for the distinct EPCs we selected in the subquery above.
        */
        LEFT JOIN (SELECT epc,
            l.product_id,
            l.order_id,
            o.created as time_updated,
            --- Get the cost from label, if NULL, get cost from product_history, if NULL get cost
            --- from product, if NULL get 0. label has the most accurate cost info for
            --- the specific epc, then product_history, then product.
            COALESCE(l.cost, ph.cost, p.cost,0) as cost,
            --- Get the price from product_history, if NULL, get price from label, if NULL get price
            --- from product, if NULL get 0. product_history has the most accurate price info for
            --- that time, then label, then product.
            COALESCE(ph.price, l.price, p.price,0) as price,
            l.kiosk_id,
            k.campus_id as kiosk_campus_id,
            p.campus_id as product_campus_id,
            k.enable_reporting
            FROM pantry.label l
            JOIN pantry.kiosk k
            ON k.id = l.kiosk_id
            JOIN pantry.product p
            ON p.id = l.product_id
            JOIN pantry.order o
            ON o.order_id = l.order_id
            AND to_timestamp(created)::date >= beginning_date
            AND to_timestamp(created)::date <= ending_date
            LEFT JOIN pantry.product_history ph ON ph.product_id = p.id
            AND o.created >= ph.start_time AND (ph.end_time IS NULL OR o.created <
            ph.end_time)
            AND l.status = 'out'
            AND l.order_id LIKE 'RE%'
        ) as all_epc_data
        ON unique_epcs.epc = all_epc_data.epc
        AND unique_epcs. time_updated = all_epc_data. time_updated
    ) as spoiled_data
    /*
    This subquery is used to eliminate any EPCs that were sold in W2
    (View first comment above to get details on W2)
    */
    WHERE epc NOT IN (SELECT epc
        FROM pantry.label l
        JOIN pantry.kiosk k
        ON k.id = l.kiosk_id
        JOIN pantry.product p
        ON p.id = l.product_id
        JOIN pantry.order o
        ON o.order_id = l.order_id
        WHERE to_timestamp(created)::date >= (SELECT beginning_date::date - INTERVAL '1 month')
        AND to_timestamp(created)::date <= (SELECT ending_date::date + INTERVAL '1 month')
        AND l.status = 'sold'
        AND l.order_id NOT LIKE 'RE%'
        AND l.order_id IS NOT NULL);
 END;
$$;


ALTER FUNCTION rptg.spoils(beginning_date date, ending_date date) OWNER TO dbservice;

--
-- Name: deps_restore_dependencies(character varying, character varying); Type: FUNCTION; Schema: util; Owner: dbservice
--

CREATE FUNCTION util.deps_restore_dependencies(p_view_schema character varying, p_view_name character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
declare
  v_curr record;
begin
  for v_curr in
    (
      select deps_ddl_to_run
      from util.deps_saved_ddl
      where deps_view_schema = p_view_schema and deps_view_name = p_view_name
      order by deps_id desc
    ) loop
    execute v_curr.deps_ddl_to_run;
  end loop;
  delete from util.deps_saved_ddl
  where deps_view_schema = p_view_schema and deps_view_name = p_view_name;
end;
$$;


ALTER FUNCTION util.deps_restore_dependencies(p_view_schema character varying, p_view_name character varying) OWNER TO dbservice;

--
-- Name: FUNCTION deps_restore_dependencies(p_view_schema character varying, p_view_name character varying); Type: COMMENT; Schema: util; Owner: dbservice
--

COMMENT ON FUNCTION util.deps_restore_dependencies(p_view_schema character varying, p_view_name character varying) IS 'part of save/drop/restore dependent views suite: restore previously saved dependent views';


--
-- Name: deps_save_and_drop_dependencies(character varying, character varying); Type: FUNCTION; Schema: util; Owner: dbservice
--

CREATE FUNCTION util.deps_save_and_drop_dependencies(p_view_schema character varying, p_view_name character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
declare
  v_curr record;
begin
  for v_curr in
    -- return a set of records of schema name, view name, view type (normal or materialized view)
    (
      select obj_schema, obj_name, obj_type from
        (
          with recursive recursive_deps(obj_schema, obj_name, obj_type, depth) as
            (
              select p_view_schema, p_view_name, null::varchar, 0
              union
              select dep_schema::varchar, dep_name::varchar, dep_type::varchar,
                     recursive_deps.depth + 1 from
                (
                  select ref_nsp.nspname ref_schema, ref_cl.relname ref_name,
                    rwr_cl.relkind dep_type,
                    rwr_nsp.nspname dep_schema,
                    rwr_cl.relname dep_name
                  from pg_depend dep
                         join pg_class ref_cl on dep.refobjid = ref_cl.oid
                         join pg_namespace ref_nsp on ref_cl.relnamespace = ref_nsp.oid
                         join pg_rewrite rwr on dep.objid = rwr.oid
                         join pg_class rwr_cl on rwr.ev_class = rwr_cl.oid
                         join pg_namespace rwr_nsp on rwr_cl.relnamespace = rwr_nsp.oid
                  where dep.deptype = 'n'
                  and dep.classid = 'pg_rewrite'::regclass
                ) deps
                  join recursive_deps on deps.ref_schema = recursive_deps.obj_schema
                                           and deps.ref_name = recursive_deps.obj_name
              where (deps.ref_schema != deps.dep_schema or deps.ref_name != deps.dep_name)
            )
          select obj_schema, obj_name, obj_type, depth
          from recursive_deps
          where depth > 0
        ) t
      group by obj_schema, obj_name, obj_type
      order by max(depth) desc
    ) loop

    insert into util.deps_saved_ddl(deps_view_schema, deps_view_name, deps_ddl_to_run)
      select p_view_schema, p_view_name, 'COMMENT ON '
        ||  case
             when c.relkind = 'v' then 'VIEW'
             when c.relkind = 'm' then 'MATERIALIZED VIEW'
             else ''
             end
        || ' ' || n.nspname || '.' || c.relname || ' IS '''
        || replace(d.description, '''', '''''') || ''';'
      from pg_class c
             join pg_namespace n on n.oid = c.relnamespace
             join pg_description d on d.objoid = c.oid and d.objsubid = 0
      where n.nspname = v_curr.obj_schema
        and c.relname = v_curr.obj_name and d.description is not null;

    insert into util.deps_saved_ddl(deps_view_schema, deps_view_name, deps_ddl_to_run)
      select p_view_schema, p_view_name, 'COMMENT ON COLUMN ' || n.nspname || '.' || c.relname
         || '.' || a.attname || ' IS ''' || replace(d.description, '''', '''''') || ''';'
      from pg_class c
             join pg_attribute a on c.oid = a.attrelid
             join pg_namespace n on n.oid = c.relnamespace
             join pg_description d on d.objoid = c.oid and d.objsubid = a.attnum
      where n.nspname = v_curr.obj_schema
        and c.relname = v_curr.obj_name and d.description is not null;

    insert into util.deps_saved_ddl(deps_view_schema, deps_view_name, deps_ddl_to_run)
      select p_view_schema, p_view_name, 'GRANT ' || privilege_type || ' ON ' || table_schema || '.'
         || table_name || ' TO ' || grantee
      from information_schema.role_table_grants
      where table_schema = v_curr.obj_schema and table_name = v_curr.obj_name;

    -- generate statement to create normal view
    if v_curr.obj_type = 'v' then
      insert into util.deps_saved_ddl(deps_view_schema, deps_view_name, deps_ddl_to_run)
        select p_view_schema, p_view_name, 'CREATE VIEW ' || v_curr.obj_schema || '.'
           || v_curr.obj_name || ' AS ' || view_definition
        from information_schema.views
        where table_schema = v_curr.obj_schema and table_name = v_curr.obj_name;

    -- generate statement to create materialized view
    elsif v_curr.obj_type = 'm' then
      insert into util.deps_saved_ddl(deps_view_schema, deps_view_name, deps_ddl_to_run)
        select p_view_schema, p_view_name, 'CREATE MATERIALIZED VIEW ' || v_curr.obj_schema
           || '.' || v_curr.obj_name || ' AS ' || definition
        from pg_matviews
        where schemaname = v_curr.obj_schema and matviewname = v_curr.obj_name;
    end if;

    execute 'DROP ' ||
            case
              when v_curr.obj_type = 'v' then 'VIEW'
              when v_curr.obj_type = 'm' then 'MATERIALIZED VIEW'
              end
      || ' ' || v_curr.obj_schema || '.' || v_curr.obj_name;

  end loop;
end;
$$;


ALTER FUNCTION util.deps_save_and_drop_dependencies(p_view_schema character varying, p_view_name character varying) OWNER TO dbservice;

--
-- Name: FUNCTION deps_save_and_drop_dependencies(p_view_schema character varying, p_view_name character varying); Type: COMMENT; Schema: util; Owner: dbservice
--

COMMENT ON FUNCTION util.deps_save_and_drop_dependencies(p_view_schema character varying, p_view_name character varying) IS 'part of save/drop/restore dependent views suite: store DDL of dependent views then drop the views';


--
-- Name: extract_request_log_epc_order(integer, timestamp without time zone, timestamp without time zone); Type: FUNCTION; Schema: util; Owner: dbservice
--

CREATE FUNCTION util.extract_request_log_epc_order(target_kiosk_id integer, report_start timestamp without time zone, report_end timestamp without time zone) RETURNS TABLE(epc character varying, order_id text, ts timestamp without time zone)
    LANGUAGE plpgsql
    AS $$

/*
Extract epc, order_id from mixalot.request_log for a kiosk for a period and store the result in
table request_log_sold_epc to be used by function fix_orders_using_request_log
to fix incorrectly voided orders due to kiosk sync issue.
*/

begin
  -- create table to hold sold epc's
  create table if not exists test.request_log_sold_epc(
    id serial,
    epc varchar(24) not null,
    order_id text,
    kiosk_id bigint,
    direction varchar(16) not null,
    reason text,
    ts timestamp not null
  );

  -- create table to store final result
  create table if not exists test.request_log_epc_order(
    epc varchar(24) not null,
    order_id text,
    ts timestamp not null
  );

  truncate test.request_log_sold_epc;

  -- Parse mixalot.request_log for sold epc and store them in request_log_sold_epc for target kiosk and date range
  -- When there are duplicate order_id, epc, pick the latest.
  insert into test.request_log_sold_epc(epc, order_id, kiosk_id, direction, reason, ts)
    select out_epc.epc, out_epc.order_id, out_epc.kiosk_id, out_epc.direction, out_epc.reason, out_epc.ts
    from (
           select request_body_json::json ->> 'epc' as epc,
                  request_body_json::json ->> 'order_id' as order_id,
                  nullif(regexp_replace(request_body_json::json ->> 'order_id', '[A-Za-z]+[0-9]*', '', 'g'),
                         '')::int kiosk_id,
                  request_body_json::json ->> 'direction' as direction,
                  request_body_json::json ->> 'reason' as reason,
                  start_ts ts,
                  rank() over (partition by request_body_json::json ->> 'order_id',
                        request_body_json::json ->> 'epc' order by start_ts desc) as r
           from mixalot.request_log
           where start_ts between report_start and report_end
             and endpoint in ('/item')
             and request_body_json::json ->> 'direction' = 'out'
             and request_body_json::json ->> 'order_id' is not null
             and request_body_json::json ->> 'order_id' like target_kiosk_id || '%'
         ) out_epc
    where out_epc.r = 1;

  truncate test.request_log_epc_order;

  -- insert correcting data for labels and orders
  insert into test.request_log_epc_order
    select tsp.epc, tsp.order_id, tsp.ts
      from (
             select distinct on(epc) test.request_log_sold_epc.*
             from test.request_log_sold_epc
             order by epc, ts desc
           ) tsp
      where reason = 'add_to_order';

  -- parsed epc orders from mixalot.request_log
  return query
    select * from test.request_log_epc_order;

end;

$$;


ALTER FUNCTION util.extract_request_log_epc_order(target_kiosk_id integer, report_start timestamp without time zone, report_end timestamp without time zone) OWNER TO dbservice;

--
-- Name: fix_orders_using_request_log(); Type: FUNCTION; Schema: util; Owner: dbservice
--

CREATE FUNCTION util.fix_orders_using_request_log() RETURNS TABLE(count_orders_affected integer)
    LANGUAGE plpgsql
    AS $$

/*
Address issues of specific kiosk not sending /item requests to our backend, thus voiding orders.

To fix these orders, first use function extract_request_log_epc_order to extract epc orders and save
them to request_log_epc_order.

Then run this function to fix those orders.
*/

declare count_orders_affected integer;

begin
  -- update label with curated data from mixalot.request_log
  update pantry.label l
     set order_id = p.order_id
     from test.request_log_epc_order p
     where p.epc = l.epc;

  -- count affected orders
  select count(*)
    from pantry.order o
      join test.request_log_epc_order rleo on o.order_id = rleo.order_id
      where o.state = 'Voided'
      into count_orders_affected;

  -- updated potentially affected orders
  update pantry.order o
    set state = 'PriceFinalized'
    from test.request_log_epc_order rleo
    where o.order_id = rleo.order_id and o.state = 'Voided';

  -- return number of orders affected
  return query
    select count_orders_affected;

end;

$$;


ALTER FUNCTION util.fix_orders_using_request_log() OWNER TO dbservice;

SET default_tablespace = '';

SET default_with_oids = false;

--
-- Name: awsdms_apply_exceptions; Type: TABLE; Schema: aws_dms; Owner: dbservice
--

CREATE TABLE aws_dms.awsdms_apply_exceptions (
    "TASK_NAME" character varying(384) NOT NULL,
    "TABLE_OWNER" character varying(384) NOT NULL,
    "TABLE_NAME" character varying(384) NOT NULL,
    "ERROR_TIME" timestamp without time zone NOT NULL,
    "STATEMENT" text NOT NULL,
    "ERROR" text NOT NULL
);


ALTER TABLE aws_dms.awsdms_apply_exceptions OWNER TO dbservice;

--
-- Name: awsdms_history; Type: TABLE; Schema: aws_dms; Owner: dbservice
--

CREATE TABLE aws_dms.awsdms_history (
    server_name character varying(384) NOT NULL,
    task_name character varying(384) NOT NULL,
    timeslot_type character varying(96) NOT NULL,
    timeslot timestamp without time zone NOT NULL,
    timeslot_duration bigint,
    timeslot_latency bigint,
    timeslot_records bigint,
    timeslot_volume bigint
);


ALTER TABLE aws_dms.awsdms_history OWNER TO dbservice;

--
-- Name: awsdms_status; Type: TABLE; Schema: aws_dms; Owner: dbservice
--

CREATE TABLE aws_dms.awsdms_status (
    server_name character varying(384) NOT NULL,
    task_name character varying(384) NOT NULL,
    task_status character varying(96),
    status_time timestamp without time zone,
    pending_changes bigint,
    disk_swap_size bigint,
    task_memory bigint,
    source_current_position character varying(384),
    source_current_timestamp timestamp without time zone,
    source_tail_position character varying(384),
    source_tail_timestamp timestamp without time zone,
    source_timestamp_applied timestamp without time zone
);


ALTER TABLE aws_dms.awsdms_status OWNER TO dbservice;

--
-- Name: awsdms_suspended_tables; Type: TABLE; Schema: aws_dms; Owner: dbservice
--

CREATE TABLE aws_dms.awsdms_suspended_tables (
    server_name character varying(384) NOT NULL,
    task_name character varying(384) NOT NULL,
    table_owner character varying(384) NOT NULL,
    table_name character varying(384) NOT NULL,
    suspend_reason character varying(96),
    suspend_timestamp timestamp without time zone
);


ALTER TABLE aws_dms.awsdms_suspended_tables OWNER TO dbservice;

--
-- Name: card; Type: TABLE; Schema: beta; Owner: dbservice
--

CREATE TABLE beta.card (
    id bigint,
    hash character varying(264),
    first_name character varying(135),
    last_name character varying(135),
    type character varying(45),
    number character varying(93),
    email character varying(381),
    notes text,
    created bigint,
    last_update bigint
);


ALTER TABLE beta.card OWNER TO dbservice;

--
-- Name: kiosk_projected_stock; Type: TABLE; Schema: beta; Owner: dbservice
--

CREATE TABLE beta.kiosk_projected_stock (
    kiosk_id bigint,
    kiosk_title character varying,
    fc_title character varying(765),
    count numeric
);


ALTER TABLE beta.kiosk_projected_stock OWNER TO dbservice;

--
-- Name: kiosk_sku_group_manual_scale; Type: TABLE; Schema: beta; Owner: dbservice
--

CREATE TABLE beta.kiosk_sku_group_manual_scale (
    kiosk_id integer NOT NULL,
    fc_title character varying(70) NOT NULL,
    scale numeric(4,2) NOT NULL
);


ALTER TABLE beta.kiosk_sku_group_manual_scale OWNER TO dbservice;

--
-- Name: kiosks; Type: TABLE; Schema: beta; Owner: dbservice
--

CREATE TABLE beta.kiosks (
    id integer NOT NULL
);


ALTER TABLE beta.kiosks OWNER TO dbservice;

--
-- Name: missing_hash; Type: TABLE; Schema: beta; Owner: dbservice
--

CREATE TABLE beta.missing_hash (
    order_id character varying(16) NOT NULL,
    transaction_id character varying(10),
    approval_code character varying(6),
    card_hash character varying(264),
    first_name character varying(135),
    last_name character varying(135),
    card_type character varying(45),
    card_number character varying(93),
    email character varying(381),
    created bigint,
    status_message character varying(25)
);


ALTER TABLE beta.missing_hash OWNER TO dbservice;

--
-- Name: pick_demand; Type: TABLE; Schema: beta; Owner: dbservice
--

CREATE TABLE beta.pick_demand (
    id integer NOT NULL,
    pick_date date NOT NULL,
    route_date date NOT NULL,
    kiosk_id integer NOT NULL,
    sku_group_id integer NOT NULL,
    qty integer NOT NULL
);


ALTER TABLE beta.pick_demand OWNER TO dbservice;

--
-- Name: pick_demand_id_seq; Type: SEQUENCE; Schema: beta; Owner: dbservice
--

CREATE SEQUENCE beta.pick_demand_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE beta.pick_demand_id_seq OWNER TO dbservice;

--
-- Name: pick_demand_id_seq; Type: SEQUENCE OWNED BY; Schema: beta; Owner: dbservice
--

ALTER SEQUENCE beta.pick_demand_id_seq OWNED BY beta.pick_demand.id;


--
-- Name: route; Type: TABLE; Schema: beta; Owner: dbservice
--

CREATE TABLE beta.route (
    route_date_time timestamp(6) with time zone,
    duration integer,
    vehicle_label character varying(200),
    vehicle_registration character varying(200),
    driver_serial character varying(200),
    distance numeric(28,6),
    driver_name character varying(200)
);


ALTER TABLE beta.route OWNER TO dbservice;

--
-- Name: route_stop; Type: TABLE; Schema: beta; Owner: dbservice
--

CREATE TABLE beta.route_stop (
    route_date_time timestamp(6) with time zone,
    driver_name character varying(200),
    location_name character varying(200),
    schedule_at timestamp(6) with time zone,
    longitude numeric(28,6),
    address character varying(200),
    latitude numeric(28,6),
    stop_number integer,
    order_number character varying(200),
    location_number integer
);


ALTER TABLE beta.route_stop OWNER TO dbservice;

--
-- Name: sku_group_attribute; Type: TABLE; Schema: beta; Owner: dbservice
--

CREATE TABLE beta.sku_group_attribute (
    id integer,
    title character varying(512),
    relative_size numeric(4,2),
    minimum_kiosk_qty smallint
);


ALTER TABLE beta.sku_group_attribute OWNER TO dbservice;

--
-- Name: sku_group_control; Type: TABLE; Schema: beta; Owner: dbservice
--

CREATE TABLE beta.sku_group_control (
    fc_title character varying(64) NOT NULL,
    start_level numeric(4,2) DEFAULT '-1'::integer NOT NULL,
    scale numeric(4,2) DEFAULT 1.0 NOT NULL,
    min_qty smallint DEFAULT 0 NOT NULL,
    max_qty smallint DEFAULT 0 NOT NULL
);


ALTER TABLE beta.sku_group_control OWNER TO dbservice;

--
-- Name: temp_fc_default_level; Type: TABLE; Schema: beta; Owner: dbservice
--

CREATE TABLE beta.temp_fc_default_level (
    fc_title character varying(60),
    default_level smallint
);


ALTER TABLE beta.temp_fc_default_level OWNER TO dbservice;

--
-- Name: temp_inv; Type: TABLE; Schema: beta; Owner: dbservice
--

CREATE TABLE beta.temp_inv (
    kiosk_id integer,
    fc_title character varying(100),
    qty integer,
    kiosk_title character varying(60)
);


ALTER TABLE beta.temp_inv OWNER TO dbservice;

--
-- Name: temp_nutrition_filter; Type: TABLE; Schema: beta; Owner: dbservice
--

CREATE TABLE beta.temp_nutrition_filter (
    id bigint NOT NULL,
    tag_id bigint,
    label character varying(150),
    icon character varying(381)
);


ALTER TABLE beta.temp_nutrition_filter OWNER TO dbservice;

--
-- Name: temp_pick_preference_kiosk_sku; Type: TABLE; Schema: beta; Owner: dbservice
--

CREATE TABLE beta.temp_pick_preference_kiosk_sku (
    kiosk_id integer,
    sku_id integer,
    preference smallint
);


ALTER TABLE beta.temp_pick_preference_kiosk_sku OWNER TO dbservice;

--
-- Name: temp_product; Type: TABLE; Schema: beta; Owner: dbservice
--

CREATE TABLE beta.temp_product (
    id bigint NOT NULL,
    title character varying(381) NOT NULL,
    description character varying(12285),
    tiny_description character varying(120),
    short_description character varying(300),
    medium_description character varying(1200),
    long_description character varying(3600),
    price numeric(5,2) NOT NULL,
    cost numeric(5,2) NOT NULL,
    shelf_time integer NOT NULL,
    campus_id bigint NOT NULL,
    image smallint NOT NULL,
    image_time bigint,
    last_update bigint NOT NULL,
    archived bigint,
    taxable smallint,
    allergens character varying(765),
    attribute_names character varying(1533),
    categories character varying(765),
    category_names character varying(1533),
    vendor character varying(405),
    source character varying(405),
    notes character varying(6000),
    total_cal bigint,
    num_servings real,
    ingredients character varying(6000),
    calories real,
    proteins real,
    sugar real,
    carbohydrates real,
    fat real,
    consumer_category character varying(6000),
    ws_case_size bigint,
    kiosk_ship_qty bigint,
    ws_case_cost numeric(5,2),
    pick_station bigint,
    fc_title character varying(765),
    pricing_tier character varying(765),
    width_space real,
    height_space real,
    depth_space real,
    slotted_width real,
    tag_volume bigint,
    delivery_option character varying(765),
    tag_applied_by character varying(765)
);


ALTER TABLE beta.temp_product OWNER TO dbservice;

--
-- Name: temp_sku_group_attribute; Type: TABLE; Schema: beta; Owner: dbservice
--

CREATE TABLE beta.temp_sku_group_attribute (
    title character varying(512) NOT NULL,
    relative_size numeric(4,2) NOT NULL,
    minimum_kiosk_qty smallint NOT NULL,
    maximum_kiosk_qty smallint NOT NULL
);


ALTER TABLE beta.temp_sku_group_attribute OWNER TO dbservice;

--
-- Name: temp_sync_label_2018_12_13; Type: TABLE; Schema: beta; Owner: dbservice
--

CREATE TABLE beta.temp_sync_label_2018_12_13 (
    id bigint,
    product_id bigint,
    epc character varying(72),
    is_generic_sku smallint,
    kiosk_id bigint,
    order_id character varying(135),
    status character varying(12),
    price numeric(6,2),
    cost numeric(6,2),
    time_created bigint,
    time_added bigint,
    time_updated bigint,
    notes text
);


ALTER TABLE beta.temp_sync_label_2018_12_13 OWNER TO dbservice;

--
-- Name: temp_sync_order_2018_12_13; Type: TABLE; Schema: beta; Owner: dbservice
--

CREATE TABLE beta.temp_sync_order_2018_12_13 (
    order_id character varying(135),
    first_name character varying(135),
    last_name character varying(135),
    kiosk_id bigint,
    kiosk_title character varying(138),
    email character varying(381),
    amount_paid numeric(6,2),
    payment_system character varying(135),
    transaction_id character varying(135),
    approval_code character varying(135),
    status_code character varying(135),
    status_message character varying(135),
    status character varying(135),
    batch_id character varying(45),
    created bigint,
    auth_amount character varying(21),
    data_token character varying(6141),
    time_opened bigint,
    time_closed bigint,
    card_hash character varying(264),
    state character varying(45),
    archived bigint,
    stamp bigint,
    last_update bigint,
    balance numeric(7,2),
    delta character varying(12),
    coupon_id bigint,
    coupon character varying(135),
    refund numeric(6,2),
    receipt bigint,
    campus_id bigint,
    amount_list_price numeric(6,2),
    notes text,
    time_door_opened bigint,
    time_door_closed bigint
);


ALTER TABLE beta.temp_sync_order_2018_12_13 OWNER TO dbservice;

--
-- Name: temp_test; Type: TABLE; Schema: beta; Owner: dbservice
--

CREATE TABLE beta.temp_test (
    id integer NOT NULL,
    name text
);


ALTER TABLE beta.temp_test OWNER TO dbservice;

--
-- Name: temp_test2; Type: TABLE; Schema: beta; Owner: dbservice
--

CREATE TABLE beta.temp_test2 (
    id integer NOT NULL,
    value integer
);


ALTER TABLE beta.temp_test2 OWNER TO dbservice;

--
-- Name: temp_test2_id_seq; Type: SEQUENCE; Schema: beta; Owner: dbservice
--

CREATE SEQUENCE beta.temp_test2_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE beta.temp_test2_id_seq OWNER TO dbservice;

--
-- Name: temp_test2_id_seq; Type: SEQUENCE OWNED BY; Schema: beta; Owner: dbservice
--

ALTER SEQUENCE beta.temp_test2_id_seq OWNED BY beta.temp_test2.id;


--
-- Name: temp_test3; Type: VIEW; Schema: beta; Owner: dbservice
--

CREATE VIEW beta.temp_test3 AS
 SELECT t1.id,
    t1.name,
    t2.value
   FROM (beta.temp_test t1
     JOIN beta.temp_test2 t2 ON ((t1.id = t2.id)));


ALTER TABLE beta.temp_test3 OWNER TO dbservice;

--
-- Name: temp_test_id_seq; Type: SEQUENCE; Schema: beta; Owner: dbservice
--

CREATE SEQUENCE beta.temp_test_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE beta.temp_test_id_seq OWNER TO dbservice;

--
-- Name: temp_test_id_seq; Type: SEQUENCE OWNED BY; Schema: beta; Owner: dbservice
--

ALTER SEQUENCE beta.temp_test_id_seq OWNED BY beta.temp_test.id;


--
-- Name: test; Type: TABLE; Schema: beta; Owner: dbservice
--

CREATE TABLE beta.test (
    n integer
);


ALTER TABLE beta.test OWNER TO dbservice;

--
-- Name: warehouse_inventory_history; Type: TABLE; Schema: beta; Owner: dbservice
--

CREATE TABLE beta.warehouse_inventory_history (
    date_time timestamp(6) with time zone DEFAULT now(),
    sku integer NOT NULL,
    stickered_cases integer,
    stickered_units integer,
    unstickered_cases integer,
    unstickered_units integer,
    spoils integer,
    date_ date NOT NULL
);


ALTER TABLE beta.warehouse_inventory_history OWNER TO dbservice;

--
-- Name: pgdudetail; Type: VIEW; Schema: byt_devops; Owner: dbservice
--

CREATE VIEW byt_devops.pgdudetail AS
 SELECT 0 AS union_sort_order,
    all_tables.table_name,
    pg_table_size((all_tables.table_name)::regclass) AS table_size,
    to_char((((pg_table_size((all_tables.table_name)::regclass))::double precision / (pg_total_relation_size((all_tables.table_name)::regclass))::double precision) * (100)::double precision), '999D9%'::text) AS percent_table,
    pg_indexes_size((all_tables.table_name)::regclass) AS indexes_size,
    to_char((((pg_indexes_size((all_tables.table_name)::regclass))::double precision / (pg_total_relation_size((all_tables.table_name)::regclass))::double precision) * (100)::double precision), '999D9%'::text) AS percent_index,
    pg_total_relation_size((all_tables.table_name)::regclass) AS total_size
   FROM ( SELECT (((('"'::text || (tables.table_schema)::text) || '"."'::text) || (tables.table_name)::text) || '"'::text) AS table_name
           FROM information_schema.tables) all_tables
  WHERE (pg_total_relation_size((all_tables.table_name)::regclass) > 0)
  ORDER BY (pg_total_relation_size((all_tables.table_name)::regclass)) DESC;


ALTER TABLE byt_devops.pgdudetail OWNER TO dbservice;

--
-- Name: pgdutotal; Type: VIEW; Schema: byt_devops; Owner: dbservice
--

CREATE VIEW byt_devops.pgdutotal AS
 SELECT 1 AS union_sort_order,
    'All db objects'::text AS table_name,
    sum(pgdudetail.table_size) AS table_size,
    to_char(((sum(pgdudetail.table_size) / sum(pgdudetail.total_size)) * (100)::numeric), '999D9%'::text) AS percent_table,
    sum(pgdudetail.indexes_size) AS indexes_size,
    to_char(((sum(pgdudetail.indexes_size) / sum(pgdudetail.total_size)) * (100)::numeric), '999D9%'::text) AS percent_index,
    sum(pgdudetail.total_size) AS total_size
   FROM byt_devops.pgdudetail;


ALTER TABLE byt_devops.pgdutotal OWNER TO dbservice;

--
-- Name: pgdu_union; Type: VIEW; Schema: byt_devops; Owner: dbservice
--

CREATE VIEW byt_devops.pgdu_union AS
 SELECT pgdudetail.union_sort_order,
    pgdudetail.table_name,
    pgdudetail.table_size,
    pgdudetail.percent_table,
    pgdudetail.indexes_size,
    pgdudetail.percent_index,
    pgdudetail.total_size
   FROM byt_devops.pgdudetail
UNION
 SELECT pgdutotal.union_sort_order,
    pgdutotal.table_name,
    pgdutotal.table_size,
    pgdutotal.percent_table,
    pgdutotal.indexes_size,
    pgdutotal.percent_index,
    pgdutotal.total_size
   FROM byt_devops.pgdutotal
  ORDER BY 1, 7 DESC;


ALTER TABLE byt_devops.pgdu_union OWNER TO dbservice;

--
-- Name: pgdu; Type: VIEW; Schema: byt_devops; Owner: dbservice
--

CREATE VIEW byt_devops.pgdu AS
 SELECT pgdu_union.table_name,
    pgdu_union.table_size,
    pgdu_union.percent_table,
    pgdu_union.indexes_size,
    pgdu_union.percent_index,
    pgdu_union.total_size
   FROM byt_devops.pgdu_union;


ALTER TABLE byt_devops.pgdu OWNER TO dbservice;

--
-- Name: pgdudetail_pretty; Type: VIEW; Schema: byt_devops; Owner: dbservice
--

CREATE VIEW byt_devops.pgdudetail_pretty AS
 SELECT 0 AS union_sort_order,
    pgdudetail.total_size AS total_size_sort_order,
    pgdudetail.table_name,
    pg_size_pretty(pgdudetail.table_size) AS table_size,
    pgdudetail.percent_table,
    pg_size_pretty(pgdudetail.indexes_size) AS indexes_size,
    pgdudetail.percent_index,
    pg_size_pretty(pgdudetail.total_size) AS total_size
   FROM byt_devops.pgdudetail
  ORDER BY pgdudetail.total_size DESC
 LIMIT 15;


ALTER TABLE byt_devops.pgdudetail_pretty OWNER TO dbservice;

--
-- Name: pgdutotal_pretty; Type: VIEW; Schema: byt_devops; Owner: dbservice
--

CREATE VIEW byt_devops.pgdutotal_pretty AS
 SELECT 1 AS union_sort_order,
    sum(pgdudetail.total_size) AS total_size_sort_order,
    'All db objects'::text AS table_name,
    pg_size_pretty(sum(pgdudetail.table_size)) AS table_size,
    to_char(((sum(pgdudetail.table_size) / sum(pgdudetail.total_size)) * (100)::numeric), '999D9%'::text) AS percent_table,
    pg_size_pretty(sum(pgdudetail.indexes_size)) AS indexes_size,
    to_char(((sum(pgdudetail.indexes_size) / sum(pgdudetail.total_size)) * (100)::numeric), '999D9%'::text) AS percent_index,
    pg_size_pretty(sum(pgdudetail.total_size)) AS total_size
   FROM byt_devops.pgdudetail;


ALTER TABLE byt_devops.pgdutotal_pretty OWNER TO dbservice;

--
-- Name: pgdu_union_pretty; Type: VIEW; Schema: byt_devops; Owner: dbservice
--

CREATE VIEW byt_devops.pgdu_union_pretty AS
 SELECT pgdudetail_pretty.union_sort_order,
    pgdudetail_pretty.total_size_sort_order,
    pgdudetail_pretty.table_name,
    pgdudetail_pretty.table_size,
    pgdudetail_pretty.percent_table,
    pgdudetail_pretty.indexes_size,
    pgdudetail_pretty.percent_index,
    pgdudetail_pretty.total_size
   FROM byt_devops.pgdudetail_pretty
UNION
 SELECT pgdutotal_pretty.union_sort_order,
    pgdutotal_pretty.total_size_sort_order,
    pgdutotal_pretty.table_name,
    pgdutotal_pretty.table_size,
    pgdutotal_pretty.percent_table,
    pgdutotal_pretty.indexes_size,
    pgdutotal_pretty.percent_index,
    pgdutotal_pretty.total_size
   FROM byt_devops.pgdutotal_pretty
  ORDER BY 1, 2 DESC;


ALTER TABLE byt_devops.pgdu_union_pretty OWNER TO dbservice;

--
-- Name: pgdu_pretty; Type: VIEW; Schema: byt_devops; Owner: dbservice
--

CREATE VIEW byt_devops.pgdu_pretty AS
 SELECT pgdu_union_pretty.table_name,
    pgdu_union_pretty.table_size,
    pgdu_union_pretty.percent_table,
    pgdu_union_pretty.indexes_size,
    pgdu_union_pretty.percent_index,
    pgdu_union_pretty.total_size
   FROM byt_devops.pgdu_union_pretty;


ALTER TABLE byt_devops.pgdu_pretty OWNER TO dbservice;

--
-- Name: pgdudetail; Type: VIEW; Schema: byte_pgdu; Owner: dbservice
--

CREATE VIEW byte_pgdu.pgdudetail AS
 SELECT 0 AS union_sort_order,
    all_tables.table_schema,
    all_tables.table_name,
    pg_table_size((all_tables.full_table_name)::regclass) AS table_size,
    to_char((((pg_table_size((all_tables.full_table_name)::regclass))::double precision / (pg_total_relation_size((all_tables.full_table_name)::regclass))::double precision) * (100)::double precision), '999D9%'::text) AS percent_table,
    pg_indexes_size((all_tables.full_table_name)::regclass) AS indexes_size,
    to_char((((pg_indexes_size((all_tables.full_table_name)::regclass))::double precision / (pg_total_relation_size((all_tables.full_table_name)::regclass))::double precision) * (100)::double precision), '999D9%'::text) AS percent_index,
    pg_total_relation_size((all_tables.full_table_name)::regclass) AS total_size
   FROM ( SELECT tables.table_schema,
            tables.table_name,
            (((('"'::text || (tables.table_schema)::text) || '"."'::text) || (tables.table_name)::text) || '"'::text) AS full_table_name
           FROM information_schema.tables
          WHERE (((tables.table_schema)::text !~~ 'pg_%'::text) AND ((tables.table_schema)::text <> 'information_schema'::text))) all_tables
  WHERE (pg_total_relation_size((all_tables.full_table_name)::regclass) > 0)
  ORDER BY (pg_total_relation_size((all_tables.full_table_name)::regclass)) DESC;


ALTER TABLE byte_pgdu.pgdudetail OWNER TO dbservice;

--
-- Name: accounting; Type: TABLE; Schema: develop; Owner: dbservice
--

CREATE TABLE develop.accounting (
    id bigint NOT NULL,
    date character varying(135) NOT NULL,
    kiosk_id bigint NOT NULL,
    campus_id bigint NOT NULL,
    sales_ipc numeric(6,2) NOT NULL,
    sales_fp numeric(6,2) NOT NULL,
    sales_cs numeric(6,2) NOT NULL,
    sales_cp numeric(6,2) NOT NULL,
    tags_got bigint NOT NULL,
    tags_spent bigint NOT NULL,
    timezone smallint NOT NULL,
    sales_tax numeric(4,2) NOT NULL,
    sales_tax_ipc numeric(6,2) NOT NULL,
    sales_tax_fp numeric(6,2) NOT NULL,
    sales_tax_cs numeric(6,2) NOT NULL,
    sales_tax_cp numeric(6,2) NOT NULL,
    prepaid bigint NOT NULL,
    current_fee bigint NOT NULL,
    next_fee bigint NOT NULL,
    recalculated_fee numeric(6,2),
    prepaid_day bigint NOT NULL,
    next_fee_from character varying(135),
    fee_connectivity numeric(5,2) NOT NULL
);


ALTER TABLE develop.accounting OWNER TO dbservice;

--
-- Name: campus; Type: TABLE; Schema: develop; Owner: dbservice
--

CREATE TABLE develop.campus (
    id bigint NOT NULL,
    title character varying(135) NOT NULL,
    timezone character varying(150),
    archived smallint
);


ALTER TABLE develop.campus OWNER TO dbservice;

--
-- Name: card; Type: TABLE; Schema: develop; Owner: dbservice
--

CREATE TABLE develop.card (
    id bigint NOT NULL,
    hash character varying(264) NOT NULL,
    first_name character varying(135),
    last_name character varying(135),
    type character varying(45),
    number character varying(93),
    email character varying(381) NOT NULL
);


ALTER TABLE develop.card OWNER TO dbservice;

--
-- Name: contract; Type: TABLE; Schema: develop; Owner: dbservice
--

CREATE TABLE develop.contract (
    id bigint NOT NULL,
    url character varying(765) NOT NULL,
    user_id integer,
    name character varying(381),
    email character varying(381),
    payment_type character varying(150),
    pantry_quantity bigint,
    step smallint,
    paid smallint,
    archived smallint,
    initials character varying(150),
    total bigint,
    pricing_structure smallint,
    payment_transaction_id character varying(765),
    fee_monthly numeric(8,2),
    fee_6_month_pre_payment numeric(8,2),
    fee_12_month_pre_payment numeric(8,2),
    fee_label numeric(3,2),
    fee_transact numeric(5,4),
    fee_deposit numeric(8,2),
    logo character varying(765),
    terms character varying(765),
    requester_id bigint,
    monthly_allowed smallint NOT NULL
);


ALTER TABLE develop.contract OWNER TO dbservice;

--
-- Name: coupon; Type: TABLE; Schema: develop; Owner: dbservice
--

CREATE TABLE develop.coupon (
    id bigint NOT NULL,
    code character varying(135) NOT NULL,
    flat_discount numeric(5,2) NOT NULL,
    real_discount numeric(5,2) NOT NULL,
    used smallint NOT NULL,
    kiosk_list character varying(765)
);


ALTER TABLE develop.coupon OWNER TO dbservice;

--
-- Name: cron; Type: TABLE; Schema: develop; Owner: dbservice
--

CREATE TABLE develop.cron (
    id integer NOT NULL,
    "time" character varying(300),
    kiosks character varying(1500),
    command character varying(300),
    payload text,
    trigger_id integer,
    dependencies character varying(300),
    user_id integer,
    raw_task text,
    active integer,
    group_id integer,
    timezone character varying(210)
);


ALTER TABLE develop.cron OWNER TO dbservice;

--
-- Name: current_label_status_365days; Type: TABLE; Schema: develop; Owner: dbservice
--

CREATE TABLE develop.current_label_status_365days (
    epc character varying(72) NOT NULL,
    campus_id bigint NOT NULL,
    product_id bigint NOT NULL,
    product_title character varying(381) NOT NULL,
    price numeric(5,2) NOT NULL,
    status character varying(12) NOT NULL,
    kiosk_id bigint NOT NULL,
    order_id character varying(150) NOT NULL,
    first_timestamp bigint NOT NULL,
    last_timestamp bigint NOT NULL,
    cost numeric(5,2)
);


ALTER TABLE develop.current_label_status_365days OWNER TO dbservice;

--
-- Name: discount; Type: TABLE; Schema: develop; Owner: dbservice
--

CREATE TABLE develop.discount (
    id bigint NOT NULL,
    kiosk_id bigint,
    product_id bigint,
    value integer NOT NULL
);


ALTER TABLE develop.discount OWNER TO dbservice;

--
-- Name: discount_history; Type: TABLE; Schema: develop; Owner: dbservice
--

CREATE TABLE develop.discount_history (
    id integer NOT NULL,
    kiosk_id integer,
    product_id integer,
    value integer,
    start_time integer,
    end_time integer,
    discount_id integer
);


ALTER TABLE develop.discount_history OWNER TO dbservice;

--
-- Name: event; Type: TABLE; Schema: develop; Owner: dbservice
--

CREATE TABLE develop.event (
    id bigint NOT NULL,
    user_id bigint NOT NULL,
    params character varying(6141) NOT NULL,
    action character varying(45) NOT NULL,
    options character varying(6141) NOT NULL,
    archived smallint NOT NULL
);


ALTER TABLE develop.event OWNER TO dbservice;

--
-- Name: fee_rates; Type: TABLE; Schema: develop; Owner: dbservice
--

CREATE TABLE develop.fee_rates (
    id bigint NOT NULL,
    fee_lease numeric(6,2) NOT NULL,
    fee_tags numeric(3,2) NOT NULL,
    fee_ipc numeric(5,4) NOT NULL,
    bi_monthly smallint NOT NULL,
    archived smallint NOT NULL,
    custom smallint NOT NULL,
    prepaid_amount bigint NOT NULL,
    name character varying(384) NOT NULL
);


ALTER TABLE develop.fee_rates OWNER TO dbservice;

--
-- Name: feedback; Type: TABLE; Schema: develop; Owner: dbservice
--

CREATE TABLE develop.feedback (
    id bigint NOT NULL,
    rate smallint NOT NULL,
    order_id character varying(135) NOT NULL,
    message character varying(1536),
    taste smallint,
    freshness smallint,
    variety smallint,
    value smallint,
    ticket_created smallint
);


ALTER TABLE develop.feedback OWNER TO dbservice;

--
-- Name: group; Type: TABLE; Schema: develop; Owner: dbservice
--

CREATE TABLE develop."group" (
    id bigint NOT NULL,
    name character varying(135) NOT NULL,
    title character varying(135) NOT NULL,
    notes character varying(6000) NOT NULL,
    archived smallint
);


ALTER TABLE develop."group" OWNER TO dbservice;

--
-- Name: group_campus; Type: TABLE; Schema: develop; Owner: dbservice
--

CREATE TABLE develop.group_campus (
    group_id bigint NOT NULL,
    campus_id bigint NOT NULL,
    owner smallint NOT NULL,
    archived smallint
);


ALTER TABLE develop.group_campus OWNER TO dbservice;

--
-- Name: history; Type: TABLE; Schema: develop; Owner: dbservice
--

CREATE TABLE develop.history (
    id bigint NOT NULL,
    epc character varying(72) NOT NULL,
    kiosk_id bigint NOT NULL,
    user_id bigint,
    order_id character varying(135),
    direction character varying(9) NOT NULL,
    "time" bigint NOT NULL
);


ALTER TABLE develop.history OWNER TO dbservice;

--
-- Name: history_epc_order; Type: TABLE; Schema: develop; Owner: dbservice
--

CREATE TABLE develop.history_epc_order (
    id bigint NOT NULL,
    epc character varying(72) NOT NULL,
    kiosk_id bigint NOT NULL,
    order_id character varying(135),
    "time" bigint NOT NULL,
    product_id integer
);


ALTER TABLE develop.history_epc_order OWNER TO dbservice;

--
-- Name: inventory_history; Type: TABLE; Schema: develop; Owner: dbservice
--

CREATE TABLE develop.inventory_history (
    id integer NOT NULL,
    "time" integer NOT NULL,
    kiosk_id integer NOT NULL,
    product_id integer NOT NULL,
    qty integer NOT NULL
);


ALTER TABLE develop.inventory_history OWNER TO dbservice;

--
-- Name: kiosk; Type: TABLE; Schema: develop; Owner: dbservice
--

CREATE TABLE develop.kiosk (
    id bigint NOT NULL,
    campus_id bigint NOT NULL,
    serial character varying(135) NOT NULL,
    title character varying(138),
    address character varying(381),
    location_x numeric(9,6) NOT NULL,
    location_y numeric(9,6) NOT NULL,
    gcm_id character varying(765),
    app_vname character varying(75),
    app_vcode smallint,
    archived smallint,
    creation_time bigint,
    deployment_time bigint,
    last_update bigint,
    client_name character varying(765),
    last_status bigint,
    last_inventory bigint NOT NULL,
    kiosk_name character varying(765) NOT NULL,
    payment_start bigint,
    payment_stop bigint,
    features character varying(765) NOT NULL,
    sales_tax smallint NOT NULL,
    default_fee_plan bigint NOT NULL,
    timezone character varying(150)
);


ALTER TABLE develop.kiosk OWNER TO dbservice;

--
-- Name: kiosk_par_level; Type: TABLE; Schema: develop; Owner: dbservice
--

CREATE TABLE develop.kiosk_par_level (
    kiosk_id bigint NOT NULL,
    product_id bigint NOT NULL,
    amount bigint
);


ALTER TABLE develop.kiosk_par_level OWNER TO dbservice;

--
-- Name: kiosk_status; Type: TABLE; Schema: develop; Owner: dbservice
--

CREATE TABLE develop.kiosk_status (
    id bigint NOT NULL,
    kiosk_id bigint NOT NULL,
    kiosk_temperature numeric(6,3),
    kit_temperature numeric(6,3),
    power integer,
    battery_level smallint,
    rfid_0 integer,
    rfid_1 integer,
    rfid_2 integer,
    rfid_3 bigint NOT NULL,
    "time" bigint,
    modem_signal_percentage smallint,
    modem_signal_type character varying(81),
    ip character varying(135)
);


ALTER TABLE develop.kiosk_status OWNER TO dbservice;

--
-- Name: label; Type: TABLE; Schema: develop; Owner: dbservice
--

CREATE TABLE develop.label (
    id bigint NOT NULL,
    product_id bigint NOT NULL,
    epc character varying(72) NOT NULL,
    is_generic_sku smallint,
    kiosk_id bigint,
    order_id character varying(135),
    status character varying(12),
    price numeric(6,2),
    time_created bigint,
    time_added bigint,
    time_updated bigint
);


ALTER TABLE develop.label OWNER TO dbservice;

--
-- Name: label_order; Type: TABLE; Schema: develop; Owner: dbservice
--

CREATE TABLE develop.label_order (
    id bigint NOT NULL,
    product_id bigint,
    group_id bigint,
    box_id character varying(48),
    amount bigint NOT NULL,
    time_order bigint NOT NULL,
    time_encoded bigint,
    time_delivery bigint,
    time_updated bigint,
    status character varying(45)
);


ALTER TABLE develop.label_order OWNER TO dbservice;

--
-- Name: last_kiosk_status; Type: TABLE; Schema: develop; Owner: dbservice
--

CREATE TABLE develop.last_kiosk_status (
    id bigint NOT NULL,
    kiosk_id bigint NOT NULL,
    kiosk_temperature numeric(6,3),
    kit_temperature numeric(6,3),
    power integer,
    battery_level smallint,
    rfid_0 integer,
    rfid_1 integer,
    rfid_2 integer,
    rfid_3 bigint NOT NULL,
    "time" bigint,
    modem_signal_percentage smallint,
    modem_signal_type character varying(81),
    ip character varying(135)
);


ALTER TABLE develop.last_kiosk_status OWNER TO dbservice;

--
-- Name: manual_adjustment; Type: TABLE; Schema: develop; Owner: dbservice
--

CREATE TABLE develop.manual_adjustment (
    id bigint NOT NULL,
    kiosk_id bigint NOT NULL,
    date character varying(135) NOT NULL,
    sum numeric(6,2) NOT NULL,
    reason character varying(384) NOT NULL,
    auto_generated smallint NOT NULL,
    archived smallint NOT NULL
);


ALTER TABLE develop.manual_adjustment OWNER TO dbservice;

--
-- Name: order; Type: TABLE; Schema: develop; Owner: dbservice
--

CREATE TABLE develop."order" (
    order_id character varying(135) NOT NULL,
    kiosk_id bigint NOT NULL,
    kiosk_title character varying(138),
    email character varying(381) NOT NULL,
    amount_paid numeric(6,2),
    payment_system character varying(135) NOT NULL,
    transaction_id character varying(135) NOT NULL,
    approval_code character varying(135) NOT NULL,
    status_code character varying(135),
    status_message character varying(135),
    status character varying(135),
    batch_id character varying(45),
    created bigint,
    auth_amount character varying(21),
    data_token character varying(6141),
    time_opened bigint,
    time_closed bigint,
    card_hash character varying(264) NOT NULL,
    state character varying(45) NOT NULL,
    archived smallint,
    stamp bigint NOT NULL,
    last_update bigint,
    balance numeric(7,2),
    delta character varying(12),
    coupon_id bigint,
    coupon character varying(135),
    refund numeric(6,2) NOT NULL,
    receipt smallint NOT NULL,
    campus_id integer
);


ALTER TABLE develop."order" OWNER TO dbservice;

--
-- Name: par_history; Type: TABLE; Schema: develop; Owner: dbservice
--

CREATE TABLE develop.par_history (
    id integer NOT NULL,
    kiosk_id integer,
    par_level character varying(3069),
    end_time integer
);


ALTER TABLE develop.par_history OWNER TO dbservice;

--
-- Name: permission; Type: TABLE; Schema: develop; Owner: dbservice
--

CREATE TABLE develop.permission (
    id integer NOT NULL,
    permission character varying(765),
    api character varying(765),
    "isFrontend" integer NOT NULL
);


ALTER TABLE develop.permission OWNER TO dbservice;

--
-- Name: permission_mapping; Type: TABLE; Schema: develop; Owner: dbservice
--

CREATE TABLE develop.permission_mapping (
    role_id integer NOT NULL,
    permission_id integer NOT NULL
);


ALTER TABLE develop.permission_mapping OWNER TO dbservice;

--
-- Name: product; Type: TABLE; Schema: develop; Owner: dbservice
--

CREATE TABLE develop.product (
    id bigint NOT NULL,
    title character varying(381) NOT NULL,
    description character varying(12285),
    price numeric(5,2) NOT NULL,
    cost numeric(5,2) NOT NULL,
    shelf_time integer NOT NULL,
    campus_id bigint NOT NULL,
    image smallint NOT NULL,
    last_update bigint NOT NULL,
    archived smallint,
    taxable smallint,
    allergens character varying(765),
    categories character varying(765),
    vendor character varying(6000)
);


ALTER TABLE develop.product OWNER TO dbservice;

--
-- Name: product_history; Type: TABLE; Schema: develop; Owner: dbservice
--

CREATE TABLE develop.product_history (
    id integer NOT NULL,
    price numeric(5,2),
    cost numeric(5,2),
    start_time integer,
    end_time integer,
    product_id integer,
    campus_id integer
);


ALTER TABLE develop.product_history OWNER TO dbservice;

--
-- Name: refunds; Type: TABLE; Schema: develop; Owner: dbservice
--

CREATE TABLE develop.refunds (
    order_id character varying(135) NOT NULL,
    product_id integer NOT NULL,
    price numeric(6,2) NOT NULL
);


ALTER TABLE develop.refunds OWNER TO dbservice;

--
-- Name: ro_order; Type: TABLE; Schema: develop; Owner: dbservice
--

CREATE TABLE develop.ro_order (
    order_id character varying(135) NOT NULL,
    campus_id bigint NOT NULL,
    kiosk_id bigint NOT NULL,
    kiosk_title character varying(138),
    created bigint,
    state character varying(45) NOT NULL,
    customer_full_name character varying(300),
    full_price numeric(6,2),
    real_full_price numeric(6,2),
    archived smallint,
    time_updated bigint
);


ALTER TABLE develop.ro_order OWNER TO dbservice;

--
-- Name: role; Type: TABLE; Schema: develop; Owner: dbservice
--

CREATE TABLE develop.role (
    id integer NOT NULL,
    role character varying(765)
);


ALTER TABLE develop.role OWNER TO dbservice;

--
-- Name: role_mapping; Type: TABLE; Schema: develop; Owner: dbservice
--

CREATE TABLE develop.role_mapping (
    role_id integer NOT NULL,
    parent_id integer NOT NULL
);


ALTER TABLE develop.role_mapping OWNER TO dbservice;

--
-- Name: sessions; Type: TABLE; Schema: develop; Owner: dbservice
--

CREATE TABLE develop.sessions (
    sid character varying(765) NOT NULL,
    session character varying(65535) NOT NULL,
    expires integer
);


ALTER TABLE develop.sessions OWNER TO dbservice;

--
-- Name: spoilage; Type: TABLE; Schema: develop; Owner: dbservice
--

CREATE TABLE develop.spoilage (
    id integer NOT NULL,
    epc character varying(72) NOT NULL,
    kiosk_id integer NOT NULL,
    order_id character varying(135),
    time_removed integer,
    time_added integer,
    product_id integer
);


ALTER TABLE develop.spoilage OWNER TO dbservice;

--
-- Name: tag; Type: TABLE; Schema: develop; Owner: dbservice
--

CREATE TABLE develop.tag (
    id bigint NOT NULL,
    tag character varying(93) NOT NULL
);


ALTER TABLE develop.tag OWNER TO dbservice;

--
-- Name: temp; Type: TABLE; Schema: develop; Owner: dbservice
--

CREATE TABLE develop.temp (
    id bigint NOT NULL,
    date_processed character varying(135),
    date_auth character varying(135),
    type character varying(135),
    card character varying(135),
    num character varying(135),
    appcode character varying(135),
    amount character varying(135)
);


ALTER TABLE develop.temp OWNER TO dbservice;

--
-- Name: timezone_mapping; Type: TABLE; Schema: develop; Owner: dbservice
--

CREATE TABLE develop.timezone_mapping (
    id bigint NOT NULL,
    value smallint NOT NULL,
    name character varying(135) NOT NULL
);


ALTER TABLE develop.timezone_mapping OWNER TO dbservice;

--
-- Name: tmp_watcher; Type: TABLE; Schema: develop; Owner: dbservice
--

CREATE TABLE develop.tmp_watcher (
    label_id bigint,
    order_id character varying(135) NOT NULL,
    created bigint
);


ALTER TABLE develop.tmp_watcher OWNER TO dbservice;

--
-- Name: transact_comp; Type: TABLE; Schema: develop; Owner: dbservice
--

CREATE TABLE develop.transact_comp (
    id bigint NOT NULL,
    order_id character varying(93),
    result character varying(3069),
    "time" bigint
);


ALTER TABLE develop.transact_comp OWNER TO dbservice;

--
-- Name: transact_cs; Type: TABLE; Schema: develop; Owner: dbservice
--

CREATE TABLE develop.transact_cs (
    id bigint NOT NULL,
    order_id character varying(93),
    result character varying(3069),
    "time" bigint
);


ALTER TABLE develop.transact_cs OWNER TO dbservice;

--
-- Name: transact_fp; Type: TABLE; Schema: develop; Owner: dbservice
--

CREATE TABLE develop.transact_fp (
    id bigint NOT NULL,
    order_id character varying(93),
    result character varying(3069),
    "time" bigint
);


ALTER TABLE develop.transact_fp OWNER TO dbservice;

--
-- Name: transact_ipc; Type: TABLE; Schema: develop; Owner: dbservice
--

CREATE TABLE develop.transact_ipc (
    id bigint NOT NULL,
    order_id character varying(93),
    result character varying(12285),
    "time" bigint
);


ALTER TABLE develop.transact_ipc OWNER TO dbservice;

--
-- Name: unused_user_mapping; Type: TABLE; Schema: develop; Owner: dbservice
--

CREATE TABLE develop.unused_user_mapping (
    user_id integer NOT NULL,
    role_id integer NOT NULL
);


ALTER TABLE develop.unused_user_mapping OWNER TO dbservice;

--
-- Name: user; Type: TABLE; Schema: develop; Owner: dbservice
--

CREATE TABLE develop."user" (
    id bigint NOT NULL,
    login character varying(135) NOT NULL,
    first_name character varying(381),
    last_name character varying(381),
    password character varying(264) NOT NULL,
    email character varying(381),
    role_id bigint NOT NULL,
    group_id bigint NOT NULL,
    archived smallint NOT NULL,
    date_registered bigint NOT NULL,
    timezone character varying(150),
    email_params character varying(65535),
    token character varying(120)
);


ALTER TABLE develop."user" OWNER TO dbservice;

--
-- Name: awsdms_apply_exceptions; Type: TABLE; Schema: dms7; Owner: dbservice
--

CREATE TABLE dms7.awsdms_apply_exceptions (
    "TASK_NAME" character varying(384) NOT NULL,
    "TABLE_OWNER" character varying(384) NOT NULL,
    "TABLE_NAME" character varying(384) NOT NULL,
    "ERROR_TIME" timestamp without time zone NOT NULL,
    "STATEMENT" text NOT NULL,
    "ERROR" text NOT NULL
);


ALTER TABLE dms7.awsdms_apply_exceptions OWNER TO dbservice;

--
-- Name: awsdms_history; Type: TABLE; Schema: dms7; Owner: dbservice
--

CREATE TABLE dms7.awsdms_history (
    server_name character varying(384) NOT NULL,
    task_name character varying(384) NOT NULL,
    timeslot_type character varying(96) NOT NULL,
    timeslot timestamp without time zone NOT NULL,
    timeslot_duration bigint,
    timeslot_latency bigint,
    timeslot_records bigint,
    timeslot_volume bigint
);


ALTER TABLE dms7.awsdms_history OWNER TO dbservice;

--
-- Name: awsdms_status; Type: TABLE; Schema: dms7; Owner: dbservice
--

CREATE TABLE dms7.awsdms_status (
    server_name character varying(384) NOT NULL,
    task_name character varying(384) NOT NULL,
    task_status character varying(96),
    status_time timestamp without time zone,
    pending_changes bigint,
    disk_swap_size bigint,
    task_memory bigint,
    source_current_position character varying(384),
    source_current_timestamp timestamp without time zone,
    source_tail_position character varying(384),
    source_tail_timestamp timestamp without time zone,
    source_timestamp_applied timestamp without time zone
);


ALTER TABLE dms7.awsdms_status OWNER TO dbservice;

--
-- Name: awsdms_suspended_tables; Type: TABLE; Schema: dms7; Owner: dbservice
--

CREATE TABLE dms7.awsdms_suspended_tables (
    server_name character varying(384) NOT NULL,
    task_name character varying(384) NOT NULL,
    table_owner character varying(384) NOT NULL,
    table_name character varying(384) NOT NULL,
    suspend_reason character varying(96),
    suspend_timestamp timestamp without time zone
);


ALTER TABLE dms7.awsdms_suspended_tables OWNER TO dbservice;

--
-- Name: a; Type: TABLE; Schema: fnrenames; Owner: dbservice
--

CREATE TABLE fnrenames.a (
    "?column?" integer
);


ALTER TABLE fnrenames.a OWNER TO dbservice;

--
-- Name: card_id_seq; Type: SEQUENCE; Schema: fnrenames; Owner: dbservice
--

CREATE SEQUENCE fnrenames.card_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE fnrenames.card_id_seq OWNER TO dbservice;

--
-- Name: discount_history_id_seq; Type: SEQUENCE; Schema: fnrenames; Owner: dbservice
--

CREATE SEQUENCE fnrenames.discount_history_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE fnrenames.discount_history_id_seq OWNER TO dbservice;

--
-- Name: history_id_seq; Type: SEQUENCE; Schema: fnrenames; Owner: dbservice
--

CREATE SEQUENCE fnrenames.history_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE fnrenames.history_id_seq OWNER TO dbservice;

--
-- Name: kiosk_id_seq; Type: SEQUENCE; Schema: fnrenames; Owner: dbservice
--

CREATE SEQUENCE fnrenames.kiosk_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE fnrenames.kiosk_id_seq OWNER TO dbservice;

--
-- Name: kiosk_status_id_seq; Type: SEQUENCE; Schema: fnrenames; Owner: dbservice
--

CREATE SEQUENCE fnrenames.kiosk_status_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE fnrenames.kiosk_status_id_seq OWNER TO dbservice;

--
-- Name: label_id_seq; Type: SEQUENCE; Schema: fnrenames; Owner: dbservice
--

CREATE SEQUENCE fnrenames.label_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE fnrenames.label_id_seq OWNER TO dbservice;

--
-- Name: nutrition_filter_id_seq; Type: SEQUENCE; Schema: fnrenames; Owner: dbservice
--

CREATE SEQUENCE fnrenames.nutrition_filter_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE fnrenames.nutrition_filter_id_seq OWNER TO dbservice;

--
-- Name: overstock_multiplier; Type: TABLE; Schema: fnrenames; Owner: dbservice
--

CREATE TABLE fnrenames.overstock_multiplier (
    setting character varying(100)
);


ALTER TABLE fnrenames.overstock_multiplier OWNER TO dbservice;

--
-- Name: overstock_multiplier2; Type: TABLE; Schema: fnrenames; Owner: dbservice
--

CREATE TABLE fnrenames.overstock_multiplier2 (
    value character varying(100)
);


ALTER TABLE fnrenames.overstock_multiplier2 OWNER TO dbservice;

--
-- Name: product_id_seq; Type: SEQUENCE; Schema: fnrenames; Owner: dbservice
--

CREATE SEQUENCE fnrenames.product_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE fnrenames.product_id_seq OWNER TO dbservice;

--
-- Name: tag_id_seq; Type: SEQUENCE; Schema: fnrenames; Owner: dbservice
--

CREATE SEQUENCE fnrenames.tag_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE fnrenames.tag_id_seq OWNER TO dbservice;

--
-- Name: temp_sync_order_2018_12_13; Type: TABLE; Schema: fnrenames; Owner: dbservice
--

CREATE TABLE fnrenames.temp_sync_order_2018_12_13 (
    order_id character varying(135),
    first_name character varying(135),
    last_name character varying(135),
    kiosk_id bigint,
    kiosk_title character varying(138),
    email character varying(381),
    amount_paid numeric(6,2),
    payment_system character varying(135),
    transaction_id character varying(135),
    approval_code character varying(135),
    status_code character varying(135),
    status_message character varying(135),
    status character varying(135),
    batch_id character varying(45),
    created bigint,
    auth_amount character varying(21),
    data_token character varying(6141),
    time_opened bigint,
    time_closed bigint,
    card_hash character varying(264),
    state character varying(45),
    archived bigint,
    stamp bigint,
    last_update bigint,
    balance numeric(7,2),
    delta character varying(12),
    coupon_id bigint,
    coupon character varying(135),
    refund numeric(6,2),
    receipt bigint,
    campus_id bigint,
    amount_list_price numeric(6,2),
    notes text,
    time_door_opened bigint,
    time_door_closed bigint
);


ALTER TABLE fnrenames.temp_sync_order_2018_12_13 OWNER TO dbservice;

--
-- Name: tmp_payment_information; Type: TABLE; Schema: fnrenames; Owner: dbservice
--

CREATE TABLE fnrenames.tmp_payment_information (
    order_id character varying(20) NOT NULL,
    magne_print character varying(112),
    ksn character varying(20),
    magne_print_status character varying(8),
    track2 character varying(80)
);


ALTER TABLE fnrenames.tmp_payment_information OWNER TO dbservice;

--
-- Name: warehouse_inventory; Type: TABLE; Schema: inm; Owner: dbservice
--

CREATE TABLE inm.warehouse_inventory (
    inventory_date date NOT NULL,
    product_id integer NOT NULL,
    stickered_units integer DEFAULT 0 NOT NULL,
    unstickered_units integer DEFAULT 0 NOT NULL,
    stickered_cases integer DEFAULT 0 NOT NULL,
    unstickered_cases integer DEFAULT 0 NOT NULL,
    spoiled_units integer DEFAULT 0 NOT NULL,
    units_per_case integer NOT NULL,
    sort_order smallint NOT NULL
);


ALTER TABLE inm.warehouse_inventory OWNER TO dbservice;

--
-- Name: product; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.product (
    id bigint NOT NULL,
    title character varying(127) NOT NULL,
    description character varying(4095) DEFAULT 'No description yet'::character varying,
    tiny_description character varying(40),
    short_description character varying(100),
    medium_description character varying(400),
    long_description character varying(1200),
    price numeric(5,2) DEFAULT 0.00 NOT NULL,
    cost numeric(5,2) DEFAULT 0.00 NOT NULL,
    shelf_time integer DEFAULT 1 NOT NULL,
    campus_id bigint NOT NULL,
    image smallint DEFAULT 0 NOT NULL,
    image_time bigint,
    last_update bigint DEFAULT 0 NOT NULL,
    archived bigint DEFAULT 0,
    taxable smallint DEFAULT 0,
    allergens character varying(255),
    attribute_names character varying(511),
    categories character varying(255),
    category_names character varying(511),
    vendor character varying(135),
    source character varying(135),
    notes character varying(2000),
    total_cal bigint,
    num_servings real,
    ingredients character varying(2000),
    calories real,
    proteins real,
    sugar real,
    carbohydrates real,
    fat real,
    consumer_category character varying(2000),
    ws_case_size bigint,
    kiosk_ship_qty bigint,
    ws_case_cost numeric(5,2),
    pick_station bigint,
    fc_title character varying(255),
    pricing_tier character varying(255),
    width_space real,
    height_space real,
    depth_space real,
    slotted_width real,
    tag_volume bigint,
    delivery_option character varying(255) DEFAULT 'M'::character varying,
    tag_applied_by character varying(255) DEFAULT 'W'::character varying,
    internal_id text,
    CONSTRAINT product_internal_id_check CHECK ((length(internal_id) <= 400))
);


ALTER TABLE pantry.product OWNER TO dbservice;

--
-- Name: allocable_inventory; Type: VIEW; Schema: inm; Owner: dbservice
--

CREATE VIEW inm.allocable_inventory AS
 SELECT i.inventory_date,
    i.product_id,
    ((i.stickered_units + (i.stickered_cases * i.units_per_case)) - i.spoiled_units) AS qty,
    p.pick_station,
    p.title,
    p.fc_title,
    p.vendor
   FROM (inm.warehouse_inventory i
     JOIN pantry.product p ON ((i.product_id = p.id)))
  WHERE (((i.stickered_units + (i.stickered_cases * i.units_per_case)) - i.spoiled_units) > 0);


ALTER TABLE inm.allocable_inventory OWNER TO dbservice;

--
-- Name: bringg_delivery; Type: TABLE; Schema: inm; Owner: dbservice
--

CREATE TABLE inm.bringg_delivery (
    task_id integer NOT NULL,
    route_date_time timestamp(6) with time zone NOT NULL,
    driver_name character varying(200) NOT NULL,
    kid integer NOT NULL,
    stop_number integer,
    status character varying(200),
    ready_to_execute character varying(200)
);


ALTER TABLE inm.bringg_delivery OWNER TO dbservice;

--
-- Name: configuration; Type: TABLE; Schema: inm; Owner: dbservice
--

CREATE TABLE inm.configuration (
    setting character varying(100) NOT NULL,
    value character varying(100) NOT NULL
);


ALTER TABLE inm.configuration OWNER TO dbservice;

--
-- Name: kiosk_attribute; Type: TABLE; Schema: inm; Owner: dbservice
--

CREATE TABLE inm.kiosk_attribute (
    id integer NOT NULL,
    start_level numeric(4,2) NOT NULL,
    min_level numeric(4,2) NOT NULL,
    manual_multiplier numeric(4,2) NOT NULL
);


ALTER TABLE inm.kiosk_attribute OWNER TO dbservice;

--
-- Name: kiosk_control; Type: TABLE; Schema: inm; Owner: dbservice
--

CREATE TABLE inm.kiosk_control (
    kiosk_id integer NOT NULL,
    start_level numeric(4,2) NOT NULL,
    min_level numeric(4,2) NOT NULL,
    scale numeric(4,2) DEFAULT 1.0 NOT NULL,
    manual_multiplier numeric(4,2) DEFAULT 1.0 NOT NULL
);


ALTER TABLE inm.kiosk_control OWNER TO dbservice;

--
-- Name: kiosk_product_disabled; Type: TABLE; Schema: inm; Owner: dbservice
--

CREATE TABLE inm.kiosk_product_disabled (
    kiosk_id bigint NOT NULL,
    product_id integer NOT NULL
);


ALTER TABLE inm.kiosk_product_disabled OWNER TO dbservice;

--
-- Name: pick_allocation; Type: TABLE; Schema: inm; Owner: dbservice
--

CREATE TABLE inm.pick_allocation (
    pick_date date NOT NULL,
    route_date date NOT NULL,
    kiosk_id integer NOT NULL,
    sku_id integer NOT NULL,
    qty integer NOT NULL
);


ALTER TABLE inm.pick_allocation OWNER TO dbservice;

--
-- Name: sku_group_attribute; Type: TABLE; Schema: inm; Owner: dbservice
--

CREATE TABLE inm.sku_group_attribute (
    id integer NOT NULL,
    title character varying(512) NOT NULL,
    relative_size numeric(4,2) NOT NULL,
    minimum_kiosk_qty smallint NOT NULL,
    maximum_kiosk_qty smallint
);


ALTER TABLE inm.sku_group_attribute OWNER TO dbservice;

--
-- Name: kiosk; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.kiosk (
    id bigint NOT NULL,
    campus_id bigint NOT NULL,
    serial character varying(45) DEFAULT '000000000000000'::character varying NOT NULL,
    title character varying(46),
    address character varying(127),
    location_x numeric(9,6) DEFAULT 0.000000 NOT NULL,
    location_y numeric(9,6) DEFAULT 0.000000 NOT NULL,
    gcm_id character varying(255),
    app_vname character varying(63),
    app_vcode integer,
    archived bigint DEFAULT 0,
    creation_time bigint,
    deployment_time bigint,
    last_update bigint DEFAULT 0,
    client_name character varying(255),
    last_status bigint,
    last_inventory bigint DEFAULT 0 NOT NULL,
    kiosk_name character varying(200) NOT NULL,
    payment_start bigint,
    payment_stop bigint,
    features character varying(255) NOT NULL,
    sales_tax smallint DEFAULT 0 NOT NULL,
    default_fee_plan bigint DEFAULT 1 NOT NULL,
    timezone character varying(50),
    estd_num_users bigint DEFAULT 0,
    tags character varying(255),
    publicly_accessible bigint DEFAULT 0,
    cardkey_required bigint DEFAULT 0,
    delivery_insns character varying(65535),
    fridge_loc_info character varying(65535),
    contact_first_name character varying(65535),
    contact_last_name character varying(65535),
    contact_email character varying(65535),
    contact_phone character varying(65535),
    accounting_email character varying(65535),
    byte_discount character varying(255),
    subsidy_info character varying(50),
    subsidy_notes character varying(65535),
    max_subscription character varying(50),
    delivery_window_mon character varying(50),
    delivery_window_tue character varying(50),
    delivery_window_wed character varying(50),
    delivery_window_thu character varying(50),
    delivery_window_fri character varying(50),
    delivery_window_sat character varying(50),
    delivery_window_sun character varying(50),
    notes character varying(2000),
    components text,
    email_receipt_subject character varying(200),
    ops_team_notes character varying(65535),
    geo character varying(3),
    server_url character varying(127) DEFAULT 'https://kiosk-prod.bytefoods.com'::character varying,
    subscription_amount numeric(8,2) DEFAULT 0.00 NOT NULL,
    enable_reporting bigint,
    enable_monitoring bigint,
    employees_num bigint,
    kiosk_restrictions character varying(2000),
    CONSTRAINT check_features CHECK (((((features)::text ~~ '%nursing%'::text) AND ((features)::text !~~ '%no_vending%'::text)) OR (((features)::text ~~ '%no_vending%'::text) AND ((features)::text !~~ '%nursing%'::text)) OR (((features)::text !~~ '%no_vending%'::text) AND ((features)::text !~~ '%nursing%'::text))))
);


ALTER TABLE pantry.kiosk OWNER TO dbservice;

--
-- Name: label; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.label (
    id bigint NOT NULL,
    product_id bigint NOT NULL,
    epc character varying(24) NOT NULL,
    is_generic_sku smallint,
    kiosk_id bigint,
    order_id character varying(45),
    status character varying(4),
    price numeric(6,2),
    cost numeric(6,2),
    time_created bigint,
    time_added bigint,
    time_updated bigint,
    notes text
);


ALTER TABLE pantry.label OWNER TO dbservice;

--
-- Name: order; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry."order" (
    order_id character varying(45) NOT NULL,
    first_name character varying(45),
    last_name character varying(45),
    kiosk_id bigint NOT NULL,
    kiosk_title character varying(46),
    email character varying(127) NOT NULL,
    amount_paid numeric(6,2) DEFAULT 0.00,
    payment_system character varying(45) NOT NULL,
    transaction_id character varying(45) NOT NULL,
    approval_code character varying(45) NOT NULL,
    status_code character varying(45),
    status_message character varying(45),
    status character varying(45),
    batch_id character varying(15),
    created bigint,
    auth_amount character varying(7),
    data_token character varying(2047),
    time_opened bigint,
    time_closed bigint,
    card_hash character varying(88) NOT NULL,
    state character varying(15) NOT NULL,
    archived bigint DEFAULT 0,
    stamp bigint DEFAULT 0 NOT NULL,
    last_update bigint,
    balance numeric(7,2),
    delta character varying(4),
    coupon_id bigint,
    coupon character varying(45),
    refund numeric(6,2) DEFAULT 0.00 NOT NULL,
    receipt bigint DEFAULT 0 NOT NULL,
    campus_id bigint NOT NULL,
    amount_list_price numeric(6,2),
    time_door_opened bigint,
    time_door_closed bigint,
    notes text
);


ALTER TABLE pantry."order" OWNER TO dbservice;

--
-- Name: kiosk_projected_minimum; Type: VIEW; Schema: inm; Owner: dbservice
--

CREATE VIEW inm.kiosk_projected_minimum AS
 SELECT combined_stock.kiosk_id,
    combined_stock.kiosk_title,
    combined_stock.fc_title,
    sga.minimum_kiosk_qty AS min_qty,
    sum(combined_stock.qty) AS stock_qty,
    ((sga.minimum_kiosk_qty)::numeric - sum(combined_stock.qty)) AS min_need
   FROM (( SELECT l.kiosk_id,
            k.title AS kiosk_title,
            p.fc_title,
            count(l.epc) AS qty
           FROM ((pantry.label l
             JOIN pantry.product p ON ((l.product_id = p.id)))
             JOIN pantry.kiosk k ON ((l.kiosk_id = k.id)))
          WHERE (((l.status)::text ~~ 'ok'::text) AND (k.campus_id = 87) AND (k.enable_reporting = 1) AND (k.archived <> 1) AND (l.kiosk_id <> 737))
          GROUP BY l.kiosk_id, k.title, p.fc_title
        UNION ALL
         SELECT a.kiosk_id,
            k.title AS kiosk_title,
            p.fc_title,
            a.qty
           FROM (((inm.pick_allocation a
             LEFT JOIN pantry."order" o ON (((a.route_date = (to_timestamp((o.created)::double precision))::date) AND (a.kiosk_id = o.kiosk_id) AND ((o.payment_system)::text = 'Restocking'::text))))
             JOIN pantry.product p ON ((a.sku_id = p.id)))
             JOIN pantry.kiosk k ON ((a.kiosk_id = k.id)))
          WHERE ((a.route_date >= ('now'::text)::date) AND (a.pick_date > (('now'::text)::date - 1)) AND (o.kiosk_id IS NULL))) combined_stock
     JOIN inm.sku_group_attribute sga ON (((combined_stock.fc_title)::text = (sga.title)::text)))
  GROUP BY combined_stock.kiosk_id, combined_stock.kiosk_title, combined_stock.fc_title, sga.minimum_kiosk_qty;


ALTER TABLE inm.kiosk_projected_minimum OWNER TO dbservice;

--
-- Name: VIEW kiosk_projected_minimum; Type: COMMENT; Schema: inm; Owner: dbservice
--

COMMENT ON VIEW inm.kiosk_projected_minimum IS 'Anbalysis of minimum using current and expect inventory from pick';


--
-- Name: kiosk_projected_stock; Type: VIEW; Schema: inm; Owner: dbservice
--

CREATE VIEW inm.kiosk_projected_stock AS
 SELECT combined_stock.kiosk_id,
    combined_stock.kiosk_title,
    combined_stock.fc_title,
    sum(combined_stock.qty) AS count
   FROM ( SELECT l.kiosk_id,
            k.title AS kiosk_title,
            p.fc_title,
            count(l.epc) AS qty
           FROM ((pantry.label l
             JOIN pantry.product p ON ((l.product_id = p.id)))
             JOIN pantry.kiosk k ON ((l.kiosk_id = k.id)))
          WHERE (((l.status)::text ~~ 'ok'::text) AND (k.campus_id = 87) AND (k.enable_reporting = 1) AND (k.archived <> 1))
          GROUP BY l.kiosk_id, k.title, p.fc_title
        UNION ALL
         SELECT a.kiosk_id,
            k.title AS kiosk_title,
            p.fc_title,
            a.qty
           FROM (((inm.pick_allocation a
             LEFT JOIN pantry."order" o ON (((a.route_date = (to_timestamp((o.created)::double precision))::date) AND (a.kiosk_id = o.kiosk_id) AND ((o.payment_system)::text = 'Restocking'::text))))
             JOIN pantry.product p ON ((a.sku_id = p.id)))
             JOIN pantry.kiosk k ON ((a.kiosk_id = k.id)))
          WHERE ((a.route_date >= ('now'::text)::date) AND (a.pick_date = (('now'::text)::date - 1)) AND (o.kiosk_id IS NULL))
        UNION ALL
         SELECT pl.kiosk_id,
            pl.kiosk_title,
            p.fc_title,
            count(*) AS qty
           FROM (inm.get_spoilage_pull_list() pl(category, kiosk_id, kiosk_title, product_id, product_tile, epc)
             JOIN pantry.product p ON ((pl.product_id = p.id)))
          GROUP BY pl.kiosk_id, pl.kiosk_title, p.fc_title) combined_stock
  WHERE (combined_stock.fc_title IS NOT NULL)
  GROUP BY combined_stock.kiosk_id, combined_stock.kiosk_title, combined_stock.fc_title;


ALTER TABLE inm.kiosk_projected_stock OWNER TO dbservice;

--
-- Name: kiosk_projected_stock_sku_level; Type: VIEW; Schema: inm; Owner: dbservice
--

CREATE VIEW inm.kiosk_projected_stock_sku_level AS
 SELECT NULL::bigint AS kiosk_id,
    NULL::character varying(138) AS kiosk_title,
    NULL::character varying(255) AS fc_title,
    NULL::bigint AS id,
    NULL::character varying(127) AS title,
    NULL::numeric AS count;


ALTER TABLE inm.kiosk_projected_stock_sku_level OWNER TO dbservice;

--
-- Name: VIEW kiosk_projected_stock_sku_level; Type: COMMENT; Schema: inm; Owner: dbservice
--

COMMENT ON VIEW inm.kiosk_projected_stock_sku_level IS 'Projected skus in a kiosk which includes items on delivery';


--
-- Name: kiosk_restriction_by_product; Type: TABLE; Schema: inm; Owner: dbservice
--

CREATE TABLE inm.kiosk_restriction_by_product (
    kiosk_id bigint NOT NULL,
    product_id integer NOT NULL
);


ALTER TABLE inm.kiosk_restriction_by_product OWNER TO dbservice;

--
-- Name: kiosk_restriction_by_property; Type: TABLE; Schema: inm; Owner: dbservice
--

CREATE TABLE inm.kiosk_restriction_by_property (
    kiosk_id integer NOT NULL,
    property_id integer NOT NULL
);


ALTER TABLE inm.kiosk_restriction_by_property OWNER TO dbservice;

--
-- Name: kiosk_restriction_by_sku; Type: TABLE; Schema: inm; Owner: dbservice
--

CREATE TABLE inm.kiosk_restriction_by_sku (
    kiosk_id integer NOT NULL,
    sku_id integer NOT NULL
);


ALTER TABLE inm.kiosk_restriction_by_sku OWNER TO dbservice;

--
-- Name: product_property_def; Type: TABLE; Schema: inm; Owner: dbservice
--

CREATE TABLE inm.product_property_def (
    id integer NOT NULL,
    name text NOT NULL,
    value text
);


ALTER TABLE inm.product_property_def OWNER TO dbservice;

--
-- Name: kiosk_restriction_list; Type: VIEW; Schema: inm; Owner: dbservice
--

CREATE VIEW inm.kiosk_restriction_list AS
 SELECT kr.kiosk_id,
    string_agg(pp.value, ','::text) AS restrictions
   FROM (inm.kiosk_restriction_by_property kr
     JOIN inm.product_property_def pp ON ((pp.id = kr.property_id)))
  GROUP BY kr.kiosk_id;


ALTER TABLE inm.kiosk_restriction_list OWNER TO dbservice;

--
-- Name: kiosk_sku_group_manual_scale; Type: TABLE; Schema: inm; Owner: dbservice
--

CREATE TABLE inm.kiosk_sku_group_manual_scale (
    kiosk_id integer NOT NULL,
    sku_group_id integer NOT NULL,
    scale numeric(4,2) NOT NULL
);


ALTER TABLE inm.kiosk_sku_group_manual_scale OWNER TO dbservice;

--
-- Name: pick_demand; Type: TABLE; Schema: inm; Owner: dbservice
--

CREATE TABLE inm.pick_demand (
    pick_date date NOT NULL,
    route_date date NOT NULL,
    kiosk_id integer NOT NULL,
    sku_group_id integer NOT NULL,
    qty integer NOT NULL
);


ALTER TABLE inm.pick_demand OWNER TO dbservice;

--
-- Name: pick_inventory; Type: TABLE; Schema: inm; Owner: dbservice
--

CREATE TABLE inm.pick_inventory (
    pick_date date NOT NULL,
    route_date date NOT NULL,
    kiosk_id integer NOT NULL,
    sku_group_id integer NOT NULL,
    qty integer NOT NULL
);


ALTER TABLE inm.pick_inventory OWNER TO dbservice;

--
-- Name: pick_list; Type: TABLE; Schema: inm; Owner: dbservice
--

CREATE TABLE inm.pick_list (
    pick_date date NOT NULL,
    create_ts timestamp with time zone DEFAULT CURRENT_TIMESTAMP NOT NULL,
    timeout_seconds smallint DEFAULT 360,
    finish_ts timestamp with time zone,
    status text DEFAULT 'started'::text,
    log text,
    url text,
    CONSTRAINT pick_list_status_check CHECK ((status = ANY (ARRAY['started'::text, 'ready'::text, 'failed'::text])))
);


ALTER TABLE inm.pick_list OWNER TO dbservice;

--
-- Name: pick_preference_kiosk_sku; Type: TABLE; Schema: inm; Owner: dbservice
--

CREATE TABLE inm.pick_preference_kiosk_sku (
    kiosk_id integer NOT NULL,
    sku_id integer NOT NULL,
    preference smallint NOT NULL
);


ALTER TABLE inm.pick_preference_kiosk_sku OWNER TO dbservice;

--
-- Name: pick_priority_kiosk; Type: TABLE; Schema: inm; Owner: dbservice
--

CREATE TABLE inm.pick_priority_kiosk (
    kiosk_id integer NOT NULL,
    priority integer,
    comment text,
    end_date date
);


ALTER TABLE inm.pick_priority_kiosk OWNER TO dbservice;

--
-- Name: pick_priority_sku; Type: TABLE; Schema: inm; Owner: dbservice
--

CREATE TABLE inm.pick_priority_sku (
    sku_id integer NOT NULL,
    priority integer
);


ALTER TABLE inm.pick_priority_sku OWNER TO dbservice;

--
-- Name: pick_rejection; Type: TABLE; Schema: inm; Owner: dbservice
--

CREATE TABLE inm.pick_rejection (
    pick_date date NOT NULL,
    route_date date NOT NULL,
    kiosk_id integer NOT NULL,
    item_id integer NOT NULL,
    item_type character varying(32) NOT NULL,
    reason character varying(64) NOT NULL
);


ALTER TABLE inm.pick_rejection OWNER TO dbservice;

--
-- Name: pick_route; Type: TABLE; Schema: inm; Owner: dbservice
--

CREATE TABLE inm.pick_route (
    pick_date date NOT NULL,
    kiosk_id integer NOT NULL,
    route_number character varying(256),
    driver_name character varying(64) NOT NULL,
    route_time time(6) without time zone NOT NULL,
    route_date date NOT NULL,
    delivery_order smallint NOT NULL
);


ALTER TABLE inm.pick_route OWNER TO dbservice;

--
-- Name: pick_substitution; Type: TABLE; Schema: inm; Owner: dbservice
--

CREATE TABLE inm.pick_substitution (
    substituting_sku_group_id integer NOT NULL,
    substituted_sku_group_id integer NOT NULL,
    qty integer NOT NULL,
    pick_date date NOT NULL
);


ALTER TABLE inm.pick_substitution OWNER TO dbservice;

--
-- Name: product_property; Type: TABLE; Schema: inm; Owner: dbservice
--

CREATE TABLE inm.product_property (
    product_id bigint NOT NULL,
    property_id integer NOT NULL
);


ALTER TABLE inm.product_property OWNER TO dbservice;

--
-- Name: product_property_def_id_seq; Type: SEQUENCE; Schema: inm; Owner: dbservice
--

CREATE SEQUENCE inm.product_property_def_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE inm.product_property_def_id_seq OWNER TO dbservice;

--
-- Name: product_property_def_id_seq; Type: SEQUENCE OWNED BY; Schema: inm; Owner: dbservice
--

ALTER SEQUENCE inm.product_property_def_id_seq OWNED BY inm.product_property_def.id;


--
-- Name: sku_def; Type: TABLE; Schema: inm; Owner: dbservice
--

CREATE TABLE inm.sku_def (
    id integer NOT NULL,
    title character varying(512) NOT NULL
);


ALTER TABLE inm.sku_def OWNER TO dbservice;

--
-- Name: sku_group; Type: TABLE; Schema: inm; Owner: dbservice
--

CREATE TABLE inm.sku_group (
    id integer NOT NULL,
    fc_title inm_beta.text_name NOT NULL,
    unit_size numeric(4,2) NOT NULL
);


ALTER TABLE inm.sku_group OWNER TO dbservice;

--
-- Name: sku_group_control; Type: TABLE; Schema: inm; Owner: dbservice
--

CREATE TABLE inm.sku_group_control (
    sku_group_id integer NOT NULL,
    default_level numeric(4,2) DEFAULT '-1'::integer NOT NULL,
    scale numeric(4,2) DEFAULT 1.0 NOT NULL,
    min_qty smallint,
    max_qty smallint
);


ALTER TABLE inm.sku_group_control OWNER TO dbservice;

--
-- Name: sku_property; Type: TABLE; Schema: inm; Owner: dbservice
--

CREATE TABLE inm.sku_property (
    sku_id integer NOT NULL,
    property_id integer NOT NULL
);


ALTER TABLE inm.sku_property OWNER TO dbservice;

--
-- Name: sku_property_def; Type: TABLE; Schema: inm; Owner: dbservice
--

CREATE TABLE inm.sku_property_def (
    id integer NOT NULL,
    attribute character varying(256),
    title character varying(512) NOT NULL
);


ALTER TABLE inm.sku_property_def OWNER TO dbservice;

--
-- Name: temp_pick_order; Type: TABLE; Schema: inm; Owner: dbservice
--

CREATE TABLE inm.temp_pick_order (
    kiosk_id integer,
    route_date_time timestamp with time zone,
    sku_group_id integer,
    fc_title text,
    week_qty integer,
    plan_qty integer
);


ALTER TABLE inm.temp_pick_order OWNER TO dbservice;

--
-- Name: temp_velocity; Type: TABLE; Schema: inm; Owner: dbservice
--

CREATE TABLE inm.temp_velocity (
    kiosk_id bigint,
    sku_group character varying(765),
    sample_size bigint,
    dt_avg numeric,
    dt_std numeric,
    w_departure_time numeric,
    preference numeric,
    pref_total numeric,
    ws_avg numeric,
    ws_std numeric,
    ws_live bigint,
    demand_weekly_wo_min numeric
);


ALTER TABLE inm.temp_velocity OWNER TO dbservice;

--
-- Name: all_raw_orders; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.all_raw_orders AS
 SELECT o.order_id,
    o.first_name,
    o.last_name,
    o.kiosk_id,
    o.kiosk_title,
    o.email,
    o.amount_paid,
    o.payment_system,
    o.transaction_id,
    o.approval_code,
    o.status_code,
    o.status_message,
    o.status,
    o.batch_id,
    o.created,
    o.auth_amount,
    o.data_token,
    o.time_opened,
    o.time_closed,
    o.card_hash,
    o.state,
    o.archived,
    o.stamp,
    o.last_update,
    o.balance,
    o.delta,
    o.coupon_id,
    o.coupon,
    o.refund,
    o.receipt,
    o.campus_id,
    o.amount_list_price,
    o.notes,
    o.time_door_opened,
    o.time_door_closed,
    k.client_name,
    k.estd_num_users,
    to_timestamp((o.created)::double precision) AS ts,
    concat(btrim((o.first_name)::text), ' ', btrim((o.last_name)::text)) AS full_name,
    (o.time_closed - o.time_opened) AS door_opened_secs
   FROM (pantry."order" o
     JOIN pantry.kiosk k ON ((o.kiosk_id = k.id)));


ALTER TABLE public.all_raw_orders OWNER TO dbservice;

--
-- Name: _all_orders; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public._all_orders AS
 SELECT all_raw_orders.order_id,
    all_raw_orders.first_name,
    all_raw_orders.last_name,
    all_raw_orders.kiosk_id,
    all_raw_orders.kiosk_title,
    all_raw_orders.email,
    all_raw_orders.amount_paid,
    all_raw_orders.payment_system,
    all_raw_orders.transaction_id,
    all_raw_orders.approval_code,
    all_raw_orders.status_code,
    all_raw_orders.status_message,
    all_raw_orders.status,
    all_raw_orders.batch_id,
    all_raw_orders.created,
    all_raw_orders.auth_amount,
    all_raw_orders.data_token,
    all_raw_orders.time_opened,
    all_raw_orders.time_closed,
    all_raw_orders.card_hash,
    all_raw_orders.state,
    all_raw_orders.archived,
    all_raw_orders.stamp,
    all_raw_orders.last_update,
    all_raw_orders.balance,
    all_raw_orders.delta,
    all_raw_orders.coupon_id,
    all_raw_orders.coupon,
    all_raw_orders.refund,
    all_raw_orders.receipt,
    all_raw_orders.campus_id,
    all_raw_orders.amount_list_price,
    all_raw_orders.notes,
    all_raw_orders.time_door_opened,
    all_raw_orders.time_door_closed,
    all_raw_orders.client_name,
    all_raw_orders.estd_num_users,
    all_raw_orders.ts,
    all_raw_orders.full_name,
    all_raw_orders.door_opened_secs,
    date_trunc('month'::text, all_raw_orders.ts) AS month,
    date_trunc('week'::text, all_raw_orders.ts) AS week,
    date_trunc('day'::text, all_raw_orders.ts) AS date,
    date_part('dow'::text, all_raw_orders.ts) AS dayofweek,
    date_trunc('hour'::text, all_raw_orders.ts) AS hour
   FROM public.all_raw_orders;


ALTER TABLE public._all_orders OWNER TO dbservice;

--
-- Name: all_orders; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.all_orders AS
 SELECT _all_orders.order_id,
    _all_orders.first_name,
    _all_orders.last_name,
    _all_orders.kiosk_id,
    _all_orders.kiosk_title,
    _all_orders.email,
    _all_orders.amount_paid,
    _all_orders.payment_system,
    _all_orders.transaction_id,
    _all_orders.approval_code,
    _all_orders.status_code,
    _all_orders.status_message,
    _all_orders.status,
    _all_orders.batch_id,
    _all_orders.created,
    _all_orders.auth_amount,
    _all_orders.data_token,
    _all_orders.time_opened,
    _all_orders.time_closed,
    _all_orders.card_hash,
    _all_orders.state,
    _all_orders.archived,
    _all_orders.stamp,
    _all_orders.last_update,
    _all_orders.balance,
    _all_orders.delta,
    _all_orders.coupon_id,
    _all_orders.coupon,
    _all_orders.refund,
    _all_orders.receipt,
    _all_orders.campus_id,
    _all_orders.amount_list_price,
    _all_orders.notes,
    _all_orders.time_door_opened,
    _all_orders.time_door_closed,
    _all_orders.client_name,
    _all_orders.estd_num_users,
    _all_orders.ts,
    _all_orders.full_name,
    _all_orders.door_opened_secs,
    _all_orders.month,
    _all_orders.week,
    _all_orders.date,
    _all_orders.dayofweek,
    _all_orders.hour,
    public.dowhour(_all_orders.hour) AS dowhour
   FROM public._all_orders;


ALTER TABLE public.all_orders OWNER TO dbservice;

--
-- Name: byte_products_fast; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_products_fast AS
 SELECT product.id,
    product.title,
    product.description,
    product.tiny_description,
    product.short_description,
    product.medium_description,
    product.long_description,
    product.price,
    product.cost,
    product.shelf_time,
    product.campus_id,
    product.image,
    product.image_time,
    product.last_update,
    product.archived,
    product.taxable,
    product.allergens,
    product.attribute_names,
    product.categories,
    product.category_names,
    product.vendor,
    product.source,
    product.notes,
    product.total_cal,
    product.num_servings,
    product.ingredients,
    product.calories,
    product.proteins,
    product.sugar,
    product.carbohydrates,
    product.fat,
    product.consumer_category,
    product.ws_case_size,
    product.kiosk_ship_qty,
    product.ws_case_cost,
    product.pick_station,
    product.fc_title,
    product.pricing_tier,
    product.width_space,
    product.height_space,
    product.depth_space,
    product.slotted_width,
    product.tag_volume,
    product.delivery_option,
    product.shelf_time AS shelf_life_days
   FROM pantry.product
  WHERE (product.campus_id = 87);


ALTER TABLE public.byte_products_fast OWNER TO dbservice;

--
-- Name: byte_products; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_products WITH (security_barrier='false') AS
 SELECT byte_products_fast.id,
    byte_products_fast.title,
    byte_products_fast.vendor,
    byte_products_fast.price,
    byte_products_fast.cost,
    byte_products_fast.shelf_time AS shelf_life_days,
    byte_products_fast.archived,
    byte_products_fast.attribute_names AS attributes,
    byte_products_fast.category_names AS categories,
    byte_products_fast.consumer_category,
    byte_products_fast.source,
    byte_products_fast.ws_case_size,
    byte_products_fast.kiosk_ship_qty,
    byte_products_fast.ws_case_cost,
    byte_products_fast.pick_station,
    byte_products_fast.allergens AS pantry_allergens,
    byte_products_fast.categories AS pantry_categories,
    byte_products_fast.fc_title
   FROM public.byte_products_fast;


ALTER TABLE public.byte_products OWNER TO dbservice;

--
-- Name: byte_label_product; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_label_product WITH (security_barrier='false') AS
 SELECT l.epc,
    l.order_id AS label_order_id,
    l.status AS label_status,
    l.price AS label_price,
    l.time_created,
    l.time_added,
    l.time_updated,
    to_timestamp((l.time_created)::double precision) AS ts_created,
    to_timestamp((l.time_added)::double precision) AS ts_added,
    to_timestamp((l.time_updated)::double precision) AS ts_updated,
    l.kiosk_id AS label_kiosk_id,
    p.id AS product_id,
    p.title AS product_title,
    p.archived AS product_archived,
    p.vendor AS product_vendor,
    p.price AS product_price,
    p.cost AS product_cost,
    p.shelf_life_days AS product_shelf_life_days,
    p.attributes AS product_attributes,
    p.categories AS product_categories,
    p.consumer_category,
    p.source AS product_source,
    p.fc_title
   FROM (pantry.label l
     JOIN public.byte_products p ON ((l.product_id = p.id)));


ALTER TABLE public.byte_label_product OWNER TO dbservice;

--
-- Name: byte_orders; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_orders AS
 SELECT all_orders.order_id,
    all_orders.first_name,
    all_orders.last_name,
    all_orders.kiosk_id,
    all_orders.kiosk_title,
    all_orders.email,
    all_orders.amount_paid,
    all_orders.payment_system,
    all_orders.transaction_id,
    all_orders.approval_code,
    all_orders.status_code,
    all_orders.status_message,
    all_orders.status,
    all_orders.batch_id,
    all_orders.created,
    all_orders.auth_amount,
    all_orders.data_token,
    all_orders.time_opened,
    all_orders.time_closed,
    all_orders.card_hash,
    all_orders.state,
    all_orders.archived,
    all_orders.stamp,
    all_orders.last_update,
    all_orders.balance,
    all_orders.delta,
    all_orders.coupon_id,
    all_orders.coupon,
    all_orders.refund,
    all_orders.receipt,
    all_orders.campus_id,
    all_orders.amount_list_price,
    all_orders.notes,
    all_orders.time_door_opened,
    all_orders.time_door_closed,
    all_orders.client_name,
    all_orders.estd_num_users,
    all_orders.ts,
    all_orders.full_name,
    all_orders.door_opened_secs,
    all_orders.month,
    all_orders.week,
    all_orders.date,
    all_orders.dayofweek,
    all_orders.hour,
    all_orders.dowhour
   FROM (public.all_orders all_orders
     JOIN pantry.kiosk kiosk ON ((all_orders.kiosk_id = kiosk.id)))
  WHERE ((all_orders.campus_id = 87) AND (kiosk.enable_reporting = 1));


ALTER TABLE public.byte_orders OWNER TO dbservice;

--
-- Name: byte_tickets; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_tickets AS
 SELECT byte_orders.order_id,
    byte_orders.first_name,
    byte_orders.last_name,
    byte_orders.kiosk_id,
    byte_orders.kiosk_title,
    byte_orders.email,
    byte_orders.amount_paid,
    byte_orders.payment_system,
    byte_orders.transaction_id,
    byte_orders.approval_code,
    byte_orders.status_code,
    byte_orders.status_message,
    byte_orders.status,
    byte_orders.batch_id,
    byte_orders.created,
    byte_orders.auth_amount,
    byte_orders.data_token,
    byte_orders.time_opened,
    byte_orders.time_closed,
    byte_orders.card_hash,
    byte_orders.state,
    byte_orders.archived,
    byte_orders.stamp,
    byte_orders.last_update,
    byte_orders.balance,
    byte_orders.delta,
    byte_orders.coupon_id,
    byte_orders.coupon,
    byte_orders.refund,
    byte_orders.receipt,
    byte_orders.campus_id,
    byte_orders.amount_list_price,
    byte_orders.notes,
    byte_orders.time_door_opened,
    byte_orders.time_door_closed,
    byte_orders.client_name,
    byte_orders.estd_num_users,
    byte_orders.ts,
    byte_orders.full_name,
    byte_orders.door_opened_secs,
    byte_orders.month,
    byte_orders.week,
    byte_orders.date,
    byte_orders.dayofweek,
    byte_orders.hour,
    byte_orders.dowhour,
    btrim(concat("left"(btrim((byte_orders.first_name)::text), 1), '.', btrim((byte_orders.last_name)::text))) AS uniq_user
   FROM public.byte_orders
  WHERE ((byte_orders.state)::text <> 'NonTrans'::text);


ALTER TABLE public.byte_tickets OWNER TO dbservice;

--
-- Name: byte_tickets_12weeks; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_tickets_12weeks AS
 SELECT byte_tickets.order_id,
    byte_tickets.first_name,
    byte_tickets.last_name,
    byte_tickets.kiosk_id,
    byte_tickets.kiosk_title,
    byte_tickets.email,
    byte_tickets.amount_paid,
    byte_tickets.payment_system,
    byte_tickets.transaction_id,
    byte_tickets.approval_code,
    byte_tickets.status_code,
    byte_tickets.status_message,
    byte_tickets.status,
    byte_tickets.batch_id,
    byte_tickets.created,
    byte_tickets.auth_amount,
    byte_tickets.data_token,
    byte_tickets.time_opened,
    byte_tickets.time_closed,
    byte_tickets.card_hash,
    byte_tickets.state,
    byte_tickets.archived,
    byte_tickets.stamp,
    byte_tickets.last_update,
    byte_tickets.balance,
    byte_tickets.delta,
    byte_tickets.coupon_id,
    byte_tickets.coupon,
    byte_tickets.refund,
    byte_tickets.receipt,
    byte_tickets.campus_id,
    byte_tickets.amount_list_price,
    byte_tickets.notes,
    byte_tickets.time_door_opened,
    byte_tickets.time_door_closed,
    byte_tickets.client_name,
    byte_tickets.estd_num_users,
    byte_tickets.ts,
    byte_tickets.full_name,
    byte_tickets.door_opened_secs,
    byte_tickets.month,
    byte_tickets.week,
    byte_tickets.date,
    byte_tickets.dayofweek,
    byte_tickets.hour,
    byte_tickets.dowhour,
    byte_tickets.uniq_user
   FROM public.byte_tickets
  WHERE (byte_tickets.ts > (now() - '84 days'::interval day));


ALTER TABLE public.byte_tickets_12weeks OWNER TO dbservice;

--
-- Name: byte_epcssold_12weeks; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_epcssold_12weeks AS
 SELECT o.order_id,
    o.first_name,
    o.last_name,
    o.kiosk_id,
    o.kiosk_title,
    o.email,
    o.amount_paid,
    o.payment_system,
    o.transaction_id,
    o.approval_code,
    o.status_code,
    o.status_message,
    o.status,
    o.batch_id,
    o.created,
    o.auth_amount,
    o.data_token,
    o.time_opened,
    o.time_closed,
    o.card_hash,
    o.state,
    o.archived,
    o.stamp,
    o.last_update,
    o.balance,
    o.delta,
    o.coupon_id,
    o.coupon,
    o.refund,
    o.receipt,
    o.campus_id,
    o.amount_list_price,
    o.notes,
    o.time_door_opened,
    o.time_door_closed,
    o.client_name,
    o.estd_num_users,
    o.ts,
    o.full_name,
    o.door_opened_secs,
    o.month,
    o.week,
    o.date,
    o.dayofweek,
    o.hour,
    o.dowhour,
    o.uniq_user,
    lp.epc,
    lp.label_order_id,
    lp.label_status,
    lp.label_price,
    lp.time_created,
    lp.time_added,
    lp.time_updated,
    lp.ts_created,
    lp.ts_added,
    lp.ts_updated,
    lp.label_kiosk_id,
    lp.product_id,
    lp.product_title,
    lp.product_archived,
    lp.product_vendor,
    lp.product_price,
    lp.product_cost,
    lp.product_shelf_life_days,
    lp.product_attributes,
    lp.product_categories,
    lp.consumer_category,
    lp.product_source,
    lp.fc_title
   FROM (public.byte_tickets_12weeks o
     JOIN public.byte_label_product lp ON (((lp.label_order_id)::text = (o.order_id)::text)))
  WHERE ((lp.label_status)::text = 'sold'::text);


ALTER TABLE public.byte_epcssold_12weeks OWNER TO dbservice;

--
-- Name: v_kiosk_sale_hourly; Type: VIEW; Schema: inm; Owner: dbservice
--

CREATE VIEW inm.v_kiosk_sale_hourly AS
 SELECT units_sold.kiosk_id,
    units_sold.dow,
    units_sold.hod,
    units_sold.units_sold,
    round((units_sold.units_sold / GREATEST(1.00, sum(units_sold.units_sold) OVER (PARTITION BY units_sold.kiosk_id))), 4) AS units_sold_normalized
   FROM ( SELECT k.kiosk_id,
            dow.dow,
            hod.hod,
            round(COALESCE(((s.units_sold)::numeric / 12.0), 0.00), 2) AS units_sold
           FROM (((( SELECT k_1.id AS kiosk_id
                   FROM pantry.kiosk k_1
                  WHERE ((k_1.campus_id = 87) AND (k_1.archived = 0) AND (k_1.enable_reporting = 1))) k
             CROSS JOIN ( SELECT generate_series.generate_series AS dow
                   FROM generate_series(0, 6) generate_series(generate_series)) dow)
             CROSS JOIN ( SELECT generate_series.generate_series AS hod
                   FROM generate_series(0, 23) generate_series(generate_series)) hod)
             LEFT JOIN ( SELECT byte_epcssold_12weeks.kiosk_id,
                    date_part('dow'::text, timezone('US/Pacific'::text, byte_epcssold_12weeks.ts)) AS dow,
                    date_part('hour'::text, timezone('US/Pacific'::text, byte_epcssold_12weeks.ts)) AS hod,
                    count(*) AS units_sold
                   FROM public.byte_epcssold_12weeks
                  GROUP BY byte_epcssold_12weeks.kiosk_id, (date_part('dow'::text, timezone('US/Pacific'::text, byte_epcssold_12weeks.ts))), (date_part('hour'::text, timezone('US/Pacific'::text, byte_epcssold_12weeks.ts)))
                  ORDER BY byte_epcssold_12weeks.kiosk_id, (date_part('dow'::text, timezone('US/Pacific'::text, byte_epcssold_12weeks.ts))), (date_part('hour'::text, timezone('US/Pacific'::text, byte_epcssold_12weeks.ts)))) s ON (((k.kiosk_id = s.kiosk_id) AND ((dow.dow)::double precision = s.dow) AND ((hod.hod)::double precision = s.hod))))
          ORDER BY k.kiosk_id, dow.dow, hod.hod) units_sold;


ALTER TABLE inm.v_kiosk_sale_hourly OWNER TO dbservice;

--
-- Name: route_stop; Type: TABLE; Schema: mixalot; Owner: dbservice
--

CREATE TABLE mixalot.route_stop (
    route_date_time timestamp(6) with time zone NOT NULL,
    driver_name character varying(200) NOT NULL,
    location_name character varying(200) NOT NULL,
    schedule_at timestamp(6) with time zone NOT NULL,
    longitude numeric(28,6),
    address character varying(200),
    latitude numeric(28,6),
    stop_number integer,
    order_number character varying(200),
    location_number integer
);


ALTER TABLE mixalot.route_stop OWNER TO dbservice;

--
-- Name: v_kiosk_demand_plan_ratio; Type: VIEW; Schema: inm; Owner: dbservice
--

CREATE VIEW inm.v_kiosk_demand_plan_ratio AS
 SELECT ksh.kiosk_id,
        CASE
            WHEN (rdt.d0_delivery = 1) THEN (ksh.d0_demand +
            CASE
                WHEN (rdt.d1_delivery = 0) THEN (ksh.d1_demand +
                CASE
                    WHEN (rdt.d2_delivery = 0) THEN (ksh.d2_demand +
                    CASE
                        WHEN (rdt.d3_delivery = 0) THEN (ksh.d3_demand +
                        CASE
                            WHEN (rdt.d4_delivery = 0) THEN ksh.d4_demand
                            ELSE (0)::numeric
                        END)
                        ELSE (0)::numeric
                    END)
                    ELSE (0)::numeric
                END)
                ELSE (0)::numeric
            END)
            ELSE (0)::numeric
        END AS d0_plan_demand_ratio,
        CASE
            WHEN (rdt.d1_delivery = 1) THEN (ksh.d1_demand +
            CASE
                WHEN (rdt.d2_delivery = 0) THEN (ksh.d2_demand +
                CASE
                    WHEN (rdt.d3_delivery = 0) THEN (ksh.d3_demand +
                    CASE
                        WHEN (rdt.d4_delivery = 0) THEN (ksh.d4_demand +
                        CASE
                            WHEN (rdt.d0_delivery = 0) THEN ksh.d0_demand
                            ELSE (0)::numeric
                        END)
                        ELSE (0)::numeric
                    END)
                    ELSE (0)::numeric
                END)
                ELSE (0)::numeric
            END)
            ELSE (0)::numeric
        END AS d1_plan_demand_ratio,
        CASE
            WHEN (rdt.d2_delivery = 1) THEN (ksh.d2_demand +
            CASE
                WHEN (rdt.d3_delivery = 0) THEN (ksh.d3_demand +
                CASE
                    WHEN (rdt.d4_delivery = 0) THEN (ksh.d4_demand +
                    CASE
                        WHEN (rdt.d1_delivery = 0) THEN (ksh.d1_demand +
                        CASE
                            WHEN (rdt.d2_delivery = 0) THEN ksh.d2_demand
                            ELSE (0)::numeric
                        END)
                        ELSE (0)::numeric
                    END)
                    ELSE (0)::numeric
                END)
                ELSE (0)::numeric
            END)
            ELSE (0)::numeric
        END AS d2_plan_demand_ratio,
        CASE
            WHEN (rdt.d3_delivery = 1) THEN (ksh.d3_demand +
            CASE
                WHEN (rdt.d4_delivery = 0) THEN (ksh.d4_demand +
                CASE
                    WHEN (rdt.d0_delivery = 0) THEN (ksh.d0_demand +
                    CASE
                        WHEN (rdt.d1_delivery = 0) THEN (ksh.d1_demand +
                        CASE
                            WHEN (rdt.d2_delivery = 0) THEN ksh.d2_demand
                            ELSE (0)::numeric
                        END)
                        ELSE (0)::numeric
                    END)
                    ELSE (0)::numeric
                END)
                ELSE (0)::numeric
            END)
            ELSE (0)::numeric
        END AS d3_plan_demand_ratio,
        CASE
            WHEN (rdt.d4_delivery = 1) THEN (ksh.d4_demand +
            CASE
                WHEN (rdt.d0_delivery = 0) THEN (ksh.d0_demand +
                CASE
                    WHEN (rdt.d1_delivery = 0) THEN (ksh.d1_demand +
                    CASE
                        WHEN (rdt.d2_delivery = 0) THEN (ksh.d2_demand +
                        CASE
                            WHEN (rdt.d3_delivery = 0) THEN ksh.d3_demand
                            ELSE (0)::numeric
                        END)
                        ELSE (0)::numeric
                    END)
                    ELSE (0)::numeric
                END)
                ELSE (0)::numeric
            END)
            ELSE (0)::numeric
        END AS d4_plan_demand_ratio
   FROM (( SELECT ksh_1.kiosk_id,
            sum(ksh_1.units_sold_normalized) FILTER (WHERE ((ksh_1.how >= 34) AND (ksh_1.how < 58))) AS d0_demand,
            sum(ksh_1.units_sold_normalized) FILTER (WHERE ((ksh_1.how >= 58) AND (ksh_1.how < 82))) AS d1_demand,
            sum(ksh_1.units_sold_normalized) FILTER (WHERE ((ksh_1.how >= 82) AND (ksh_1.how < 106))) AS d2_demand,
            sum(ksh_1.units_sold_normalized) FILTER (WHERE ((ksh_1.how >= 106) AND (ksh_1.how < 130))) AS d3_demand,
            sum(ksh_1.units_sold_normalized) FILTER (WHERE ((ksh_1.how >= 130) OR (ksh_1.how < 34))) AS d4_demand
           FROM ( SELECT ksh_2.kiosk_id,
                    ksh_2.dow,
                    ksh_2.hod,
                    ksh_2.units_sold,
                    ksh_2.units_sold_normalized,
                    ((24 * ksh_2.dow) + ksh_2.hod) AS how
                   FROM inm.v_kiosk_sale_hourly ksh_2) ksh_1
          GROUP BY ksh_1.kiosk_id) ksh
     LEFT JOIN ( SELECT rdt_1.kiosk_id,
            count(rdt_1.d) FILTER (WHERE (rdt_1.d = (0)::double precision)) AS d0_delivery,
            count(rdt_1.d) FILTER (WHERE (rdt_1.d = (1)::double precision)) AS d1_delivery,
            count(rdt_1.d) FILTER (WHERE (rdt_1.d = (2)::double precision)) AS d2_delivery,
            count(rdt_1.d) FILTER (WHERE (rdt_1.d = (3)::double precision)) AS d3_delivery,
            count(rdt_1.d) FILTER (WHERE (rdt_1.d = (4)::double precision)) AS d4_delivery
           FROM ( SELECT route_stop.location_number AS kiosk_id,
                    date_part('dow'::text, (timezone('US/Pacific'::text, route_stop.route_date_time) - ('11:00:00'::time without time zone)::interval)) AS d
                   FROM mixalot.route_stop
                  WHERE (date_trunc('week'::text, route_stop.route_date_time) = date_trunc('week'::text, now()))
                  ORDER BY route_stop.route_date_time, route_stop.schedule_at) rdt_1
          GROUP BY rdt_1.kiosk_id) rdt ON ((ksh.kiosk_id = rdt.kiosk_id)))
  ORDER BY ksh.kiosk_id;


ALTER TABLE inm.v_kiosk_demand_plan_ratio OWNER TO dbservice;

--
-- Name: v_kiosk_sku_enabled; Type: VIEW; Schema: inm; Owner: dbservice
--

CREATE VIEW inm.v_kiosk_sku_enabled AS
 SELECT k.kiosk_id,
    p.sku_group,
    p.sku,
    public.if((kpd.product_id IS NOT NULL), 0, 1) AS enabled
   FROM ((( SELECT k_1.id AS kiosk_id
           FROM pantry.kiosk k_1
          WHERE ((k_1.campus_id = 87) AND (k_1.archived = 0) AND (k_1.enable_reporting = 1))) k
     CROSS JOIN ( SELECT p_1.id AS sku,
            p_1.fc_title AS sku_group
           FROM pantry.product p_1
          WHERE ((p_1.campus_id = 87) AND (p_1.archived = 0) AND (p_1.fc_title IS NOT NULL) AND ((p_1.fc_title)::text <> 'N/A'::text))
          ORDER BY p_1.fc_title) p)
     LEFT JOIN inm.kiosk_product_disabled kpd ON (((k.kiosk_id = kpd.kiosk_id) AND (p.sku = kpd.product_id))))
  ORDER BY k.kiosk_id, p.sku_group, p.sku;


ALTER TABLE inm.v_kiosk_sku_enabled OWNER TO dbservice;

--
-- Name: v_kiosk_sku_group_stock_sale_spoil_history; Type: VIEW; Schema: inm; Owner: dbservice
--

CREATE VIEW inm.v_kiosk_sku_group_stock_sale_spoil_history AS
 SELECT t3.kiosk_id,
    t3.sku_group,
    round(avg(t3.stock_count), 2) AS stock_avg,
    round(stddev(t3.stock_count), 2) AS stock_std,
    round(avg(t3.sale_count), 2) AS sale_avg,
    round(stddev(t3.sale_count), 2) AS sale_std,
    round(avg(t3.spoil_count), 2) AS spoil_avg,
    round(stddev(t3.spoil_count), 2) AS spoil_std,
    round(avg(t3.week_stock), 2) AS week_stock_avg,
    round(stddev(t3.week_stock), 2) AS week_stock_std,
    round(avg(t3.week_sale), 2) AS week_sale_avg,
    round(stddev(t3.week_sale), 2) AS week_sale_std,
    round(avg(t3.week_spoil), 2) AS week_spoil_avg,
    round(stddev(t3.week_spoil), 2) AS week_spoil_std
   FROM ( SELECT t2.kiosk_id,
            t2.week,
            t2.sku_group,
            t2.stock_count,
            t2.sale_count,
            t2.spoil_count,
            sum(t2.stock_count) OVER (PARTITION BY t2.kiosk_id, t2.week) AS week_stock,
            sum(t2.sale_count) OVER (PARTITION BY t2.kiosk_id, t2.week) AS week_sale,
            sum(t2.spoil_count) OVER (PARTITION BY t2.kiosk_id, t2.week) AS week_spoil
           FROM ( SELECT t1.kiosk_id,
                    t1.week,
                    t1.sku_group,
                    sum(t1.stock_count) AS stock_count,
                    sum(t1.sale_count) AS sale_count,
                    sum(t1.spoil_count) AS spoil_count
                   FROM ( SELECT kk.kiosk_id,
                            kk.week,
                            pp.sku_group,
                            sss.product_id,
                            COALESCE(sss.stock_count, (0)::bigint) AS stock_count,
                            COALESCE(sss.sale_count, (0)::bigint) AS sale_count,
                            COALESCE(sss.spoil_count, (0)::bigint) AS spoil_count
                           FROM ((( SELECT k.id AS kiosk_id,
                                    (date_trunc('week'::text, generate_series((now() - '3 mons'::interval month), now(), '7 days'::interval)))::date AS week
                                   FROM pantry.kiosk k
                                  WHERE ((k.campus_id = 87) AND (k.archived = 0) AND (k.enable_reporting = 1) AND (k.enable_monitoring = 1))) kk
                             CROSS JOIN ( SELECT DISTINCT p.fc_title AS sku_group
                                   FROM pantry.product p
                                  WHERE ((p.campus_id = 87) AND (p.archived = 0) AND (p.fc_title IS NOT NULL) AND ((p.fc_title)::text <> 'N/A'::text))) pp)
                             LEFT JOIN ( SELECT COALESCE(stock.kiosk_id, sale.kiosk_id, spoil.kiosk_id) AS kiosk_id,
                                    COALESCE(stock.week, sale.week, spoil.week) AS week,
                                    COALESCE(stock.sku_group, sale.sku_group, spoil.sku_group) AS sku_group,
                                    COALESCE(stock.product_id, sale.product_id, spoil.product_id) AS product_id,
                                    COALESCE(stock.stock_count, (0)::bigint) AS stock_count,
                                    COALESCE(sale.sale_count, (0)::bigint) AS sale_count,
                                    COALESCE(spoil.spoil_count, (0)::bigint) AS spoil_count
                                   FROM ((( SELECT l.kiosk_id,
    p.fc_title AS sku_group,
    l.product_id,
    (date_trunc('week'::text, to_timestamp((l.time_updated)::double precision)))::date AS week,
    count(*) AS stock_count
   FROM (pantry.label l
     LEFT JOIN pantry.product p ON ((l.product_id = p.id)))
  WHERE ((to_timestamp((l.time_added)::double precision) > (now() - '3 mons'::interval month)) AND (p.campus_id = 87) AND (p.archived = 0) AND (p.fc_title IS NOT NULL) AND ((p.fc_title)::text <> 'N/A'::text))
  GROUP BY l.kiosk_id, p.fc_title, l.product_id, ((date_trunc('week'::text, to_timestamp((l.time_updated)::double precision)))::date)) stock
                                     FULL JOIN ( SELECT l.kiosk_id,
    p.fc_title AS sku_group,
    l.product_id,
    (date_trunc('week'::text, to_timestamp((l.time_updated)::double precision)))::date AS week,
    count(*) AS sale_count
   FROM (pantry.label l
     LEFT JOIN pantry.product p ON ((l.product_id = p.id)))
  WHERE ((to_timestamp((l.time_updated)::double precision) > (now() - '3 mons'::interval month)) AND ((l.status)::text = 'sold'::text) AND (l.order_id IS NOT NULL) AND (p.campus_id = 87) AND (p.archived = 0) AND (p.fc_title IS NOT NULL) AND ((p.fc_title)::text <> 'N/A'::text))
  GROUP BY l.kiosk_id, p.fc_title, l.product_id, ((date_trunc('week'::text, to_timestamp((l.time_updated)::double precision)))::date)) sale ON (((stock.kiosk_id = sale.kiosk_id) AND (stock.week = sale.week) AND ((stock.sku_group)::text = (sale.sku_group)::text) AND (stock.product_id = sale.product_id))))
                                     FULL JOIN ( SELECT l.kiosk_id,
    p.fc_title AS sku_group,
    l.product_id,
    (date_trunc('week'::text, to_timestamp((l.time_updated)::double precision)))::date AS week,
    count(*) AS spoil_count
   FROM (pantry.label l
     LEFT JOIN pantry.product p ON ((l.product_id = p.id)))
  WHERE ((to_timestamp((l.time_updated)::double precision) > (now() - '3 mons'::interval month)) AND ((l.status)::text = 'out'::text) AND ((l.order_id)::text ~~ 'RE%'::text) AND (p.campus_id = 87) AND (p.archived = 0) AND (p.fc_title IS NOT NULL) AND ((p.fc_title)::text <> 'N/A'::text))
  GROUP BY l.kiosk_id, p.fc_title, l.product_id, ((date_trunc('week'::text, to_timestamp((l.time_updated)::double precision)))::date)) spoil ON (((stock.kiosk_id = spoil.kiosk_id) AND (stock.week = spoil.week) AND ((stock.sku_group)::text = (spoil.sku_group)::text) AND (stock.product_id = spoil.product_id))))) sss ON (((kk.kiosk_id = sss.kiosk_id) AND (kk.week = sss.week) AND ((pp.sku_group)::text = (sss.sku_group)::text))))
                          ORDER BY kk.kiosk_id, kk.week, pp.sku_group) t1
                  GROUP BY t1.kiosk_id, t1.week, t1.sku_group) t2) t3
  GROUP BY t3.kiosk_id, t3.sku_group
  ORDER BY t3.kiosk_id, t3.sku_group;


ALTER TABLE inm.v_kiosk_sku_group_stock_sale_spoil_history OWNER TO dbservice;

--
-- Name: byte_tickets_3months; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_tickets_3months AS
 SELECT byte_tickets.order_id,
    byte_tickets.first_name,
    byte_tickets.last_name,
    byte_tickets.kiosk_id,
    byte_tickets.kiosk_title,
    byte_tickets.email,
    byte_tickets.amount_paid,
    byte_tickets.payment_system,
    byte_tickets.transaction_id,
    byte_tickets.approval_code,
    byte_tickets.status_code,
    byte_tickets.status_message,
    byte_tickets.status,
    byte_tickets.batch_id,
    byte_tickets.created,
    byte_tickets.auth_amount,
    byte_tickets.data_token,
    byte_tickets.time_opened,
    byte_tickets.time_closed,
    byte_tickets.card_hash,
    byte_tickets.state,
    byte_tickets.archived,
    byte_tickets.stamp,
    byte_tickets.last_update,
    byte_tickets.balance,
    byte_tickets.delta,
    byte_tickets.coupon_id,
    byte_tickets.coupon,
    byte_tickets.refund,
    byte_tickets.receipt,
    byte_tickets.campus_id,
    byte_tickets.amount_list_price,
    byte_tickets.notes,
    byte_tickets.time_door_opened,
    byte_tickets.time_door_closed,
    byte_tickets.client_name,
    byte_tickets.estd_num_users,
    byte_tickets.ts,
    byte_tickets.full_name,
    byte_tickets.door_opened_secs,
    byte_tickets.month,
    byte_tickets.week,
    byte_tickets.date,
    byte_tickets.dayofweek,
    byte_tickets.hour,
    byte_tickets.dowhour,
    byte_tickets.uniq_user
   FROM public.byte_tickets
  WHERE (byte_tickets.ts > (now() - '3 mons'::interval month));


ALTER TABLE public.byte_tickets_3months OWNER TO dbservice;

--
-- Name: byte_epcssold_3months; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_epcssold_3months AS
 SELECT o.order_id,
    o.first_name,
    o.last_name,
    o.kiosk_id,
    o.kiosk_title,
    o.email,
    o.amount_paid,
    o.payment_system,
    o.transaction_id,
    o.approval_code,
    o.status_code,
    o.status_message,
    o.status,
    o.batch_id,
    o.created,
    o.auth_amount,
    o.data_token,
    o.time_opened,
    o.time_closed,
    o.card_hash,
    o.state,
    o.archived,
    o.stamp,
    o.last_update,
    o.balance,
    o.delta,
    o.coupon_id,
    o.coupon,
    o.refund,
    o.receipt,
    o.campus_id,
    o.amount_list_price,
    o.notes,
    o.time_door_opened,
    o.time_door_closed,
    o.client_name,
    o.estd_num_users,
    o.ts,
    o.full_name,
    o.door_opened_secs,
    o.month,
    o.week,
    o.date,
    o.dayofweek,
    o.hour,
    o.dowhour,
    o.uniq_user,
    lp.epc,
    lp.label_order_id,
    lp.label_status,
    lp.label_price,
    lp.time_created,
    lp.time_added,
    lp.time_updated,
    lp.ts_created,
    lp.ts_added,
    lp.ts_updated,
    lp.label_kiosk_id,
    lp.product_id,
    lp.product_title,
    lp.product_archived,
    lp.product_vendor,
    lp.product_price,
    lp.product_cost,
    lp.product_shelf_life_days,
    lp.product_attributes,
    lp.product_categories,
    lp.consumer_category,
    lp.product_source
   FROM (public.byte_tickets_3months o
     JOIN public.byte_label_product lp ON (((lp.label_order_id)::text = (o.order_id)::text)))
  WHERE ((lp.label_status)::text = 'sold'::text);


ALTER TABLE public.byte_epcssold_3months OWNER TO dbservice;

--
-- Name: v_kiosk_sku_group_velocity_demand_week; Type: VIEW; Schema: inm; Owner: dbservice
--

CREATE VIEW inm.v_kiosk_sku_group_velocity_demand_week AS
 SELECT kc.kiosk_id,
    sg.id AS sku_group_id,
    (sg.fc_title)::text AS sku_group,
    COALESCE(dwwom.sample_size, (0)::bigint) AS sample_size,
    COALESCE(dwwom.preference, 0.00) AS preference,
    max(COALESCE(dwwom.ws_avg, 0.00)) OVER (PARTITION BY kc.kiosk_id) AS ws_avg,
    max(COALESCE(dwwom.ws_std, 0.00)) OVER (PARTITION BY kc.kiosk_id) AS ws_std,
    max(COALESCE(dwwom.ws_max, 0.00)) OVER (PARTITION BY kc.kiosk_id) AS ws_max,
    max(COALESCE(dwwom.ws_live, (0)::bigint)) OVER (PARTITION BY kc.kiosk_id) AS ws_live,
    kc.start_level AS kc_start_level,
    kc.min_level AS kc_min_level,
    kc.manual_multiplier AS kc_manual_multiplier,
    sgc.default_level AS sgc_default_level,
    sgc.scale AS sgc_scale,
    COALESCE(ksms.scale, 1.00) AS ksms_scale,
    round((((((kc.start_level * kc.manual_multiplier) * sgc.scale) * COALESCE(ksms.scale, 1.00)) * sgc.scale) * sgc.default_level), 2) AS start_count,
    round((((((kc.min_level * kc.manual_multiplier) * sgc.scale) * COALESCE(ksms.scale, 1.00)) * sgc.scale) * sgc.default_level), 2) AS min_count,
    round((((COALESCE(dwwom.preference, 0.00) * kc.manual_multiplier) * sgc.scale) * COALESCE(ksms.scale, 1.00)), 2) AS scaled_preference,
    round(sum((((COALESCE(dwwom.preference, 0.00) * kc.manual_multiplier) * sgc.scale) * COALESCE(ksms.scale, 1.00))) OVER (PARTITION BY kc.kiosk_id), 2) AS scaled_preference_total,
    round((COALESCE(dwwom.ws_max, 0.00) * ((((COALESCE(dwwom.preference, 0.00) * kc.manual_multiplier) * sgc.scale) * COALESCE(ksms.scale, 1.00)) / GREATEST(0.01, sum((((COALESCE(dwwom.preference, 0.00) * kc.manual_multiplier) * sgc.scale) * COALESCE(ksms.scale, 1.00))) OVER (PARTITION BY kc.kiosk_id)))), 2) AS preference_count
   FROM ((((inm.sku_group sg
     CROSS JOIN inm.kiosk_control kc)
     LEFT JOIN inm.kiosk_sku_group_manual_scale ksms ON (((ksms.kiosk_id = kc.kiosk_id) AND (ksms.sku_group_id = sg.id))))
     LEFT JOIN inm.sku_group_control sgc ON ((sgc.sku_group_id = sg.id)))
     LEFT JOIN ( SELECT t4.kiosk_id,
            t4.sku_group,
            t4.sample_size,
            t4.dt_avg,
            t4.dt_std,
            t4.w_departure_time,
            t4.preference,
            t6.ws_avg,
            t6.ws_std,
            t6.ws_max,
            t6.ws_live
           FROM (( SELECT t3.kiosk_id,
                    t3.sku_group,
                    count(t3.purchase_index) AS sample_size,
                    round(avg(t3.departure_time), 2) AS dt_avg,
                    COALESCE(round(stddev(t3.departure_time), 2), (0)::numeric) AS dt_std,
                    round((sum((t3.departure_time * (t3.w)::numeric)) / (sum(t3.w))::numeric), 2) AS w_departure_time,
                    LEAST(round((1.00 / (sum((t3.departure_time * (t3.w)::numeric)) / (sum(t3.w))::numeric)), 2), 0.20) AS preference
                   FROM ( SELECT t2.kiosk_id,
                            t2.sku_group,
                            t2.time_stocked,
                            t2.time_sold,
                            t2.purchase_index,
                            t2.last_sale,
                            t2.last_purchase_index,
                            GREATEST(COALESCE(round((((t2.time_sold - GREATEST(t2.last_sale, t2.time_stocked)))::numeric / (3600)::numeric), 2), 50.00), 1.00) AS departure_time,
                            0 AS qty_sold,
                            1 AS w
                           FROM ( SELECT t1.kiosk_id,
                                    t1.sku_group,
                                    t1.time_stocked,
                                    t1.time_sold,
                                    t1.purchase_index,
                                    lag(t1.time_sold, 1) OVER (PARTITION BY t1.kiosk_id, t1.sku_group ORDER BY t1.time_sold) AS last_sale,
                                    lag(t1.purchase_index, 1) OVER (PARTITION BY t1.kiosk_id, t1.sku_group ORDER BY t1.time_sold) AS last_purchase_index
                                   FROM ( SELECT k.kiosk_id,
    p.sku_group,
    l.time_stocked,
    l.time_sold,
    l.purchase_index
   FROM ((( SELECT k_1.id AS kiosk_id
     FROM pantry.kiosk k_1
    WHERE ((k_1.campus_id = 87) AND (k_1.archived = 0) AND (k_1.enable_reporting = 1))) k
     CROSS JOIN ( SELECT DISTINCT p_1.fc_title AS sku_group
     FROM pantry.product p_1
    WHERE ((p_1.campus_id = 87) AND (p_1.archived = 0) AND (p_1.fc_title IS NOT NULL) AND ((p_1.fc_title)::text <> 'N/A'::text))
    ORDER BY p_1.fc_title) p)
     LEFT JOIN ( SELECT l_1.kiosk_id,
      p_1.fc_title AS sku_group,
      l_1.time_created AS time_stocked,
      l_1.time_updated AS time_sold,
      row_number() OVER (PARTITION BY l_1.kiosk_id ORDER BY l_1.time_updated) AS purchase_index
     FROM (pantry.label l_1
       JOIN pantry.product p_1 ON ((l_1.product_id = p_1.id)))
    WHERE ((l_1.kiosk_id IS NOT NULL) AND ((l_1.status)::text = 'sold'::text) AND (timezone('US/Pacific'::text, to_timestamp((l_1.time_updated)::double precision)) > (date_trunc('week'::text, CURRENT_TIMESTAMP) - '168 days'::interval)) AND (p_1.campus_id = 87) AND (p_1.archived = 0) AND (p_1.fc_title IS NOT NULL))) l ON (((k.kiosk_id = l.kiosk_id) AND ((p.sku_group)::text = (l.sku_group)::text))))
  ORDER BY k.kiosk_id, p.sku_group, l.purchase_index) t1) t2) t3
                  GROUP BY t3.kiosk_id, t3.sku_group) t4
             JOIN ( SELECT t5.kiosk_id,
                    round(avg(t5.units_sold), 2) AS ws_avg,
                    round(stddev(t5.units_sold), 2) AS ws_std,
                    round((max(t5.units_sold))::numeric, 2) AS ws_max,
                    count(t5.units_sold) AS ws_live
                   FROM ( SELECT concat((kk.kiosk_id)::character varying(4), ' ', kk.woy) AS key,
                            kk.kiosk_id,
                            kk.woy,
                            ss.units_sold
                           FROM (( SELECT k.id AS kiosk_id,
                                    generate_series(1, 52) AS woy
                                   FROM pantry.kiosk k
                                  WHERE ((k.campus_id = 87) AND (k.archived = 0) AND (k.enable_reporting = 1) AND (k.enable_monitoring = 1))) kk
                             LEFT JOIN ( SELECT s.kiosk_id,
                                    date_part('week'::text, s.ts) AS woy,
                                    count(*) AS units_sold
                                   FROM public.byte_epcssold_3months s
                                  GROUP BY s.kiosk_id, (date_part('week'::text, s.ts))) ss ON (((kk.kiosk_id = ss.kiosk_id) AND ((kk.woy)::double precision = ss.woy))))
                          ORDER BY ss.kiosk_id, ss.woy) t5
                  GROUP BY t5.kiosk_id
                  ORDER BY t5.kiosk_id) t6 ON ((t4.kiosk_id = t6.kiosk_id)))) dwwom ON (((dwwom.kiosk_id = kc.kiosk_id) AND ((dwwom.sku_group)::text = (sg.fc_title)::text))));


ALTER TABLE inm.v_kiosk_sku_group_velocity_demand_week OWNER TO dbservice;

--
-- Name: v_kiosk_sku_velocity; Type: VIEW; Schema: inm; Owner: dbservice
--

CREATE VIEW inm.v_kiosk_sku_velocity AS
 SELECT t3.kiosk_id,
    t3.sku_group,
    t3.sku,
    t3.name,
    count(t3.purchase_index) AS sample_size,
    round(avg(t3.departure_time), 2) AS dt_avg,
    COALESCE(round(stddev(t3.departure_time), 2), (0)::numeric) AS dt_std,
    round((sum((t3.departure_time * (t3.w)::numeric)) / (sum(t3.w))::numeric), 2) AS w_departure_time,
    LEAST(round((1.00 / (sum((t3.departure_time * (t3.w)::numeric)) / (sum(t3.w))::numeric)), 2), 0.20) AS preference
   FROM ( SELECT t2.kiosk_id,
            t2.sku_group,
            t2.sku,
            t2.name,
            t2.time_stocked,
            t2.time_sold,
            t2.purchase_index,
            t2.last_sale,
            t2.last_purchase_index,
            GREATEST(COALESCE(round((((t2.time_sold - GREATEST(t2.last_sale, t2.time_stocked)))::numeric / (3600)::numeric), 2), 50.00), 1.00) AS departure_time,
            0 AS qty_sold,
            1 AS w
           FROM ( SELECT t1.kiosk_id,
                    t1.sku_group,
                    t1.sku,
                    t1.name,
                    t1.time_stocked,
                    t1.time_sold,
                    t1.purchase_index,
                    lag(t1.time_sold, 1) OVER (PARTITION BY t1.kiosk_id, t1.sku ORDER BY t1.time_sold) AS last_sale,
                    lag(t1.purchase_index, 1) OVER (PARTITION BY t1.kiosk_id, t1.sku ORDER BY t1.time_sold) AS last_purchase_index
                   FROM ( SELECT k.kiosk_id,
                            p.sku_group,
                            p.sku,
                            p.name,
                            l.time_stocked,
                            l.time_sold,
                            l.purchase_index
                           FROM ((( SELECT k_1.id AS kiosk_id
                                   FROM pantry.kiosk k_1
                                  WHERE ((k_1.campus_id = 87) AND (k_1.archived = 0) AND (k_1.enable_reporting = 1))) k
                             CROSS JOIN ( SELECT p_1.fc_title AS sku_group,
                                    p_1.id AS sku,
                                    p_1.title AS name
                                   FROM pantry.product p_1
                                  WHERE ((p_1.campus_id = 87) AND (p_1.archived = 0) AND ((p_1.fc_title)::text <> 'N/A'::text) AND (p_1.fc_title IS NOT NULL))
                                  ORDER BY p_1.fc_title, p_1.id) p)
                             LEFT JOIN ( SELECT l_1.kiosk_id,
                                    p_1.fc_title AS sku_group,
                                    p_1.id AS sku,
                                    l_1.time_created AS time_stocked,
                                    l_1.time_updated AS time_sold,
                                    row_number() OVER (PARTITION BY l_1.kiosk_id ORDER BY l_1.time_updated) AS purchase_index
                                   FROM (pantry.label l_1
                                     JOIN pantry.product p_1 ON ((l_1.product_id = p_1.id)))
                                  WHERE ((l_1.kiosk_id IS NOT NULL) AND ((l_1.status)::text = 'sold'::text) AND (timezone('US/Pacific'::text, to_timestamp((l_1.time_updated)::double precision)) > (date_trunc('week'::text, CURRENT_TIMESTAMP) - '168 days'::interval)) AND (p_1.campus_id = 87) AND (p_1.archived = 0) AND ((p_1.fc_title)::text <> 'N/A'::text) AND (p_1.fc_title IS NOT NULL))) l ON (((k.kiosk_id = l.kiosk_id) AND (p.sku = l.sku))))
                          ORDER BY k.kiosk_id, p.sku_group, p.sku, l.purchase_index) t1) t2) t3
  GROUP BY t3.kiosk_id, t3.sku_group, t3.sku, t3.name
  ORDER BY t3.kiosk_id, t3.sku_group, t3.sku;


ALTER TABLE inm.v_kiosk_sku_velocity OWNER TO dbservice;

--
-- Name: v_kiosk_sku_group_sku_stats; Type: VIEW; Schema: inm; Owner: dbservice
--

CREATE VIEW inm.v_kiosk_sku_group_sku_stats AS
 SELECT enabled.kiosk_id,
    enabled.sku_group,
    demand.sku_group_id,
    enabled.sku,
    velocity.name,
    enabled.enabled,
    velocity.sample_size AS sku_sample_size,
    velocity.w_departure_time AS sku_departure_time,
    velocity.preference AS sku_preference,
    demand.sample_size AS sku_group_sample_size,
    demand.preference AS sku_group_preference,
    demand.kc_start_level AS kiosk_start_level,
    demand.kc_min_level AS kiosk_min_level,
    demand.kc_manual_multiplier AS kiosk_manual_multiplier,
    demand.sgc_default_level AS sku_group_default_level,
    demand.sgc_scale AS sku_group_scale,
    demand.ksms_scale AS kiosk_sku_group_scale,
    demand.start_count AS sku_group_start_count,
    demand.min_count AS sku_group_min_count,
    demand.preference_count AS sku_group_preference_count,
    history.stock_avg AS sku_group_stock_avg,
    history.stock_std AS sku_group_stock_std,
    history.sale_avg AS sku_group_sale_avg,
    history.sale_std AS sku_group_sale_std,
    history.spoil_avg AS sku_group_spoil_avg,
    history.spoil_std AS sku_group_spoil_std,
    demand.ws_live AS kiosk_weeks_live,
    demand.ws_max AS kiosk_sale_max,
    history.week_stock_avg AS kiosk_stock_avg,
    history.week_stock_std AS kiosk_stock_std,
    history.week_sale_avg AS kiosk_sale_avg,
    history.week_sale_std AS kiosk_sale_std,
    history.week_spoil_avg AS kiosk_spoil_avg,
    history.week_spoil_std AS kiosk_spoil_std,
    plan.d0_plan_demand_ratio,
    plan.d1_plan_demand_ratio,
    plan.d2_plan_demand_ratio,
    plan.d3_plan_demand_ratio,
    plan.d4_plan_demand_ratio
   FROM ((((inm.v_kiosk_sku_enabled enabled
     LEFT JOIN inm.v_kiosk_sku_velocity velocity ON (((enabled.kiosk_id = velocity.kiosk_id) AND (enabled.sku = velocity.sku))))
     LEFT JOIN inm.v_kiosk_sku_group_velocity_demand_week demand ON (((enabled.kiosk_id = demand.kiosk_id) AND ((enabled.sku_group)::text = demand.sku_group))))
     LEFT JOIN inm.v_kiosk_sku_group_stock_sale_spoil_history history ON (((enabled.kiosk_id = history.kiosk_id) AND ((enabled.sku_group)::text = (history.sku_group)::text))))
     LEFT JOIN inm.v_kiosk_demand_plan_ratio plan ON ((enabled.kiosk_id = plan.kiosk_id)))
  ORDER BY enabled.kiosk_id, enabled.sku_group, enabled.sku;


ALTER TABLE inm.v_kiosk_sku_group_sku_stats OWNER TO dbservice;

--
-- Name: v_warehouse_ordering_rec; Type: VIEW; Schema: inm; Owner: dbservice
--

CREATE VIEW inm.v_warehouse_ordering_rec AS
 SELECT stats.sku_group,
    stats.sku,
    stats.name,
    stats.vendor,
    ceiling(sum((stats.d0_plan_demand_ratio * (stats.sku_demand + stats.sku_overstock)))) AS su,
    ceiling(sum((stats.d1_plan_demand_ratio * (stats.sku_demand + stats.sku_overstock)))) AS mo,
    ceiling(sum((stats.d2_plan_demand_ratio * (stats.sku_demand + stats.sku_overstock)))) AS tu,
    ceiling(sum((stats.d3_plan_demand_ratio * (stats.sku_demand + stats.sku_overstock)))) AS we,
    ceiling(sum((stats.d4_plan_demand_ratio * (stats.sku_demand + stats.sku_overstock)))) AS th,
    ceiling(sum(stats.sku_demand)) AS demand_week,
    ceiling(sum(stats.sku_overstock)) AS overstock_week,
    max(stats.sku_shelf_time) AS shelf_time
   FROM ( SELECT stats_1.kiosk_id,
            stats_1.sku_group,
            stats_1.sku_group_id,
            stats_1.sku,
            stats_1.name,
            stats_1.enabled,
            stats_1.sku_sample_size,
            stats_1.sku_departure_time,
            stats_1.sku_preference,
            stats_1.sku_group_sample_size,
            stats_1.sku_group_preference,
            stats_1.kiosk_start_level,
            stats_1.kiosk_min_level,
            stats_1.kiosk_manual_multiplier,
            stats_1.sku_group_default_level,
            stats_1.sku_group_scale,
            stats_1.kiosk_sku_group_scale,
            stats_1.sku_group_start_count,
            stats_1.sku_group_min_count,
            stats_1.sku_group_preference_count,
            stats_1.sku_group_stock_avg,
            stats_1.sku_group_stock_std,
            stats_1.sku_group_sale_avg,
            stats_1.sku_group_sale_std,
            stats_1.sku_group_spoil_avg,
            stats_1.sku_group_spoil_std,
            stats_1.kiosk_weeks_live,
            stats_1.kiosk_sale_max,
            stats_1.kiosk_stock_avg,
            stats_1.kiosk_stock_std,
            stats_1.kiosk_sale_avg,
            stats_1.kiosk_sale_std,
            stats_1.kiosk_spoil_avg,
            stats_1.kiosk_spoil_std,
            stats_1.d0_plan_demand_ratio,
            stats_1.d1_plan_demand_ratio,
            stats_1.d2_plan_demand_ratio,
            stats_1.d3_plan_demand_ratio,
            stats_1.d4_plan_demand_ratio,
            stats_1.vendor,
            stats_1.sku_shelf_time,
            stats_1.sku_pref_total_kiosk_sku_group,
            stats_1.sku_group_demand,
            stats_1.sku_group_overstock,
            round(public.if((stats_1.sku_pref_total_kiosk_sku_group <> (0)::numeric), (((stats_1.sku_group_demand * (stats_1.enabled)::numeric) * stats_1.sku_preference) / stats_1.sku_pref_total_kiosk_sku_group), 0.00), 2) AS sku_demand,
            round(public.if((stats_1.sku_pref_total_kiosk_sku_group <> (0)::numeric), ((((LEAST(1.00, (7.00 / (stats_1.sku_shelf_time)::numeric)) * stats_1.sku_group_overstock) * (stats_1.enabled)::numeric) * stats_1.sku_preference) / stats_1.sku_pref_total_kiosk_sku_group), 0.00), 2) AS sku_overstock
           FROM ( SELECT stats_2.kiosk_id,
                    stats_2.sku_group,
                    stats_2.sku_group_id,
                    stats_2.sku,
                    stats_2.name,
                    stats_2.enabled,
                    stats_2.sku_sample_size,
                    stats_2.sku_departure_time,
                    stats_2.sku_preference,
                    stats_2.sku_group_sample_size,
                    stats_2.sku_group_preference,
                    stats_2.kiosk_start_level,
                    stats_2.kiosk_min_level,
                    stats_2.kiosk_manual_multiplier,
                    stats_2.sku_group_default_level,
                    stats_2.sku_group_scale,
                    stats_2.kiosk_sku_group_scale,
                    stats_2.sku_group_start_count,
                    stats_2.sku_group_min_count,
                    stats_2.sku_group_preference_count,
                    stats_2.sku_group_stock_avg,
                    stats_2.sku_group_stock_std,
                    stats_2.sku_group_sale_avg,
                    stats_2.sku_group_sale_std,
                    stats_2.sku_group_spoil_avg,
                    stats_2.sku_group_spoil_std,
                    stats_2.kiosk_weeks_live,
                    stats_2.kiosk_sale_max,
                    stats_2.kiosk_stock_avg,
                    stats_2.kiosk_stock_std,
                    stats_2.kiosk_sale_avg,
                    stats_2.kiosk_sale_std,
                    stats_2.kiosk_spoil_avg,
                    stats_2.kiosk_spoil_std,
                    stats_2.d0_plan_demand_ratio,
                    stats_2.d1_plan_demand_ratio,
                    stats_2.d2_plan_demand_ratio,
                    stats_2.d3_plan_demand_ratio,
                    stats_2.d4_plan_demand_ratio,
                    product.vendor,
                    product.shelf_time AS sku_shelf_time,
                    sum(((stats_2.enabled)::numeric * stats_2.sku_preference)) OVER (PARTITION BY stats_2.kiosk_id, stats_2.sku_group) AS sku_pref_total_kiosk_sku_group,
                    stats_2.sku_group_preference_count AS sku_group_demand,
                    GREATEST((public.if((stats_2.kiosk_weeks_live <= 4), GREATEST(stats_2.sku_group_start_count, stats_2.sku_group_preference_count), GREATEST(stats_2.sku_group_min_count, stats_2.sku_group_preference_count)) - stats_2.sku_group_preference_count), 0.00) AS sku_group_overstock
                   FROM (inm.v_kiosk_sku_group_sku_stats stats_2
                     LEFT JOIN pantry.product product ON ((stats_2.sku = product.id)))) stats_1) stats
  GROUP BY stats.sku_group, stats.sku, stats.name, stats.vendor
  ORDER BY stats.sku_group, stats.vendor;


ALTER TABLE inm.v_warehouse_ordering_rec OWNER TO dbservice;

--
-- Name: view_sku_sku_group; Type: VIEW; Schema: inm; Owner: dbservice
--

CREATE VIEW inm.view_sku_sku_group AS
 SELECT p.id AS product_id,
    p.title,
    sga.id AS sku_group_id,
    p.fc_title
   FROM (pantry.product p
     JOIN inm.sku_group_attribute sga ON (((p.fc_title)::text = (sga.title)::text)))
  WHERE ((p.campus_id = 87) AND (p.fc_title IS NOT NULL) AND (p.archived = 0));


ALTER TABLE inm.view_sku_sku_group OWNER TO dbservice;

--
-- Name: inm_sku_velocity; Type: VIEW; Schema: mixalot; Owner: dbservice
--

CREATE VIEW mixalot.inm_sku_velocity AS
 SELECT t3.kiosk_id,
    t3.sku_group,
    t3.sku,
    t3.name,
    count(t3.purchase_index) AS sample_size,
    round(avg(t3.departure_time), 2) AS dt_avg,
    COALESCE(round(stddev(t3.departure_time), 2), (0)::numeric) AS dt_std,
    round((sum((t3.departure_time * (t3.w)::numeric)) / (sum(t3.w))::numeric), 2) AS w_departure_time,
    LEAST(round((1.00 / (sum((t3.departure_time * (t3.w)::numeric)) / (sum(t3.w))::numeric)), 2), 0.20) AS preference
   FROM ( SELECT t2.kiosk_id,
            t2.sku_group,
            t2.sku,
            t2.name,
            t2.time_stocked,
            t2.time_sold,
            t2.purchase_index,
            t2.last_sale,
            t2.last_purchase_index,
            GREATEST(COALESCE(round((((t2.time_sold - GREATEST(t2.last_sale, t2.time_stocked)))::numeric / (3600)::numeric), 2), 50.00), 1.00) AS departure_time,
            0 AS qty_sold,
            1 AS w
           FROM ( SELECT t1.kiosk_id,
                    t1.sku_group,
                    t1.sku,
                    t1.name,
                    t1.time_stocked,
                    t1.time_sold,
                    t1.purchase_index,
                    lag(t1.time_sold, 1) OVER (PARTITION BY t1.kiosk_id, t1.sku ORDER BY t1.time_sold) AS last_sale,
                    lag(t1.purchase_index, 1) OVER (PARTITION BY t1.kiosk_id, t1.sku ORDER BY t1.time_sold) AS last_purchase_index
                   FROM ( SELECT k.kiosk_id,
                            p.sku_group,
                            p.sku,
                            p.name,
                            l.time_stocked,
                            l.time_sold,
                            l.purchase_index
                           FROM ((( SELECT k_1.id AS kiosk_id
                                   FROM pantry.kiosk k_1
                                  WHERE ((k_1.campus_id = 87) AND (k_1.archived = 0) AND (k_1.enable_reporting = 1))) k
                             CROSS JOIN ( SELECT p_1.fc_title AS sku_group,
                                    p_1.id AS sku,
                                    p_1.title AS name
                                   FROM pantry.product p_1
                                  WHERE ((p_1.campus_id = 87) AND (p_1.archived = 0) AND ((p_1.fc_title)::text <> 'N/A'::text) AND (p_1.fc_title IS NOT NULL))
                                  ORDER BY p_1.fc_title, p_1.id) p)
                             LEFT JOIN ( SELECT l_1.kiosk_id,
                                    p_1.fc_title AS sku_group,
                                    p_1.id AS sku,
                                    l_1.time_created AS time_stocked,
                                    l_1.time_updated AS time_sold,
                                    row_number() OVER (PARTITION BY l_1.kiosk_id ORDER BY l_1.time_updated) AS purchase_index
                                   FROM (pantry.label l_1
                                     JOIN pantry.product p_1 ON ((l_1.product_id = p_1.id)))
                                  WHERE ((l_1.kiosk_id IS NOT NULL) AND ((l_1.status)::text = 'sold'::text) AND (timezone('US/Pacific'::text, to_timestamp((l_1.time_updated)::double precision)) > (date_trunc('week'::text, CURRENT_TIMESTAMP) - '168 days'::interval)) AND (p_1.campus_id = 87) AND (p_1.archived = 0) AND ((p_1.fc_title)::text <> 'N/A'::text) AND (p_1.fc_title IS NOT NULL))) l ON (((k.kiosk_id = l.kiosk_id) AND (p.sku = l.sku))))
                          ORDER BY k.kiosk_id, p.sku_group, p.sku, l.purchase_index) t1) t2) t3
  GROUP BY t3.kiosk_id, t3.sku_group, t3.sku, t3.name
  ORDER BY t3.kiosk_id, t3.sku_group, t3.sku;


ALTER TABLE mixalot.inm_sku_velocity OWNER TO dbservice;

--
-- Name: inm_warehouse_sku_enabled; Type: VIEW; Schema: mixalot; Owner: dbservice
--

CREATE VIEW mixalot.inm_warehouse_sku_enabled AS
 SELECT p.sku,
    p.name,
    p.sku_group,
    1 AS scale
   FROM (( SELECT p_1.fc_title AS sku_group,
            p_1.id AS sku,
            p_1.title AS name
           FROM pantry.product p_1
          WHERE ((p_1.campus_id = 87) AND (p_1.archived = 0) AND ((p_1.fc_title)::text <> 'N/A'::text) AND (p_1.fc_title IS NOT NULL))
          ORDER BY p_1.fc_title, p_1.id) p
     LEFT JOIN ( SELECT p_1.id AS sku,
            count(*) AS units_sold
           FROM (pantry.label l_1
             JOIN pantry.product p_1 ON ((l_1.product_id = p_1.id)))
          WHERE ((l_1.kiosk_id IS NOT NULL) AND ((l_1.status)::text = 'sold'::text) AND (timezone('US/Pacific'::text, to_timestamp((l_1.time_updated)::double precision)) > (date_trunc('week'::text, CURRENT_TIMESTAMP) - '28 days'::interval)) AND (p_1.campus_id = 87) AND (p_1.archived = 0) AND ((p_1.fc_title)::text <> 'N/A'::text) AND (p_1.fc_title IS NOT NULL))
          GROUP BY p_1.id) l ON ((p.sku = l.sku)));


ALTER TABLE mixalot.inm_warehouse_sku_enabled OWNER TO dbservice;

--
-- Name: warehouse_ordering; Type: VIEW; Schema: inm; Owner: dbservice
--

CREATE VIEW inm.warehouse_ordering AS
 SELECT t9.sku_group,
    t9.sku,
    t9.name,
    sum(t9.su_plan_demand_qty) AS su,
    sum(t9.mo_plan_demand_qty) AS mo,
    sum(t9.tu_plan_demand_qty) AS tu,
    sum(t9.we_plan_demand_qty) AS we,
    sum(t9.th_plan_demand_qty) AS th
   FROM ( SELECT t8.kiosk_id,
            t8.sku_group,
            t8.sku,
            t8.name,
            COALESCE(round(
                CASE
                    WHEN (t8.preference_sum > (0)::numeric) THEN ((t8.preference_scale / t8.preference_sum) * t8.d1_plan_demand_qty)
                    ELSE 0.00
                END, 2), 0.00) AS su_plan_demand_qty,
            COALESCE(round(
                CASE
                    WHEN (t8.preference_sum > (0)::numeric) THEN ((t8.preference_scale / t8.preference_sum) * t8.d2_plan_demand_qty)
                    ELSE 0.00
                END, 2), 0.00) AS mo_plan_demand_qty,
            COALESCE(round(
                CASE
                    WHEN (t8.preference_sum > (0)::numeric) THEN ((t8.preference_scale / t8.preference_sum) * t8.d3_plan_demand_qty)
                    ELSE 0.00
                END, 2), 0.00) AS tu_plan_demand_qty,
            COALESCE(round(
                CASE
                    WHEN (t8.preference_sum > (0)::numeric) THEN ((t8.preference_scale / t8.preference_sum) * t8.d4_plan_demand_qty)
                    ELSE 0.00
                END, 2), 0.00) AS we_plan_demand_qty,
            COALESCE(round(
                CASE
                    WHEN (t8.preference_sum > (0)::numeric) THEN ((t8.preference_scale / t8.preference_sum) * t8.d5_plan_demand_qty)
                    ELSE 0.00
                END, 2), 0.00) AS th_plan_demand_qty
           FROM ( SELECT t7.kiosk_id,
                    t7.sku_group,
                    t7.sku,
                    t7.name,
                    t7.sample_size,
                    t7.dt_avg,
                    t7.dt_std,
                    t7.w_departure_time,
                    t7.preference,
                    t7.scale,
                    t7.week_demand_qty,
                    t7.d1_plan_demand_qty,
                    t7.d2_plan_demand_qty,
                    t7.d3_plan_demand_qty,
                    t7.d4_plan_demand_qty,
                    t7.d5_plan_demand_qty,
                    round((t7.preference * (t7.scale)::numeric), 2) AS preference_scale,
                    sum((t7.preference * (t7.scale)::numeric)) OVER (PARTITION BY t7.kiosk_id, t7.sku_group) AS preference_sum
                   FROM ( SELECT t4.kiosk_id,
                            t4.sku_group,
                            t4.sku,
                            t4.name,
                            t4.sample_size,
                            t4.dt_avg,
                            t4.dt_std,
                            t4.w_departure_time,
                            t4.preference,
                            t5.scale,
                            t6.week_demand_qty,
                            t6.d1_plan_demand_qty,
                            t6.d2_plan_demand_qty,
                            t6.d3_plan_demand_qty,
                            t6.d4_plan_demand_qty,
                            t6.d5_plan_demand_qty
                           FROM ((mixalot.inm_sku_velocity t4
                             LEFT JOIN mixalot.inm_warehouse_sku_enabled t5 ON ((t4.sku = t5.sku)))
                             LEFT JOIN ( SELECT t1.kiosk_id,
                                    t1.sku_group,
                                    t1.week_demand_qty,
                                    round(((t1.week_demand_qty * t1.d1_plan_demand_qty) / ((((t1.d1_plan_demand_qty + t1.d2_plan_demand_qty) + t1.d3_plan_demand_qty) + t1.d4_plan_demand_qty) + t1.d5_plan_demand_qty)), 2) AS d1_plan_demand_qty,
                                    round(((t1.week_demand_qty * t1.d2_plan_demand_qty) / ((((t1.d1_plan_demand_qty + t1.d2_plan_demand_qty) + t1.d3_plan_demand_qty) + t1.d4_plan_demand_qty) + t1.d5_plan_demand_qty)), 2) AS d2_plan_demand_qty,
                                    round(((t1.week_demand_qty * t1.d3_plan_demand_qty) / ((((t1.d1_plan_demand_qty + t1.d2_plan_demand_qty) + t1.d3_plan_demand_qty) + t1.d4_plan_demand_qty) + t1.d5_plan_demand_qty)), 2) AS d3_plan_demand_qty,
                                    round(((t1.week_demand_qty * t1.d4_plan_demand_qty) / ((((t1.d1_plan_demand_qty + t1.d2_plan_demand_qty) + t1.d3_plan_demand_qty) + t1.d4_plan_demand_qty) + t1.d5_plan_demand_qty)), 2) AS d4_plan_demand_qty,
                                    round(((t1.week_demand_qty * t1.d5_plan_demand_qty) / ((((t1.d1_plan_demand_qty + t1.d2_plan_demand_qty) + t1.d3_plan_demand_qty) + t1.d4_plan_demand_qty) + t1.d5_plan_demand_qty)), 2) AS d5_plan_demand_qty
                                   FROM ( SELECT k.kiosk_id,
    p.sku_group,
    COALESCE(d1.week_demand_qty, d2.week_demand_qty, d3.week_demand_qty, d4.week_demand_qty, d5.week_demand_qty) AS week_demand_qty,
    COALESCE(d1.plan_demand_qty, (0)::numeric) AS d1_plan_demand_qty,
    COALESCE(d2.plan_demand_qty, (0)::numeric) AS d2_plan_demand_qty,
    COALESCE(d3.plan_demand_qty, (0)::numeric) AS d3_plan_demand_qty,
    COALESCE(d4.plan_demand_qty, (0)::numeric) AS d4_plan_demand_qty,
    COALESCE(d5.plan_demand_qty, (0)::numeric) AS d5_plan_demand_qty
   FROM ((((((( SELECT k_1.id AS kiosk_id
     FROM pantry.kiosk k_1
    WHERE ((k_1.campus_id = 87) AND (k_1.archived = 0) AND (k_1.enable_reporting = 1))) k
     CROSS JOIN ( SELECT DISTINCT p_1.fc_title AS sku_group
     FROM pantry.product p_1
    WHERE ((p_1.campus_id = 87) AND (p_1.archived = 0) AND (p_1.fc_title IS NOT NULL) AND ((p_1.fc_title)::text <> 'N/A'::text))
    ORDER BY p_1.fc_title) p)
     FULL JOIN inm.pick_get_order_with_velocity('2018-12-16 20:00:00+00'::timestamp with time zone, '2018-12-17 18:00:00+00'::timestamp with time zone) d1(kiosk_id, route_date_time, sku_group_id, fc_title, week_demand_qty, plan_demand_qty, plan_order_qty) ON (((k.kiosk_id = d1.kiosk_id) AND ((p.sku_group)::text = d1.fc_title))))
     FULL JOIN inm.pick_get_order_with_velocity('2018-12-17 20:00:00+00'::timestamp with time zone, '2018-12-18 18:00:00+00'::timestamp with time zone) d2(kiosk_id, route_date_time, sku_group_id, fc_title, week_demand_qty, plan_demand_qty, plan_order_qty) ON (((k.kiosk_id = d2.kiosk_id) AND ((p.sku_group)::text = d2.fc_title))))
     FULL JOIN inm.pick_get_order_with_velocity('2018-12-18 20:00:00+00'::timestamp with time zone, '2018-12-19 18:00:00+00'::timestamp with time zone) d3(kiosk_id, route_date_time, sku_group_id, fc_title, week_demand_qty, plan_demand_qty, plan_order_qty) ON (((k.kiosk_id = d3.kiosk_id) AND ((p.sku_group)::text = d3.fc_title))))
     FULL JOIN inm.pick_get_order_with_velocity('2018-12-19 20:00:00+00'::timestamp with time zone, '2018-12-20 18:00:00+00'::timestamp with time zone) d4(kiosk_id, route_date_time, sku_group_id, fc_title, week_demand_qty, plan_demand_qty, plan_order_qty) ON (((k.kiosk_id = d4.kiosk_id) AND ((p.sku_group)::text = d4.fc_title))))
     FULL JOIN inm.pick_get_order_with_velocity('2018-12-20 20:00:00+00'::timestamp with time zone, '2018-12-21 18:00:00+00'::timestamp with time zone) d5(kiosk_id, route_date_time, sku_group_id, fc_title, week_demand_qty, plan_demand_qty, plan_order_qty) ON (((k.kiosk_id = d5.kiosk_id) AND ((p.sku_group)::text = d5.fc_title))))
  ORDER BY k.kiosk_id, p.sku_group) t1
                                  WHERE (((((t1.d1_plan_demand_qty + t1.d2_plan_demand_qty) + t1.d3_plan_demand_qty) + t1.d4_plan_demand_qty) + t1.d5_plan_demand_qty) > (0)::numeric)) t6 ON (((t4.kiosk_id = t6.kiosk_id) AND ((t4.sku_group)::text = (t6.sku_group)::text))))) t7) t8) t9
  GROUP BY t9.sku_group, t9.sku, t9.name
  ORDER BY t9.sku_group, t9.sku, t9.name;


ALTER TABLE inm.warehouse_ordering OWNER TO dbservice;

--
-- Name: kiosk_control; Type: TABLE; Schema: inm_backup; Owner: dbservice
--

CREATE TABLE inm_backup.kiosk_control (
    kiosk_id integer NOT NULL,
    start_level numeric(4,2) NOT NULL,
    min_level numeric(4,2) NOT NULL,
    scale numeric(4,2) NOT NULL,
    manual_multiplier numeric(4,2) NOT NULL
);


ALTER TABLE inm_backup.kiosk_control OWNER TO dbservice;

--
-- Name: kiosk_product_disabled; Type: TABLE; Schema: inm_backup; Owner: dbservice
--

CREATE TABLE inm_backup.kiosk_product_disabled (
    kiosk_id bigint,
    product_id integer
);


ALTER TABLE inm_backup.kiosk_product_disabled OWNER TO dbservice;

--
-- Name: kiosk_restriction_by_product; Type: TABLE; Schema: inm_backup; Owner: dbservice
--

CREATE TABLE inm_backup.kiosk_restriction_by_product (
    kiosk_id bigint,
    product_id integer
);


ALTER TABLE inm_backup.kiosk_restriction_by_product OWNER TO dbservice;

--
-- Name: kiosk_restriction_by_property; Type: TABLE; Schema: inm_backup; Owner: dbservice
--

CREATE TABLE inm_backup.kiosk_restriction_by_property (
    kiosk_id integer,
    property_id integer
);


ALTER TABLE inm_backup.kiosk_restriction_by_property OWNER TO dbservice;

--
-- Name: kiosk_sku_group_manual_scale; Type: TABLE; Schema: inm_backup; Owner: dbservice
--

CREATE TABLE inm_backup.kiosk_sku_group_manual_scale (
    kiosk_id integer,
    sku_group_id integer,
    scale numeric(4,2)
);


ALTER TABLE inm_backup.kiosk_sku_group_manual_scale OWNER TO dbservice;

--
-- Name: ku_group_attribute; Type: TABLE; Schema: inm_backup; Owner: dbservice
--

CREATE TABLE inm_backup.ku_group_attribute (
    id integer,
    title character varying(512),
    relative_size numeric(4,2),
    minimum_kiosk_qty smallint,
    maximum_kiosk_qty smallint
);


ALTER TABLE inm_backup.ku_group_attribute OWNER TO dbservice;

--
-- Name: pick_allocation; Type: TABLE; Schema: inm_backup; Owner: dbservice
--

CREATE TABLE inm_backup.pick_allocation (
    pick_date date,
    route_date date,
    kiosk_id integer,
    sku_id integer,
    qty integer
);


ALTER TABLE inm_backup.pick_allocation OWNER TO dbservice;

--
-- Name: pick_demand; Type: TABLE; Schema: inm_backup; Owner: dbservice
--

CREATE TABLE inm_backup.pick_demand (
    pick_date date,
    route_date date,
    kiosk_id integer,
    sku_group_id integer,
    qty integer
);


ALTER TABLE inm_backup.pick_demand OWNER TO dbservice;

--
-- Name: pick_inventory; Type: TABLE; Schema: inm_backup; Owner: dbservice
--

CREATE TABLE inm_backup.pick_inventory (
    pick_date date,
    route_date date,
    kiosk_id integer,
    sku_group_id integer,
    qty integer
);


ALTER TABLE inm_backup.pick_inventory OWNER TO dbservice;

--
-- Name: pick_preference_kiosk_sku_20190120; Type: TABLE; Schema: inm_backup; Owner: dbservice
--

CREATE TABLE inm_backup.pick_preference_kiosk_sku_20190120 (
    kiosk_id integer,
    sku_id integer,
    preference smallint
);


ALTER TABLE inm_backup.pick_preference_kiosk_sku_20190120 OWNER TO dbservice;

--
-- Name: pick_priority_kiosk; Type: TABLE; Schema: inm_backup; Owner: dbservice
--

CREATE TABLE inm_backup.pick_priority_kiosk (
    kiosk_id integer,
    priority integer,
    comment text,
    end_date date
);


ALTER TABLE inm_backup.pick_priority_kiosk OWNER TO dbservice;

--
-- Name: pick_route; Type: TABLE; Schema: inm_backup; Owner: dbservice
--

CREATE TABLE inm_backup.pick_route (
    pick_date date,
    kiosk_id integer,
    route_number character varying(256),
    driver_name character varying(64),
    route_time time(6) without time zone,
    route_date date,
    delivery_order smallint
);


ALTER TABLE inm_backup.pick_route OWNER TO dbservice;

--
-- Name: pick_substitution; Type: TABLE; Schema: inm_backup; Owner: dbservice
--

CREATE TABLE inm_backup.pick_substitution (
    substituting_sku_group_id integer,
    substituted_sku_group_id integer,
    qty integer,
    pick_date date
);


ALTER TABLE inm_backup.pick_substitution OWNER TO dbservice;

--
-- Name: product_property; Type: TABLE; Schema: inm_backup; Owner: dbservice
--

CREATE TABLE inm_backup.product_property (
    product_id bigint,
    property_id integer
);


ALTER TABLE inm_backup.product_property OWNER TO dbservice;

--
-- Name: sku_group_control; Type: TABLE; Schema: inm_backup; Owner: dbservice
--

CREATE TABLE inm_backup.sku_group_control (
    sku_group_id integer,
    default_level numeric(4,2),
    scale numeric(4,2),
    min_qty smallint,
    max_qty smallint
);


ALTER TABLE inm_backup.sku_group_control OWNER TO dbservice;

--
-- Name: sku_group_def; Type: TABLE; Schema: inm_backup; Owner: dbservice
--

CREATE TABLE inm_backup.sku_group_def (
    id integer,
    title character varying(512),
    volume numeric(4,2)
);


ALTER TABLE inm_backup.sku_group_def OWNER TO dbservice;

--
-- Name: sku_velocity_20190120; Type: TABLE; Schema: inm_backup; Owner: dbservice
--

CREATE TABLE inm_backup.sku_velocity_20190120 (
    kiosk_id bigint,
    sku_group character varying(765),
    sku bigint,
    name character varying(381),
    sample_size bigint,
    dt_avg numeric,
    dt_std numeric,
    w_departure_time numeric,
    preference numeric
);


ALTER TABLE inm_backup.sku_velocity_20190120 OWNER TO dbservice;

--
-- Name: allocable_inventory; Type: VIEW; Schema: inm_beta; Owner: dbservice
--

CREATE VIEW inm_beta.allocable_inventory AS
 SELECT warehouse_inventory.inventory_date,
    warehouse_inventory.product_id,
    ((warehouse_inventory.stickered_units + (warehouse_inventory.stickered_cases * warehouse_inventory.units_per_case)) - warehouse_inventory.spoiled_units) AS qty
   FROM inm.warehouse_inventory;


ALTER TABLE inm_beta.allocable_inventory OWNER TO dbservice;

--
-- Name: kiosk_control; Type: TABLE; Schema: inm_beta; Owner: dbservice
--

CREATE TABLE inm_beta.kiosk_control (
    kiosk_id integer NOT NULL,
    start_level numeric(4,2) NOT NULL,
    min_level numeric(4,2) NOT NULL,
    scale numeric(4,2) DEFAULT 1.0 NOT NULL,
    manual_multiplier numeric(4,2) DEFAULT 1.0 NOT NULL
);


ALTER TABLE inm_beta.kiosk_control OWNER TO dbservice;

--
-- Name: kiosk_product_disabled; Type: TABLE; Schema: inm_beta; Owner: dbservice
--

CREATE TABLE inm_beta.kiosk_product_disabled (
    kiosk_id bigint NOT NULL,
    product_id integer NOT NULL
);


ALTER TABLE inm_beta.kiosk_product_disabled OWNER TO dbservice;

--
-- Name: kiosk_restriction_by_product; Type: TABLE; Schema: inm_beta; Owner: dbservice
--

CREATE TABLE inm_beta.kiosk_restriction_by_product (
    kiosk_id bigint NOT NULL,
    product_id integer NOT NULL
);


ALTER TABLE inm_beta.kiosk_restriction_by_product OWNER TO dbservice;

--
-- Name: kiosk_restriction_by_property; Type: TABLE; Schema: inm_beta; Owner: dbservice
--

CREATE TABLE inm_beta.kiosk_restriction_by_property (
    kiosk_id integer NOT NULL,
    property_id integer NOT NULL
);


ALTER TABLE inm_beta.kiosk_restriction_by_property OWNER TO dbservice;

--
-- Name: kiosk_sku_group_manual_scale; Type: TABLE; Schema: inm_beta; Owner: dbservice
--

CREATE TABLE inm_beta.kiosk_sku_group_manual_scale (
    kiosk_id integer NOT NULL,
    sku_group_id integer NOT NULL,
    scale numeric(4,2) NOT NULL
);


ALTER TABLE inm_beta.kiosk_sku_group_manual_scale OWNER TO dbservice;

--
-- Name: pick_allocation; Type: TABLE; Schema: inm_beta; Owner: dbservice
--

CREATE TABLE inm_beta.pick_allocation (
    pick_date date NOT NULL,
    route_date date NOT NULL,
    kiosk_id integer NOT NULL,
    sku_id integer NOT NULL,
    qty integer NOT NULL
);


ALTER TABLE inm_beta.pick_allocation OWNER TO dbservice;

--
-- Name: pick_demand; Type: TABLE; Schema: inm_beta; Owner: dbservice
--

CREATE TABLE inm_beta.pick_demand (
    pick_date date NOT NULL,
    route_date date NOT NULL,
    kiosk_id integer NOT NULL,
    sku_group_id integer NOT NULL,
    qty integer NOT NULL
);


ALTER TABLE inm_beta.pick_demand OWNER TO dbservice;

--
-- Name: pick_inventory; Type: TABLE; Schema: inm_beta; Owner: dbservice
--

CREATE TABLE inm_beta.pick_inventory (
    pick_date date NOT NULL,
    route_date date NOT NULL,
    kiosk_id integer NOT NULL,
    sku_group_id integer NOT NULL,
    qty integer NOT NULL
);


ALTER TABLE inm_beta.pick_inventory OWNER TO dbservice;

--
-- Name: pick_list; Type: TABLE; Schema: inm_beta; Owner: dbservice
--

CREATE TABLE inm_beta.pick_list (
    pick_date date NOT NULL,
    create_ts timestamp with time zone,
    finish_ts timestamp with time zone,
    status text,
    log text,
    url text
);


ALTER TABLE inm_beta.pick_list OWNER TO dbservice;

--
-- Name: pick_preference_kiosk_sku; Type: TABLE; Schema: inm_beta; Owner: dbservice
--

CREATE TABLE inm_beta.pick_preference_kiosk_sku (
    kiosk_id integer NOT NULL,
    sku_id integer NOT NULL,
    preference smallint NOT NULL
);


ALTER TABLE inm_beta.pick_preference_kiosk_sku OWNER TO dbservice;

--
-- Name: pick_priority_kiosk; Type: TABLE; Schema: inm_beta; Owner: dbservice
--

CREATE TABLE inm_beta.pick_priority_kiosk (
    kiosk_id integer NOT NULL,
    priority integer,
    start_date date,
    end_date date,
    comment text
);


ALTER TABLE inm_beta.pick_priority_kiosk OWNER TO dbservice;

--
-- Name: pick_priority_sku; Type: TABLE; Schema: inm_beta; Owner: dbservice
--

CREATE TABLE inm_beta.pick_priority_sku (
    sku_id integer NOT NULL,
    priority integer,
    start_date date,
    end_date date,
    comment text
);


ALTER TABLE inm_beta.pick_priority_sku OWNER TO dbservice;

--
-- Name: pick_rejection; Type: TABLE; Schema: inm_beta; Owner: dbservice
--

CREATE TABLE inm_beta.pick_rejection (
    pick_date date NOT NULL,
    route_date date NOT NULL,
    kiosk_id integer NOT NULL,
    item_id integer NOT NULL,
    item_type character varying(32) NOT NULL,
    reason character varying(64) NOT NULL
);


ALTER TABLE inm_beta.pick_rejection OWNER TO dbservice;

--
-- Name: pick_route; Type: TABLE; Schema: inm_beta; Owner: dbservice
--

CREATE TABLE inm_beta.pick_route (
    pick_date date NOT NULL,
    kiosk_id integer NOT NULL,
    route_number character varying(256),
    driver_name character varying(64) NOT NULL,
    route_time time(6) without time zone NOT NULL,
    route_date date NOT NULL,
    delivery_order smallint NOT NULL
);


ALTER TABLE inm_beta.pick_route OWNER TO dbservice;

--
-- Name: pick_substitution; Type: TABLE; Schema: inm_beta; Owner: dbservice
--

CREATE TABLE inm_beta.pick_substitution (
    substituting_sku_group_id integer NOT NULL,
    substituted_sku_group_id integer NOT NULL,
    qty integer NOT NULL,
    pick_date date NOT NULL
);


ALTER TABLE inm_beta.pick_substitution OWNER TO dbservice;

--
-- Name: product_property; Type: TABLE; Schema: inm_beta; Owner: dbservice
--

CREATE TABLE inm_beta.product_property (
    product_id bigint,
    property_id integer
);


ALTER TABLE inm_beta.product_property OWNER TO dbservice;

--
-- Name: sku_group; Type: TABLE; Schema: inm_beta; Owner: dbservice
--

CREATE TABLE inm_beta.sku_group (
    id integer NOT NULL,
    fc_title inm_beta.text_name NOT NULL,
    unit_size numeric(4,2) NOT NULL
);


ALTER TABLE inm_beta.sku_group OWNER TO dbservice;

--
-- Name: sku_group_control; Type: TABLE; Schema: inm_beta; Owner: dbservice
--

CREATE TABLE inm_beta.sku_group_control (
    sku_group_id integer NOT NULL,
    default_level numeric(4,2) DEFAULT '-1'::integer NOT NULL,
    scale numeric(4,2) DEFAULT 1.0 NOT NULL,
    min_qty smallint,
    max_qty smallint
);


ALTER TABLE inm_beta.sku_group_control OWNER TO dbservice;

--
-- Name: warehouse_inventory; Type: TABLE; Schema: inm_beta; Owner: dbservice
--

CREATE TABLE inm_beta.warehouse_inventory (
    inventory_date date NOT NULL,
    product_id integer NOT NULL,
    stickered_units integer DEFAULT 0 NOT NULL,
    unstickered_units integer DEFAULT 0 NOT NULL,
    stickered_cases integer DEFAULT 0 NOT NULL,
    unstickered_cases integer DEFAULT 0 NOT NULL,
    spoiled_units integer DEFAULT 0 NOT NULL,
    units_per_case integer NOT NULL,
    sort_order smallint NOT NULL
);


ALTER TABLE inm_beta.warehouse_inventory OWNER TO dbservice;

--
-- Name: backup_inm_data_09_16; Type: TABLE; Schema: inm_test; Owner: dbservice
--

CREATE TABLE inm_test.backup_inm_data_09_16 (
    id integer,
    import_ts timestamp(6) with time zone,
    kiosk_id integer,
    product_id integer,
    fc_title text,
    qty integer,
    data_type text,
    route_date timestamp(6) with time zone,
    route_name text,
    route_time text,
    driver_name text,
    refrigerated smallint,
    sort_order integer
);


ALTER TABLE inm_test.backup_inm_data_09_16 OWNER TO dbservice;

--
-- Name: broken_product; Type: TABLE; Schema: inm_test; Owner: dbservice
--

CREATE TABLE inm_test.broken_product (
    id bigint,
    title character varying(127),
    description character varying(4095),
    tiny_description character varying(40),
    short_description character varying(100),
    medium_description character varying(400),
    long_description character varying(1200),
    price numeric(5,2),
    cost numeric(5,2),
    shelf_time integer,
    campus_id bigint,
    image smallint,
    image_time bigint,
    last_update bigint,
    archived bigint,
    taxable smallint,
    allergens character varying(255),
    attribute_names character varying(511),
    categories character varying(255),
    category_names character varying(511),
    vendor character varying(135),
    source character varying(135),
    notes character varying(2000),
    total_cal bigint,
    num_servings real,
    ingredients character varying(2000),
    calories real,
    proteins real,
    sugar real,
    carbohydrates real,
    fat real,
    consumer_category character varying(2000),
    ws_case_size bigint,
    kiosk_ship_qty bigint,
    ws_case_cost numeric(5,2),
    pick_station bigint,
    fc_title character varying(255),
    pricing_tier character varying(255),
    width_space real,
    height_space real,
    depth_space real,
    slotted_width real,
    tag_volume bigint,
    delivery_option character varying(255),
    tag_applied_by character varying(255)
);


ALTER TABLE inm_test.broken_product OWNER TO dbservice;

--
-- Name: inm_kiosk_hourly_sale; Type: TABLE; Schema: inm_test; Owner: dbservice
--

CREATE TABLE inm_test.inm_kiosk_hourly_sale (
    key text,
    kiosk_id bigint,
    dow integer,
    hod integer,
    units_sold numeric(28,6)
);


ALTER TABLE inm_test.inm_kiosk_hourly_sale OWNER TO dbservice;

--
-- Name: inm_kiosk_restock; Type: TABLE; Schema: inm_test; Owner: dbservice
--

CREATE TABLE inm_test.inm_kiosk_restock (
    key text,
    kiosk_id bigint,
    dow integer,
    hod integer,
    delivery bigint
);


ALTER TABLE inm_test.inm_kiosk_restock OWNER TO dbservice;

--
-- Name: inm_kiosk_skugroup_sale; Type: TABLE; Schema: inm_test; Owner: dbservice
--

CREATE TABLE inm_test.inm_kiosk_skugroup_sale (
    key text,
    kiosk_id bigint,
    sku_group character varying(765),
    sku_group_contribution numeric(28,6)
);


ALTER TABLE inm_test.inm_kiosk_skugroup_sale OWNER TO dbservice;

--
-- Name: inm_kiosk_weekly_sale; Type: TABLE; Schema: inm_test; Owner: dbservice
--

CREATE TABLE inm_test.inm_kiosk_weekly_sale (
    key text,
    kiosk_id bigint,
    woy integer,
    units_sold bigint
);


ALTER TABLE inm_test.inm_kiosk_weekly_sale OWNER TO dbservice;

--
-- Name: kiosk_20190508; Type: TABLE; Schema: inm_test; Owner: dbservice
--

CREATE TABLE inm_test.kiosk_20190508 (
    id bigint,
    campus_id bigint,
    serial character varying(45),
    title character varying(46),
    address character varying(127),
    location_x numeric(9,6),
    location_y numeric(9,6),
    gcm_id character varying(255),
    app_vname character varying(63),
    app_vcode integer,
    archived bigint,
    creation_time bigint,
    deployment_time bigint,
    last_update bigint,
    client_name character varying(255),
    last_status bigint,
    last_inventory bigint,
    kiosk_name character varying(255),
    payment_start bigint,
    payment_stop bigint,
    features character varying(255),
    sales_tax smallint,
    default_fee_plan bigint,
    timezone character varying(50),
    estd_num_users bigint,
    tags character varying(255),
    publicly_accessible bigint,
    cardkey_required bigint,
    delivery_insns character varying(65535),
    fridge_loc_info character varying(65535),
    contact_first_name character varying(65535),
    contact_last_name character varying(65535),
    contact_email character varying(65535),
    contact_phone character varying(65535),
    accounting_email character varying(65535),
    byte_discount character varying(255),
    subsidy_info character varying(50),
    subsidy_notes character varying(65535),
    max_subscription character varying(50),
    delivery_window_mon character varying(50),
    delivery_window_tue character varying(50),
    delivery_window_wed character varying(50),
    delivery_window_thu character varying(50),
    delivery_window_fri character varying(50),
    delivery_window_sat character varying(50),
    delivery_window_sun character varying(50),
    notes character varying(2000),
    components text,
    email_receipt_subject character varying(255),
    ops_team_notes character varying(65535),
    geo character varying(3),
    server_url character varying(127),
    subscription_amount numeric(8,2),
    enable_reporting bigint,
    enable_monitoring bigint,
    employees_num bigint,
    kiosk_restrictions character varying(2000)
);


ALTER TABLE inm_test.kiosk_20190508 OWNER TO dbservice;

--
-- Name: kiosk_20190531; Type: TABLE; Schema: inm_test; Owner: dbservice
--

CREATE TABLE inm_test.kiosk_20190531 (
    id bigint,
    campus_id bigint,
    serial character varying(45),
    title character varying(46),
    address character varying(127),
    location_x numeric(9,6),
    location_y numeric(9,6),
    gcm_id character varying(255),
    app_vname character varying(63),
    app_vcode integer,
    archived bigint,
    creation_time bigint,
    deployment_time bigint,
    last_update bigint,
    client_name character varying(255),
    last_status bigint,
    last_inventory bigint,
    kiosk_name character varying(255),
    payment_start bigint,
    payment_stop bigint,
    features character varying(255),
    sales_tax smallint,
    default_fee_plan bigint,
    timezone character varying(50),
    estd_num_users bigint,
    tags character varying(255),
    publicly_accessible bigint,
    cardkey_required bigint,
    delivery_insns character varying(65535),
    fridge_loc_info character varying(65535),
    contact_first_name character varying(65535),
    contact_last_name character varying(65535),
    contact_email character varying(65535),
    contact_phone character varying(65535),
    accounting_email character varying(65535),
    byte_discount character varying(255),
    subsidy_info character varying(50),
    subsidy_notes character varying(65535),
    max_subscription character varying(50),
    delivery_window_mon character varying(50),
    delivery_window_tue character varying(50),
    delivery_window_wed character varying(50),
    delivery_window_thu character varying(50),
    delivery_window_fri character varying(50),
    delivery_window_sat character varying(50),
    delivery_window_sun character varying(50),
    notes character varying(2000),
    components text,
    email_receipt_subject character varying(255),
    ops_team_notes character varying(65535),
    geo character varying(3),
    server_url character varying(127),
    subscription_amount numeric(8,2),
    enable_reporting bigint,
    enable_monitoring bigint,
    employees_num bigint,
    kiosk_restrictions character varying(2000)
);


ALTER TABLE inm_test.kiosk_20190531 OWNER TO dbservice;

--
-- Name: kiosk_20190531_test_update; Type: TABLE; Schema: inm_test; Owner: dbservice
--

CREATE TABLE inm_test.kiosk_20190531_test_update (
    id bigint,
    campus_id bigint,
    serial character varying(45),
    title character varying(46),
    address character varying(127),
    location_x numeric(9,6),
    location_y numeric(9,6),
    gcm_id character varying(255),
    app_vname character varying(63),
    app_vcode integer,
    archived bigint,
    creation_time bigint,
    deployment_time bigint,
    last_update bigint,
    client_name character varying(255),
    last_status bigint,
    last_inventory bigint,
    kiosk_name character varying(255),
    payment_start bigint,
    payment_stop bigint,
    features character varying(255),
    sales_tax smallint,
    default_fee_plan bigint,
    timezone character varying(50),
    estd_num_users bigint,
    tags character varying(255),
    publicly_accessible bigint,
    cardkey_required bigint,
    delivery_insns character varying(65535),
    fridge_loc_info character varying(65535),
    contact_first_name character varying(65535),
    contact_last_name character varying(65535),
    contact_email character varying(65535),
    contact_phone character varying(65535),
    accounting_email character varying(65535),
    byte_discount character varying(255),
    subsidy_info character varying(50),
    subsidy_notes character varying(65535),
    max_subscription character varying(50),
    delivery_window_mon character varying(50),
    delivery_window_tue character varying(50),
    delivery_window_wed character varying(50),
    delivery_window_thu character varying(50),
    delivery_window_fri character varying(50),
    delivery_window_sat character varying(50),
    delivery_window_sun character varying(50),
    notes character varying(2000),
    components text,
    email_receipt_subject character varying(255),
    ops_team_notes character varying(65535),
    geo character varying(3),
    server_url character varying(127),
    subscription_amount numeric(8,2),
    enable_reporting bigint,
    enable_monitoring bigint,
    employees_num bigint,
    kiosk_restrictions character varying(2000)
);


ALTER TABLE inm_test.kiosk_20190531_test_update OWNER TO dbservice;

--
-- Name: kiosk_20190810; Type: TABLE; Schema: inm_test; Owner: dbservice
--

CREATE TABLE inm_test.kiosk_20190810 (
    id bigint,
    campus_id bigint,
    serial character varying(45),
    title character varying(46),
    address character varying(127),
    location_x numeric(9,6),
    location_y numeric(9,6),
    gcm_id character varying(255),
    app_vname character varying(63),
    app_vcode integer,
    archived bigint,
    creation_time bigint,
    deployment_time bigint,
    last_update bigint,
    client_name character varying(255),
    last_status bigint,
    last_inventory bigint,
    kiosk_name character varying(255),
    payment_start bigint,
    payment_stop bigint,
    features character varying(255),
    sales_tax smallint,
    default_fee_plan bigint,
    timezone character varying(50),
    estd_num_users bigint,
    tags character varying(255),
    publicly_accessible bigint,
    cardkey_required bigint,
    delivery_insns character varying(65535),
    fridge_loc_info character varying(65535),
    contact_first_name character varying(65535),
    contact_last_name character varying(65535),
    contact_email character varying(65535),
    contact_phone character varying(65535),
    accounting_email character varying(65535),
    byte_discount character varying(255),
    subsidy_info character varying(50),
    subsidy_notes character varying(65535),
    max_subscription character varying(50),
    delivery_window_mon character varying(50),
    delivery_window_tue character varying(50),
    delivery_window_wed character varying(50),
    delivery_window_thu character varying(50),
    delivery_window_fri character varying(50),
    delivery_window_sat character varying(50),
    delivery_window_sun character varying(50),
    notes character varying(2000),
    components text,
    email_receipt_subject character varying(255),
    ops_team_notes character varying(65535),
    geo character varying(3),
    server_url character varying(127),
    subscription_amount numeric(8,2),
    enable_reporting bigint,
    enable_monitoring bigint,
    employees_num bigint,
    kiosk_restrictions character varying(2000)
);


ALTER TABLE inm_test.kiosk_20190810 OWNER TO dbservice;

--
-- Name: kiosk_audit; Type: TABLE; Schema: inm_test; Owner: dbservice
--

CREATE TABLE inm_test.kiosk_audit (
    a text,
    b text,
    kid integer NOT NULL,
    status text,
    e text,
    enable_reporting character(1),
    enable_monitoring character(1)
);


ALTER TABLE inm_test.kiosk_audit OWNER TO dbservice;

--
-- Name: kiosk_par_level; Type: TABLE; Schema: inm_test; Owner: dbservice
--

CREATE TABLE inm_test.kiosk_par_level (
    kiosk_id bigint NOT NULL,
    product_id bigint NOT NULL,
    amount bigint
);


ALTER TABLE inm_test.kiosk_par_level OWNER TO dbservice;

--
-- Name: kiosk_par_level_bkup; Type: TABLE; Schema: inm_test; Owner: dbservice
--

CREATE TABLE inm_test.kiosk_par_level_bkup (
    kiosk_id bigint,
    product_id bigint,
    amount bigint
);


ALTER TABLE inm_test.kiosk_par_level_bkup OWNER TO dbservice;

--
-- Name: kiosk_software; Type: TABLE; Schema: inm_test; Owner: dbservice
--

CREATE TABLE inm_test.kiosk_software (
    id integer NOT NULL,
    app_vname character varying(63),
    components text
);


ALTER TABLE inm_test.kiosk_software OWNER TO dbservice;

--
-- Name: pick_allocation; Type: TABLE; Schema: inm_test; Owner: dbservice
--

CREATE TABLE inm_test.pick_allocation (
    pick_date date NOT NULL,
    route_date date NOT NULL,
    kiosk_id integer NOT NULL,
    sku_id integer NOT NULL,
    qty integer NOT NULL
);


ALTER TABLE inm_test.pick_allocation OWNER TO dbservice;

--
-- Name: pick_demand; Type: TABLE; Schema: inm_test; Owner: dbservice
--

CREATE TABLE inm_test.pick_demand (
    pick_date date NOT NULL,
    route_date date NOT NULL,
    kiosk_id integer NOT NULL,
    sku_group_id integer NOT NULL,
    qty integer NOT NULL
);


ALTER TABLE inm_test.pick_demand OWNER TO dbservice;

--
-- Name: pick_inventory; Type: TABLE; Schema: inm_test; Owner: dbservice
--

CREATE TABLE inm_test.pick_inventory (
    pick_date date NOT NULL,
    route_date date NOT NULL,
    kiosk_id integer NOT NULL,
    sku_group_id integer NOT NULL,
    qty integer NOT NULL
);


ALTER TABLE inm_test.pick_inventory OWNER TO dbservice;

--
-- Name: pick_rejection; Type: TABLE; Schema: inm_test; Owner: dbservice
--

CREATE TABLE inm_test.pick_rejection (
    pick_date date NOT NULL,
    route_date date NOT NULL,
    kiosk_id integer NOT NULL,
    item_id integer NOT NULL,
    item_type character varying(32) NOT NULL,
    reason character varying(64) NOT NULL
);


ALTER TABLE inm_test.pick_rejection OWNER TO dbservice;

--
-- Name: pick_route; Type: TABLE; Schema: inm_test; Owner: dbservice
--

CREATE TABLE inm_test.pick_route (
    pick_date date NOT NULL,
    kiosk_id integer NOT NULL,
    route_number character varying(256),
    driver_name character varying(64) NOT NULL,
    route_time time(6) without time zone NOT NULL,
    route_date date NOT NULL,
    delivery_order smallint NOT NULL
);


ALTER TABLE inm_test.pick_route OWNER TO dbservice;

--
-- Name: pick_substitution; Type: TABLE; Schema: inm_test; Owner: dbservice
--

CREATE TABLE inm_test.pick_substitution (
    substituting_sku_group_id integer NOT NULL,
    substituted_sku_group_id integer NOT NULL,
    qty integer NOT NULL,
    pick_date date NOT NULL
);


ALTER TABLE inm_test.pick_substitution OWNER TO dbservice;

--
-- Name: plan_kiosks; Type: TABLE; Schema: inm_test; Owner: dbservice
--

CREATE TABLE inm_test.plan_kiosks (
    kiosk_id integer,
    route_date_time timestamp(6) with time zone,
    driver_name character varying(8000),
    location_name character varying(8000),
    next_delivery_ts timestamp(6) with time zone,
    time_to_next_delivery interval,
    days_to_next_delivery double precision,
    delivery_order bigint
);


ALTER TABLE inm_test.plan_kiosks OWNER TO dbservice;

--
-- Name: product_20190508; Type: TABLE; Schema: inm_test; Owner: dbservice
--

CREATE TABLE inm_test.product_20190508 (
    id bigint,
    title character varying(127),
    description character varying(4095),
    tiny_description character varying(40),
    short_description character varying(100),
    medium_description character varying(400),
    long_description character varying(1200),
    price numeric(5,2),
    cost numeric(5,2),
    shelf_time integer,
    campus_id bigint,
    image smallint,
    image_time bigint,
    last_update bigint,
    archived bigint,
    taxable smallint,
    allergens character varying(255),
    attribute_names character varying(511),
    categories character varying(255),
    category_names character varying(511),
    vendor character varying(135),
    source character varying(135),
    notes character varying(2000),
    total_cal bigint,
    num_servings real,
    ingredients character varying(2000),
    calories real,
    proteins real,
    sugar real,
    carbohydrates real,
    fat real,
    consumer_category character varying(2000),
    ws_case_size bigint,
    kiosk_ship_qty bigint,
    ws_case_cost numeric(5,2),
    pick_station bigint,
    fc_title character varying(255),
    pricing_tier character varying(255),
    width_space real,
    height_space real,
    depth_space real,
    slotted_width real,
    tag_volume bigint,
    delivery_option character varying(255),
    tag_applied_by character varying(255)
);


ALTER TABLE inm_test.product_20190508 OWNER TO dbservice;

--
-- Name: product_20190514; Type: TABLE; Schema: inm_test; Owner: dbservice
--

CREATE TABLE inm_test.product_20190514 (
    id bigint,
    title character varying(127),
    description character varying(4095),
    tiny_description character varying(40),
    short_description character varying(100),
    medium_description character varying(400),
    long_description character varying(1200),
    price numeric(5,2),
    cost numeric(5,2),
    shelf_time integer,
    campus_id bigint,
    image smallint,
    image_time bigint,
    last_update bigint,
    archived bigint,
    taxable smallint,
    allergens character varying(255),
    attribute_names character varying(511),
    categories character varying(255),
    category_names character varying(511),
    vendor character varying(135),
    source character varying(135),
    notes character varying(2000),
    total_cal bigint,
    num_servings real,
    ingredients character varying(2000),
    calories real,
    proteins real,
    sugar real,
    carbohydrates real,
    fat real,
    consumer_category character varying(2000),
    ws_case_size bigint,
    kiosk_ship_qty bigint,
    ws_case_cost numeric(5,2),
    pick_station bigint,
    fc_title character varying(255),
    pricing_tier character varying(255),
    width_space real,
    height_space real,
    depth_space real,
    slotted_width real,
    tag_volume bigint,
    delivery_option character varying(255),
    tag_applied_by character varying(255)
);


ALTER TABLE inm_test.product_20190514 OWNER TO dbservice;

--
-- Name: restricted; Type: TABLE; Schema: inm_test; Owner: dbservice
--

CREATE TABLE inm_test.restricted (
    kid integer NOT NULL,
    sku_id integer NOT NULL
);


ALTER TABLE inm_test.restricted OWNER TO dbservice;

--
-- Name: route_stop; Type: TABLE; Schema: inm_test; Owner: dbservice
--

CREATE TABLE inm_test.route_stop (
    route_date_time timestamp(6) with time zone,
    driver_name character varying(200),
    location_name character varying(200),
    schedule_at timestamp(6) with time zone,
    longitude numeric(28,6),
    address character varying(200),
    latitude numeric(28,6),
    stop_number integer,
    order_number character varying(200),
    location_number integer
);


ALTER TABLE inm_test.route_stop OWNER TO dbservice;

--
-- Name: tag_2019_05_15; Type: TABLE; Schema: inm_test; Owner: dbservice
--

CREATE TABLE inm_test.tag_2019_05_15 (
    id bigint,
    tag character varying(100)
);


ALTER TABLE inm_test.tag_2019_05_15 OWNER TO dbservice;

--
-- Name: temp_kiosk; Type: TABLE; Schema: inm_test; Owner: dbservice
--

CREATE TABLE inm_test.temp_kiosk (
    id bigint,
    campus_id bigint,
    serial character varying(45),
    title character varying(46),
    address character varying(127),
    location_x numeric(9,6),
    location_y numeric(9,6),
    gcm_id character varying(255),
    app_vname character varying(63),
    app_vcode integer,
    archived bigint,
    creation_time bigint,
    deployment_time bigint,
    last_update bigint,
    client_name character varying(255),
    last_status bigint,
    last_inventory bigint,
    kiosk_name character varying(255),
    payment_start bigint,
    payment_stop bigint,
    features character varying(255),
    sales_tax smallint,
    default_fee_plan bigint,
    timezone character varying(50),
    estd_num_users bigint,
    tags character varying(255),
    publicly_accessible bigint,
    cardkey_required bigint,
    delivery_insns character varying(65535),
    fridge_loc_info character varying(65535),
    contact_first_name character varying(65535),
    contact_last_name character varying(65535),
    contact_email character varying(65535),
    contact_phone character varying(65535),
    accounting_email character varying(65535),
    byte_discount character varying(255),
    subsidy_info character varying(50),
    subsidy_notes character varying(65535),
    max_subscription character varying(50),
    delivery_window_mon character varying(50),
    delivery_window_tue character varying(50),
    delivery_window_wed character varying(50),
    delivery_window_thu character varying(50),
    delivery_window_fri character varying(50),
    delivery_window_sat character varying(50),
    delivery_window_sun character varying(50),
    notes character varying(2000),
    components text,
    email_receipt_subject character varying(255),
    ops_team_notes character varying(65535),
    geo character varying(3),
    server_url character varying(127),
    subscription_amount numeric(8,2),
    enable_reporting bigint,
    enable_monitoring bigint,
    employees_num bigint,
    kiosk_restrictions character varying(2000)
);


ALTER TABLE inm_test.temp_kiosk OWNER TO dbservice;

--
-- Name: test; Type: TABLE; Schema: inm_test; Owner: dbservice
--

CREATE TABLE inm_test.test (
    id integer NOT NULL
);


ALTER TABLE inm_test.test OWNER TO dbservice;

--
-- Name: test_hours; Type: TABLE; Schema: inm_test; Owner: dbservice
--

CREATE TABLE inm_test.test_hours (
    h smallint NOT NULL
);


ALTER TABLE inm_test.test_hours OWNER TO dbservice;

--
-- Name: facing_category; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.facing_category (
    id bigint NOT NULL,
    title character varying(765) NOT NULL,
    shelf_level bigint,
    sku_count bigint,
    min_slotted bigint,
    max_slotted bigint,
    mixed_slotted bigint
);


ALTER TABLE pantry.facing_category OWNER TO dbservice;

--
-- Name: facing_category_v1; Type: VIEW; Schema: iplanner; Owner: dbservice
--

CREATE VIEW iplanner.facing_category_v1 AS
 SELECT facing_category.id,
    facing_category.title,
    facing_category.shelf_level,
    facing_category.sku_count,
    facing_category.min_slotted,
    facing_category.max_slotted,
    facing_category.mixed_slotted
   FROM pantry.facing_category;


ALTER TABLE iplanner.facing_category_v1 OWNER TO dbservice;

--
-- Name: insync_kiosk_v1; Type: VIEW; Schema: iplanner; Owner: dbservice
--

CREATE VIEW iplanner.insync_kiosk_v1 AS
 SELECT kiosk.id,
    kiosk.campus_id,
    kiosk.title,
    kiosk.address,
    kiosk.location_x,
    kiosk.location_y,
    kiosk.archived,
    kiosk.creation_time,
    kiosk.deployment_time,
    kiosk.last_update,
    kiosk.client_name,
    kiosk.last_inventory,
    kiosk.kiosk_name,
    kiosk.payment_start,
    kiosk.payment_stop,
    kiosk.timezone,
    kiosk.estd_num_users,
    kiosk.delivery_window_mon,
    kiosk.delivery_window_tue,
    kiosk.delivery_window_wed,
    kiosk.delivery_window_thu,
    kiosk.delivery_window_fri,
    kiosk.delivery_window_sat,
    kiosk.delivery_window_sun,
    kiosk.geo,
    kiosk.kiosk_restrictions
   FROM pantry.kiosk
  WHERE ((kiosk.campus_id = 87) AND (kiosk.archived <> 1) AND ((kiosk.title)::text !~~* 'test%'::text) AND ((kiosk.title)::text !~~* 'burn%'::text));


ALTER TABLE iplanner.insync_kiosk_v1 OWNER TO dbservice;

--
-- Name: card_fact; Type: TABLE; Schema: mixalot; Owner: dbservice
--

CREATE TABLE mixalot.card_fact (
    id integer NOT NULL,
    hash text,
    first_name text,
    last_name text,
    email text,
    first_order_id text,
    first_order_ts timestamp(6) with time zone,
    first_order_num_items integer,
    first_order_sales_price double precision,
    first_order_list_price double precision,
    first_order_discount_amt double precision,
    last_order_id text,
    last_order_ts timestamp(6) with time zone,
    last_order_num_items integer,
    last_order_sales_price double precision,
    last_order_list_price double precision,
    last_order_discount_amt double precision,
    avg_order_list_price double precision,
    avg_order_num_items double precision,
    kiosk_ids text,
    user_cat text,
    cac double precision,
    acc_lt_total double precision,
    acc_lt_discount double precision,
    cnt_lt_orders integer,
    cnt_lt_voided integer,
    dow_0_pct double precision,
    dow_1_pct double precision,
    dow_2_pct double precision,
    dow_3_pct double precision,
    dow_4_pct double precision,
    dow_5_pct double precision,
    dow_6_pct double precision
);


ALTER TABLE mixalot.card_fact OWNER TO dbservice;

--
-- Name: card_fact_id_seq; Type: SEQUENCE; Schema: mixalot; Owner: dbservice
--

CREATE SEQUENCE mixalot.card_fact_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE mixalot.card_fact_id_seq OWNER TO dbservice;

--
-- Name: card_fact_id_seq; Type: SEQUENCE OWNED BY; Schema: mixalot; Owner: dbservice
--

ALTER SEQUENCE mixalot.card_fact_id_seq OWNED BY mixalot.card_fact.id;


--
-- Name: card_product_fact; Type: TABLE; Schema: mixalot; Owner: dbservice
--

CREATE TABLE mixalot.card_product_fact (
    id integer NOT NULL,
    card_hash text,
    product_id integer,
    sku text,
    first_available_ts timestamp(6) with time zone,
    first_purchased_ts timestamp(6) with time zone,
    acc_sales_1w double precision,
    acc_sales_30d double precision,
    acc_sales_6m double precision,
    avg_item_price double precision,
    avg_item_discount double precision,
    cnt_purchases_lt integer,
    cnt_purchased_30d integer,
    cnt_purchased_6m integer,
    cnt_purchased_1y integer,
    prob_purch_first double precision,
    prob_purch_again double precision,
    number_not_purchased_before_1st integer,
    number_available_lt integer,
    number_not_purchased_lt integer,
    number_available_after_1st integer,
    number_not_purchased_after_1st integer,
    number_stockouts_after_1st integer
);


ALTER TABLE mixalot.card_product_fact OWNER TO dbservice;

--
-- Name: card_product_fact_id_seq; Type: SEQUENCE; Schema: mixalot; Owner: dbservice
--

CREATE SEQUENCE mixalot.card_product_fact_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE mixalot.card_product_fact_id_seq OWNER TO dbservice;

--
-- Name: card_product_fact_id_seq; Type: SEQUENCE OWNED BY; Schema: mixalot; Owner: dbservice
--

ALTER SEQUENCE mixalot.card_product_fact_id_seq OWNED BY mixalot.card_product_fact.id;


--
-- Name: discount_rule; Type: TABLE; Schema: mixalot; Owner: dbservice
--

CREATE TABLE mixalot.discount_rule (
    id character varying(25) NOT NULL,
    create_d timestamp(6) without time zone NOT NULL,
    update_d timestamp(6) without time zone NOT NULL,
    hash character varying(32) NOT NULL,
    json text NOT NULL,
    repeat_count integer NOT NULL,
    repeat_cycle timestamp(6) without time zone NOT NULL
);


ALTER TABLE mixalot.discount_rule OWNER TO dbservice;

--
-- Name: gsheet_cache; Type: TABLE; Schema: mixalot; Owner: dbservice
--

CREATE TABLE mixalot.gsheet_cache (
    id character varying(50) NOT NULL,
    update_d timestamp(6) with time zone,
    email_count integer,
    email_json text,
    payload json
);


ALTER TABLE mixalot.gsheet_cache OWNER TO dbservice;

--
-- Name: gsheets_kiosk_restriction; Type: TABLE; Schema: mixalot; Owner: dbservice
--

CREATE TABLE mixalot.gsheets_kiosk_restriction (
    kiosk_id integer NOT NULL,
    restriction character varying(512) NOT NULL
);


ALTER TABLE mixalot.gsheets_kiosk_restriction OWNER TO dbservice;

--
-- Name: history_order_pipeline; Type: TABLE; Schema: mixalot; Owner: dbservice
--

CREATE TABLE mixalot.history_order_pipeline (
    id integer NOT NULL,
    order_id character varying(45),
    action character varying(45),
    system character varying(45),
    "user" character varying(45),
    data text,
    ts timestamp(6) with time zone
);


ALTER TABLE mixalot.history_order_pipeline OWNER TO dbservice;

--
-- Name: history_order_id_seq; Type: SEQUENCE; Schema: mixalot; Owner: dbservice
--

CREATE SEQUENCE mixalot.history_order_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE mixalot.history_order_id_seq OWNER TO dbservice;

--
-- Name: history_order_id_seq; Type: SEQUENCE OWNED BY; Schema: mixalot; Owner: dbservice
--

ALTER SEQUENCE mixalot.history_order_id_seq OWNED BY mixalot.history_order_pipeline.id;


--
-- Name: inm_byte_kiosk; Type: VIEW; Schema: mixalot; Owner: dbservice
--

CREATE VIEW mixalot.inm_byte_kiosk AS
 SELECT kiosk.id,
    kiosk.campus_id,
    kiosk.title,
    kiosk.address
   FROM pantry.kiosk
  WHERE ((kiosk.archived <> 0) AND (kiosk.campus_id = 87));


ALTER TABLE mixalot.inm_byte_kiosk OWNER TO dbservice;

--
-- Name: inm_data; Type: TABLE; Schema: mixalot; Owner: dbservice
--

CREATE TABLE mixalot.inm_data (
    id integer NOT NULL,
    import_ts timestamp(6) with time zone,
    kiosk_id integer,
    product_id integer,
    fc_title text,
    qty integer,
    data_type text,
    route_date timestamp(6) with time zone,
    route_name text,
    route_time text,
    driver_name text,
    refrigerated smallint,
    sort_order integer
);


ALTER TABLE mixalot.inm_data OWNER TO dbservice;

--
-- Name: inm_data_id_seq; Type: SEQUENCE; Schema: mixalot; Owner: dbservice
--

CREATE SEQUENCE mixalot.inm_data_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE mixalot.inm_data_id_seq OWNER TO dbservice;

--
-- Name: inm_data_id_seq; Type: SEQUENCE OWNED BY; Schema: mixalot; Owner: dbservice
--

ALTER SEQUENCE mixalot.inm_data_id_seq OWNED BY mixalot.inm_data.id;


--
-- Name: merchandising_slot_sku_group; Type: TABLE; Schema: mixalot; Owner: dbservice
--

CREATE TABLE mixalot.merchandising_slot_sku_group (
    sku_group_id integer NOT NULL,
    merchandising_slot_id integer NOT NULL
);


ALTER TABLE mixalot.merchandising_slot_sku_group OWNER TO dbservice;

--
-- Name: TABLE merchandising_slot_sku_group; Type: COMMENT; Schema: mixalot; Owner: dbservice
--

COMMENT ON TABLE mixalot.merchandising_slot_sku_group IS 'store all the sku groups for each merchandising slot';


--
-- Name: sku_group_def; Type: TABLE; Schema: mixalot; Owner: dbservice
--

CREATE TABLE mixalot.sku_group_def (
    id integer NOT NULL,
    title character varying(512) NOT NULL,
    volume numeric(4,2)
);


ALTER TABLE mixalot.sku_group_def OWNER TO dbservice;

--
-- Name: TABLE sku_group_def; Type: COMMENT; Schema: mixalot; Owner: dbservice
--

COMMENT ON TABLE mixalot.sku_group_def IS 'sku group id''s and names';


--
-- Name: sku_group_sku; Type: TABLE; Schema: mixalot; Owner: dbservice
--

CREATE TABLE mixalot.sku_group_sku (
    sku_id integer NOT NULL,
    sku_group_id integer NOT NULL
);


ALTER TABLE mixalot.sku_group_sku OWNER TO dbservice;

--
-- Name: TABLE sku_group_sku; Type: COMMENT; Schema: mixalot; Owner: dbservice
--

COMMENT ON TABLE mixalot.sku_group_sku IS 'store SKUs for each sku_group';


--
-- Name: inm_dc_inventory; Type: VIEW; Schema: mixalot; Owner: dbservice
--

CREATE VIEW mixalot.inm_dc_inventory AS
 SELECT dc_sku.product_id AS sku_id,
    sku_group.sku_group_id,
    sgd.title AS sku_group_title,
    ms.merchandising_slot_id,
    dc_sku.qty,
    dc_sku.sort_order,
    dc_sku.import_ts
   FROM (((mixalot.inm_data dc_sku
     JOIN mixalot.sku_group_sku sku_group ON ((dc_sku.product_id = sku_group.sku_id)))
     JOIN mixalot.merchandising_slot_sku_group ms ON ((sku_group.sku_group_id = ms.sku_group_id)))
     JOIN mixalot.sku_group_def sgd ON ((sku_group.sku_group_id = sgd.id)))
  WHERE ((dc_sku.data_type = 'Warehouse SKU Inventory'::text) AND (dc_sku.import_ts = ( SELECT max(dc_sku_1.import_ts) AS max
           FROM mixalot.inm_data dc_sku_1
          WHERE (dc_sku_1.data_type = 'Warehouse SKU Inventory'::text))));


ALTER TABLE mixalot.inm_dc_inventory OWNER TO dbservice;

--
-- Name: inm_demand; Type: VIEW; Schema: mixalot; Owner: dbservice
--

CREATE VIEW mixalot.inm_demand AS
 SELECT demand.kiosk_id,
    demand.fc_title,
    demand.qty
   FROM mixalot.inm_data demand
  WHERE ((demand.data_type = 'Plan Demand'::text) AND (demand.qty > 0) AND (demand.import_ts = ( SELECT max(dc_sku.import_ts) AS max
           FROM mixalot.inm_data dc_sku
          WHERE (dc_sku.data_type = 'Plan Demand'::text))));


ALTER TABLE mixalot.inm_demand OWNER TO dbservice;

--
-- Name: inm_gsheets_kiosk_restriction; Type: TABLE; Schema: mixalot; Owner: dbservice
--

CREATE TABLE mixalot.inm_gsheets_kiosk_restriction (
    kiosk_id integer NOT NULL,
    restriction character varying(512) NOT NULL
);


ALTER TABLE mixalot.inm_gsheets_kiosk_restriction OWNER TO dbservice;

--
-- Name: inm_kiosk_restriction_list; Type: VIEW; Schema: mixalot; Owner: dbservice
--

CREATE VIEW mixalot.inm_kiosk_restriction_list AS
 SELECT gsheets_kiosk_restriction.kiosk_id,
    string_agg((gsheets_kiosk_restriction.restriction)::text, ','::text) AS restrictions
   FROM mixalot.gsheets_kiosk_restriction
  GROUP BY gsheets_kiosk_restriction.kiosk_id;


ALTER TABLE mixalot.inm_kiosk_restriction_list OWNER TO dbservice;

--
-- Name: kiosk_restriction_by_property; Type: TABLE; Schema: mixalot; Owner: dbservice
--

CREATE TABLE mixalot.kiosk_restriction_by_property (
    kiosk_id integer NOT NULL,
    property_id integer NOT NULL
);


ALTER TABLE mixalot.kiosk_restriction_by_property OWNER TO dbservice;

--
-- Name: kiosk_restriction_by_sku; Type: TABLE; Schema: mixalot; Owner: dbservice
--

CREATE TABLE mixalot.kiosk_restriction_by_sku (
    kiosk_id integer NOT NULL,
    sku_id integer NOT NULL
);


ALTER TABLE mixalot.kiosk_restriction_by_sku OWNER TO dbservice;

--
-- Name: sku_def; Type: TABLE; Schema: mixalot; Owner: dbservice
--

CREATE TABLE mixalot.sku_def (
    id integer NOT NULL,
    title character varying(512) NOT NULL
);


ALTER TABLE mixalot.sku_def OWNER TO dbservice;

--
-- Name: TABLE sku_def; Type: COMMENT; Schema: mixalot; Owner: dbservice
--

COMMENT ON TABLE mixalot.sku_def IS 'SKUs id''s and names';


--
-- Name: sku_property; Type: TABLE; Schema: mixalot; Owner: dbservice
--

CREATE TABLE mixalot.sku_property (
    sku_id integer NOT NULL,
    property_id integer NOT NULL
);


ALTER TABLE mixalot.sku_property OWNER TO dbservice;

--
-- Name: TABLE sku_property; Type: COMMENT; Schema: mixalot; Owner: dbservice
--

COMMENT ON TABLE mixalot.sku_property IS 'all the properties for each sku';


--
-- Name: sku_property_def; Type: TABLE; Schema: mixalot; Owner: dbservice
--

CREATE TABLE mixalot.sku_property_def (
    id integer NOT NULL,
    attribute character varying(256),
    title character varying(512) NOT NULL
);


ALTER TABLE mixalot.sku_property_def OWNER TO dbservice;

--
-- Name: TABLE sku_property_def; Type: COMMENT; Schema: mixalot; Owner: dbservice
--

COMMENT ON TABLE mixalot.sku_property_def IS 'property_id, attribute, value.
Example:
1234 | container | glass
1235 | allergen | peanut
';


--
-- Name: inm_kiosk_sku_disabled; Type: VIEW; Schema: mixalot; Owner: dbservice
--

CREATE VIEW mixalot.inm_kiosk_sku_disabled AS
 SELECT DISTINCT krbp.kiosk_id,
    sd.id AS sku_id
   FROM (((mixalot.sku_def sd
     JOIN mixalot.sku_property sp ON ((sd.id = sp.sku_id)))
     JOIN mixalot.sku_property_def spd ON ((sp.property_id = spd.id)))
     JOIN mixalot.kiosk_restriction_by_property krbp ON ((krbp.property_id = spd.id)))
UNION
 SELECT DISTINCT kiosk_restriction_by_sku.kiosk_id,
    kiosk_restriction_by_sku.sku_id
   FROM mixalot.kiosk_restriction_by_sku;


ALTER TABLE mixalot.inm_kiosk_sku_disabled OWNER TO dbservice;

--
-- Name: inm_sku_enabled; Type: VIEW; Schema: mixalot; Owner: dbservice
--

CREATE VIEW mixalot.inm_sku_enabled AS
 SELECT k.id AS kiosk_id,
    s.id AS sku_id
   FROM ((mixalot.inm_byte_kiosk k
     CROSS JOIN mixalot.sku_def s)
     LEFT JOIN mixalot.inm_kiosk_sku_disabled d ON (((k.id = d.kiosk_id) AND (s.id = d.sku_id))))
  WHERE ((d.kiosk_id IS NULL) AND (d.sku_id IS NULL));


ALTER TABLE mixalot.inm_sku_enabled OWNER TO dbservice;

--
-- Name: inm_sku_group_title_to_merchandising_slot; Type: VIEW; Schema: mixalot; Owner: dbservice
--

CREATE VIEW mixalot.inm_sku_group_title_to_merchandising_slot AS
 SELECT sgd.title AS sku_group_title,
    mssg.merchandising_slot_id
   FROM (mixalot.merchandising_slot_sku_group mssg
     JOIN mixalot.sku_group_def sgd ON ((mssg.sku_group_id = sgd.id)))
  ORDER BY mssg.merchandising_slot_id;


ALTER TABLE mixalot.inm_sku_group_title_to_merchandising_slot OWNER TO dbservice;

--
-- Name: kiosk; Type: TABLE; Schema: mixalot; Owner: dbservice
--

CREATE TABLE mixalot.kiosk (
    kiosk_id integer NOT NULL,
    gcm_id text,
    app_vname text,
    app_vcode text,
    last_login timestamp(6) with time zone,
    last_update timestamp(6) with time zone,
    last_inventory timestamp(6) with time zone,
    last_status timestamp(6) with time zone,
    components json
);


ALTER TABLE mixalot.kiosk OWNER TO dbservice;

--
-- Name: kiosk_contents; Type: TABLE; Schema: mixalot; Owner: dbservice
--

CREATE TABLE mixalot.kiosk_contents (
    id integer NOT NULL,
    product_id integer,
    quantity integer,
    "time" bigint
);


ALTER TABLE mixalot.kiosk_contents OWNER TO dbservice;

--
-- Name: kiosk_contents_id_seq; Type: SEQUENCE; Schema: mixalot; Owner: dbservice
--

CREATE SEQUENCE mixalot.kiosk_contents_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE mixalot.kiosk_contents_id_seq OWNER TO dbservice;

--
-- Name: kiosk_contents_id_seq; Type: SEQUENCE OWNED BY; Schema: mixalot; Owner: dbservice
--

ALTER SEQUENCE mixalot.kiosk_contents_id_seq OWNED BY mixalot.kiosk_contents.id;


--
-- Name: kiosk_fact; Type: TABLE; Schema: mixalot; Owner: dbservice
--

CREATE TABLE mixalot.kiosk_fact (
    id integer NOT NULL,
    kiosk_id integer,
    kiosk_title text,
    campus_id integer,
    serials text,
    current_serial text,
    archived integer,
    last_delivery_ts timestamp(6) with time zone,
    last_purchase_ts timestamp(6) with time zone,
    cnt_deliveries_1w double precision,
    cnt_deliveries_30d double precision,
    cnt_deliveries_6m double precision,
    acc_list_price_1w double precision,
    acc_list_price_30d double precision,
    acc_list_price_6m double precision,
    cnt_orders_1w double precision,
    cnt_orders_30d double precision,
    cnt_orders_6m double precision,
    cnt_unique_cards_1w double precision,
    cnt_unique_cards_30d double precision,
    cnt_unique_cards_6m double precision
);


ALTER TABLE mixalot.kiosk_fact OWNER TO dbservice;

--
-- Name: kiosk_fact_id_seq; Type: SEQUENCE; Schema: mixalot; Owner: dbservice
--

CREATE SEQUENCE mixalot.kiosk_fact_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE mixalot.kiosk_fact_id_seq OWNER TO dbservice;

--
-- Name: kiosk_fact_id_seq; Type: SEQUENCE OWNED BY; Schema: mixalot; Owner: dbservice
--

ALTER SEQUENCE mixalot.kiosk_fact_id_seq OWNED BY mixalot.kiosk_fact.id;


--
-- Name: kiosk_restriction; Type: TABLE; Schema: mixalot; Owner: dbservice
--

CREATE TABLE mixalot.kiosk_restriction (
    kiosk_id integer NOT NULL,
    sku_id integer NOT NULL
);


ALTER TABLE mixalot.kiosk_restriction OWNER TO dbservice;

--
-- Name: request_log; Type: TABLE; Schema: mixalot; Owner: dbservice
--

CREATE TABLE mixalot.request_log (
    request_uuid uuid NOT NULL,
    endpoint text,
    client_ip text,
    version text,
    cookie text,
    message text,
    request_body text,
    request_headers text,
    start_ts timestamp(6) with time zone,
    response_body text,
    response_headers text,
    status_code integer,
    end_ts timestamp(6) with time zone,
    traceback text,
    request_body_json text,
    request_headers_json text,
    response_headers_json text,
    kiosk_id character varying(50),
    source text,
    flushed timestamp(6) with time zone,
    order_id character varying(135),
    stamp bigint,
    "time" bigint,
    kid bigint,
    client_time timestamp(6) with time zone,
    rec_version integer,
    query_string text
);


ALTER TABLE mixalot.request_log OWNER TO dbservice;

--
-- Name: kiosk_status; Type: VIEW; Schema: mixalot; Owner: dbservice
--

CREATE VIEW mixalot.kiosk_status AS
 SELECT l.kiosk_id AS auth_token_kiosk_id,
    l.start_ts AS server_time,
    to_timestamp(((((l.request_body_json)::json ->> 'time'::text))::integer)::double precision) AS "time",
    ((l.request_body_json)::json ->> 'kiosk_id'::text) AS kiosk_id,
    ((l.request_body_json)::json ->> 'retry_queue_length'::text) AS retry_queue_length,
    ((l.request_body_json)::json ->> 'retry_count'::text) AS retry_count,
    ((l.request_body_json)::json ->> 'happy_hour'::text) AS happy_hour,
    ((l.request_body_json)::json ->> 'app_uptime'::text) AS app_uptime,
    ((l.request_body_json)::json ->> 'system_uptime'::text) AS system_uptime,
    ((l.request_body_json)::json ->> 'kiosk_temperature'::text) AS kiosk_temperature,
    ((l.request_body_json)::json ->> 'kit_temperature'::text) AS kit_temperature,
    ((l.request_body_json)::json ->> 'power'::text) AS power,
    ((l.request_body_json)::json ->> 'battery_level'::text) AS battery_level,
    ((l.request_body_json)::json ->> 'rfid_0'::text) AS rfid_0,
    ((l.request_body_json)::json ->> 'rfid_1'::text) AS rfid_1,
    ((l.request_body_json)::json ->> 'rfid_2'::text) AS rfid_2,
    ((l.request_body_json)::json ->> 'rfid_3'::text) AS rfid_3,
    ((l.request_body_json)::json ->> 'rfid_4'::text) AS rfid_4,
    ((l.request_body_json)::json ->> 'rfid_5'::text) AS rfid_5,
    ((l.request_body_json)::json ->> 'rfid_6'::text) AS rfid_6,
    ((l.request_body_json)::json ->> 'rfid_7'::text) AS rfid_7
   FROM mixalot.request_log l
  WHERE ((((l.request_headers_json)::json ->> 'User-Agent'::text) !~~ '%monitis%'::text) AND (l.endpoint = '/status'::text))
  ORDER BY l.start_ts;


ALTER TABLE mixalot.kiosk_status OWNER TO dbservice;

--
-- Name: last_kiosk_status; Type: TABLE; Schema: mixalot; Owner: dbservice
--

CREATE TABLE mixalot.last_kiosk_status (
    id bigint NOT NULL,
    kiosk_id bigint NOT NULL,
    kiosk_temperature numeric(6,3),
    kiosk_temperature_count smallint,
    kit_temperature numeric(6,3),
    temperature_tags character varying(6141),
    kiosk_temperature_source character varying(93),
    power integer,
    battery_level smallint,
    rfid_0 integer,
    rfid_1 integer,
    rfid_2 integer,
    rfid_3 integer,
    rfid_4 integer,
    rfid_5 integer,
    rfid_6 integer,
    rfid_7 integer,
    "time" bigint,
    modem_signal_percentage smallint,
    modem_signal_type character varying(81),
    ip character varying(135),
    app_uptime bigint,
    system_uptime bigint,
    is_locked smallint
);


ALTER TABLE mixalot.last_kiosk_status OWNER TO dbservice;

--
-- Name: tmp_unit; Type: TABLE; Schema: mixalot; Owner: dbservice
--

CREATE TABLE mixalot.tmp_unit (
    id integer NOT NULL,
    order_id character varying(135),
    epc character varying(135),
    product_id integer,
    name text,
    discounts json,
    price numeric(28,6),
    list_price numeric(28,6),
    cost numeric(28,6),
    create_dt timestamp(6) with time zone,
    modify_dt timestamp(6) with time zone
);


ALTER TABLE mixalot.tmp_unit OWNER TO dbservice;

--
-- Name: lineitem_id_seq; Type: SEQUENCE; Schema: mixalot; Owner: dbservice
--

CREATE SEQUENCE mixalot.lineitem_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE mixalot.lineitem_id_seq OWNER TO dbservice;

--
-- Name: lineitem_id_seq; Type: SEQUENCE OWNED BY; Schema: mixalot; Owner: dbservice
--

ALTER SEQUENCE mixalot.lineitem_id_seq OWNED BY mixalot.tmp_unit.id;


--
-- Name: log; Type: TABLE; Schema: mixalot; Owner: dbservice
--

CREATE TABLE mixalot.log (
    id integer NOT NULL,
    request_uuid uuid,
    endpoint text,
    version text,
    system text,
    subsystem text,
    ts timestamp(6) with time zone,
    message text,
    herenow text,
    traceback text,
    kiosk_id integer,
    order_id character varying(135),
    product_id integer,
    epc text,
    client_ip text,
    attributes json
);


ALTER TABLE mixalot.log OWNER TO dbservice;

--
-- Name: log_id_seq; Type: SEQUENCE; Schema: mixalot; Owner: dbservice
--

CREATE SEQUENCE mixalot.log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE mixalot.log_id_seq OWNER TO dbservice;

--
-- Name: log_id_seq; Type: SEQUENCE OWNED BY; Schema: mixalot; Owner: dbservice
--

ALTER SEQUENCE mixalot.log_id_seq OWNED BY mixalot.log.id;


--
-- Name: merchandising_slot; Type: TABLE; Schema: mixalot; Owner: dbservice
--

CREATE TABLE mixalot.merchandising_slot (
    id integer NOT NULL,
    title character varying(512) NOT NULL
);


ALTER TABLE mixalot.merchandising_slot OWNER TO dbservice;

--
-- Name: merchandising_slot_def; Type: TABLE; Schema: mixalot; Owner: dbservice
--

CREATE TABLE mixalot.merchandising_slot_def (
    id integer NOT NULL,
    title character varying(512) NOT NULL
);


ALTER TABLE mixalot.merchandising_slot_def OWNER TO dbservice;

--
-- Name: merchandising_slot_def_id_seq; Type: SEQUENCE; Schema: mixalot; Owner: dbservice
--

CREATE SEQUENCE mixalot.merchandising_slot_def_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE mixalot.merchandising_slot_def_id_seq OWNER TO dbservice;

--
-- Name: merchandising_slot_def_id_seq; Type: SEQUENCE OWNED BY; Schema: mixalot; Owner: dbservice
--

ALTER SEQUENCE mixalot.merchandising_slot_def_id_seq OWNED BY mixalot.merchandising_slot_def.id;


--
-- Name: merchandising_slot_id_seq; Type: SEQUENCE; Schema: mixalot; Owner: dbservice
--

CREATE SEQUENCE mixalot.merchandising_slot_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE mixalot.merchandising_slot_id_seq OWNER TO dbservice;

--
-- Name: merchandising_slot_id_seq; Type: SEQUENCE OWNED BY; Schema: mixalot; Owner: dbservice
--

ALTER SEQUENCE mixalot.merchandising_slot_id_seq OWNED BY mixalot.merchandising_slot.id;


--
-- Name: order_fact; Type: TABLE; Schema: mixalot; Owner: dbservice
--

CREATE TABLE mixalot.order_fact (
    id integer NOT NULL,
    order_id text,
    hash text,
    email text,
    first_name text,
    last_name text,
    kiosk_id integer,
    kiosk_title text,
    campus_id integer,
    sales_price double precision,
    list_price double precision,
    contents_id integer
);


ALTER TABLE mixalot.order_fact OWNER TO dbservice;

--
-- Name: order_fact_id_seq; Type: SEQUENCE; Schema: mixalot; Owner: dbservice
--

CREATE SEQUENCE mixalot.order_fact_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE mixalot.order_fact_id_seq OWNER TO dbservice;

--
-- Name: order_fact_id_seq; Type: SEQUENCE OWNED BY; Schema: mixalot; Owner: dbservice
--

ALTER SEQUENCE mixalot.order_fact_id_seq OWNED BY mixalot.order_fact.id;


--
-- Name: pgdu_bytes; Type: VIEW; Schema: mixalot; Owner: dbservice
--

CREATE VIEW mixalot.pgdu_bytes AS
 SELECT all_tables.table_name,
    pg_table_size((all_tables.table_name)::regclass) AS table_size,
    pg_indexes_size((all_tables.table_name)::regclass) AS indexes_size,
    pg_total_relation_size((all_tables.table_name)::regclass) AS total_size
   FROM ( SELECT (((('"'::text || (tables.table_schema)::text) || '"."'::text) || (tables.table_name)::text) || '"'::text) AS table_name
           FROM information_schema.tables) all_tables
  ORDER BY (pg_total_relation_size((all_tables.table_name)::regclass)) DESC;


ALTER TABLE mixalot.pgdu_bytes OWNER TO dbservice;

--
-- Name: pgdu; Type: VIEW; Schema: mixalot; Owner: dbservice
--

CREATE VIEW mixalot.pgdu AS
 SELECT pgdu_bytes.table_name,
    pg_size_pretty(pgdu_bytes.table_size) AS table_size,
    pg_size_pretty(pgdu_bytes.indexes_size) AS indexes_size,
    pg_size_pretty(pgdu_bytes.total_size) AS total_size
   FROM mixalot.pgdu_bytes;


ALTER TABLE mixalot.pgdu OWNER TO dbservice;

--
-- Name: pick; Type: TABLE; Schema: mixalot; Owner: dbservice
--

CREATE TABLE mixalot.pick (
    kiosk_id integer NOT NULL,
    sku_id integer NOT NULL,
    inventory_qty smallint,
    demand_qty smallint,
    allocated_qty smallint,
    substituted_qty smallint,
    driver_name character varying(60) NOT NULL,
    route_time time(6) without time zone NOT NULL,
    route_date date NOT NULL,
    route_number character varying(60) NOT NULL,
    delivery_order smallint NOT NULL,
    pick_date date NOT NULL
);


ALTER TABLE mixalot.pick OWNER TO dbservice;

--
-- Name: pick_preference_kiosk_sku; Type: TABLE; Schema: mixalot; Owner: dbservice
--

CREATE TABLE mixalot.pick_preference_kiosk_sku (
    kiosk_id integer NOT NULL,
    sku_id integer NOT NULL,
    preference smallint NOT NULL
);


ALTER TABLE mixalot.pick_preference_kiosk_sku OWNER TO dbservice;

--
-- Name: pick_priority_kiosk; Type: TABLE; Schema: mixalot; Owner: dbservice
--

CREATE TABLE mixalot.pick_priority_kiosk (
    kiosk_id integer NOT NULL,
    priority integer,
    comment text,
    end_date date
);


ALTER TABLE mixalot.pick_priority_kiosk OWNER TO dbservice;

--
-- Name: pick_priority_sku; Type: TABLE; Schema: mixalot; Owner: dbservice
--

CREATE TABLE mixalot.pick_priority_sku (
    sku_id integer NOT NULL,
    priority integer
);


ALTER TABLE mixalot.pick_priority_sku OWNER TO dbservice;

--
-- Name: product_fact; Type: TABLE; Schema: mixalot; Owner: dbservice
--

CREATE TABLE mixalot.product_fact (
    id integer NOT NULL,
    product_id integer,
    sku text,
    first_available_ts timestamp(6) with time zone,
    first_purchased_ts timestamp(6) with time zone,
    kiosks text,
    cnt_sales_1w integer,
    cnt_sales_30d integer,
    cnt_sales_6m integer
);


ALTER TABLE mixalot.product_fact OWNER TO dbservice;

--
-- Name: product_fact_id_seq; Type: SEQUENCE; Schema: mixalot; Owner: dbservice
--

CREATE SEQUENCE mixalot.product_fact_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE mixalot.product_fact_id_seq OWNER TO dbservice;

--
-- Name: product_fact_id_seq; Type: SEQUENCE OWNED BY; Schema: mixalot; Owner: dbservice
--

ALTER SEQUENCE mixalot.product_fact_id_seq OWNED BY mixalot.product_fact.id;


--
-- Name: product_kiosk_fact; Type: TABLE; Schema: mixalot; Owner: dbservice
--

CREATE TABLE mixalot.product_kiosk_fact (
    id integer NOT NULL,
    product_id integer,
    kiosk_id integer,
    qty integer,
    "timestamp" timestamp(6) with time zone
);


ALTER TABLE mixalot.product_kiosk_fact OWNER TO dbservice;

--
-- Name: product_kiosk_fact_id_seq; Type: SEQUENCE; Schema: mixalot; Owner: dbservice
--

CREATE SEQUENCE mixalot.product_kiosk_fact_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE mixalot.product_kiosk_fact_id_seq OWNER TO dbservice;

--
-- Name: product_kiosk_fact_id_seq; Type: SEQUENCE OWNED BY; Schema: mixalot; Owner: dbservice
--

ALTER SEQUENCE mixalot.product_kiosk_fact_id_seq OWNED BY mixalot.product_kiosk_fact.id;


--
-- Name: route; Type: TABLE; Schema: mixalot; Owner: dbservice
--

CREATE TABLE mixalot.route (
    route_date_time timestamp(6) with time zone NOT NULL,
    duration integer,
    vehicle_label character varying(200),
    vehicle_registration character varying(200),
    driver_serial character varying(200),
    distance numeric(28,6),
    driver_name character varying(200) NOT NULL
);


ALTER TABLE mixalot.route OWNER TO dbservice;

--
-- Name: server; Type: TABLE; Schema: mixalot; Owner: dbservice
--

CREATE TABLE mixalot.server (
    id integer NOT NULL,
    name text,
    time_offset integer,
    modify_dt timestamp(6) with time zone
);


ALTER TABLE mixalot.server OWNER TO dbservice;

--
-- Name: server_id_seq; Type: SEQUENCE; Schema: mixalot; Owner: dbservice
--

CREATE SEQUENCE mixalot.server_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE mixalot.server_id_seq OWNER TO dbservice;

--
-- Name: server_id_seq; Type: SEQUENCE OWNED BY; Schema: mixalot; Owner: dbservice
--

ALTER SEQUENCE mixalot.server_id_seq OWNED BY mixalot.server.id;


--
-- Name: sku_attribute_def_id_seq; Type: SEQUENCE; Schema: mixalot; Owner: dbservice
--

CREATE SEQUENCE mixalot.sku_attribute_def_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE mixalot.sku_attribute_def_id_seq OWNER TO dbservice;

--
-- Name: sku_attribute_def_id_seq; Type: SEQUENCE OWNED BY; Schema: mixalot; Owner: dbservice
--

ALTER SEQUENCE mixalot.sku_attribute_def_id_seq OWNED BY mixalot.sku_property_def.id;


--
-- Name: sku_group; Type: TABLE; Schema: mixalot; Owner: dbservice
--

CREATE TABLE mixalot.sku_group (
    id integer NOT NULL,
    title character varying(50),
    group_type character varying(50),
    replacement_type character varying(50),
    created timestamp(6) with time zone,
    updated timestamp(6) with time zone
);


ALTER TABLE mixalot.sku_group OWNER TO dbservice;

--
-- Name: sku_group_def_id_seq; Type: SEQUENCE; Schema: mixalot; Owner: dbservice
--

CREATE SEQUENCE mixalot.sku_group_def_id_seq
    START WITH 1
    INCREMENT BY 1
    MINVALUE 0
    NO MAXVALUE
    CACHE 1;


ALTER TABLE mixalot.sku_group_def_id_seq OWNER TO dbservice;

--
-- Name: sku_group_def_id_seq; Type: SEQUENCE OWNED BY; Schema: mixalot; Owner: dbservice
--

ALTER SEQUENCE mixalot.sku_group_def_id_seq OWNED BY mixalot.sku_group_def.id;


--
-- Name: sku_group_id_seq; Type: SEQUENCE; Schema: mixalot; Owner: dbservice
--

CREATE SEQUENCE mixalot.sku_group_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE mixalot.sku_group_id_seq OWNER TO dbservice;

--
-- Name: sku_group_id_seq; Type: SEQUENCE OWNED BY; Schema: mixalot; Owner: dbservice
--

ALTER SEQUENCE mixalot.sku_group_id_seq OWNED BY mixalot.sku_group.id;


--
-- Name: sku_group_member; Type: TABLE; Schema: mixalot; Owner: dbservice
--

CREATE TABLE mixalot.sku_group_member (
    id integer NOT NULL,
    sku_group_id integer,
    product_id integer,
    created timestamp(6) with time zone,
    updated timestamp(6) with time zone
);


ALTER TABLE mixalot.sku_group_member OWNER TO dbservice;

--
-- Name: sku_group_member_id_seq; Type: SEQUENCE; Schema: mixalot; Owner: dbservice
--

CREATE SEQUENCE mixalot.sku_group_member_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE mixalot.sku_group_member_id_seq OWNER TO dbservice;

--
-- Name: sku_group_member_id_seq; Type: SEQUENCE OWNED BY; Schema: mixalot; Owner: dbservice
--

ALTER SEQUENCE mixalot.sku_group_member_id_seq OWNED BY mixalot.sku_group_member.id;


--
-- Name: tally; Type: TABLE; Schema: mixalot; Owner: dbservice
--

CREATE TABLE mixalot.tally (
    n integer NOT NULL
);


ALTER TABLE mixalot.tally OWNER TO dbservice;

--
-- Name: temp_kiosk_restriction; Type: TABLE; Schema: mixalot; Owner: dbservice
--

CREATE TABLE mixalot.temp_kiosk_restriction (
    kiosk_id integer NOT NULL,
    restriction character varying(256) NOT NULL,
    property_id integer
);


ALTER TABLE mixalot.temp_kiosk_restriction OWNER TO dbservice;

--
-- Name: temp_ms_to_sg; Type: TABLE; Schema: mixalot; Owner: dbservice
--

CREATE TABLE mixalot.temp_ms_to_sg (
    mslot character varying(512) NOT NULL,
    sgroup character varying(512) NOT NULL
);


ALTER TABLE mixalot.temp_ms_to_sg OWNER TO dbservice;

--
-- Name: TABLE temp_ms_to_sg; Type: COMMENT; Schema: mixalot; Owner: dbservice
--

COMMENT ON TABLE mixalot.temp_ms_to_sg IS 'temp lookup table for merchandising slot to skugroup';


--
-- Name: temp_sku_group_volume; Type: TABLE; Schema: mixalot; Owner: dbservice
--

CREATE TABLE mixalot.temp_sku_group_volume (
    title character varying(512) NOT NULL,
    volume numeric(4,2) NOT NULL,
    minimum smallint
);


ALTER TABLE mixalot.temp_sku_group_volume OWNER TO dbservice;

--
-- Name: temp_sku_to_skugroup; Type: TABLE; Schema: mixalot; Owner: dbservice
--

CREATE TABLE mixalot.temp_sku_to_skugroup (
    sku integer NOT NULL,
    sku_group character varying(512) NOT NULL
);


ALTER TABLE mixalot.temp_sku_to_skugroup OWNER TO dbservice;

--
-- Name: TABLE temp_sku_to_skugroup; Type: COMMENT; Schema: mixalot; Owner: dbservice
--

COMMENT ON TABLE mixalot.temp_sku_to_skugroup IS 'temp lookup table for sku-sku_group';


--
-- Name: temp_test; Type: TABLE; Schema: mixalot; Owner: dbservice
--

CREATE TABLE mixalot.temp_test (
    id integer NOT NULL,
    name character varying(16) NOT NULL,
    total integer NOT NULL
);


ALTER TABLE mixalot.temp_test OWNER TO dbservice;

--
-- Name: temp_test_id_seq; Type: SEQUENCE; Schema: mixalot; Owner: dbservice
--

CREATE SEQUENCE mixalot.temp_test_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE mixalot.temp_test_id_seq OWNER TO dbservice;

--
-- Name: temp_test_id_seq; Type: SEQUENCE OWNED BY; Schema: mixalot; Owner: dbservice
--

ALTER SEQUENCE mixalot.temp_test_id_seq OWNED BY mixalot.temp_test.id;


--
-- Name: test_time; Type: TABLE; Schema: mixalot; Owner: dbservice
--

CREATE TABLE mixalot.test_time (
    id integer NOT NULL,
    ts timestamp(6) with time zone
);


ALTER TABLE mixalot.test_time OWNER TO dbservice;

--
-- Name: test_time_id_seq; Type: SEQUENCE; Schema: mixalot; Owner: dbservice
--

CREATE SEQUENCE mixalot.test_time_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE mixalot.test_time_id_seq OWNER TO dbservice;

--
-- Name: test_time_id_seq; Type: SEQUENCE OWNED BY; Schema: mixalot; Owner: dbservice
--

ALTER SEQUENCE mixalot.test_time_id_seq OWNED BY mixalot.test_time.id;


--
-- Name: tmp_discount_applied; Type: TABLE; Schema: mixalot; Owner: dbservice
--

CREATE TABLE mixalot.tmp_discount_applied (
    id integer NOT NULL,
    order_id character varying(135),
    sequence integer,
    epc character varying(135),
    product_id integer,
    discount json,
    price_before numeric(28,6),
    price_after numeric(28,6),
    sponsor character varying(135),
    ts timestamp(6) with time zone
);


ALTER TABLE mixalot.tmp_discount_applied OWNER TO dbservice;

--
-- Name: tmp_discount_applied_id_seq; Type: SEQUENCE; Schema: mixalot; Owner: dbservice
--

CREATE SEQUENCE mixalot.tmp_discount_applied_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE mixalot.tmp_discount_applied_id_seq OWNER TO dbservice;

--
-- Name: tmp_discount_applied_id_seq; Type: SEQUENCE OWNED BY; Schema: mixalot; Owner: dbservice
--

ALTER SEQUENCE mixalot.tmp_discount_applied_id_seq OWNED BY mixalot.tmp_discount_applied.id;


--
-- Name: tmp_kiosk_status; Type: TABLE; Schema: mixalot; Owner: dbservice
--

CREATE TABLE mixalot.tmp_kiosk_status (
    id integer NOT NULL,
    kiosk_id integer NOT NULL,
    kiosk_temperature numeric(6,3),
    kit_temperature numeric(6,3),
    power integer,
    battery_level smallint,
    rfid_0 integer,
    rfid_1 integer,
    rfid_2 integer,
    rfid_3 integer,
    rfid_4 integer,
    rfid_5 integer,
    rfid_6 integer,
    rfid_7 integer,
    "time" bigint,
    modem_signal_percentage smallint,
    modem_signal_type character varying(81),
    ip character varying(135),
    notes text
);


ALTER TABLE mixalot.tmp_kiosk_status OWNER TO dbservice;

--
-- Name: tmp_kiosk_status_id_seq; Type: SEQUENCE; Schema: mixalot; Owner: dbservice
--

CREATE SEQUENCE mixalot.tmp_kiosk_status_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE mixalot.tmp_kiosk_status_id_seq OWNER TO dbservice;

--
-- Name: tmp_kiosk_status_id_seq; Type: SEQUENCE OWNED BY; Schema: mixalot; Owner: dbservice
--

ALTER SEQUENCE mixalot.tmp_kiosk_status_id_seq OWNED BY mixalot.tmp_kiosk_status.id;


--
-- Name: tmp_transact; Type: TABLE; Schema: mixalot; Owner: dbservice
--

CREATE TABLE mixalot.tmp_transact (
    order_id character varying(135) NOT NULL,
    first_name text,
    last_name text,
    kiosk_id integer,
    kiosk_title text,
    email text,
    amount_paid numeric(28,6),
    payment_system text,
    transaction_id text,
    approval_code text,
    status_code text,
    status_message text,
    created timestamp(6) with time zone,
    time_opened timestamp(6) with time zone,
    time_closed timestamp(6) with time zone,
    card_hash text,
    card_number text,
    card_type text,
    state text,
    stamp integer,
    last_update timestamp(6) with time zone,
    balance numeric(28,6),
    coupon_id integer,
    coupon text,
    refund numeric(28,6),
    receipt integer,
    campus_id integer,
    amount_list_price numeric(28,6),
    flushed timestamp(6) with time zone,
    create_dt timestamp(6) with time zone,
    modify_dt timestamp(6) with time zone,
    finalized integer
);


ALTER TABLE mixalot.tmp_transact OWNER TO dbservice;

--
-- Name: v_kiosk_request_log; Type: VIEW; Schema: mixalot; Owner: dbservice
--

CREATE VIEW mixalot.v_kiosk_request_log AS
 SELECT l.start_ts AS ts,
    (((l.request_body_json)::json ->> 'time'::text))::bigint AS "time",
    l.request_uuid,
    l.endpoint,
    l.client_ip,
    l.version,
    l.cookie,
    l.message,
    l.request_body,
    l.request_headers,
    l.start_ts,
    l.response_body,
    l.response_headers,
    l.status_code,
    l.end_ts,
    l.traceback,
    l.request_body_json,
    l.request_headers_json,
    l.response_headers_json,
    l.kiosk_id,
    l.source
   FROM mixalot.request_log l
  WHERE ((((l.request_headers_json)::json ->> 'User-Agent'::text) !~~ '%monitis%'::text) AND (l.source = 'mixalot'::text));


ALTER TABLE mixalot.v_kiosk_request_log OWNER TO dbservice;

--
-- Name: v_kiosk_inventory_log; Type: VIEW; Schema: mixalot; Owner: dbservice
--

CREATE VIEW mixalot.v_kiosk_inventory_log AS
 SELECT l.ts,
    l."time",
    l.request_uuid,
    l.endpoint,
    l.client_ip,
    l.version,
    l.cookie,
    l.message,
    l.request_body,
    l.request_headers,
    l.start_ts,
    l.response_body,
    l.response_headers,
    l.status_code,
    l.end_ts,
    l.traceback,
    l.request_body_json,
    l.request_headers_json,
    l.response_headers_json,
    l.kiosk_id,
    l.source,
    (((l.request_body_json)::json ->> 'epc'::text))::character varying AS epc,
    (((l.request_body_json)::json ->> 'retry_count'::text))::integer AS retry_count
   FROM mixalot.v_kiosk_request_log l
  WHERE ((l.endpoint = '/inventory'::text) AND (l.source = 'mixalot'::text));


ALTER TABLE mixalot.v_kiosk_inventory_log OWNER TO dbservice;

--
-- Name: v_kiosk_item_log; Type: VIEW; Schema: mixalot; Owner: dbservice
--

CREATE VIEW mixalot.v_kiosk_item_log AS
 SELECT l.ts,
    l."time",
    l.request_uuid,
    l.endpoint,
    l.client_ip,
    l.version,
    l.cookie,
    l.message,
    l.request_body,
    l.request_headers,
    l.start_ts,
    l.response_body,
    l.response_headers,
    l.status_code,
    l.end_ts,
    l.traceback,
    l.request_body_json,
    l.request_headers_json,
    l.response_headers_json,
    l.kiosk_id,
    l.source,
    (((l.request_body_json)::json ->> 'epc'::text))::character varying AS epc,
    (((l.request_body_json)::json ->> 'direction'::text))::character varying AS direction,
    (((l.request_body_json)::json ->> 'rssi'::text))::integer AS rssi,
    (((l.request_body_json)::json ->> 'read_count'::text))::integer AS read_count
   FROM mixalot.v_kiosk_request_log l
  WHERE ((l.endpoint = '/item'::text) AND (l.source = 'mixalot'::text));


ALTER TABLE mixalot.v_kiosk_item_log OWNER TO dbservice;

--
-- Name: v_kiosk_status_log; Type: VIEW; Schema: mixalot; Owner: dbservice
--

CREATE VIEW mixalot.v_kiosk_status_log AS
 SELECT l.ts,
    l."time",
    l.request_uuid,
    l.endpoint,
    l.client_ip,
    l.version,
    l.cookie,
    l.message,
    l.request_body,
    l.request_headers,
    l.start_ts,
    l.response_body,
    l.response_headers,
    l.status_code,
    l.end_ts,
    l.traceback,
    l.request_body_json,
    l.request_headers_json,
    l.response_headers_json,
    l.kiosk_id,
    l.source,
    (((l.request_body_json)::json ->> 'kiosk_id'::text))::integer AS client_kiosk_id,
    (((l.request_body_json)::json ->> 'retry_queue_length'::text))::integer AS retry_queue_length,
    (((l.request_body_json)::json ->> 'retry_count'::text))::integer AS retry_count,
    (((l.request_body_json)::json ->> 'happy_hour'::text))::integer AS happy_hour,
    (((l.request_body_json)::json ->> 'app_uptime'::text))::integer AS app_uptime,
    (((l.request_body_json)::json ->> 'system_uptime'::text))::integer AS system_uptime,
    (((l.request_body_json)::json ->> 'kiosk_temperature'::text))::numeric AS kiosk_temperature,
    (((l.request_body_json)::json ->> 'kit_temperature'::text))::numeric AS kit_temperature,
    (((l.request_body_json)::json ->> 'power'::text))::integer AS power,
    (((l.request_body_json)::json ->> 'battery_level'::text))::integer AS battery_level,
    (((l.request_body_json)::json ->> 'rfid_0'::text))::integer AS rfid_0,
    (((l.request_body_json)::json ->> 'rfid_1'::text))::integer AS rfid_1,
    (((l.request_body_json)::json ->> 'rfid_2'::text))::integer AS rfid_2,
    (((l.request_body_json)::json ->> 'rfid_3'::text))::integer AS rfid_3,
    (((l.request_body_json)::json ->> 'rfid_4'::text))::integer AS rfid_4,
    (((l.request_body_json)::json ->> 'rfid_5'::text))::integer AS rfid_5,
    (((l.request_body_json)::json ->> 'rfid_6'::text))::integer AS rfid_6,
    (((l.request_body_json)::json ->> 'rfid_7'::text))::integer AS rfid_7
   FROM mixalot.v_kiosk_request_log l
  WHERE ((l.endpoint = '/status'::text) AND (l.source = 'mixalot'::text));


ALTER TABLE mixalot.v_kiosk_status_log OWNER TO dbservice;

--
-- Name: v_node_kiosk_request_log; Type: VIEW; Schema: mixalot; Owner: dbservice
--

CREATE VIEW mixalot.v_node_kiosk_request_log AS
 SELECT l.start_ts AS ts,
    (((l.request_body_json)::json ->> 'time'::text))::bigint AS "time",
    l.request_uuid,
    l.endpoint,
    l.client_ip,
    l.version,
    l.cookie,
    l.message,
    l.request_body,
    l.request_headers,
    l.start_ts,
    l.response_body,
    l.response_headers,
    l.status_code,
    l.end_ts,
    l.traceback,
    l.request_body_json,
    l.request_headers_json,
    l.response_headers_json,
    l.kiosk_id,
    l.source
   FROM mixalot.request_log l
  WHERE (l.source = 'node'::text);


ALTER TABLE mixalot.v_node_kiosk_request_log OWNER TO dbservice;

--
-- Name: v_node_kiosk_status_log; Type: VIEW; Schema: mixalot; Owner: dbservice
--

CREATE VIEW mixalot.v_node_kiosk_status_log AS
 SELECT l.ts,
    l."time",
    l.request_uuid,
    l.endpoint,
    l.client_ip,
    l.version,
    l.cookie,
    l.message,
    l.request_body,
    l.request_headers,
    l.start_ts,
    l.response_body,
    l.response_headers,
    l.status_code,
    l.end_ts,
    l.traceback,
    l.request_body_json,
    l.request_headers_json,
    l.response_headers_json,
    l.kiosk_id,
    l.source,
    (((l.request_body_json)::json ->> 'kiosk_id'::text))::integer AS client_kiosk_id,
    (((l.request_body_json)::json ->> 'retry_queue_length'::text))::integer AS retry_queue_length,
    (((l.request_body_json)::json ->> 'retry_count'::text))::integer AS retry_count,
    (((l.request_body_json)::json ->> 'happy_hour'::text))::integer AS happy_hour,
    (((l.request_body_json)::json ->> 'app_uptime'::text))::bigint AS app_uptime,
    (((l.request_body_json)::json ->> 'system_uptime'::text))::bigint AS system_uptime,
    (((l.request_body_json)::json ->> 'kiosk_temperature'::text))::numeric AS kiosk_temperature,
    (((l.request_body_json)::json ->> 'kit_temperature'::text))::numeric AS kit_temperature,
    (((l.request_body_json)::json ->> 'power'::text))::integer AS power,
    (((l.request_body_json)::json ->> 'battery_level'::text))::integer AS battery_level,
    (((l.request_body_json)::json ->> 'rfid_0'::text))::integer AS rfid_0,
    (((l.request_body_json)::json ->> 'rfid_1'::text))::integer AS rfid_1,
    (((l.request_body_json)::json ->> 'rfid_2'::text))::integer AS rfid_2,
    (((l.request_body_json)::json ->> 'rfid_3'::text))::integer AS rfid_3,
    (((l.request_body_json)::json ->> 'rfid_4'::text))::integer AS rfid_4,
    (((l.request_body_json)::json ->> 'rfid_5'::text))::integer AS rfid_5,
    (((l.request_body_json)::json ->> 'rfid_6'::text))::integer AS rfid_6,
    (((l.request_body_json)::json ->> 'rfid_7'::text))::integer AS rfid_7
   FROM mixalot.v_node_kiosk_request_log l
  WHERE ((l.endpoint = '/status'::text) AND (l.source = 'node'::text));


ALTER TABLE mixalot.v_node_kiosk_status_log OWNER TO dbservice;

--
-- Name: warehouse_order_history; Type: TABLE; Schema: mixalot; Owner: dbservice
--

CREATE TABLE mixalot.warehouse_order_history (
    time_added timestamp(6) with time zone NOT NULL,
    sku integer NOT NULL,
    qty integer NOT NULL,
    order_date date NOT NULL,
    delivery_date date NOT NULL,
    amount_arrived integer,
    status character varying(200),
    warehouse_comment text,
    ordering_comment text,
    action character varying(200),
    purchase_order character varying(200),
    best_by_date character varying(200)
);


ALTER TABLE mixalot.warehouse_order_history OWNER TO dbservice;

--
-- Name: cron_state; Type: TABLE; Schema: monitor; Owner: dbservice
--

CREATE TABLE monitor.cron_state (
    key text NOT NULL,
    value text
);


ALTER TABLE monitor.cron_state OWNER TO dbservice;

--
-- Name: kiosk_status; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.kiosk_status (
    id bigint NOT NULL,
    kiosk_id bigint NOT NULL,
    kiosk_temperature numeric(6,3),
    kiosk_temperature_count smallint,
    kit_temperature numeric(6,3),
    temperature_tags character varying(2047),
    kiosk_temperature_source character varying(31),
    power integer,
    battery_level smallint,
    rfid_0 integer,
    rfid_1 integer,
    rfid_2 integer,
    rfid_3 integer,
    rfid_4 integer,
    rfid_5 integer,
    rfid_6 integer,
    rfid_7 integer,
    "time" bigint,
    modem_signal_percentage smallint,
    modem_signal_type character varying(27),
    ip character varying(45),
    notes text,
    app_uptime bigint,
    system_uptime bigint,
    is_locked smallint,
    num_payment_messages_pending_sync integer DEFAULT 0,
    offline smallint DEFAULT 0
);


ALTER TABLE pantry.kiosk_status OWNER TO dbservice;

--
-- Name: kiosk_not_heard; Type: VIEW; Schema: monitor; Owner: dbservice
--

CREATE VIEW monitor.kiosk_not_heard AS
 SELECT kiosk_last_beat.id,
    kiosk_last_beat.geo,
    kiosk_last_beat.title,
    kiosk_last_beat.last_heard,
    kiosk_last_beat.last_heart_beat_minutes,
    kiosk_last_beat.campus_id
   FROM ( SELECT ks.kiosk_id AS id,
            k.geo,
            k.title,
            k.last_inventory AS last_heard,
            round((date_part('epoch'::text, (CURRENT_TIMESTAMP - max(to_timestamp((ks."time")::double precision)))) / (60.0)::double precision)) AS last_heart_beat_minutes,
            k.campus_id
           FROM (pantry.kiosk_status ks
             JOIN pantry.kiosk k ON ((k.id = ks.kiosk_id)))
          WHERE ((k.archived = 0) AND (k.last_inventory > 0))
          GROUP BY ks.kiosk_id, k.title, k.geo, k.last_inventory, k.campus_id) kiosk_last_beat
  WHERE (kiosk_last_beat.last_heart_beat_minutes > (40)::double precision);


ALTER TABLE monitor.kiosk_not_heard OWNER TO dbservice;

--
-- Name: opt_connect; Type: TABLE; Schema: monitor; Owner: dbservice
--

CREATE TABLE monitor.opt_connect (
    date_time timestamp(6) without time zone NOT NULL,
    summit_id integer NOT NULL,
    carrier text,
    customer_name text,
    customer_id integer,
    your_device_id text,
    signal_strength text,
    description text,
    device_model text,
    serial_number text,
    device_up_time text,
    static_ip text,
    snapshot_refresh_time bigint,
    last_check_in_time bigint,
    signal_quality text,
    data_plan bigint,
    data_used_date date,
    data_used bigint
);


ALTER TABLE monitor.opt_connect OWNER TO dbservice;

--
-- Name: accounting; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.accounting (
    id bigint NOT NULL,
    date character varying(45) NOT NULL,
    kiosk_id bigint NOT NULL,
    campus_id bigint NOT NULL,
    sales_ipc numeric(6,2) NOT NULL,
    sales_fp numeric(6,2) NOT NULL,
    sales_cs numeric(6,2) NOT NULL,
    sales_cp numeric(6,2) NOT NULL,
    tags_got bigint NOT NULL,
    tags_spent bigint NOT NULL,
    timezone smallint DEFAULT 0 NOT NULL,
    sales_tax numeric(4,2) NOT NULL,
    sales_tax_ipc numeric(6,2) NOT NULL,
    sales_tax_fp numeric(6,2) NOT NULL,
    sales_tax_cs numeric(6,2) NOT NULL,
    sales_tax_cp numeric(6,2) NOT NULL,
    prepaid bigint NOT NULL,
    current_fee bigint NOT NULL,
    next_fee bigint NOT NULL,
    recalculated_fee numeric(6,2),
    prepaid_day bigint NOT NULL,
    next_fee_from character varying(45),
    fee_connectivity numeric(5,2) NOT NULL
);


ALTER TABLE pantry.accounting OWNER TO dbservice;

--
-- Name: accounting_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.accounting_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.accounting_id_seq OWNER TO dbservice;

--
-- Name: accounting_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.accounting_id_seq OWNED BY pantry.accounting.id;


--
-- Name: bad_timestamp; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.bad_timestamp (
    id bigint NOT NULL,
    kiosk_id bigint,
    endpoint character varying(93),
    server_time bigint,
    data character varying(3069)
);


ALTER TABLE pantry.bad_timestamp OWNER TO dbservice;

--
-- Name: bad_timestamp_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.bad_timestamp_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.bad_timestamp_id_seq OWNER TO dbservice;

--
-- Name: bad_timestamp_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.bad_timestamp_id_seq OWNED BY pantry.bad_timestamp.id;


--
-- Name: campus; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.campus (
    id bigint NOT NULL,
    title character varying(45) NOT NULL,
    timezone character varying(50),
    archived integer DEFAULT 0
);


ALTER TABLE pantry.campus OWNER TO dbservice;

--
-- Name: campus_assets; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.campus_assets (
    campus_id bigint NOT NULL,
    logo character varying(255),
    background_image character varying(255),
    background_color character varying(50),
    receipt_header_text character varying(1000),
    receipt_footer_text character varying(1000),
    from_email text
);


ALTER TABLE pantry.campus_assets OWNER TO dbservice;

--
-- Name: campus_attribute; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.campus_attribute (
    id integer NOT NULL,
    campus_id bigint NOT NULL,
    key_id integer NOT NULL,
    value character varying(150) NOT NULL
);


ALTER TABLE pantry.campus_attribute OWNER TO dbservice;

--
-- Name: campus_attribute_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.campus_attribute_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.campus_attribute_id_seq OWNER TO dbservice;

--
-- Name: campus_attribute_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.campus_attribute_id_seq OWNED BY pantry.campus_attribute.id;


--
-- Name: campus_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.campus_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.campus_id_seq OWNER TO dbservice;

--
-- Name: campus_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.campus_id_seq OWNED BY pantry.campus.id;


--
-- Name: card; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.card (
    id bigint NOT NULL,
    hash character varying(88) NOT NULL,
    first_name character varying(45),
    last_name character varying(45),
    type character varying(15),
    number character varying(31),
    email character varying(127) NOT NULL,
    notes text,
    created bigint,
    last_update bigint
);


ALTER TABLE pantry.card OWNER TO dbservice;

--
-- Name: card_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.card_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.card_id_seq OWNER TO dbservice;

--
-- Name: card_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.card_id_seq OWNED BY pantry.card.id;


--
-- Name: kiosk_components_history; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.kiosk_components_history (
    id bigint NOT NULL,
    kiosk_id bigint NOT NULL,
    "time" bigint NOT NULL,
    type character varying(63),
    common_name character varying(63),
    version character varying(63),
    "full" character varying(255),
    notes text
);


ALTER TABLE pantry.kiosk_components_history OWNER TO dbservice;

--
-- Name: component_history_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.component_history_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.component_history_id_seq OWNER TO dbservice;

--
-- Name: component_history_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.component_history_id_seq OWNED BY pantry.kiosk_components_history.id;


--
-- Name: contract; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.contract (
    id bigint NOT NULL,
    url character varying(255) NOT NULL,
    user_id integer,
    name character varying(127),
    email character varying(127),
    payment_type character varying(50),
    pantry_quantity bigint,
    step smallint,
    paid smallint,
    archived smallint,
    initials character varying(50),
    total bigint,
    pricing_structure smallint,
    payment_transaction_id character varying(255),
    fee_monthly numeric(8,2),
    fee_6_month_pre_payment numeric(8,2),
    fee_12_month_pre_payment numeric(8,2),
    fee_label numeric(3,2),
    fee_transact numeric(5,4),
    fee_deposit numeric(8,2),
    logo character varying(255),
    terms character varying(255),
    requester_id bigint,
    monthly_allowed smallint NOT NULL
);


ALTER TABLE pantry.contract OWNER TO dbservice;

--
-- Name: contract_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.contract_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.contract_id_seq OWNER TO dbservice;

--
-- Name: contract_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.contract_id_seq OWNED BY pantry.contract.id;


--
-- Name: coupon; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.coupon (
    id bigint NOT NULL,
    code character varying(45) NOT NULL,
    flat_discount numeric(5,2) DEFAULT 0.00 NOT NULL,
    real_discount numeric(5,2) DEFAULT 0.00 NOT NULL,
    used bigint DEFAULT 0 NOT NULL,
    kiosk_list character varying(255),
    campaign character varying(255),
    created_by character varying(255)
);


ALTER TABLE pantry.coupon OWNER TO dbservice;

--
-- Name: coupon_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.coupon_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.coupon_id_seq OWNER TO dbservice;

--
-- Name: coupon_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.coupon_id_seq OWNED BY pantry.coupon.id;


--
-- Name: cron; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.cron (
    id integer NOT NULL,
    "time" character varying(300),
    kiosks character varying(30000),
    command character varying(300),
    payload text,
    trigger_id integer,
    dependencies character varying(300),
    user_id integer,
    raw_task text,
    active integer DEFAULT 1,
    group_id integer,
    timezone character varying(210),
    archived integer DEFAULT 0 NOT NULL
);


ALTER TABLE pantry.cron OWNER TO dbservice;

--
-- Name: cron_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.cron_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.cron_id_seq OWNER TO dbservice;

--
-- Name: cron_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.cron_id_seq OWNED BY pantry.cron.id;


--
-- Name: currency_symbol; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.currency_symbol (
    id integer NOT NULL,
    code character(3) NOT NULL,
    symbol text NOT NULL
);


ALTER TABLE pantry.currency_symbol OWNER TO dbservice;

--
-- Name: currency_symbol_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.currency_symbol_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.currency_symbol_id_seq OWNER TO dbservice;

--
-- Name: currency_symbol_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.currency_symbol_id_seq OWNED BY pantry.currency_symbol.id;


--
-- Name: current_label_status_365days; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.current_label_status_365days (
    epc character varying(72) NOT NULL,
    campus_id bigint NOT NULL,
    product_id bigint NOT NULL,
    product_title character varying(381) NOT NULL,
    price numeric(5,2) NOT NULL,
    status character varying(12) NOT NULL,
    kiosk_id bigint NOT NULL,
    order_id character varying(150) NOT NULL,
    first_timestamp bigint NOT NULL,
    last_timestamp bigint NOT NULL,
    cost numeric(5,2)
);


ALTER TABLE pantry.current_label_status_365days OWNER TO dbservice;

--
-- Name: dc_inventory; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.dc_inventory (
    product_id bigint NOT NULL,
    product_title character varying(765),
    tesla_inv bigint,
    inventory bigint,
    spoil bigint,
    date date
);


ALTER TABLE pantry.dc_inventory OWNER TO dbservice;

--
-- Name: delivery_schedule; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.delivery_schedule (
    id bigint NOT NULL,
    date date,
    driver character varying(765),
    route character varying(765),
    start_time character varying(30),
    location character varying(765),
    day character varying(765),
    pull_count bigint,
    kiosk_id bigint,
    loc_name character varying(765),
    pull_date date,
    clean_list character varying(765),
    clean_key bigint,
    kiosk_for_key character varying(765)
);


ALTER TABLE pantry.delivery_schedule OWNER TO dbservice;

--
-- Name: delivery_schedule_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.delivery_schedule_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.delivery_schedule_id_seq OWNER TO dbservice;

--
-- Name: delivery_schedule_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.delivery_schedule_id_seq OWNED BY pantry.delivery_schedule.id;


--
-- Name: discount; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.discount (
    id bigint NOT NULL,
    kiosk_id bigint,
    product_id bigint,
    value integer NOT NULL,
    type character varying(10),
    end_time integer,
    cron_task_id integer
);


ALTER TABLE pantry.discount OWNER TO dbservice;

--
-- Name: discount_applied; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.discount_applied (
    id integer NOT NULL,
    order_id character varying(135),
    sequence integer,
    epc character varying(135),
    product_id integer,
    discount character varying(65535),
    price_before numeric(6,2),
    price_after numeric(6,2),
    sponsor character varying(135),
    ts integer,
    notes text
);


ALTER TABLE pantry.discount_applied OWNER TO dbservice;

--
-- Name: discount_applied_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.discount_applied_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.discount_applied_id_seq OWNER TO dbservice;

--
-- Name: discount_applied_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.discount_applied_id_seq OWNED BY pantry.discount_applied.id;


--
-- Name: discount_history; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.discount_history (
    id integer NOT NULL,
    kiosk_id integer,
    product_id integer,
    value integer,
    start_time integer,
    end_time integer,
    discount_id integer
);


ALTER TABLE pantry.discount_history OWNER TO dbservice;

--
-- Name: discount_history_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.discount_history_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.discount_history_id_seq OWNER TO dbservice;

--
-- Name: discount_history_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.discount_history_id_seq OWNED BY pantry.discount_history.id;


--
-- Name: discount_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.discount_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.discount_id_seq OWNER TO dbservice;

--
-- Name: discount_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.discount_id_seq OWNED BY pantry.discount.id;


--
-- Name: email; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.email (
    id integer NOT NULL,
    hash character varying(100),
    "timestamp" integer NOT NULL,
    "from" character varying(200),
    "to" character varying(200),
    cc character varying(200),
    bcc character varying(200),
    subject character varying(200),
    body text,
    order_id character varying(12),
    kiosk_id integer,
    type character varying(100) NOT NULL
);


ALTER TABLE pantry.email OWNER TO dbservice;

--
-- Name: email_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.email_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.email_id_seq OWNER TO dbservice;

--
-- Name: email_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.email_id_seq OWNED BY pantry.email.id;


--
-- Name: empty_transaction; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.empty_transaction (
    id integer NOT NULL,
    order_id character varying(36),
    kiosk_name character varying(192),
    email character varying(384),
    created character varying(384),
    representative character varying(384),
    notes character varying(65535),
    fixed character varying(90),
    status character varying(150)
);


ALTER TABLE pantry.empty_transaction OWNER TO dbservice;

--
-- Name: empty_transaction_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.empty_transaction_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.empty_transaction_id_seq OWNER TO dbservice;

--
-- Name: empty_transaction_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.empty_transaction_id_seq OWNED BY pantry.empty_transaction.id;


--
-- Name: event; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.event (
    id bigint NOT NULL,
    user_id bigint NOT NULL,
    params character varying(6141) NOT NULL,
    action character varying(45) NOT NULL,
    options character varying(6141) NOT NULL,
    archived bigint NOT NULL
);


ALTER TABLE pantry.event OWNER TO dbservice;

--
-- Name: event_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.event_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.event_id_seq OWNER TO dbservice;

--
-- Name: event_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.event_id_seq OWNED BY pantry.event.id;


--
-- Name: facing_category_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.facing_category_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.facing_category_id_seq OWNER TO dbservice;

--
-- Name: facing_category_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.facing_category_id_seq OWNED BY pantry.facing_category.id;


--
-- Name: fee_rates; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.fee_rates (
    id bigint NOT NULL,
    fee_lease numeric(6,2) DEFAULT 0.00 NOT NULL,
    fee_tags numeric(3,2) DEFAULT 0.00 NOT NULL,
    fee_ipc numeric(5,4) DEFAULT 0.0000 NOT NULL,
    bi_monthly smallint DEFAULT 0 NOT NULL,
    archived smallint DEFAULT 0 NOT NULL,
    custom smallint DEFAULT 0 NOT NULL,
    prepaid_amount bigint DEFAULT 0 NOT NULL,
    name character varying(128) NOT NULL
);


ALTER TABLE pantry.fee_rates OWNER TO dbservice;

--
-- Name: fee_rates_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.fee_rates_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.fee_rates_id_seq OWNER TO dbservice;

--
-- Name: fee_rates_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.fee_rates_id_seq OWNED BY pantry.fee_rates.id;


--
-- Name: feedback; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.feedback (
    id bigint NOT NULL,
    rate bigint NOT NULL,
    order_id character varying(45) NOT NULL,
    message character varying(512),
    taste bigint,
    freshness bigint,
    variety bigint,
    value bigint,
    ticket_created bigint
);


ALTER TABLE pantry.feedback OWNER TO dbservice;

--
-- Name: feedback_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.feedback_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.feedback_id_seq OWNER TO dbservice;

--
-- Name: feedback_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.feedback_id_seq OWNED BY pantry.feedback.id;


--
-- Name: global_attribute_def; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.global_attribute_def (
    id integer NOT NULL,
    key character varying(150) NOT NULL,
    default_value character varying(150)
);


ALTER TABLE pantry.global_attribute_def OWNER TO dbservice;

--
-- Name: global_attribute_def_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.global_attribute_def_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.global_attribute_def_id_seq OWNER TO dbservice;

--
-- Name: global_attribute_def_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.global_attribute_def_id_seq OWNED BY pantry.global_attribute_def.id;


--
-- Name: group; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry."group" (
    id bigint NOT NULL,
    name character varying(45) NOT NULL,
    title character varying(45) NOT NULL,
    notes character varying(2000) DEFAULT ''::character varying NOT NULL,
    archived integer DEFAULT 0
);


ALTER TABLE pantry."group" OWNER TO dbservice;

--
-- Name: group_campus; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.group_campus (
    group_id bigint NOT NULL,
    campus_id bigint NOT NULL,
    owner smallint DEFAULT 0 NOT NULL,
    archived integer DEFAULT 0
);


ALTER TABLE pantry.group_campus OWNER TO dbservice;

--
-- Name: group_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.group_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.group_id_seq OWNER TO dbservice;

--
-- Name: group_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.group_id_seq OWNED BY pantry."group".id;


--
-- Name: history; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.history (
    id bigint NOT NULL,
    epc character varying(24) NOT NULL,
    kiosk_id bigint NOT NULL,
    user_id bigint,
    order_id character varying(45),
    direction character varying(3) NOT NULL,
    "time" bigint NOT NULL
);


ALTER TABLE pantry.history OWNER TO dbservice;

--
-- Name: history_campus_attribute; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.history_campus_attribute (
    id integer NOT NULL,
    time_modified timestamp with time zone,
    campus_id integer,
    gad_id integer,
    value character varying(100),
    action character varying(100)
);


ALTER TABLE pantry.history_campus_attribute OWNER TO dbservice;

--
-- Name: TABLE history_campus_attribute; Type: COMMENT; Schema: pantry; Owner: dbservice
--

COMMENT ON TABLE pantry.history_campus_attribute IS 'Table used to store changes information relating to history_campus_attribute';


--
-- Name: history_campus_attribute_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

ALTER TABLE pantry.history_campus_attribute ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME pantry.history_campus_attribute_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: history_epc_order; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.history_epc_order (
    id bigint NOT NULL,
    epc character varying(72) NOT NULL,
    kiosk_id bigint NOT NULL,
    order_id character varying(135),
    "time" bigint NOT NULL,
    product_id integer,
    price numeric(5,2),
    action character varying(135),
    system character varying(135),
    "user" character varying(135)
);


ALTER TABLE pantry.history_epc_order OWNER TO dbservice;

--
-- Name: history_epc_order_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.history_epc_order_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.history_epc_order_id_seq OWNER TO dbservice;

--
-- Name: history_epc_order_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.history_epc_order_id_seq OWNED BY pantry.history_epc_order.id;


--
-- Name: history_global_attribute_def; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.history_global_attribute_def (
    id integer NOT NULL,
    time_modified timestamp with time zone,
    key character varying(45) NOT NULL,
    value character varying(100),
    action character varying(100)
);


ALTER TABLE pantry.history_global_attribute_def OWNER TO dbservice;

--
-- Name: TABLE history_global_attribute_def; Type: COMMENT; Schema: pantry; Owner: dbservice
--

COMMENT ON TABLE pantry.history_global_attribute_def IS 'Table used to store changes to global_attribute_def';


--
-- Name: history_global_attribute_def_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

ALTER TABLE pantry.history_global_attribute_def ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME pantry.history_global_attribute_def_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: history_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.history_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.history_id_seq OWNER TO dbservice;

--
-- Name: history_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.history_id_seq OWNED BY pantry.history.id;


--
-- Name: history_kiosk_attribute; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.history_kiosk_attribute (
    id integer NOT NULL,
    time_modified timestamp with time zone,
    kiosk_id integer,
    gad_id integer,
    value character varying(100),
    action character varying(100)
);


ALTER TABLE pantry.history_kiosk_attribute OWNER TO dbservice;

--
-- Name: TABLE history_kiosk_attribute; Type: COMMENT; Schema: pantry; Owner: dbservice
--

COMMENT ON TABLE pantry.history_kiosk_attribute IS 'Table used to store changes information relating to kiosk_attribute';


--
-- Name: history_kiosk_attribute_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

ALTER TABLE pantry.history_kiosk_attribute ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME pantry.history_kiosk_attribute_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: history_kiosk_device; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.history_kiosk_device (
    id integer NOT NULL,
    time_modified timestamp with time zone,
    kiosk_id integer,
    payload jsonb,
    action character varying(100)
);


ALTER TABLE pantry.history_kiosk_device OWNER TO dbservice;

--
-- Name: TABLE history_kiosk_device; Type: COMMENT; Schema: pantry; Owner: dbservice
--

COMMENT ON TABLE pantry.history_kiosk_device IS 'Table used to store changes information relating to kiosk_device';


--
-- Name: history_kiosk_device_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

ALTER TABLE pantry.history_kiosk_device ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME pantry.history_kiosk_device_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: history_kiosk_service_version; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.history_kiosk_service_version (
    id integer NOT NULL,
    time_modified timestamp with time zone,
    kiosk_id integer,
    service character varying(150),
    version character varying(100),
    action character varying(100)
);


ALTER TABLE pantry.history_kiosk_service_version OWNER TO dbservice;

--
-- Name: TABLE history_kiosk_service_version; Type: COMMENT; Schema: pantry; Owner: dbservice
--

COMMENT ON TABLE pantry.history_kiosk_service_version IS 'Table used to store changes information relating to kiosk_service_version';


--
-- Name: history_kiosk_service_version_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

ALTER TABLE pantry.history_kiosk_service_version ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME pantry.history_kiosk_service_version_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: inventory_history; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.inventory_history (
    id integer NOT NULL,
    "time" integer NOT NULL,
    kiosk_id integer NOT NULL,
    product_id integer NOT NULL,
    qty integer NOT NULL,
    campus_id integer NOT NULL,
    is_restored bigint NOT NULL
);


ALTER TABLE pantry.inventory_history OWNER TO dbservice;

--
-- Name: inventory_history_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.inventory_history_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.inventory_history_id_seq OWNER TO dbservice;

--
-- Name: inventory_history_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.inventory_history_id_seq OWNED BY pantry.inventory_history.id;


--
-- Name: inventory_request; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.inventory_request (
    id bigint NOT NULL,
    kiosk_id bigint,
    "time" bigint,
    epc character varying(72)
);


ALTER TABLE pantry.inventory_request OWNER TO dbservice;

--
-- Name: inventory_request_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.inventory_request_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.inventory_request_id_seq OWNER TO dbservice;

--
-- Name: inventory_request_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.inventory_request_id_seq OWNED BY pantry.inventory_request.id;


--
-- Name: kiosk_attribute; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.kiosk_attribute (
    id integer NOT NULL,
    kiosk_id bigint NOT NULL,
    key_id integer NOT NULL,
    value character varying(150) NOT NULL
);


ALTER TABLE pantry.kiosk_attribute OWNER TO dbservice;

--
-- Name: kiosk_attribute_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.kiosk_attribute_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.kiosk_attribute_id_seq OWNER TO dbservice;

--
-- Name: kiosk_attribute_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.kiosk_attribute_id_seq OWNED BY pantry.kiosk_attribute.id;


--
-- Name: kiosk_audit_log; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.kiosk_audit_log (
    id bigint NOT NULL,
    kiosk_id integer NOT NULL,
    created_at timestamp without time zone DEFAULT now(),
    archived smallint,
    enable_reporting smallint,
    enable_monitoring smallint
);


ALTER TABLE pantry.kiosk_audit_log OWNER TO dbservice;

--
-- Name: kiosk_audit_log_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.kiosk_audit_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.kiosk_audit_log_id_seq OWNER TO dbservice;

--
-- Name: kiosk_audit_log_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.kiosk_audit_log_id_seq OWNED BY pantry.kiosk_audit_log.id;


--
-- Name: kiosk_catalog_downloads; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.kiosk_catalog_downloads (
    id bigint NOT NULL,
    kiosk_id bigint NOT NULL,
    "timestamp" bigint NOT NULL,
    duration bigint NOT NULL,
    num_bytes bigint NOT NULL,
    num_products bigint NOT NULL,
    current_discounts text,
    recent_discount_history text
);


ALTER TABLE pantry.kiosk_catalog_downloads OWNER TO dbservice;

--
-- Name: kiosk_catalog_downloads_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.kiosk_catalog_downloads_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.kiosk_catalog_downloads_id_seq OWNER TO dbservice;

--
-- Name: kiosk_catalog_downloads_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.kiosk_catalog_downloads_id_seq OWNED BY pantry.kiosk_catalog_downloads.id;


--
-- Name: kiosk_cd_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.kiosk_cd_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.kiosk_cd_id_seq OWNER TO dbservice;

--
-- Name: kiosk_cd_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.kiosk_cd_id_seq OWNED BY pantry.kiosk_catalog_downloads.id;


--
-- Name: kiosk_components_history_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.kiosk_components_history_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.kiosk_components_history_id_seq OWNER TO dbservice;

--
-- Name: kiosk_components_history_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.kiosk_components_history_id_seq OWNED BY pantry.kiosk_components_history.id;


--
-- Name: kiosk_device; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.kiosk_device (
    id integer NOT NULL,
    kiosk_id bigint NOT NULL,
    payload jsonb
);


ALTER TABLE pantry.kiosk_device OWNER TO dbservice;

--
-- Name: kiosk_device_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.kiosk_device_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.kiosk_device_id_seq OWNER TO dbservice;

--
-- Name: kiosk_device_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.kiosk_device_id_seq OWNED BY pantry.kiosk_device.id;


--
-- Name: kiosk_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.kiosk_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.kiosk_id_seq OWNER TO dbservice;

--
-- Name: kiosk_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.kiosk_id_seq OWNED BY pantry.kiosk.id;


--
-- Name: kiosk_par_level; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.kiosk_par_level (
    kiosk_id bigint NOT NULL,
    product_id bigint NOT NULL,
    amount bigint
);


ALTER TABLE pantry.kiosk_par_level OWNER TO dbservice;

--
-- Name: kiosk_service_version; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.kiosk_service_version (
    kiosk_id integer NOT NULL,
    service character varying(150) NOT NULL,
    version character varying(100)
);


ALTER TABLE pantry.kiosk_service_version OWNER TO dbservice;

--
-- Name: kiosk_status_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.kiosk_status_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.kiosk_status_id_seq OWNER TO dbservice;

--
-- Name: kiosk_status_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.kiosk_status_id_seq OWNED BY pantry.kiosk_status.id;


--
-- Name: kiosks_date_non_new; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.kiosks_date_non_new (
    id integer NOT NULL,
    kiosk_id integer NOT NULL,
    new_ts integer NOT NULL
);


ALTER TABLE pantry.kiosks_date_non_new OWNER TO dbservice;

--
-- Name: kiosks_date_non_new_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.kiosks_date_non_new_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.kiosks_date_non_new_id_seq OWNER TO dbservice;

--
-- Name: kiosks_date_non_new_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.kiosks_date_non_new_id_seq OWNED BY pantry.kiosks_date_non_new.id;


--
-- Name: label_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.label_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.label_id_seq OWNER TO dbservice;

--
-- Name: label_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.label_id_seq OWNED BY pantry.label.id;


--
-- Name: label_order; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.label_order (
    id bigint NOT NULL,
    product_id bigint,
    group_id bigint,
    box_id character varying(16),
    amount bigint NOT NULL,
    time_order bigint NOT NULL,
    time_encoded bigint,
    time_delivery bigint,
    time_updated bigint,
    status character varying(15),
    delivery_option character varying(255),
    priority character varying(255)
);


ALTER TABLE pantry.label_order OWNER TO dbservice;

--
-- Name: label_order_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.label_order_id_seq
    START WITH 1
    INCREMENT BY 2
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.label_order_id_seq OWNER TO dbservice;

--
-- Name: label_order_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.label_order_id_seq OWNED BY pantry.label_order.id;


--
-- Name: label_stats; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.label_stats (
    product_id bigint,
    used_since_last_delivery bigint,
    used_total bigint,
    last_delivery_date bigint,
    last_delivery bigint,
    delivered_total bigint
);


ALTER TABLE pantry.label_stats OWNER TO dbservice;

--
-- Name: last_kiosk_status; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.last_kiosk_status (
    id bigint NOT NULL,
    kiosk_id bigint NOT NULL,
    kiosk_temperature numeric(6,3),
    kiosk_temperature_count smallint,
    kit_temperature numeric(6,3),
    temperature_tags character varying(6141),
    kiosk_temperature_source character varying(93),
    power integer,
    battery_level smallint,
    rfid_0 integer,
    rfid_1 integer,
    rfid_2 integer,
    rfid_3 integer,
    rfid_4 integer,
    rfid_5 integer,
    rfid_6 integer,
    rfid_7 integer,
    "time" bigint,
    modem_signal_percentage smallint,
    modem_signal_type character varying(81),
    ip character varying(135),
    app_uptime bigint,
    system_uptime bigint,
    is_locked smallint,
    num_payment_messages_pending_sync integer DEFAULT 0
);


ALTER TABLE pantry.last_kiosk_status OWNER TO dbservice;

--
-- Name: last_kiosk_status_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.last_kiosk_status_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.last_kiosk_status_id_seq OWNER TO dbservice;

--
-- Name: last_kiosk_status_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.last_kiosk_status_id_seq OWNED BY pantry.last_kiosk_status.id;


--
-- Name: manual_adjustment; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.manual_adjustment (
    id bigint NOT NULL,
    kiosk_id bigint NOT NULL,
    date character varying(45) NOT NULL,
    sum numeric(6,2) NOT NULL,
    reason character varying(128) NOT NULL,
    auto_generated smallint DEFAULT 0 NOT NULL,
    archived bigint DEFAULT 0 NOT NULL
);


ALTER TABLE pantry.manual_adjustment OWNER TO dbservice;

--
-- Name: manual_adjustment_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.manual_adjustment_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.manual_adjustment_id_seq OWNER TO dbservice;

--
-- Name: manual_adjustment_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.manual_adjustment_id_seq OWNED BY pantry.manual_adjustment.id;


--
-- Name: nutrition_filter; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.nutrition_filter (
    id bigint NOT NULL,
    tag_id bigint,
    label character varying(150),
    icon character varying(381)
);


ALTER TABLE pantry.nutrition_filter OWNER TO dbservice;

--
-- Name: nutrition_filter_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.nutrition_filter_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.nutrition_filter_id_seq OWNER TO dbservice;

--
-- Name: nutrition_filter_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.nutrition_filter_id_seq OWNED BY pantry.nutrition_filter.id;


--
-- Name: order_meta; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.order_meta (
    id integer NOT NULL,
    order_id character varying(45) NOT NULL,
    time_auth bigint,
    time_capture bigint,
    currency character varying DEFAULT 'USD'::character varying,
    num_scans_completed integer DEFAULT 0,
    tablet_processing_done boolean DEFAULT false,
    time_preauth bigint
);


ALTER TABLE pantry.order_meta OWNER TO dbservice;

--
-- Name: TABLE order_meta; Type: COMMENT; Schema: pantry; Owner: dbservice
--

COMMENT ON TABLE pantry.order_meta IS 'Table used to store additional information relating to pantry_meta';


--
-- Name: order_meta_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.order_meta_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.order_meta_id_seq OWNER TO dbservice;

--
-- Name: order_meta_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.order_meta_id_seq OWNED BY pantry.order_meta.id;


--
-- Name: par_history; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.par_history (
    id integer NOT NULL,
    kiosk_id integer,
    par_level character varying(3069),
    end_time integer
);


ALTER TABLE pantry.par_history OWNER TO dbservice;

--
-- Name: par_history_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.par_history_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.par_history_id_seq OWNER TO dbservice;

--
-- Name: par_history_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.par_history_id_seq OWNED BY pantry.par_history.id;


--
-- Name: payment_order; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.payment_order (
    order_id character varying(45) NOT NULL,
    payload jsonb,
    re_auth_attempts integer DEFAULT 0,
    id integer NOT NULL
);


ALTER TABLE pantry.payment_order OWNER TO dbservice;

--
-- Name: payment_order_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.payment_order_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.payment_order_id_seq OWNER TO dbservice;

--
-- Name: payment_order_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.payment_order_id_seq OWNED BY pantry.payment_order.id;


--
-- Name: payment_order_nursing; Type: VIEW; Schema: pantry; Owner: dbservice
--

CREATE VIEW pantry.payment_order_nursing AS
 SELECT payment_order.order_id,
    (payment_order.payload ->> 'nurse_id'::text) AS nurse_id,
    (payment_order.payload ->> 'patient_id'::text) AS patient_id
   FROM pantry.payment_order
  WHERE (((payment_order.payload ->> 'nurse_id'::text) IS NOT NULL) AND ((payment_order.payload ->> 'patient_id'::text) IS NOT NULL));


ALTER TABLE pantry.payment_order_nursing OWNER TO dbservice;

--
-- Name: permission; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.permission (
    id integer NOT NULL,
    permission character varying(765),
    api character varying(765),
    "isFrontend" integer NOT NULL
);


ALTER TABLE pantry.permission OWNER TO dbservice;

--
-- Name: permission_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.permission_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.permission_id_seq OWNER TO dbservice;

--
-- Name: permission_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.permission_id_seq OWNED BY pantry.permission.id;


--
-- Name: permission_mapping; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.permission_mapping (
    role_id integer NOT NULL,
    permission_id integer NOT NULL
);


ALTER TABLE pantry.permission_mapping OWNER TO dbservice;

--
-- Name: pick_list_row; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.pick_list_row (
    id integer NOT NULL,
    "SiteCode" character varying(384),
    "SiteName" character varying(384),
    "PickStation" character varying(384),
    "Vendor" character varying(384),
    "ItemName" character varying(384),
    "ProposedSupply" integer,
    status character varying(150),
    "DriverName" character varying(384),
    "RouteTime" character varying(384),
    "RouteDate" character varying(384),
    "RouteNumber" character varying(384),
    route_time bigint,
    created bigint,
    "Refrigerated" character varying(65535),
    "TotalPickQty" character varying(65535),
    "TotalPickSKU" integer,
    "KioskInvQty" character varying(65535),
    "KioskSKUCnt" integer
);


ALTER TABLE pantry.pick_list_row OWNER TO dbservice;

--
-- Name: pick_list_row_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.pick_list_row_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.pick_list_row_id_seq OWNER TO dbservice;

--
-- Name: pick_list_row_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.pick_list_row_id_seq OWNED BY pantry.pick_list_row.id;


--
-- Name: product_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.product_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.product_id_seq OWNER TO dbservice;

--
-- Name: product_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.product_id_seq OWNED BY pantry.product.id;


--
-- Name: product_20190507; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.product_20190507 (
    id bigint DEFAULT nextval('pantry.product_id_seq'::regclass) NOT NULL,
    title character varying(127) NOT NULL,
    description character varying(4095) DEFAULT 'No description yet'::character varying,
    tiny_description character varying(40),
    short_description character varying(100),
    medium_description character varying(400),
    long_description character varying(1200),
    price numeric(5,2) DEFAULT 0.00 NOT NULL,
    cost numeric(5,2) DEFAULT 0.00 NOT NULL,
    shelf_time integer DEFAULT 1 NOT NULL,
    campus_id bigint NOT NULL,
    image smallint DEFAULT 0 NOT NULL,
    image_time bigint,
    last_update bigint DEFAULT 0 NOT NULL,
    archived bigint DEFAULT 0,
    taxable smallint DEFAULT 0,
    allergens character varying(255),
    attribute_names character varying(511),
    categories character varying(255),
    category_names character varying(511),
    vendor character varying(135),
    source character varying(135),
    notes character varying(2000),
    total_cal bigint,
    num_servings real,
    ingredients character varying(2000),
    calories real,
    proteins real,
    sugar real,
    carbohydrates real,
    fat real,
    consumer_category character varying(2000),
    ws_case_size bigint,
    kiosk_ship_qty bigint,
    ws_case_cost numeric(5,2),
    pick_station bigint,
    fc_title character varying(255),
    pricing_tier character varying(255),
    width_space real,
    height_space real,
    depth_space real,
    slotted_width real,
    tag_volume bigint,
    delivery_option character varying(255) DEFAULT 'M'::character varying,
    tag_applied_by character varying(255) DEFAULT 'W'::character varying
);


ALTER TABLE pantry.product_20190507 OWNER TO dbservice;

--
-- Name: product_categories; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.product_categories (
    id bigint NOT NULL,
    cat_name character varying(50) NOT NULL,
    cat_name_tiny character varying(50),
    subcat_name character varying(50) NOT NULL,
    subcat_name_tiny character varying(50),
    tags character varying(255) NOT NULL,
    no_image_placeholder character varying(255),
    icon character varying(255)
);


ALTER TABLE pantry.product_categories OWNER TO dbservice;

--
-- Name: product_categories_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.product_categories_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.product_categories_id_seq OWNER TO dbservice;

--
-- Name: product_categories_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.product_categories_id_seq OWNED BY pantry.product_categories.id;


--
-- Name: product_history; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.product_history (
    id integer NOT NULL,
    price numeric(5,2),
    cost numeric(5,2),
    start_time integer,
    end_time integer,
    product_id integer,
    campus_id integer
);


ALTER TABLE pantry.product_history OWNER TO dbservice;

--
-- Name: product_history_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.product_history_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.product_history_id_seq OWNER TO dbservice;

--
-- Name: product_history_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.product_history_id_seq OWNED BY pantry.product_history.id;


--
-- Name: product_kiosk_price_offset; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.product_kiosk_price_offset (
    id integer NOT NULL,
    name character varying(384),
    kiosk character varying(12288),
    product character varying(12288),
    vendor character varying(12288),
    discount character varying(3072),
    end_timestamp bigint
);


ALTER TABLE pantry.product_kiosk_price_offset OWNER TO dbservice;

--
-- Name: product_kiosk_price_offset_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.product_kiosk_price_offset_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.product_kiosk_price_offset_id_seq OWNER TO dbservice;

--
-- Name: product_kiosk_price_offset_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.product_kiosk_price_offset_id_seq OWNED BY pantry.product_kiosk_price_offset.id;


--
-- Name: product_request; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.product_request (
    id bigint NOT NULL,
    customer character varying(765),
    request_date date,
    customer_email character varying(765),
    product_id bigint,
    product_title character varying(765),
    kiosk_id bigint,
    kiosk_title character varying(765),
    request character varying(765),
    date_item_added date,
    increase_factor bigint,
    expiry_date date,
    purchased character varying(765)
);


ALTER TABLE pantry.product_request OWNER TO dbservice;

--
-- Name: product_request_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.product_request_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.product_request_id_seq OWNER TO dbservice;

--
-- Name: product_request_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.product_request_id_seq OWNED BY pantry.product_request.id;


--
-- Name: product_stats_by_kiosk; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.product_stats_by_kiosk (
    kiosk_id bigint,
    product_id bigint,
    is_new integer,
    is_popular integer,
    "timestamp" integer,
    date_when_new bigint,
    popularity_ranking bigint
);


ALTER TABLE pantry.product_stats_by_kiosk OWNER TO dbservice;

--
-- Name: recent_transactions; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.recent_transactions (
    kiosk_id integer NOT NULL,
    current_less_recent integer,
    current_most_recent integer,
    less_recent integer,
    most_recent integer
);


ALTER TABLE pantry.recent_transactions OWNER TO dbservice;

--
-- Name: refunds; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.refunds (
    order_id character varying(135) NOT NULL,
    product_id integer NOT NULL,
    price numeric(6,2) NOT NULL
);


ALTER TABLE pantry.refunds OWNER TO dbservice;

--
-- Name: restock_item; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.restock_item (
    id integer NOT NULL,
    order_id character varying(36),
    epc character varying(72),
    created integer,
    kiosk_id integer,
    product_id integer
);


ALTER TABLE pantry.restock_item OWNER TO dbservice;

--
-- Name: restock_item_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.restock_item_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.restock_item_id_seq OWNER TO dbservice;

--
-- Name: restock_item_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.restock_item_id_seq OWNED BY pantry.restock_item.id;


--
-- Name: ro_order; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.ro_order (
    order_id character varying(135) NOT NULL,
    campus_id bigint NOT NULL,
    kiosk_id bigint NOT NULL,
    kiosk_title character varying(138),
    created bigint,
    state character varying(45) NOT NULL,
    customer_full_name character varying(300),
    full_price numeric(6,2),
    real_full_price numeric(6,2),
    archived bigint DEFAULT 0,
    time_updated bigint
);


ALTER TABLE pantry.ro_order OWNER TO dbservice;

--
-- Name: role; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.role (
    id integer NOT NULL,
    role character varying(765)
);


ALTER TABLE pantry.role OWNER TO dbservice;

--
-- Name: role_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.role_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.role_id_seq OWNER TO dbservice;

--
-- Name: role_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.role_id_seq OWNED BY pantry.role.id;


--
-- Name: role_mapping; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.role_mapping (
    role_id integer NOT NULL,
    parent_id integer NOT NULL
);


ALTER TABLE pantry.role_mapping OWNER TO dbservice;

--
-- Name: running_service; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.running_service (
    app_name text NOT NULL,
    started_at timestamp without time zone,
    host text
);


ALTER TABLE pantry.running_service OWNER TO dbservice;

--
-- Name: spoilage; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.spoilage (
    id integer NOT NULL,
    epc character varying(72) NOT NULL,
    kiosk_id integer NOT NULL,
    order_id character varying(135),
    time_removed integer,
    time_added integer,
    product_id integer,
    "timestamp" integer
);


ALTER TABLE pantry.spoilage OWNER TO dbservice;

--
-- Name: spoilage_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.spoilage_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.spoilage_id_seq OWNER TO dbservice;

--
-- Name: spoilage_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.spoilage_id_seq OWNED BY pantry.spoilage.id;


--
-- Name: stockout; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.stockout (
    id integer NOT NULL,
    kiosk_id integer,
    product_id integer,
    order_id character varying(36),
    "timestamp" integer,
    restock_timestamp integer,
    restock_order_id character varying(36)
);


ALTER TABLE pantry.stockout OWNER TO dbservice;

--
-- Name: stockout_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.stockout_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.stockout_id_seq OWNER TO dbservice;

--
-- Name: stockout_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.stockout_id_seq OWNED BY pantry.stockout.id;


--
-- Name: tag; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.tag (
    id bigint NOT NULL,
    tag character varying(100)
);


ALTER TABLE pantry.tag OWNER TO dbservice;

--
-- Name: tag_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.tag_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.tag_id_seq OWNER TO dbservice;

--
-- Name: tag_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.tag_id_seq OWNED BY pantry.tag.id;


--
-- Name: temp_kiosk_backup; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.temp_kiosk_backup (
    id bigint NOT NULL,
    campus_id bigint NOT NULL,
    serial character varying(135) NOT NULL,
    title character varying(138),
    address character varying(381),
    location_x numeric(9,6) NOT NULL,
    location_y numeric(9,6) NOT NULL,
    gcm_id character varying(765),
    app_vname character varying(189),
    app_vcode integer,
    archived bigint,
    creation_time bigint,
    deployment_time bigint,
    last_update bigint,
    client_name character varying(765),
    last_status bigint,
    last_inventory bigint NOT NULL,
    kiosk_name character varying(765) NOT NULL,
    payment_start bigint,
    payment_stop bigint,
    features character varying(765) NOT NULL,
    sales_tax smallint NOT NULL,
    default_fee_plan bigint NOT NULL,
    timezone character varying(150),
    estd_num_users bigint,
    tags character varying(765),
    publicly_accessible bigint,
    cardkey_required bigint,
    delivery_insns character varying(65535),
    fridge_loc_info character varying(65535),
    contact_first_name character varying(65535),
    contact_last_name character varying(65535),
    contact_email character varying(65535),
    contact_phone character varying(65535),
    accounting_email character varying(65535),
    byte_discount character varying(765),
    subsidy_info character varying(150),
    subsidy_notes character varying(65535),
    max_subscription character varying(150),
    delivery_window_mon character varying(150),
    delivery_window_tue character varying(150),
    delivery_window_wed character varying(150),
    delivery_window_thu character varying(150),
    delivery_window_fri character varying(150),
    delivery_window_sat character varying(150),
    delivery_window_sun character varying(150),
    notes character varying(6000),
    email_receipt_subject character varying(765),
    ops_team_notes character varying(65535),
    geo character varying(9),
    server_url character varying(381),
    subscription_amount numeric(8,2) NOT NULL,
    enable_reporting bigint,
    enable_monitoring bigint,
    employees_num bigint,
    kiosk_restrictions character varying(6000)
);


ALTER TABLE pantry.temp_kiosk_backup OWNER TO dbservice;

--
-- Name: temp_product_backup; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.temp_product_backup (
    id bigint NOT NULL,
    title character varying(127) NOT NULL,
    description character varying(4095),
    tiny_description character varying(40),
    short_description character varying(100),
    medium_description character varying(400),
    long_description character varying(1200),
    price numeric(5,2) NOT NULL,
    cost numeric(5,2) NOT NULL,
    shelf_time integer NOT NULL,
    campus_id bigint NOT NULL,
    image smallint NOT NULL,
    image_time bigint,
    last_update bigint NOT NULL,
    archived bigint,
    taxable smallint,
    allergens character varying(255),
    attribute_names character varying(511),
    categories character varying(255),
    category_names character varying(511),
    vendor character varying(135),
    source character varying(135),
    notes character varying(2000),
    total_cal bigint,
    num_servings real,
    ingredients character varying(2000),
    calories real,
    proteins real,
    sugar real,
    carbohydrates real,
    fat real,
    consumer_category character varying(2000),
    ws_case_size bigint,
    kiosk_ship_qty bigint,
    ws_case_cost numeric(5,2),
    pick_station bigint,
    fc_title character varying(255),
    pricing_tier character varying(255),
    width_space real,
    height_space real,
    depth_space real,
    slotted_width real,
    tag_volume bigint,
    delivery_option character varying(255),
    tag_applied_by character varying(255)
);


ALTER TABLE pantry.temp_product_backup OWNER TO dbservice;

--
-- Name: temperature_tag_history; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.temperature_tag_history (
    id bigint NOT NULL,
    kiosk_id bigint,
    "time" bigint,
    epc character varying(72),
    current numeric(5,2),
    average numeric(5,2),
    "full" character varying(381),
    read_count smallint
);


ALTER TABLE pantry.temperature_tag_history OWNER TO dbservice;

--
-- Name: temperature_tag_history_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.temperature_tag_history_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.temperature_tag_history_id_seq OWNER TO dbservice;

--
-- Name: temperature_tag_history_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.temperature_tag_history_id_seq OWNED BY pantry.temperature_tag_history.id;


--
-- Name: tmp_april23_error_order_fixes; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.tmp_april23_error_order_fixes (
    order_id character varying(45) NOT NULL,
    transaction_id character varying(45),
    amount_paid numeric(6,2)
);


ALTER TABLE pantry.tmp_april23_error_order_fixes OWNER TO dbservice;

--
-- Name: tmp_backup_order_before_05_03_process_will; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.tmp_backup_order_before_05_03_process_will (
    order_id character varying(45),
    first_name character varying(45),
    last_name character varying(45),
    kiosk_id bigint,
    kiosk_title character varying(46),
    email character varying(127),
    amount_paid numeric(6,2),
    payment_system character varying(45),
    transaction_id character varying(45),
    approval_code character varying(45),
    status_code character varying(45),
    status_message character varying(45),
    status character varying(45),
    batch_id character varying(15),
    created bigint,
    auth_amount character varying(7),
    data_token character varying(2047),
    time_opened bigint,
    time_closed bigint,
    card_hash character varying(88),
    state character varying(15),
    archived bigint,
    stamp bigint,
    last_update bigint,
    balance numeric(7,2),
    delta character varying(4),
    coupon_id bigint,
    coupon character varying(45),
    refund numeric(6,2),
    receipt bigint,
    campus_id bigint,
    amount_list_price numeric(6,2),
    time_door_opened bigint,
    time_door_closed bigint,
    notes text
);


ALTER TABLE pantry.tmp_backup_order_before_05_03_process_will OWNER TO dbservice;

--
-- Name: tmp_cards_to_update; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.tmp_cards_to_update (
    card_id bigint NOT NULL,
    c_fn character varying(135),
    c_ln character varying(135),
    email character varying(381) NOT NULL
);


ALTER TABLE pantry.tmp_cards_to_update OWNER TO dbservice;

--
-- Name: tmp_eng_3692; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.tmp_eng_3692 (
    order_id character varying(45) NOT NULL
);


ALTER TABLE pantry.tmp_eng_3692 OWNER TO dbservice;

--
-- Name: tmp_eng_495_cards_to_update; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.tmp_eng_495_cards_to_update (
    card_id bigint NOT NULL,
    c_fn character varying(135),
    c_ln character varying(135)
);


ALTER TABLE pantry.tmp_eng_495_cards_to_update OWNER TO dbservice;

--
-- Name: tmp_march1_rollingback_auths; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.tmp_march1_rollingback_auths (
    order_id character varying(45)
);


ALTER TABLE pantry.tmp_march1_rollingback_auths OWNER TO dbservice;

--
-- Name: tmp_may4_error_order_fixes; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.tmp_may4_error_order_fixes (
    order_id character varying(45) NOT NULL,
    transaction_id character varying(45),
    amount_paid numeric(6,2)
);


ALTER TABLE pantry.tmp_may4_error_order_fixes OWNER TO dbservice;

--
-- Name: tmp_may4_pricefinalize_order_fixes; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.tmp_may4_pricefinalize_order_fixes (
    order_id character varying(45) NOT NULL,
    transaction_id character varying(45),
    amount_paid numeric(6,2)
);


ALTER TABLE pantry.tmp_may4_pricefinalize_order_fixes OWNER TO dbservice;

--
-- Name: tmp_order_eng_1915; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.tmp_order_eng_1915 (
    order_id character varying(45),
    campus_id bigint,
    kiosk_id bigint,
    receipt bigint,
    amount_paid numeric(6,2),
    state character varying(15),
    status character varying(45),
    created bigint,
    last_update bigint
);


ALTER TABLE pantry.tmp_order_eng_1915 OWNER TO dbservice;

--
-- Name: tmp_order_may_6_preapr23; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.tmp_order_may_6_preapr23 (
    order_id character varying(45),
    first_name character varying(45),
    last_name character varying(45),
    kiosk_id bigint,
    kiosk_title character varying(46),
    email character varying(127),
    amount_paid numeric(6,2),
    payment_system character varying(45),
    transaction_id character varying(45),
    approval_code character varying(45),
    status_code character varying(45),
    status_message character varying(45),
    status character varying(45),
    batch_id character varying(15),
    created bigint,
    auth_amount character varying(7),
    data_token character varying(2047),
    time_opened bigint,
    time_closed bigint,
    card_hash character varying(88),
    state character varying(15),
    archived bigint,
    stamp bigint,
    last_update bigint,
    balance numeric(7,2),
    delta character varying(4),
    coupon_id bigint,
    coupon character varying(45),
    refund numeric(6,2),
    receipt bigint,
    campus_id bigint,
    amount_list_price numeric(6,2),
    time_door_opened bigint,
    time_door_closed bigint,
    notes text
);


ALTER TABLE pantry.tmp_order_may_6_preapr23 OWNER TO dbservice;

--
-- Name: tmp_order_transaction_id_map; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.tmp_order_transaction_id_map (
    transaction_id integer NOT NULL,
    order_id character varying(45),
    amount numeric(5,2),
    direction character varying(5)
);


ALTER TABLE pantry.tmp_order_transaction_id_map OWNER TO dbservice;

--
-- Name: tmp_orderstoerror; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.tmp_orderstoerror (
    order_id character varying(45)
);


ALTER TABLE pantry.tmp_orderstoerror OWNER TO dbservice;

--
-- Name: tmp_payment_order; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.tmp_payment_order (
    order_id character varying(45) NOT NULL,
    payload text,
    re_auth_attempts integer DEFAULT 0
);


ALTER TABLE pantry.tmp_payment_order OWNER TO dbservice;

--
-- Name: tmp_payment_order_with_id; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.tmp_payment_order_with_id (
    order_id character varying(45) NOT NULL,
    payload text,
    re_auth_attempts integer DEFAULT 0,
    id integer NOT NULL
);


ALTER TABLE pantry.tmp_payment_order_with_id OWNER TO dbservice;

--
-- Name: tmp_payment_order_with_id_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

ALTER TABLE pantry.tmp_payment_order_with_id ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME pantry.tmp_payment_order_with_id_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: tmp_price_finalized_order_ids; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.tmp_price_finalized_order_ids (
    order_id character varying(45) DEFAULT 0 NOT NULL
);


ALTER TABLE pantry.tmp_price_finalized_order_ids OWNER TO dbservice;

--
-- Name: tmp_process_order_txt; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.tmp_process_order_txt (
    amount_paid character varying(15),
    approval_code character varying(45),
    batch_id character varying(15),
    state character varying(15),
    status character varying(45),
    status_code character varying(45),
    status_message character varying(45),
    transaction_id character varying(45),
    order_id character varying(45) NOT NULL,
    id integer NOT NULL
);


ALTER TABLE pantry.tmp_process_order_txt OWNER TO dbservice;

--
-- Name: tmp_process_order; Type: VIEW; Schema: pantry; Owner: dbservice
--

CREATE VIEW pantry.tmp_process_order AS
 SELECT ("substring"((tmp_process_order_txt.amount_paid)::text, 5))::numeric(6,2) AS amount_paid,
    tmp_process_order_txt.approval_code,
    tmp_process_order_txt.batch_id,
    tmp_process_order_txt.state,
    tmp_process_order_txt.status,
    tmp_process_order_txt.status_code,
    tmp_process_order_txt.status_message,
    tmp_process_order_txt.transaction_id,
    tmp_process_order_txt.order_id,
    tmp_process_order_txt.id
   FROM pantry.tmp_process_order_txt;


ALTER TABLE pantry.tmp_process_order OWNER TO dbservice;

--
-- Name: tmp_process_order_txt_d_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

ALTER TABLE pantry.tmp_process_order_txt ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME pantry.tmp_process_order_txt_d_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: tmp_process_order_vantiv; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.tmp_process_order_vantiv (
    date integer,
    "time" integer,
    transactionid integer,
    status character varying(40),
    accountid character varying(40),
    acceptorid character varying(40),
    transactiontype character varying(40),
    rc integer,
    rm character varying(40),
    amount numeric(6,2),
    card character varying(40),
    apprv character varying(40),
    id integer NOT NULL
);


ALTER TABLE pantry.tmp_process_order_vantiv OWNER TO dbservice;

--
-- Name: tmp_process_order_vantiv_d_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

ALTER TABLE pantry.tmp_process_order_vantiv ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME pantry.tmp_process_order_vantiv_d_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: tmp_revert_order_status; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.tmp_revert_order_status (
    order_id character varying(45) NOT NULL
);


ALTER TABLE pantry.tmp_revert_order_status OWNER TO dbservice;

--
-- Name: tmp_watcher; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.tmp_watcher (
    label_id bigint,
    order_id character varying(135) NOT NULL,
    created bigint
);


ALTER TABLE pantry.tmp_watcher OWNER TO dbservice;

--
-- Name: transact_comp; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.transact_comp (
    id bigint NOT NULL,
    order_id character varying(93),
    result character varying(3069),
    "time" bigint
);


ALTER TABLE pantry.transact_comp OWNER TO dbservice;

--
-- Name: transact_comp_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.transact_comp_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.transact_comp_id_seq OWNER TO dbservice;

--
-- Name: transact_comp_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.transact_comp_id_seq OWNED BY pantry.transact_comp.id;


--
-- Name: transact_express; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.transact_express (
    id bigint NOT NULL,
    order_id character varying(93),
    amount numeric(4,2),
    "time" bigint,
    ksn character varying(93),
    magne_print character varying(381),
    magne_print_status character varying(381),
    track2 character varying(381),
    transaction_id character varying(150),
    approval_code character varying(150),
    status_code character varying(150),
    status_message character varying(150),
    status character varying(150),
    batch_id character varying(45)
);


ALTER TABLE pantry.transact_express OWNER TO dbservice;

--
-- Name: transact_express_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.transact_express_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.transact_express_id_seq OWNER TO dbservice;

--
-- Name: transact_express_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.transact_express_id_seq OWNED BY pantry.transact_express.id;


--
-- Name: transact_fp; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.transact_fp (
    id bigint NOT NULL,
    order_id character varying(93),
    result character varying(3069),
    "time" bigint
);


ALTER TABLE pantry.transact_fp OWNER TO dbservice;

--
-- Name: transact_fp_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.transact_fp_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.transact_fp_id_seq OWNER TO dbservice;

--
-- Name: transact_fp_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.transact_fp_id_seq OWNED BY pantry.transact_fp.id;


--
-- Name: transact_ipc; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.transact_ipc (
    id bigint NOT NULL,
    order_id character varying(93),
    result character varying(12285),
    "time" bigint
);


ALTER TABLE pantry.transact_ipc OWNER TO dbservice;

--
-- Name: transact_ipc_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.transact_ipc_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.transact_ipc_id_seq OWNER TO dbservice;

--
-- Name: transact_ipc_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.transact_ipc_id_seq OWNED BY pantry.transact_ipc.id;


--
-- Name: user; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry."user" (
    id bigint NOT NULL,
    login character varying(45) NOT NULL,
    first_name character varying(127),
    last_name character varying(127),
    password character varying(88) NOT NULL,
    email character varying(127),
    role_id bigint DEFAULT 2 NOT NULL,
    group_id bigint DEFAULT 0 NOT NULL,
    archived bigint DEFAULT 0 NOT NULL,
    date_registered bigint NOT NULL,
    timezone character varying(50),
    email_params character varying(65535),
    token character varying(40),
    notes character varying(2000)
);


ALTER TABLE pantry."user" OWNER TO dbservice;

--
-- Name: user_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.user_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.user_id_seq OWNER TO dbservice;

--
-- Name: user_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.user_id_seq OWNED BY pantry."user".id;


--
-- Name: awsdms_apply_exceptions; Type: TABLE; Schema: public; Owner: dbservice
--

CREATE TABLE public.awsdms_apply_exceptions (
    "TASK_NAME" character varying(384) NOT NULL,
    "TABLE_OWNER" character varying(384) NOT NULL,
    "TABLE_NAME" character varying(384) NOT NULL,
    "ERROR_TIME" timestamp without time zone NOT NULL,
    "STATEMENT" text NOT NULL,
    "ERROR" text NOT NULL
);


ALTER TABLE public.awsdms_apply_exceptions OWNER TO dbservice;

--
-- Name: awsdms_ddl_audit; Type: TABLE; Schema: public; Owner: dbservice
--

CREATE TABLE public.awsdms_ddl_audit (
    c_key bigint NOT NULL,
    c_time timestamp(6) without time zone,
    c_user character varying(64),
    c_txn character varying(16),
    c_tag character varying(24),
    c_oid integer,
    c_name character varying(64),
    c_schema character varying(64),
    c_ddlqry text
);


ALTER TABLE public.awsdms_ddl_audit OWNER TO dbservice;

--
-- Name: awsdms_ddl_audit_c_key_seq; Type: SEQUENCE; Schema: public; Owner: dbservice
--

CREATE SEQUENCE public.awsdms_ddl_audit_c_key_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.awsdms_ddl_audit_c_key_seq OWNER TO dbservice;

--
-- Name: awsdms_ddl_audit_c_key_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: dbservice
--

ALTER SEQUENCE public.awsdms_ddl_audit_c_key_seq OWNED BY public.awsdms_ddl_audit.c_key;


--
-- Name: awsdms_heartbeat; Type: TABLE; Schema: public; Owner: dbservice
--

CREATE TABLE public.awsdms_heartbeat (
    hb_key integer NOT NULL,
    hb_created_at timestamp without time zone,
    hb_created_by character varying(64),
    hb_last_heartbeat_at timestamp without time zone,
    hb_last_heartbeat_by character varying(64)
);


ALTER TABLE public.awsdms_heartbeat OWNER TO dbservice;

--
-- Name: awsdms_heartbeat_hb_key_seq; Type: SEQUENCE; Schema: public; Owner: dbservice
--

CREATE SEQUENCE public.awsdms_heartbeat_hb_key_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.awsdms_heartbeat_hb_key_seq OWNER TO dbservice;

--
-- Name: awsdms_heartbeat_hb_key_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: dbservice
--

ALTER SEQUENCE public.awsdms_heartbeat_hb_key_seq OWNED BY public.awsdms_heartbeat.hb_key;


--
-- Name: awsdms_history; Type: TABLE; Schema: public; Owner: dbservice
--

CREATE TABLE public.awsdms_history (
    server_name character varying(384) NOT NULL,
    task_name character varying(384) NOT NULL,
    timeslot_type character varying(96) NOT NULL,
    timeslot timestamp without time zone NOT NULL,
    timeslot_duration bigint,
    timeslot_latency bigint,
    timeslot_records bigint,
    timeslot_volume bigint
);


ALTER TABLE public.awsdms_history OWNER TO dbservice;

--
-- Name: awsdms_status; Type: TABLE; Schema: public; Owner: dbservice
--

CREATE TABLE public.awsdms_status (
    server_name character varying(384) NOT NULL,
    task_name character varying(384) NOT NULL,
    task_status character varying(96),
    status_time timestamp without time zone,
    pending_changes bigint,
    disk_swap_size bigint,
    task_memory bigint,
    source_current_position character varying(384),
    source_current_timestamp timestamp without time zone,
    source_tail_position character varying(384),
    source_tail_timestamp timestamp without time zone,
    source_timestamp_applied timestamp without time zone
);


ALTER TABLE public.awsdms_status OWNER TO dbservice;

--
-- Name: awsdms_suspended_tables; Type: TABLE; Schema: public; Owner: dbservice
--

CREATE TABLE public.awsdms_suspended_tables (
    server_name character varying(384) NOT NULL,
    task_name character varying(384) NOT NULL,
    table_owner character varying(384) NOT NULL,
    table_name character varying(384) NOT NULL,
    suspend_reason character varying(96),
    suspend_timestamp timestamp without time zone
);


ALTER TABLE public.awsdms_suspended_tables OWNER TO dbservice;

--
-- Name: awsdms_validation_failures_v1; Type: TABLE; Schema: public; Owner: dbservice
--

CREATE TABLE public.awsdms_validation_failures_v1 (
    "TASK_NAME" character varying(128) NOT NULL,
    "TABLE_OWNER" character varying(128) NOT NULL,
    "TABLE_NAME" character varying(128) NOT NULL,
    "FAILURE_TIME" timestamp without time zone NOT NULL,
    "KEY_TYPE" character varying(128) NOT NULL,
    "KEY" character varying(8000) NOT NULL,
    "FAILURE_TYPE" character varying(128) NOT NULL,
    "DETAILS" character varying(8000) NOT NULL
);


ALTER TABLE public.awsdms_validation_failures_v1 OWNER TO dbservice;

--
-- Name: byte_tickets_120days; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_tickets_120days AS
 SELECT byte_tickets.order_id,
    byte_tickets.first_name,
    byte_tickets.last_name,
    byte_tickets.kiosk_id,
    byte_tickets.kiosk_title,
    byte_tickets.email,
    byte_tickets.amount_paid,
    byte_tickets.payment_system,
    byte_tickets.transaction_id,
    byte_tickets.approval_code,
    byte_tickets.status_code,
    byte_tickets.status_message,
    byte_tickets.status,
    byte_tickets.batch_id,
    byte_tickets.created,
    byte_tickets.auth_amount,
    byte_tickets.data_token,
    byte_tickets.time_opened,
    byte_tickets.time_closed,
    byte_tickets.card_hash,
    byte_tickets.state,
    byte_tickets.archived,
    byte_tickets.stamp,
    byte_tickets.last_update,
    byte_tickets.balance,
    byte_tickets.delta,
    byte_tickets.coupon_id,
    byte_tickets.coupon,
    byte_tickets.refund,
    byte_tickets.receipt,
    byte_tickets.campus_id,
    byte_tickets.amount_list_price,
    byte_tickets.notes,
    byte_tickets.time_door_opened,
    byte_tickets.time_door_closed,
    byte_tickets.client_name,
    byte_tickets.estd_num_users,
    byte_tickets.ts,
    byte_tickets.full_name,
    byte_tickets.door_opened_secs,
    byte_tickets.month,
    byte_tickets.week,
    byte_tickets.date,
    byte_tickets.dayofweek,
    byte_tickets.hour,
    byte_tickets.dowhour,
    byte_tickets.uniq_user
   FROM public.byte_tickets
  WHERE (byte_tickets.ts > (now() - '120 days'::interval day));


ALTER TABLE public.byte_tickets_120days OWNER TO dbservice;

--
-- Name: byte_epcssold_120days; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_epcssold_120days AS
 SELECT o.order_id,
    o.first_name,
    o.last_name,
    o.kiosk_id,
    o.kiosk_title,
    o.email,
    o.amount_paid,
    o.payment_system,
    o.transaction_id,
    o.approval_code,
    o.status_code,
    o.status_message,
    o.status,
    o.batch_id,
    o.created,
    o.auth_amount,
    o.data_token,
    o.time_opened,
    o.time_closed,
    o.card_hash,
    o.state,
    o.archived,
    o.stamp,
    o.last_update,
    o.balance,
    o.delta,
    o.coupon_id,
    o.coupon,
    o.refund,
    o.receipt,
    o.campus_id,
    o.amount_list_price,
    o.notes,
    o.time_door_opened,
    o.time_door_closed,
    o.client_name,
    o.estd_num_users,
    o.ts,
    o.full_name,
    o.door_opened_secs,
    o.month,
    o.week,
    o.date,
    o.dayofweek,
    o.hour,
    o.dowhour,
    o.uniq_user,
    lp.epc,
    lp.label_order_id,
    lp.label_status,
    lp.label_price,
    lp.time_created,
    lp.time_added,
    lp.time_updated,
    lp.ts_created,
    lp.ts_added,
    lp.ts_updated,
    lp.label_kiosk_id,
    lp.product_id,
    lp.product_title,
    lp.product_archived,
    lp.product_vendor,
    lp.product_price,
    lp.product_cost,
    lp.product_shelf_life_days,
    lp.product_attributes,
    lp.product_categories,
    lp.consumer_category,
    lp.product_source
   FROM (public.byte_tickets_120days o
     JOIN public.byte_label_product lp ON (((lp.label_order_id)::text = (o.order_id)::text)))
  WHERE ((lp.label_status)::text = 'sold'::text);


ALTER TABLE public.byte_epcssold_120days OWNER TO dbservice;

--
-- Name: byte_addicted_users_120days; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_addicted_users_120days AS
 SELECT t.kiosk_id,
    t.kiosk_title,
    t.product_id,
    t.product_title,
    count(*) AS count
   FROM ( SELECT items.kiosk_id,
            items.kiosk_title,
            ((btrim((items.first_name)::text) || ' '::text) || btrim((items.last_name)::text)) AS username,
            items.product_id,
            items.product_title,
            count(*) AS last_120d_purchases,
            sum(public.if((items.ts > (now() - '14 days'::interval day)), 1, 0)) AS last_14d_purchases
           FROM public.byte_epcssold_120days items
          GROUP BY items.kiosk_id, items.kiosk_title, ((btrim((items.first_name)::text) || ' '::text) || btrim((items.last_name)::text)), items.product_id, items.product_title) t
  WHERE ((t.last_14d_purchases >= 1) AND (t.last_120d_purchases >= 6) AND (t.username <> ALL (ARRAY[''::text, 'Free Complimentary'::text])))
  GROUP BY t.kiosk_id, t.kiosk_title, t.product_id, t.product_title;


ALTER TABLE public.byte_addicted_users_120days OWNER TO dbservice;

--
-- Name: iplanner_inventory; Type: TABLE; Schema: public; Owner: dbservice
--

CREATE TABLE public.iplanner_inventory (
    dccode character varying(250),
    dcname character varying(250),
    bytesku integer,
    product character varying(250),
    date timestamp(6) without time zone,
    lotnumber timestamp(6) without time zone,
    inventory_count numeric(28,6),
    inventory_amount numeric(28,6),
    unit_amount numeric(28,6),
    expiration_date timestamp(6) without time zone,
    id integer
);


ALTER TABLE public.iplanner_inventory OWNER TO dbservice;

--
-- Name: byte_dc_inventory_history; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_dc_inventory_history AS
 SELECT iplanner_inventory.dccode AS dc,
    iplanner_inventory.bytesku AS product_id,
    iplanner_inventory.date,
    iplanner_inventory.inventory_count
   FROM public.iplanner_inventory;


ALTER TABLE public.byte_dc_inventory_history OWNER TO dbservice;

--
-- Name: byte_epcssold; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_epcssold AS
 SELECT o.order_id,
    o.first_name,
    o.last_name,
    o.kiosk_id,
    o.kiosk_title,
    o.email,
    o.amount_paid,
    o.payment_system,
    o.transaction_id,
    o.approval_code,
    o.status_code,
    o.status_message,
    o.status,
    o.batch_id,
    o.created,
    o.auth_amount,
    o.data_token,
    o.time_opened,
    o.time_closed,
    o.card_hash,
    o.state,
    o.archived,
    o.stamp,
    o.last_update,
    o.balance,
    o.delta,
    o.coupon_id,
    o.coupon,
    o.refund,
    o.receipt,
    o.campus_id,
    o.amount_list_price,
    o.notes,
    o.time_door_opened,
    o.time_door_closed,
    o.client_name,
    o.estd_num_users,
    o.ts,
    o.full_name,
    o.door_opened_secs,
    o.month,
    o.week,
    o.date,
    o.dayofweek,
    o.hour,
    o.dowhour,
    o.uniq_user,
    lp.epc,
    lp.label_order_id,
    lp.label_status,
    lp.label_price,
    lp.time_created,
    lp.time_added,
    lp.time_updated,
    lp.ts_created,
    lp.ts_added,
    lp.ts_updated,
    lp.label_kiosk_id,
    lp.product_id,
    lp.product_title,
    lp.product_archived,
    lp.product_vendor,
    lp.product_price,
    lp.product_cost,
    lp.product_shelf_life_days,
    lp.product_attributes,
    lp.product_categories,
    lp.consumer_category,
    lp.product_source
   FROM (public.byte_tickets o
     JOIN public.byte_label_product lp ON (((lp.label_order_id)::text = (o.order_id)::text)))
  WHERE ((lp.label_status)::text = 'sold'::text);


ALTER TABLE public.byte_epcssold OWNER TO dbservice;

--
-- Name: byte_tickets_10weeks; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_tickets_10weeks AS
 SELECT byte_tickets.order_id,
    byte_tickets.first_name,
    byte_tickets.last_name,
    byte_tickets.kiosk_id,
    byte_tickets.kiosk_title,
    byte_tickets.email,
    byte_tickets.amount_paid,
    byte_tickets.payment_system,
    byte_tickets.transaction_id,
    byte_tickets.approval_code,
    byte_tickets.status_code,
    byte_tickets.status_message,
    byte_tickets.status,
    byte_tickets.batch_id,
    byte_tickets.created,
    byte_tickets.auth_amount,
    byte_tickets.data_token,
    byte_tickets.time_opened,
    byte_tickets.time_closed,
    byte_tickets.card_hash,
    byte_tickets.state,
    byte_tickets.archived,
    byte_tickets.stamp,
    byte_tickets.last_update,
    byte_tickets.balance,
    byte_tickets.delta,
    byte_tickets.coupon_id,
    byte_tickets.coupon,
    byte_tickets.refund,
    byte_tickets.receipt,
    byte_tickets.campus_id,
    byte_tickets.amount_list_price,
    byte_tickets.notes,
    byte_tickets.time_door_opened,
    byte_tickets.time_door_closed,
    byte_tickets.client_name,
    byte_tickets.estd_num_users,
    byte_tickets.ts,
    byte_tickets.full_name,
    byte_tickets.door_opened_secs,
    byte_tickets.month,
    byte_tickets.week,
    byte_tickets.date,
    byte_tickets.dayofweek,
    byte_tickets.hour,
    byte_tickets.dowhour,
    byte_tickets.uniq_user
   FROM public.byte_tickets
  WHERE (byte_tickets.ts > (now() - '70 days'::interval day));


ALTER TABLE public.byte_tickets_10weeks OWNER TO dbservice;

--
-- Name: byte_epcssold_10weeks; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_epcssold_10weeks AS
 SELECT o.order_id,
    o.first_name,
    o.last_name,
    o.kiosk_id,
    o.kiosk_title,
    o.email,
    o.amount_paid,
    o.payment_system,
    o.transaction_id,
    o.approval_code,
    o.status_code,
    o.status_message,
    o.status,
    o.batch_id,
    o.created,
    o.auth_amount,
    o.data_token,
    o.time_opened,
    o.time_closed,
    o.card_hash,
    o.state,
    o.archived,
    o.stamp,
    o.last_update,
    o.balance,
    o.delta,
    o.coupon_id,
    o.coupon,
    o.refund,
    o.receipt,
    o.campus_id,
    o.amount_list_price,
    o.notes,
    o.time_door_opened,
    o.time_door_closed,
    o.client_name,
    o.estd_num_users,
    o.ts,
    o.full_name,
    o.door_opened_secs,
    o.month,
    o.week,
    o.date,
    o.dayofweek,
    o.hour,
    o.dowhour,
    o.uniq_user,
    lp.epc,
    lp.label_order_id,
    lp.label_status,
    lp.label_price,
    lp.time_created,
    lp.time_added,
    lp.time_updated,
    lp.ts_created,
    lp.ts_added,
    lp.ts_updated,
    lp.label_kiosk_id,
    lp.product_id,
    lp.product_title,
    lp.product_archived,
    lp.product_vendor,
    lp.product_price,
    lp.product_cost,
    lp.product_shelf_life_days,
    lp.product_attributes,
    lp.product_categories,
    lp.consumer_category,
    lp.product_source
   FROM (public.byte_tickets_10weeks o
     JOIN public.byte_label_product lp ON (((lp.label_order_id)::text = (o.order_id)::text)))
  WHERE ((lp.label_status)::text = 'sold'::text);


ALTER TABLE public.byte_epcssold_10weeks OWNER TO dbservice;

--
-- Name: byte_tickets_12months; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_tickets_12months AS
 SELECT byte_tickets.order_id,
    byte_tickets.first_name,
    byte_tickets.last_name,
    byte_tickets.kiosk_id,
    byte_tickets.kiosk_title,
    byte_tickets.email,
    byte_tickets.amount_paid,
    byte_tickets.payment_system,
    byte_tickets.transaction_id,
    byte_tickets.approval_code,
    byte_tickets.status_code,
    byte_tickets.status_message,
    byte_tickets.status,
    byte_tickets.batch_id,
    byte_tickets.created,
    byte_tickets.auth_amount,
    byte_tickets.data_token,
    byte_tickets.time_opened,
    byte_tickets.time_closed,
    byte_tickets.card_hash,
    byte_tickets.state,
    byte_tickets.archived,
    byte_tickets.stamp,
    byte_tickets.last_update,
    byte_tickets.balance,
    byte_tickets.delta,
    byte_tickets.coupon_id,
    byte_tickets.coupon,
    byte_tickets.refund,
    byte_tickets.receipt,
    byte_tickets.campus_id,
    byte_tickets.amount_list_price,
    byte_tickets.notes,
    byte_tickets.time_door_opened,
    byte_tickets.time_door_closed,
    byte_tickets.client_name,
    byte_tickets.estd_num_users,
    byte_tickets.ts,
    byte_tickets.full_name,
    byte_tickets.door_opened_secs,
    byte_tickets.month,
    byte_tickets.week,
    byte_tickets.date,
    byte_tickets.dayofweek,
    byte_tickets.hour,
    byte_tickets.dowhour,
    byte_tickets.uniq_user
   FROM public.byte_tickets
  WHERE (byte_tickets.ts > (now() - '1 year'::interval month));


ALTER TABLE public.byte_tickets_12months OWNER TO dbservice;

--
-- Name: byte_epcssold_12months; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_epcssold_12months AS
 SELECT o.order_id,
    o.first_name,
    o.last_name,
    o.kiosk_id,
    o.kiosk_title,
    o.email,
    o.amount_paid,
    o.payment_system,
    o.transaction_id,
    o.approval_code,
    o.status_code,
    o.status_message,
    o.status,
    o.batch_id,
    o.created,
    o.auth_amount,
    o.data_token,
    o.time_opened,
    o.time_closed,
    o.card_hash,
    o.state,
    o.archived,
    o.stamp,
    o.last_update,
    o.balance,
    o.delta,
    o.coupon_id,
    o.coupon,
    o.refund,
    o.receipt,
    o.campus_id,
    o.amount_list_price,
    o.notes,
    o.time_door_opened,
    o.time_door_closed,
    o.client_name,
    o.estd_num_users,
    o.ts,
    o.full_name,
    o.door_opened_secs,
    o.month,
    o.week,
    o.date,
    o.dayofweek,
    o.hour,
    o.dowhour,
    o.uniq_user,
    lp.epc,
    lp.label_order_id,
    lp.label_status,
    lp.label_price,
    lp.time_created,
    lp.time_added,
    lp.time_updated,
    lp.ts_created,
    lp.ts_added,
    lp.ts_updated,
    lp.label_kiosk_id,
    lp.product_id,
    lp.product_title,
    lp.product_archived,
    lp.product_vendor,
    lp.product_price,
    lp.product_cost,
    lp.product_shelf_life_days,
    lp.product_attributes,
    lp.product_categories,
    lp.consumer_category,
    lp.product_source,
    lp.fc_title
   FROM (public.byte_tickets_12months o
     JOIN public.byte_label_product lp ON (((lp.label_order_id)::text = (o.order_id)::text)))
  WHERE ((lp.label_status)::text = 'sold'::text);


ALTER TABLE public.byte_epcssold_12months OWNER TO dbservice;

--
-- Name: byte_tickets_180days; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_tickets_180days AS
 SELECT byte_tickets.order_id,
    byte_tickets.first_name,
    byte_tickets.last_name,
    byte_tickets.kiosk_id,
    byte_tickets.kiosk_title,
    byte_tickets.email,
    byte_tickets.amount_paid,
    byte_tickets.payment_system,
    byte_tickets.transaction_id,
    byte_tickets.approval_code,
    byte_tickets.status_code,
    byte_tickets.status_message,
    byte_tickets.status,
    byte_tickets.batch_id,
    byte_tickets.created,
    byte_tickets.auth_amount,
    byte_tickets.data_token,
    byte_tickets.time_opened,
    byte_tickets.time_closed,
    byte_tickets.card_hash,
    byte_tickets.state,
    byte_tickets.archived,
    byte_tickets.stamp,
    byte_tickets.last_update,
    byte_tickets.balance,
    byte_tickets.delta,
    byte_tickets.coupon_id,
    byte_tickets.coupon,
    byte_tickets.refund,
    byte_tickets.receipt,
    byte_tickets.campus_id,
    byte_tickets.amount_list_price,
    byte_tickets.notes,
    byte_tickets.time_door_opened,
    byte_tickets.time_door_closed,
    byte_tickets.client_name,
    byte_tickets.estd_num_users,
    byte_tickets.ts,
    byte_tickets.full_name,
    byte_tickets.door_opened_secs,
    byte_tickets.month,
    byte_tickets.week,
    byte_tickets.date,
    byte_tickets.dayofweek,
    byte_tickets.hour,
    byte_tickets.dowhour,
    byte_tickets.uniq_user
   FROM public.byte_tickets
  WHERE (byte_tickets.ts > (now() - '180 days'::interval day));


ALTER TABLE public.byte_tickets_180days OWNER TO dbservice;

--
-- Name: byte_epcssold_180days; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_epcssold_180days AS
 SELECT o.order_id,
    o.first_name,
    o.last_name,
    o.kiosk_id,
    o.kiosk_title,
    o.email,
    o.amount_paid,
    o.payment_system,
    o.transaction_id,
    o.approval_code,
    o.status_code,
    o.status_message,
    o.status,
    o.batch_id,
    o.created,
    o.auth_amount,
    o.data_token,
    o.time_opened,
    o.time_closed,
    o.card_hash,
    o.state,
    o.archived,
    o.stamp,
    o.last_update,
    o.balance,
    o.delta,
    o.coupon_id,
    o.coupon,
    o.refund,
    o.receipt,
    o.campus_id,
    o.amount_list_price,
    o.notes,
    o.time_door_opened,
    o.time_door_closed,
    o.client_name,
    o.estd_num_users,
    o.ts,
    o.full_name,
    o.door_opened_secs,
    o.month,
    o.week,
    o.date,
    o.dayofweek,
    o.hour,
    o.dowhour,
    o.uniq_user,
    lp.epc,
    lp.label_order_id,
    lp.label_status,
    lp.label_price,
    lp.time_created,
    lp.time_added,
    lp.time_updated,
    lp.ts_created,
    lp.ts_added,
    lp.ts_updated,
    lp.label_kiosk_id,
    lp.product_id,
    lp.product_title,
    lp.product_archived,
    lp.product_vendor,
    lp.product_price,
    lp.product_cost,
    lp.product_shelf_life_days,
    lp.product_attributes,
    lp.product_categories,
    lp.consumer_category,
    lp.product_source
   FROM (public.byte_tickets_180days o
     JOIN public.byte_label_product lp ON (((lp.label_order_id)::text = (o.order_id)::text)))
  WHERE ((lp.label_status)::text = 'sold'::text);


ALTER TABLE public.byte_epcssold_180days OWNER TO dbservice;

--
-- Name: byte_tickets_1day; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_tickets_1day AS
 SELECT byte_tickets.order_id,
    byte_tickets.first_name,
    byte_tickets.last_name,
    byte_tickets.kiosk_id,
    byte_tickets.kiosk_title,
    byte_tickets.email,
    byte_tickets.amount_paid,
    byte_tickets.payment_system,
    byte_tickets.transaction_id,
    byte_tickets.approval_code,
    byte_tickets.status_code,
    byte_tickets.status_message,
    byte_tickets.status,
    byte_tickets.batch_id,
    byte_tickets.created,
    byte_tickets.auth_amount,
    byte_tickets.data_token,
    byte_tickets.time_opened,
    byte_tickets.time_closed,
    byte_tickets.card_hash,
    byte_tickets.state,
    byte_tickets.archived,
    byte_tickets.stamp,
    byte_tickets.last_update,
    byte_tickets.balance,
    byte_tickets.delta,
    byte_tickets.coupon_id,
    byte_tickets.coupon,
    byte_tickets.refund,
    byte_tickets.receipt,
    byte_tickets.campus_id,
    byte_tickets.amount_list_price,
    byte_tickets.notes,
    byte_tickets.time_door_opened,
    byte_tickets.time_door_closed,
    byte_tickets.client_name,
    byte_tickets.estd_num_users,
    byte_tickets.ts,
    byte_tickets.full_name,
    byte_tickets.door_opened_secs,
    byte_tickets.month,
    byte_tickets.week,
    byte_tickets.date,
    byte_tickets.dayofweek,
    byte_tickets.hour,
    byte_tickets.dowhour,
    byte_tickets.uniq_user
   FROM public.byte_tickets
  WHERE (byte_tickets.ts > (now() - '1 day'::interval day));


ALTER TABLE public.byte_tickets_1day OWNER TO dbservice;

--
-- Name: byte_epcssold_1day; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_epcssold_1day AS
 SELECT o.order_id,
    o.first_name,
    o.last_name,
    o.kiosk_id,
    o.kiosk_title,
    o.email,
    o.amount_paid,
    o.payment_system,
    o.transaction_id,
    o.approval_code,
    o.status_code,
    o.status_message,
    o.status,
    o.batch_id,
    o.created,
    o.auth_amount,
    o.data_token,
    o.time_opened,
    o.time_closed,
    o.card_hash,
    o.state,
    o.archived,
    o.stamp,
    o.last_update,
    o.balance,
    o.delta,
    o.coupon_id,
    o.coupon,
    o.refund,
    o.receipt,
    o.campus_id,
    o.amount_list_price,
    o.notes,
    o.time_door_opened,
    o.time_door_closed,
    o.client_name,
    o.estd_num_users,
    o.ts,
    o.full_name,
    o.door_opened_secs,
    o.month,
    o.week,
    o.date,
    o.dayofweek,
    o.hour,
    o.dowhour,
    o.uniq_user,
    lp.epc,
    lp.label_order_id,
    lp.label_status,
    lp.label_price,
    lp.time_created,
    lp.time_added,
    lp.time_updated,
    lp.ts_created,
    lp.ts_added,
    lp.ts_updated,
    lp.label_kiosk_id,
    lp.product_id,
    lp.product_title,
    lp.product_archived,
    lp.product_vendor,
    lp.product_price,
    lp.product_cost,
    lp.product_shelf_life_days,
    lp.product_attributes,
    lp.product_categories,
    lp.consumer_category,
    lp.product_source
   FROM (public.byte_tickets_1day o
     JOIN public.byte_label_product lp ON (((lp.label_order_id)::text = (o.order_id)::text)))
  WHERE ((lp.label_status)::text = 'sold'::text);


ALTER TABLE public.byte_epcssold_1day OWNER TO dbservice;

--
-- Name: byte_tickets_1month; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_tickets_1month AS
 SELECT byte_tickets.order_id,
    byte_tickets.first_name,
    byte_tickets.last_name,
    byte_tickets.kiosk_id,
    byte_tickets.kiosk_title,
    byte_tickets.email,
    byte_tickets.amount_paid,
    byte_tickets.payment_system,
    byte_tickets.transaction_id,
    byte_tickets.approval_code,
    byte_tickets.status_code,
    byte_tickets.status_message,
    byte_tickets.status,
    byte_tickets.batch_id,
    byte_tickets.created,
    byte_tickets.auth_amount,
    byte_tickets.data_token,
    byte_tickets.time_opened,
    byte_tickets.time_closed,
    byte_tickets.card_hash,
    byte_tickets.state,
    byte_tickets.archived,
    byte_tickets.stamp,
    byte_tickets.last_update,
    byte_tickets.balance,
    byte_tickets.delta,
    byte_tickets.coupon_id,
    byte_tickets.coupon,
    byte_tickets.refund,
    byte_tickets.receipt,
    byte_tickets.campus_id,
    byte_tickets.amount_list_price,
    byte_tickets.notes,
    byte_tickets.time_door_opened,
    byte_tickets.time_door_closed,
    byte_tickets.client_name,
    byte_tickets.estd_num_users,
    byte_tickets.ts,
    byte_tickets.full_name,
    byte_tickets.door_opened_secs,
    byte_tickets.month,
    byte_tickets.week,
    byte_tickets.date,
    byte_tickets.dayofweek,
    byte_tickets.hour,
    byte_tickets.dowhour,
    byte_tickets.uniq_user
   FROM public.byte_tickets
  WHERE (byte_tickets.ts > (now() - '1 mon'::interval month));


ALTER TABLE public.byte_tickets_1month OWNER TO dbservice;

--
-- Name: byte_epcssold_1month; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_epcssold_1month AS
 SELECT o.order_id,
    o.first_name,
    o.last_name,
    o.kiosk_id,
    o.kiosk_title,
    o.email,
    o.amount_paid,
    o.payment_system,
    o.transaction_id,
    o.approval_code,
    o.status_code,
    o.status_message,
    o.status,
    o.batch_id,
    o.created,
    o.auth_amount,
    o.data_token,
    o.time_opened,
    o.time_closed,
    o.card_hash,
    o.state,
    o.archived,
    o.stamp,
    o.last_update,
    o.balance,
    o.delta,
    o.coupon_id,
    o.coupon,
    o.refund,
    o.receipt,
    o.campus_id,
    o.amount_list_price,
    o.notes,
    o.time_door_opened,
    o.time_door_closed,
    o.client_name,
    o.estd_num_users,
    o.ts,
    o.full_name,
    o.door_opened_secs,
    o.month,
    o.week,
    o.date,
    o.dayofweek,
    o.hour,
    o.dowhour,
    o.uniq_user,
    lp.epc,
    lp.label_order_id,
    lp.label_status,
    lp.label_price,
    lp.time_created,
    lp.time_added,
    lp.time_updated,
    lp.ts_created,
    lp.ts_added,
    lp.ts_updated,
    lp.label_kiosk_id,
    lp.product_id,
    lp.product_title,
    lp.product_archived,
    lp.product_vendor,
    lp.product_price,
    lp.product_cost,
    lp.product_shelf_life_days,
    lp.product_attributes,
    lp.product_categories,
    lp.consumer_category,
    lp.product_source
   FROM (public.byte_tickets_1month o
     JOIN public.byte_label_product lp ON (((lp.label_order_id)::text = (o.order_id)::text)))
  WHERE ((lp.label_status)::text = 'sold'::text);


ALTER TABLE public.byte_epcssold_1month OWNER TO dbservice;

--
-- Name: byte_tickets_1week; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_tickets_1week AS
 SELECT byte_tickets.order_id,
    byte_tickets.first_name,
    byte_tickets.last_name,
    byte_tickets.kiosk_id,
    byte_tickets.kiosk_title,
    byte_tickets.email,
    byte_tickets.amount_paid,
    byte_tickets.payment_system,
    byte_tickets.transaction_id,
    byte_tickets.approval_code,
    byte_tickets.status_code,
    byte_tickets.status_message,
    byte_tickets.status,
    byte_tickets.batch_id,
    byte_tickets.created,
    byte_tickets.auth_amount,
    byte_tickets.data_token,
    byte_tickets.time_opened,
    byte_tickets.time_closed,
    byte_tickets.card_hash,
    byte_tickets.state,
    byte_tickets.archived,
    byte_tickets.stamp,
    byte_tickets.last_update,
    byte_tickets.balance,
    byte_tickets.delta,
    byte_tickets.coupon_id,
    byte_tickets.coupon,
    byte_tickets.refund,
    byte_tickets.receipt,
    byte_tickets.campus_id,
    byte_tickets.amount_list_price,
    byte_tickets.notes,
    byte_tickets.time_door_opened,
    byte_tickets.time_door_closed,
    byte_tickets.client_name,
    byte_tickets.estd_num_users,
    byte_tickets.ts,
    byte_tickets.full_name,
    byte_tickets.door_opened_secs,
    byte_tickets.month,
    byte_tickets.week,
    byte_tickets.date,
    byte_tickets.dayofweek,
    byte_tickets.hour,
    byte_tickets.dowhour,
    byte_tickets.uniq_user
   FROM public.byte_tickets
  WHERE (byte_tickets.ts > (now() - '7 days'::interval day));


ALTER TABLE public.byte_tickets_1week OWNER TO dbservice;

--
-- Name: byte_epcssold_1week; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_epcssold_1week AS
 SELECT o.order_id,
    o.first_name,
    o.last_name,
    o.kiosk_id,
    o.kiosk_title,
    o.email,
    o.amount_paid,
    o.payment_system,
    o.transaction_id,
    o.approval_code,
    o.status_code,
    o.status_message,
    o.status,
    o.batch_id,
    o.created,
    o.auth_amount,
    o.data_token,
    o.time_opened,
    o.time_closed,
    o.card_hash,
    o.state,
    o.archived,
    o.stamp,
    o.last_update,
    o.balance,
    o.delta,
    o.coupon_id,
    o.coupon,
    o.refund,
    o.receipt,
    o.campus_id,
    o.amount_list_price,
    o.notes,
    o.time_door_opened,
    o.time_door_closed,
    o.client_name,
    o.estd_num_users,
    o.ts,
    o.full_name,
    o.door_opened_secs,
    o.month,
    o.week,
    o.date,
    o.dayofweek,
    o.hour,
    o.dowhour,
    o.uniq_user,
    lp.epc,
    lp.label_order_id,
    lp.label_status,
    lp.label_price,
    lp.time_created,
    lp.time_added,
    lp.time_updated,
    lp.ts_created,
    lp.ts_added,
    lp.ts_updated,
    lp.label_kiosk_id,
    lp.product_id,
    lp.product_title,
    lp.product_archived,
    lp.product_vendor,
    lp.product_price,
    lp.product_cost,
    lp.product_shelf_life_days,
    lp.product_attributes,
    lp.product_categories,
    lp.consumer_category,
    lp.product_source
   FROM (public.byte_tickets_1week o
     JOIN public.byte_label_product lp ON (((lp.label_order_id)::text = (o.order_id)::text)))
  WHERE ((lp.label_status)::text = 'sold'::text);


ALTER TABLE public.byte_epcssold_1week OWNER TO dbservice;

--
-- Name: byte_tickets_1year; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_tickets_1year AS
 SELECT byte_tickets.order_id,
    byte_tickets.first_name,
    byte_tickets.last_name,
    byte_tickets.kiosk_id,
    byte_tickets.kiosk_title,
    byte_tickets.email,
    byte_tickets.amount_paid,
    byte_tickets.payment_system,
    byte_tickets.transaction_id,
    byte_tickets.approval_code,
    byte_tickets.status_code,
    byte_tickets.status_message,
    byte_tickets.status,
    byte_tickets.batch_id,
    byte_tickets.created,
    byte_tickets.auth_amount,
    byte_tickets.data_token,
    byte_tickets.time_opened,
    byte_tickets.time_closed,
    byte_tickets.card_hash,
    byte_tickets.state,
    byte_tickets.archived,
    byte_tickets.stamp,
    byte_tickets.last_update,
    byte_tickets.balance,
    byte_tickets.delta,
    byte_tickets.coupon_id,
    byte_tickets.coupon,
    byte_tickets.refund,
    byte_tickets.receipt,
    byte_tickets.campus_id,
    byte_tickets.amount_list_price,
    byte_tickets.notes,
    byte_tickets.time_door_opened,
    byte_tickets.time_door_closed,
    byte_tickets.client_name,
    byte_tickets.estd_num_users,
    byte_tickets.ts,
    byte_tickets.full_name,
    byte_tickets.door_opened_secs,
    byte_tickets.month,
    byte_tickets.week,
    byte_tickets.date,
    byte_tickets.dayofweek,
    byte_tickets.hour,
    byte_tickets.dowhour,
    byte_tickets.uniq_user
   FROM public.byte_tickets
  WHERE (byte_tickets.ts > (now() - '1 year'::interval year));


ALTER TABLE public.byte_tickets_1year OWNER TO dbservice;

--
-- Name: byte_epcssold_1year; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_epcssold_1year AS
 SELECT o.order_id,
    o.first_name,
    o.last_name,
    o.kiosk_id,
    o.kiosk_title,
    o.email,
    o.amount_paid,
    o.payment_system,
    o.transaction_id,
    o.approval_code,
    o.status_code,
    o.status_message,
    o.status,
    o.batch_id,
    o.created,
    o.auth_amount,
    o.data_token,
    o.time_opened,
    o.time_closed,
    o.card_hash,
    o.state,
    o.archived,
    o.stamp,
    o.last_update,
    o.balance,
    o.delta,
    o.coupon_id,
    o.coupon,
    o.refund,
    o.receipt,
    o.campus_id,
    o.amount_list_price,
    o.notes,
    o.time_door_opened,
    o.time_door_closed,
    o.client_name,
    o.estd_num_users,
    o.ts,
    o.full_name,
    o.door_opened_secs,
    o.month,
    o.week,
    o.date,
    o.dayofweek,
    o.hour,
    o.dowhour,
    o.uniq_user,
    lp.epc,
    lp.label_order_id,
    lp.label_status,
    lp.label_price,
    lp.time_created,
    lp.time_added,
    lp.time_updated,
    lp.ts_created,
    lp.ts_added,
    lp.ts_updated,
    lp.label_kiosk_id,
    lp.product_id,
    lp.product_title,
    lp.product_archived,
    lp.product_vendor,
    lp.product_price,
    lp.product_cost,
    lp.product_shelf_life_days,
    lp.product_attributes,
    lp.product_categories,
    lp.consumer_category,
    lp.product_source
   FROM (public.byte_tickets_1year o
     JOIN public.byte_label_product lp ON (((lp.label_order_id)::text = (o.order_id)::text)))
  WHERE ((lp.label_status)::text = 'sold'::text);


ALTER TABLE public.byte_epcssold_1year OWNER TO dbservice;

--
-- Name: byte_tickets_2015; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_tickets_2015 AS
 SELECT byte_tickets.order_id,
    byte_tickets.first_name,
    byte_tickets.last_name,
    byte_tickets.kiosk_id,
    byte_tickets.kiosk_title,
    byte_tickets.email,
    byte_tickets.amount_paid,
    byte_tickets.payment_system,
    byte_tickets.transaction_id,
    byte_tickets.approval_code,
    byte_tickets.status_code,
    byte_tickets.status_message,
    byte_tickets.status,
    byte_tickets.batch_id,
    byte_tickets.created,
    byte_tickets.auth_amount,
    byte_tickets.data_token,
    byte_tickets.time_opened,
    byte_tickets.time_closed,
    byte_tickets.card_hash,
    byte_tickets.state,
    byte_tickets.archived,
    byte_tickets.stamp,
    byte_tickets.last_update,
    byte_tickets.balance,
    byte_tickets.delta,
    byte_tickets.coupon_id,
    byte_tickets.coupon,
    byte_tickets.refund,
    byte_tickets.receipt,
    byte_tickets.campus_id,
    byte_tickets.amount_list_price,
    byte_tickets.notes,
    byte_tickets.time_door_opened,
    byte_tickets.time_door_closed,
    byte_tickets.client_name,
    byte_tickets.estd_num_users,
    byte_tickets.ts,
    byte_tickets.full_name,
    byte_tickets.door_opened_secs,
    byte_tickets.month,
    byte_tickets.week,
    byte_tickets.date,
    byte_tickets.dayofweek,
    byte_tickets.hour,
    byte_tickets.dowhour,
    byte_tickets.uniq_user
   FROM public.byte_tickets
  WHERE ((byte_tickets.ts >= '2015-01-01 08:00:00+00'::timestamp with time zone) AND (byte_tickets.ts < '2016-01-01 08:00:00+00'::timestamp with time zone));


ALTER TABLE public.byte_tickets_2015 OWNER TO dbservice;

--
-- Name: byte_epcssold_2015; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_epcssold_2015 AS
 SELECT o.order_id,
    o.first_name,
    o.last_name,
    o.kiosk_id,
    o.kiosk_title,
    o.email,
    o.amount_paid,
    o.payment_system,
    o.transaction_id,
    o.approval_code,
    o.status_code,
    o.status_message,
    o.status,
    o.batch_id,
    o.created,
    o.auth_amount,
    o.data_token,
    o.time_opened,
    o.time_closed,
    o.card_hash,
    o.state,
    o.archived,
    o.stamp,
    o.last_update,
    o.balance,
    o.delta,
    o.coupon_id,
    o.coupon,
    o.refund,
    o.receipt,
    o.campus_id,
    o.amount_list_price,
    o.notes,
    o.time_door_opened,
    o.time_door_closed,
    o.client_name,
    o.estd_num_users,
    o.ts,
    o.full_name,
    o.door_opened_secs,
    o.month,
    o.week,
    o.date,
    o.dayofweek,
    o.hour,
    o.dowhour,
    o.uniq_user,
    lp.epc,
    lp.label_order_id,
    lp.label_status,
    lp.label_price,
    lp.time_created,
    lp.time_added,
    lp.time_updated,
    lp.ts_created,
    lp.ts_added,
    lp.ts_updated,
    lp.label_kiosk_id,
    lp.product_id,
    lp.product_title,
    lp.product_archived,
    lp.product_vendor,
    lp.product_price,
    lp.product_cost,
    lp.product_shelf_life_days,
    lp.product_attributes,
    lp.product_categories,
    lp.consumer_category,
    lp.product_source
   FROM (public.byte_tickets_2015 o
     JOIN public.byte_label_product lp ON (((lp.label_order_id)::text = (o.order_id)::text)))
  WHERE ((lp.label_status)::text = 'sold'::text);


ALTER TABLE public.byte_epcssold_2015 OWNER TO dbservice;

--
-- Name: byte_tickets_2016; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_tickets_2016 AS
 SELECT byte_tickets.order_id,
    byte_tickets.first_name,
    byte_tickets.last_name,
    byte_tickets.kiosk_id,
    byte_tickets.kiosk_title,
    byte_tickets.email,
    byte_tickets.amount_paid,
    byte_tickets.payment_system,
    byte_tickets.transaction_id,
    byte_tickets.approval_code,
    byte_tickets.status_code,
    byte_tickets.status_message,
    byte_tickets.status,
    byte_tickets.batch_id,
    byte_tickets.created,
    byte_tickets.auth_amount,
    byte_tickets.data_token,
    byte_tickets.time_opened,
    byte_tickets.time_closed,
    byte_tickets.card_hash,
    byte_tickets.state,
    byte_tickets.archived,
    byte_tickets.stamp,
    byte_tickets.last_update,
    byte_tickets.balance,
    byte_tickets.delta,
    byte_tickets.coupon_id,
    byte_tickets.coupon,
    byte_tickets.refund,
    byte_tickets.receipt,
    byte_tickets.campus_id,
    byte_tickets.amount_list_price,
    byte_tickets.notes,
    byte_tickets.time_door_opened,
    byte_tickets.time_door_closed,
    byte_tickets.client_name,
    byte_tickets.estd_num_users,
    byte_tickets.ts,
    byte_tickets.full_name,
    byte_tickets.door_opened_secs,
    byte_tickets.month,
    byte_tickets.week,
    byte_tickets.date,
    byte_tickets.dayofweek,
    byte_tickets.hour,
    byte_tickets.dowhour,
    byte_tickets.uniq_user
   FROM public.byte_tickets
  WHERE ((byte_tickets.ts >= '2016-01-01 08:00:00+00'::timestamp with time zone) AND (byte_tickets.ts < '2017-01-01 08:00:00+00'::timestamp with time zone));


ALTER TABLE public.byte_tickets_2016 OWNER TO dbservice;

--
-- Name: byte_epcssold_2016; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_epcssold_2016 AS
 SELECT o.order_id,
    o.first_name,
    o.last_name,
    o.kiosk_id,
    o.kiosk_title,
    o.email,
    o.amount_paid,
    o.payment_system,
    o.transaction_id,
    o.approval_code,
    o.status_code,
    o.status_message,
    o.status,
    o.batch_id,
    o.created,
    o.auth_amount,
    o.data_token,
    o.time_opened,
    o.time_closed,
    o.card_hash,
    o.state,
    o.archived,
    o.stamp,
    o.last_update,
    o.balance,
    o.delta,
    o.coupon_id,
    o.coupon,
    o.refund,
    o.receipt,
    o.campus_id,
    o.amount_list_price,
    o.notes,
    o.time_door_opened,
    o.time_door_closed,
    o.client_name,
    o.estd_num_users,
    o.ts,
    o.full_name,
    o.door_opened_secs,
    o.month,
    o.week,
    o.date,
    o.dayofweek,
    o.hour,
    o.dowhour,
    o.uniq_user,
    lp.epc,
    lp.label_order_id,
    lp.label_status,
    lp.label_price,
    lp.time_created,
    lp.time_added,
    lp.time_updated,
    lp.ts_created,
    lp.ts_added,
    lp.ts_updated,
    lp.label_kiosk_id,
    lp.product_id,
    lp.product_title,
    lp.product_archived,
    lp.product_vendor,
    lp.product_price,
    lp.product_cost,
    lp.product_shelf_life_days,
    lp.product_attributes,
    lp.product_categories,
    lp.consumer_category,
    lp.product_source
   FROM (public.byte_tickets_2016 o
     JOIN public.byte_label_product lp ON (((lp.label_order_id)::text = (o.order_id)::text)))
  WHERE ((lp.label_status)::text = 'sold'::text);


ALTER TABLE public.byte_epcssold_2016 OWNER TO dbservice;

--
-- Name: byte_tickets_2017; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_tickets_2017 AS
 SELECT byte_tickets.order_id,
    byte_tickets.first_name,
    byte_tickets.last_name,
    byte_tickets.kiosk_id,
    byte_tickets.kiosk_title,
    byte_tickets.email,
    byte_tickets.amount_paid,
    byte_tickets.payment_system,
    byte_tickets.transaction_id,
    byte_tickets.approval_code,
    byte_tickets.status_code,
    byte_tickets.status_message,
    byte_tickets.status,
    byte_tickets.batch_id,
    byte_tickets.created,
    byte_tickets.auth_amount,
    byte_tickets.data_token,
    byte_tickets.time_opened,
    byte_tickets.time_closed,
    byte_tickets.card_hash,
    byte_tickets.state,
    byte_tickets.archived,
    byte_tickets.stamp,
    byte_tickets.last_update,
    byte_tickets.balance,
    byte_tickets.delta,
    byte_tickets.coupon_id,
    byte_tickets.coupon,
    byte_tickets.refund,
    byte_tickets.receipt,
    byte_tickets.campus_id,
    byte_tickets.amount_list_price,
    byte_tickets.notes,
    byte_tickets.time_door_opened,
    byte_tickets.time_door_closed,
    byte_tickets.client_name,
    byte_tickets.estd_num_users,
    byte_tickets.ts,
    byte_tickets.full_name,
    byte_tickets.door_opened_secs,
    byte_tickets.month,
    byte_tickets.week,
    byte_tickets.date,
    byte_tickets.dayofweek,
    byte_tickets.hour,
    byte_tickets.dowhour,
    byte_tickets.uniq_user
   FROM public.byte_tickets
  WHERE ((byte_tickets.ts >= '2017-01-01 08:00:00+00'::timestamp with time zone) AND (byte_tickets.ts < '2018-01-01 08:00:00+00'::timestamp with time zone));


ALTER TABLE public.byte_tickets_2017 OWNER TO dbservice;

--
-- Name: byte_epcssold_2017; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_epcssold_2017 AS
 SELECT o.order_id,
    o.first_name,
    o.last_name,
    o.kiosk_id,
    o.kiosk_title,
    o.email,
    o.amount_paid,
    o.payment_system,
    o.transaction_id,
    o.approval_code,
    o.status_code,
    o.status_message,
    o.status,
    o.batch_id,
    o.created,
    o.auth_amount,
    o.data_token,
    o.time_opened,
    o.time_closed,
    o.card_hash,
    o.state,
    o.archived,
    o.stamp,
    o.last_update,
    o.balance,
    o.delta,
    o.coupon_id,
    o.coupon,
    o.refund,
    o.receipt,
    o.campus_id,
    o.amount_list_price,
    o.notes,
    o.time_door_opened,
    o.time_door_closed,
    o.client_name,
    o.estd_num_users,
    o.ts,
    o.full_name,
    o.door_opened_secs,
    o.month,
    o.week,
    o.date,
    o.dayofweek,
    o.hour,
    o.dowhour,
    o.uniq_user,
    lp.epc,
    lp.label_order_id,
    lp.label_status,
    lp.label_price,
    lp.time_created,
    lp.time_added,
    lp.time_updated,
    lp.ts_created,
    lp.ts_added,
    lp.ts_updated,
    lp.label_kiosk_id,
    lp.product_id,
    lp.product_title,
    lp.product_archived,
    lp.product_vendor,
    lp.product_price,
    lp.product_cost,
    lp.product_shelf_life_days,
    lp.product_attributes,
    lp.product_categories,
    lp.consumer_category,
    lp.product_source
   FROM (public.byte_tickets_2017 o
     JOIN public.byte_label_product lp ON (((lp.label_order_id)::text = (o.order_id)::text)))
  WHERE ((lp.label_status)::text = 'sold'::text);


ALTER TABLE public.byte_epcssold_2017 OWNER TO dbservice;

--
-- Name: byte_tickets_2days; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_tickets_2days AS
 SELECT byte_tickets.order_id,
    byte_tickets.first_name,
    byte_tickets.last_name,
    byte_tickets.kiosk_id,
    byte_tickets.kiosk_title,
    byte_tickets.email,
    byte_tickets.amount_paid,
    byte_tickets.payment_system,
    byte_tickets.transaction_id,
    byte_tickets.approval_code,
    byte_tickets.status_code,
    byte_tickets.status_message,
    byte_tickets.status,
    byte_tickets.batch_id,
    byte_tickets.created,
    byte_tickets.auth_amount,
    byte_tickets.data_token,
    byte_tickets.time_opened,
    byte_tickets.time_closed,
    byte_tickets.card_hash,
    byte_tickets.state,
    byte_tickets.archived,
    byte_tickets.stamp,
    byte_tickets.last_update,
    byte_tickets.balance,
    byte_tickets.delta,
    byte_tickets.coupon_id,
    byte_tickets.coupon,
    byte_tickets.refund,
    byte_tickets.receipt,
    byte_tickets.campus_id,
    byte_tickets.amount_list_price,
    byte_tickets.notes,
    byte_tickets.time_door_opened,
    byte_tickets.time_door_closed,
    byte_tickets.client_name,
    byte_tickets.estd_num_users,
    byte_tickets.ts,
    byte_tickets.full_name,
    byte_tickets.door_opened_secs,
    byte_tickets.month,
    byte_tickets.week,
    byte_tickets.date,
    byte_tickets.dayofweek,
    byte_tickets.hour,
    byte_tickets.dowhour,
    byte_tickets.uniq_user
   FROM public.byte_tickets
  WHERE (byte_tickets.ts > (now() - '2 days'::interval day));


ALTER TABLE public.byte_tickets_2days OWNER TO dbservice;

--
-- Name: byte_epcssold_2days; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_epcssold_2days AS
 SELECT o.order_id,
    o.first_name,
    o.last_name,
    o.kiosk_id,
    o.kiosk_title,
    o.email,
    o.amount_paid,
    o.payment_system,
    o.transaction_id,
    o.approval_code,
    o.status_code,
    o.status_message,
    o.status,
    o.batch_id,
    o.created,
    o.auth_amount,
    o.data_token,
    o.time_opened,
    o.time_closed,
    o.card_hash,
    o.state,
    o.archived,
    o.stamp,
    o.last_update,
    o.balance,
    o.delta,
    o.coupon_id,
    o.coupon,
    o.refund,
    o.receipt,
    o.campus_id,
    o.amount_list_price,
    o.notes,
    o.time_door_opened,
    o.time_door_closed,
    o.client_name,
    o.estd_num_users,
    o.ts,
    o.full_name,
    o.door_opened_secs,
    o.month,
    o.week,
    o.date,
    o.dayofweek,
    o.hour,
    o.dowhour,
    o.uniq_user,
    lp.epc,
    lp.label_order_id,
    lp.label_status,
    lp.label_price,
    lp.time_created,
    lp.time_added,
    lp.time_updated,
    lp.ts_created,
    lp.ts_added,
    lp.ts_updated,
    lp.label_kiosk_id,
    lp.product_id,
    lp.product_title,
    lp.product_archived,
    lp.product_vendor,
    lp.product_price,
    lp.product_cost,
    lp.product_shelf_life_days,
    lp.product_attributes,
    lp.product_categories,
    lp.consumer_category,
    lp.product_source
   FROM (public.byte_tickets_2days o
     JOIN public.byte_label_product lp ON (((lp.label_order_id)::text = (o.order_id)::text)))
  WHERE ((lp.label_status)::text = 'sold'::text);


ALTER TABLE public.byte_epcssold_2days OWNER TO dbservice;

--
-- Name: byte_tickets_2months; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_tickets_2months AS
 SELECT byte_tickets.order_id,
    byte_tickets.first_name,
    byte_tickets.last_name,
    byte_tickets.kiosk_id,
    byte_tickets.kiosk_title,
    byte_tickets.email,
    byte_tickets.amount_paid,
    byte_tickets.payment_system,
    byte_tickets.transaction_id,
    byte_tickets.approval_code,
    byte_tickets.status_code,
    byte_tickets.status_message,
    byte_tickets.status,
    byte_tickets.batch_id,
    byte_tickets.created,
    byte_tickets.auth_amount,
    byte_tickets.data_token,
    byte_tickets.time_opened,
    byte_tickets.time_closed,
    byte_tickets.card_hash,
    byte_tickets.state,
    byte_tickets.archived,
    byte_tickets.stamp,
    byte_tickets.last_update,
    byte_tickets.balance,
    byte_tickets.delta,
    byte_tickets.coupon_id,
    byte_tickets.coupon,
    byte_tickets.refund,
    byte_tickets.receipt,
    byte_tickets.campus_id,
    byte_tickets.amount_list_price,
    byte_tickets.notes,
    byte_tickets.time_door_opened,
    byte_tickets.time_door_closed,
    byte_tickets.client_name,
    byte_tickets.estd_num_users,
    byte_tickets.ts,
    byte_tickets.full_name,
    byte_tickets.door_opened_secs,
    byte_tickets.month,
    byte_tickets.week,
    byte_tickets.date,
    byte_tickets.dayofweek,
    byte_tickets.hour,
    byte_tickets.dowhour,
    byte_tickets.uniq_user
   FROM public.byte_tickets
  WHERE (byte_tickets.ts > (now() - '2 mons'::interval month));


ALTER TABLE public.byte_tickets_2months OWNER TO dbservice;

--
-- Name: byte_epcssold_2months; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_epcssold_2months AS
 SELECT o.order_id,
    o.first_name,
    o.last_name,
    o.kiosk_id,
    o.kiosk_title,
    o.email,
    o.amount_paid,
    o.payment_system,
    o.transaction_id,
    o.approval_code,
    o.status_code,
    o.status_message,
    o.status,
    o.batch_id,
    o.created,
    o.auth_amount,
    o.data_token,
    o.time_opened,
    o.time_closed,
    o.card_hash,
    o.state,
    o.archived,
    o.stamp,
    o.last_update,
    o.balance,
    o.delta,
    o.coupon_id,
    o.coupon,
    o.refund,
    o.receipt,
    o.campus_id,
    o.amount_list_price,
    o.notes,
    o.time_door_opened,
    o.time_door_closed,
    o.client_name,
    o.estd_num_users,
    o.ts,
    o.full_name,
    o.door_opened_secs,
    o.month,
    o.week,
    o.date,
    o.dayofweek,
    o.hour,
    o.dowhour,
    o.uniq_user,
    lp.epc,
    lp.label_order_id,
    lp.label_status,
    lp.label_price,
    lp.time_created,
    lp.time_added,
    lp.time_updated,
    lp.ts_created,
    lp.ts_added,
    lp.ts_updated,
    lp.label_kiosk_id,
    lp.product_id,
    lp.product_title,
    lp.product_archived,
    lp.product_vendor,
    lp.product_price,
    lp.product_cost,
    lp.product_shelf_life_days,
    lp.product_attributes,
    lp.product_categories,
    lp.consumer_category,
    lp.product_source
   FROM (public.byte_tickets_2months o
     JOIN public.byte_label_product lp ON (((lp.label_order_id)::text = (o.order_id)::text)))
  WHERE ((lp.label_status)::text = 'sold'::text);


ALTER TABLE public.byte_epcssold_2months OWNER TO dbservice;

--
-- Name: byte_tickets_2weeks; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_tickets_2weeks AS
 SELECT byte_tickets.order_id,
    byte_tickets.first_name,
    byte_tickets.last_name,
    byte_tickets.kiosk_id,
    byte_tickets.kiosk_title,
    byte_tickets.email,
    byte_tickets.amount_paid,
    byte_tickets.payment_system,
    byte_tickets.transaction_id,
    byte_tickets.approval_code,
    byte_tickets.status_code,
    byte_tickets.status_message,
    byte_tickets.status,
    byte_tickets.batch_id,
    byte_tickets.created,
    byte_tickets.auth_amount,
    byte_tickets.data_token,
    byte_tickets.time_opened,
    byte_tickets.time_closed,
    byte_tickets.card_hash,
    byte_tickets.state,
    byte_tickets.archived,
    byte_tickets.stamp,
    byte_tickets.last_update,
    byte_tickets.balance,
    byte_tickets.delta,
    byte_tickets.coupon_id,
    byte_tickets.coupon,
    byte_tickets.refund,
    byte_tickets.receipt,
    byte_tickets.campus_id,
    byte_tickets.amount_list_price,
    byte_tickets.notes,
    byte_tickets.time_door_opened,
    byte_tickets.time_door_closed,
    byte_tickets.client_name,
    byte_tickets.estd_num_users,
    byte_tickets.ts,
    byte_tickets.full_name,
    byte_tickets.door_opened_secs,
    byte_tickets.month,
    byte_tickets.week,
    byte_tickets.date,
    byte_tickets.dayofweek,
    byte_tickets.hour,
    byte_tickets.dowhour,
    byte_tickets.uniq_user
   FROM public.byte_tickets
  WHERE (byte_tickets.ts > (now() - '14 days'::interval day));


ALTER TABLE public.byte_tickets_2weeks OWNER TO dbservice;

--
-- Name: byte_epcssold_2weeks; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_epcssold_2weeks AS
 SELECT o.order_id,
    o.first_name,
    o.last_name,
    o.kiosk_id,
    o.kiosk_title,
    o.email,
    o.amount_paid,
    o.payment_system,
    o.transaction_id,
    o.approval_code,
    o.status_code,
    o.status_message,
    o.status,
    o.batch_id,
    o.created,
    o.auth_amount,
    o.data_token,
    o.time_opened,
    o.time_closed,
    o.card_hash,
    o.state,
    o.archived,
    o.stamp,
    o.last_update,
    o.balance,
    o.delta,
    o.coupon_id,
    o.coupon,
    o.refund,
    o.receipt,
    o.campus_id,
    o.amount_list_price,
    o.notes,
    o.time_door_opened,
    o.time_door_closed,
    o.client_name,
    o.estd_num_users,
    o.ts,
    o.full_name,
    o.door_opened_secs,
    o.month,
    o.week,
    o.date,
    o.dayofweek,
    o.hour,
    o.dowhour,
    o.uniq_user,
    lp.epc,
    lp.label_order_id,
    lp.label_status,
    lp.label_price,
    lp.time_created,
    lp.time_added,
    lp.time_updated,
    lp.ts_created,
    lp.ts_added,
    lp.ts_updated,
    lp.label_kiosk_id,
    lp.product_id,
    lp.product_title,
    lp.product_archived,
    lp.product_vendor,
    lp.product_price,
    lp.product_cost,
    lp.product_shelf_life_days,
    lp.product_attributes,
    lp.product_categories,
    lp.consumer_category,
    lp.product_source
   FROM (public.byte_tickets_2weeks o
     JOIN public.byte_label_product lp ON (((lp.label_order_id)::text = (o.order_id)::text)))
  WHERE ((lp.label_status)::text = 'sold'::text);


ALTER TABLE public.byte_epcssold_2weeks OWNER TO dbservice;

--
-- Name: byte_tickets_30days; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_tickets_30days AS
 SELECT byte_tickets.order_id,
    byte_tickets.first_name,
    byte_tickets.last_name,
    byte_tickets.kiosk_id,
    byte_tickets.kiosk_title,
    byte_tickets.email,
    byte_tickets.amount_paid,
    byte_tickets.payment_system,
    byte_tickets.transaction_id,
    byte_tickets.approval_code,
    byte_tickets.status_code,
    byte_tickets.status_message,
    byte_tickets.status,
    byte_tickets.batch_id,
    byte_tickets.created,
    byte_tickets.auth_amount,
    byte_tickets.data_token,
    byte_tickets.time_opened,
    byte_tickets.time_closed,
    byte_tickets.card_hash,
    byte_tickets.state,
    byte_tickets.archived,
    byte_tickets.stamp,
    byte_tickets.last_update,
    byte_tickets.balance,
    byte_tickets.delta,
    byte_tickets.coupon_id,
    byte_tickets.coupon,
    byte_tickets.refund,
    byte_tickets.receipt,
    byte_tickets.campus_id,
    byte_tickets.amount_list_price,
    byte_tickets.notes,
    byte_tickets.time_door_opened,
    byte_tickets.time_door_closed,
    byte_tickets.client_name,
    byte_tickets.estd_num_users,
    byte_tickets.ts,
    byte_tickets.full_name,
    byte_tickets.door_opened_secs,
    byte_tickets.month,
    byte_tickets.week,
    byte_tickets.date,
    byte_tickets.dayofweek,
    byte_tickets.hour,
    byte_tickets.dowhour,
    byte_tickets.uniq_user
   FROM public.byte_tickets
  WHERE (byte_tickets.ts > (now() - '30 days'::interval day));


ALTER TABLE public.byte_tickets_30days OWNER TO dbservice;

--
-- Name: byte_epcssold_30days; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_epcssold_30days AS
 SELECT o.order_id,
    o.first_name,
    o.last_name,
    o.kiosk_id,
    o.kiosk_title,
    o.email,
    o.amount_paid,
    o.payment_system,
    o.transaction_id,
    o.approval_code,
    o.status_code,
    o.status_message,
    o.status,
    o.batch_id,
    o.created,
    o.auth_amount,
    o.data_token,
    o.time_opened,
    o.time_closed,
    o.card_hash,
    o.state,
    o.archived,
    o.stamp,
    o.last_update,
    o.balance,
    o.delta,
    o.coupon_id,
    o.coupon,
    o.refund,
    o.receipt,
    o.campus_id,
    o.amount_list_price,
    o.notes,
    o.time_door_opened,
    o.time_door_closed,
    o.client_name,
    o.estd_num_users,
    o.ts,
    o.full_name,
    o.door_opened_secs,
    o.month,
    o.week,
    o.date,
    o.dayofweek,
    o.hour,
    o.dowhour,
    o.uniq_user,
    lp.epc,
    lp.label_order_id,
    lp.label_status,
    lp.label_price,
    lp.time_created,
    lp.time_added,
    lp.time_updated,
    lp.ts_created,
    lp.ts_added,
    lp.ts_updated,
    lp.label_kiosk_id,
    lp.product_id,
    lp.product_title,
    lp.product_archived,
    lp.product_vendor,
    lp.product_price,
    lp.product_cost,
    lp.product_shelf_life_days,
    lp.product_attributes,
    lp.product_categories,
    lp.consumer_category,
    lp.product_source
   FROM (public.byte_tickets_30days o
     JOIN public.byte_label_product lp ON (((lp.label_order_id)::text = (o.order_id)::text)))
  WHERE ((lp.label_status)::text = 'sold'::text);


ALTER TABLE public.byte_epcssold_30days OWNER TO dbservice;

--
-- Name: byte_tickets_360days; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_tickets_360days AS
 SELECT byte_tickets.order_id,
    byte_tickets.first_name,
    byte_tickets.last_name,
    byte_tickets.kiosk_id,
    byte_tickets.kiosk_title,
    byte_tickets.email,
    byte_tickets.amount_paid,
    byte_tickets.payment_system,
    byte_tickets.transaction_id,
    byte_tickets.approval_code,
    byte_tickets.status_code,
    byte_tickets.status_message,
    byte_tickets.status,
    byte_tickets.batch_id,
    byte_tickets.created,
    byte_tickets.auth_amount,
    byte_tickets.data_token,
    byte_tickets.time_opened,
    byte_tickets.time_closed,
    byte_tickets.card_hash,
    byte_tickets.state,
    byte_tickets.archived,
    byte_tickets.stamp,
    byte_tickets.last_update,
    byte_tickets.balance,
    byte_tickets.delta,
    byte_tickets.coupon_id,
    byte_tickets.coupon,
    byte_tickets.refund,
    byte_tickets.receipt,
    byte_tickets.campus_id,
    byte_tickets.amount_list_price,
    byte_tickets.notes,
    byte_tickets.time_door_opened,
    byte_tickets.time_door_closed,
    byte_tickets.client_name,
    byte_tickets.estd_num_users,
    byte_tickets.ts,
    byte_tickets.full_name,
    byte_tickets.door_opened_secs,
    byte_tickets.month,
    byte_tickets.week,
    byte_tickets.date,
    byte_tickets.dayofweek,
    byte_tickets.hour,
    byte_tickets.dowhour,
    byte_tickets.uniq_user
   FROM public.byte_tickets
  WHERE (byte_tickets.ts > (now() - '360 days'::interval day));


ALTER TABLE public.byte_tickets_360days OWNER TO dbservice;

--
-- Name: byte_epcssold_360days; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_epcssold_360days AS
 SELECT o.order_id,
    o.first_name,
    o.last_name,
    o.kiosk_id,
    o.kiosk_title,
    o.email,
    o.amount_paid,
    o.payment_system,
    o.transaction_id,
    o.approval_code,
    o.status_code,
    o.status_message,
    o.status,
    o.batch_id,
    o.created,
    o.auth_amount,
    o.data_token,
    o.time_opened,
    o.time_closed,
    o.card_hash,
    o.state,
    o.archived,
    o.stamp,
    o.last_update,
    o.balance,
    o.delta,
    o.coupon_id,
    o.coupon,
    o.refund,
    o.receipt,
    o.campus_id,
    o.amount_list_price,
    o.notes,
    o.time_door_opened,
    o.time_door_closed,
    o.client_name,
    o.estd_num_users,
    o.ts,
    o.full_name,
    o.door_opened_secs,
    o.month,
    o.week,
    o.date,
    o.dayofweek,
    o.hour,
    o.dowhour,
    o.uniq_user,
    lp.epc,
    lp.label_order_id,
    lp.label_status,
    lp.label_price,
    lp.time_created,
    lp.time_added,
    lp.time_updated,
    lp.ts_created,
    lp.ts_added,
    lp.ts_updated,
    lp.label_kiosk_id,
    lp.product_id,
    lp.product_title,
    lp.product_archived,
    lp.product_vendor,
    lp.product_price,
    lp.product_cost,
    lp.product_shelf_life_days,
    lp.product_attributes,
    lp.product_categories,
    lp.consumer_category,
    lp.product_source
   FROM (public.byte_tickets_360days o
     JOIN public.byte_label_product lp ON (((lp.label_order_id)::text = (o.order_id)::text)))
  WHERE ((lp.label_status)::text = 'sold'::text);


ALTER TABLE public.byte_epcssold_360days OWNER TO dbservice;

--
-- Name: byte_tickets_365days; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_tickets_365days AS
 SELECT byte_tickets.order_id,
    byte_tickets.first_name,
    byte_tickets.last_name,
    byte_tickets.kiosk_id,
    byte_tickets.kiosk_title,
    byte_tickets.email,
    byte_tickets.amount_paid,
    byte_tickets.payment_system,
    byte_tickets.transaction_id,
    byte_tickets.approval_code,
    byte_tickets.status_code,
    byte_tickets.status_message,
    byte_tickets.status,
    byte_tickets.batch_id,
    byte_tickets.created,
    byte_tickets.auth_amount,
    byte_tickets.data_token,
    byte_tickets.time_opened,
    byte_tickets.time_closed,
    byte_tickets.card_hash,
    byte_tickets.state,
    byte_tickets.archived,
    byte_tickets.stamp,
    byte_tickets.last_update,
    byte_tickets.balance,
    byte_tickets.delta,
    byte_tickets.coupon_id,
    byte_tickets.coupon,
    byte_tickets.refund,
    byte_tickets.receipt,
    byte_tickets.campus_id,
    byte_tickets.amount_list_price,
    byte_tickets.notes,
    byte_tickets.time_door_opened,
    byte_tickets.time_door_closed,
    byte_tickets.client_name,
    byte_tickets.estd_num_users,
    byte_tickets.ts,
    byte_tickets.full_name,
    byte_tickets.door_opened_secs,
    byte_tickets.month,
    byte_tickets.week,
    byte_tickets.date,
    byte_tickets.dayofweek,
    byte_tickets.hour,
    byte_tickets.dowhour,
    byte_tickets.uniq_user
   FROM public.byte_tickets
  WHERE (byte_tickets.ts > (now() - '365 days'::interval day));


ALTER TABLE public.byte_tickets_365days OWNER TO dbservice;

--
-- Name: byte_epcssold_365days; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_epcssold_365days AS
 SELECT o.order_id,
    o.first_name,
    o.last_name,
    o.kiosk_id,
    o.kiosk_title,
    o.email,
    o.amount_paid,
    o.payment_system,
    o.transaction_id,
    o.approval_code,
    o.status_code,
    o.status_message,
    o.status,
    o.batch_id,
    o.created,
    o.auth_amount,
    o.data_token,
    o.time_opened,
    o.time_closed,
    o.card_hash,
    o.state,
    o.archived,
    o.stamp,
    o.last_update,
    o.balance,
    o.delta,
    o.coupon_id,
    o.coupon,
    o.refund,
    o.receipt,
    o.campus_id,
    o.amount_list_price,
    o.notes,
    o.time_door_opened,
    o.time_door_closed,
    o.client_name,
    o.estd_num_users,
    o.ts,
    o.full_name,
    o.door_opened_secs,
    o.month,
    o.week,
    o.date,
    o.dayofweek,
    o.hour,
    o.dowhour,
    o.uniq_user,
    lp.epc,
    lp.label_order_id,
    lp.label_status,
    lp.label_price,
    lp.time_created,
    lp.time_added,
    lp.time_updated,
    lp.ts_created,
    lp.ts_added,
    lp.ts_updated,
    lp.label_kiosk_id,
    lp.product_id,
    lp.product_title,
    lp.product_archived,
    lp.product_vendor,
    lp.product_price,
    lp.product_cost,
    lp.product_shelf_life_days,
    lp.product_attributes,
    lp.product_categories,
    lp.consumer_category,
    lp.product_source
   FROM (public.byte_tickets_365days o
     JOIN public.byte_label_product lp ON (((lp.label_order_id)::text = (o.order_id)::text)))
  WHERE ((lp.label_status)::text = 'sold'::text);


ALTER TABLE public.byte_epcssold_365days OWNER TO dbservice;

--
-- Name: byte_tickets_3days; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_tickets_3days AS
 SELECT byte_tickets.order_id,
    byte_tickets.first_name,
    byte_tickets.last_name,
    byte_tickets.kiosk_id,
    byte_tickets.kiosk_title,
    byte_tickets.email,
    byte_tickets.amount_paid,
    byte_tickets.payment_system,
    byte_tickets.transaction_id,
    byte_tickets.approval_code,
    byte_tickets.status_code,
    byte_tickets.status_message,
    byte_tickets.status,
    byte_tickets.batch_id,
    byte_tickets.created,
    byte_tickets.auth_amount,
    byte_tickets.data_token,
    byte_tickets.time_opened,
    byte_tickets.time_closed,
    byte_tickets.card_hash,
    byte_tickets.state,
    byte_tickets.archived,
    byte_tickets.stamp,
    byte_tickets.last_update,
    byte_tickets.balance,
    byte_tickets.delta,
    byte_tickets.coupon_id,
    byte_tickets.coupon,
    byte_tickets.refund,
    byte_tickets.receipt,
    byte_tickets.campus_id,
    byte_tickets.amount_list_price,
    byte_tickets.notes,
    byte_tickets.time_door_opened,
    byte_tickets.time_door_closed,
    byte_tickets.client_name,
    byte_tickets.estd_num_users,
    byte_tickets.ts,
    byte_tickets.full_name,
    byte_tickets.door_opened_secs,
    byte_tickets.month,
    byte_tickets.week,
    byte_tickets.date,
    byte_tickets.dayofweek,
    byte_tickets.hour,
    byte_tickets.dowhour,
    byte_tickets.uniq_user
   FROM public.byte_tickets
  WHERE (byte_tickets.ts > (now() - '3 days'::interval day));


ALTER TABLE public.byte_tickets_3days OWNER TO dbservice;

--
-- Name: byte_epcssold_3days; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_epcssold_3days AS
 SELECT o.order_id,
    o.first_name,
    o.last_name,
    o.kiosk_id,
    o.kiosk_title,
    o.email,
    o.amount_paid,
    o.payment_system,
    o.transaction_id,
    o.approval_code,
    o.status_code,
    o.status_message,
    o.status,
    o.batch_id,
    o.created,
    o.auth_amount,
    o.data_token,
    o.time_opened,
    o.time_closed,
    o.card_hash,
    o.state,
    o.archived,
    o.stamp,
    o.last_update,
    o.balance,
    o.delta,
    o.coupon_id,
    o.coupon,
    o.refund,
    o.receipt,
    o.campus_id,
    o.amount_list_price,
    o.notes,
    o.time_door_opened,
    o.time_door_closed,
    o.client_name,
    o.estd_num_users,
    o.ts,
    o.full_name,
    o.door_opened_secs,
    o.month,
    o.week,
    o.date,
    o.dayofweek,
    o.hour,
    o.dowhour,
    o.uniq_user,
    lp.epc,
    lp.label_order_id,
    lp.label_status,
    lp.label_price,
    lp.time_created,
    lp.time_added,
    lp.time_updated,
    lp.ts_created,
    lp.ts_added,
    lp.ts_updated,
    lp.label_kiosk_id,
    lp.product_id,
    lp.product_title,
    lp.product_archived,
    lp.product_vendor,
    lp.product_price,
    lp.product_cost,
    lp.product_shelf_life_days,
    lp.product_attributes,
    lp.product_categories,
    lp.consumer_category,
    lp.product_source
   FROM (public.byte_tickets_3days o
     JOIN public.byte_label_product lp ON (((lp.label_order_id)::text = (o.order_id)::text)))
  WHERE ((lp.label_status)::text = 'sold'::text);


ALTER TABLE public.byte_epcssold_3days OWNER TO dbservice;

--
-- Name: byte_tickets_3weeks; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_tickets_3weeks AS
 SELECT byte_tickets.order_id,
    byte_tickets.first_name,
    byte_tickets.last_name,
    byte_tickets.kiosk_id,
    byte_tickets.kiosk_title,
    byte_tickets.email,
    byte_tickets.amount_paid,
    byte_tickets.payment_system,
    byte_tickets.transaction_id,
    byte_tickets.approval_code,
    byte_tickets.status_code,
    byte_tickets.status_message,
    byte_tickets.status,
    byte_tickets.batch_id,
    byte_tickets.created,
    byte_tickets.auth_amount,
    byte_tickets.data_token,
    byte_tickets.time_opened,
    byte_tickets.time_closed,
    byte_tickets.card_hash,
    byte_tickets.state,
    byte_tickets.archived,
    byte_tickets.stamp,
    byte_tickets.last_update,
    byte_tickets.balance,
    byte_tickets.delta,
    byte_tickets.coupon_id,
    byte_tickets.coupon,
    byte_tickets.refund,
    byte_tickets.receipt,
    byte_tickets.campus_id,
    byte_tickets.amount_list_price,
    byte_tickets.notes,
    byte_tickets.time_door_opened,
    byte_tickets.time_door_closed,
    byte_tickets.client_name,
    byte_tickets.estd_num_users,
    byte_tickets.ts,
    byte_tickets.full_name,
    byte_tickets.door_opened_secs,
    byte_tickets.month,
    byte_tickets.week,
    byte_tickets.date,
    byte_tickets.dayofweek,
    byte_tickets.hour,
    byte_tickets.dowhour,
    byte_tickets.uniq_user
   FROM public.byte_tickets
  WHERE (byte_tickets.ts > (now() - '21 days'::interval day));


ALTER TABLE public.byte_tickets_3weeks OWNER TO dbservice;

--
-- Name: byte_epcssold_3weeks; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_epcssold_3weeks AS
 SELECT o.order_id,
    o.first_name,
    o.last_name,
    o.kiosk_id,
    o.kiosk_title,
    o.email,
    o.amount_paid,
    o.payment_system,
    o.transaction_id,
    o.approval_code,
    o.status_code,
    o.status_message,
    o.status,
    o.batch_id,
    o.created,
    o.auth_amount,
    o.data_token,
    o.time_opened,
    o.time_closed,
    o.card_hash,
    o.state,
    o.archived,
    o.stamp,
    o.last_update,
    o.balance,
    o.delta,
    o.coupon_id,
    o.coupon,
    o.refund,
    o.receipt,
    o.campus_id,
    o.amount_list_price,
    o.notes,
    o.time_door_opened,
    o.time_door_closed,
    o.client_name,
    o.estd_num_users,
    o.ts,
    o.full_name,
    o.door_opened_secs,
    o.month,
    o.week,
    o.date,
    o.dayofweek,
    o.hour,
    o.dowhour,
    o.uniq_user,
    lp.epc,
    lp.label_order_id,
    lp.label_status,
    lp.label_price,
    lp.time_created,
    lp.time_added,
    lp.time_updated,
    lp.ts_created,
    lp.ts_added,
    lp.ts_updated,
    lp.label_kiosk_id,
    lp.product_id,
    lp.product_title,
    lp.product_archived,
    lp.product_vendor,
    lp.product_price,
    lp.product_cost,
    lp.product_shelf_life_days,
    lp.product_attributes,
    lp.product_categories,
    lp.consumer_category,
    lp.product_source
   FROM (public.byte_tickets_3weeks o
     JOIN public.byte_label_product lp ON (((lp.label_order_id)::text = (o.order_id)::text)))
  WHERE ((lp.label_status)::text = 'sold'::text);


ALTER TABLE public.byte_epcssold_3weeks OWNER TO dbservice;

--
-- Name: byte_tickets_45days; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_tickets_45days AS
 SELECT byte_tickets.order_id,
    byte_tickets.first_name,
    byte_tickets.last_name,
    byte_tickets.kiosk_id,
    byte_tickets.kiosk_title,
    byte_tickets.email,
    byte_tickets.amount_paid,
    byte_tickets.payment_system,
    byte_tickets.transaction_id,
    byte_tickets.approval_code,
    byte_tickets.status_code,
    byte_tickets.status_message,
    byte_tickets.status,
    byte_tickets.batch_id,
    byte_tickets.created,
    byte_tickets.auth_amount,
    byte_tickets.data_token,
    byte_tickets.time_opened,
    byte_tickets.time_closed,
    byte_tickets.card_hash,
    byte_tickets.state,
    byte_tickets.archived,
    byte_tickets.stamp,
    byte_tickets.last_update,
    byte_tickets.balance,
    byte_tickets.delta,
    byte_tickets.coupon_id,
    byte_tickets.coupon,
    byte_tickets.refund,
    byte_tickets.receipt,
    byte_tickets.campus_id,
    byte_tickets.amount_list_price,
    byte_tickets.notes,
    byte_tickets.time_door_opened,
    byte_tickets.time_door_closed,
    byte_tickets.client_name,
    byte_tickets.estd_num_users,
    byte_tickets.ts,
    byte_tickets.full_name,
    byte_tickets.door_opened_secs,
    byte_tickets.month,
    byte_tickets.week,
    byte_tickets.date,
    byte_tickets.dayofweek,
    byte_tickets.hour,
    byte_tickets.dowhour,
    byte_tickets.uniq_user
   FROM public.byte_tickets
  WHERE (byte_tickets.ts > (now() - '45 days'::interval day));


ALTER TABLE public.byte_tickets_45days OWNER TO dbservice;

--
-- Name: byte_epcssold_45days; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_epcssold_45days AS
 SELECT o.order_id,
    o.first_name,
    o.last_name,
    o.kiosk_id,
    o.kiosk_title,
    o.email,
    o.amount_paid,
    o.payment_system,
    o.transaction_id,
    o.approval_code,
    o.status_code,
    o.status_message,
    o.status,
    o.batch_id,
    o.created,
    o.auth_amount,
    o.data_token,
    o.time_opened,
    o.time_closed,
    o.card_hash,
    o.state,
    o.archived,
    o.stamp,
    o.last_update,
    o.balance,
    o.delta,
    o.coupon_id,
    o.coupon,
    o.refund,
    o.receipt,
    o.campus_id,
    o.amount_list_price,
    o.notes,
    o.time_door_opened,
    o.time_door_closed,
    o.client_name,
    o.estd_num_users,
    o.ts,
    o.full_name,
    o.door_opened_secs,
    o.month,
    o.week,
    o.date,
    o.dayofweek,
    o.hour,
    o.dowhour,
    o.uniq_user,
    lp.epc,
    lp.label_order_id,
    lp.label_status,
    lp.label_price,
    lp.time_created,
    lp.time_added,
    lp.time_updated,
    lp.ts_created,
    lp.ts_added,
    lp.ts_updated,
    lp.label_kiosk_id,
    lp.product_id,
    lp.product_title,
    lp.product_archived,
    lp.product_vendor,
    lp.product_price,
    lp.product_cost,
    lp.product_shelf_life_days,
    lp.product_attributes,
    lp.product_categories,
    lp.consumer_category,
    lp.product_source
   FROM (public.byte_tickets_45days o
     JOIN public.byte_label_product lp ON (((lp.label_order_id)::text = (o.order_id)::text)))
  WHERE ((lp.label_status)::text = 'sold'::text);


ALTER TABLE public.byte_epcssold_45days OWNER TO dbservice;

--
-- Name: byte_tickets_4days; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_tickets_4days AS
 SELECT byte_tickets.order_id,
    byte_tickets.first_name,
    byte_tickets.last_name,
    byte_tickets.kiosk_id,
    byte_tickets.kiosk_title,
    byte_tickets.email,
    byte_tickets.amount_paid,
    byte_tickets.payment_system,
    byte_tickets.transaction_id,
    byte_tickets.approval_code,
    byte_tickets.status_code,
    byte_tickets.status_message,
    byte_tickets.status,
    byte_tickets.batch_id,
    byte_tickets.created,
    byte_tickets.auth_amount,
    byte_tickets.data_token,
    byte_tickets.time_opened,
    byte_tickets.time_closed,
    byte_tickets.card_hash,
    byte_tickets.state,
    byte_tickets.archived,
    byte_tickets.stamp,
    byte_tickets.last_update,
    byte_tickets.balance,
    byte_tickets.delta,
    byte_tickets.coupon_id,
    byte_tickets.coupon,
    byte_tickets.refund,
    byte_tickets.receipt,
    byte_tickets.campus_id,
    byte_tickets.amount_list_price,
    byte_tickets.notes,
    byte_tickets.time_door_opened,
    byte_tickets.time_door_closed,
    byte_tickets.client_name,
    byte_tickets.estd_num_users,
    byte_tickets.ts,
    byte_tickets.full_name,
    byte_tickets.door_opened_secs,
    byte_tickets.month,
    byte_tickets.week,
    byte_tickets.date,
    byte_tickets.dayofweek,
    byte_tickets.hour,
    byte_tickets.dowhour,
    byte_tickets.uniq_user
   FROM public.byte_tickets
  WHERE (byte_tickets.ts > (now() - '4 days'::interval day));


ALTER TABLE public.byte_tickets_4days OWNER TO dbservice;

--
-- Name: byte_epcssold_4days; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_epcssold_4days AS
 SELECT o.order_id,
    o.first_name,
    o.last_name,
    o.kiosk_id,
    o.kiosk_title,
    o.email,
    o.amount_paid,
    o.payment_system,
    o.transaction_id,
    o.approval_code,
    o.status_code,
    o.status_message,
    o.status,
    o.batch_id,
    o.created,
    o.auth_amount,
    o.data_token,
    o.time_opened,
    o.time_closed,
    o.card_hash,
    o.state,
    o.archived,
    o.stamp,
    o.last_update,
    o.balance,
    o.delta,
    o.coupon_id,
    o.coupon,
    o.refund,
    o.receipt,
    o.campus_id,
    o.amount_list_price,
    o.notes,
    o.time_door_opened,
    o.time_door_closed,
    o.client_name,
    o.estd_num_users,
    o.ts,
    o.full_name,
    o.door_opened_secs,
    o.month,
    o.week,
    o.date,
    o.dayofweek,
    o.hour,
    o.dowhour,
    o.uniq_user,
    lp.epc,
    lp.label_order_id,
    lp.label_status,
    lp.label_price,
    lp.time_created,
    lp.time_added,
    lp.time_updated,
    lp.ts_created,
    lp.ts_added,
    lp.ts_updated,
    lp.label_kiosk_id,
    lp.product_id,
    lp.product_title,
    lp.product_archived,
    lp.product_vendor,
    lp.product_price,
    lp.product_cost,
    lp.product_shelf_life_days,
    lp.product_attributes,
    lp.product_categories,
    lp.consumer_category,
    lp.product_source
   FROM (public.byte_tickets_4days o
     JOIN public.byte_label_product lp ON (((lp.label_order_id)::text = (o.order_id)::text)))
  WHERE ((lp.label_status)::text = 'sold'::text);


ALTER TABLE public.byte_epcssold_4days OWNER TO dbservice;

--
-- Name: byte_tickets_4months; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_tickets_4months AS
 SELECT byte_tickets.order_id,
    byte_tickets.first_name,
    byte_tickets.last_name,
    byte_tickets.kiosk_id,
    byte_tickets.kiosk_title,
    byte_tickets.email,
    byte_tickets.amount_paid,
    byte_tickets.payment_system,
    byte_tickets.transaction_id,
    byte_tickets.approval_code,
    byte_tickets.status_code,
    byte_tickets.status_message,
    byte_tickets.status,
    byte_tickets.batch_id,
    byte_tickets.created,
    byte_tickets.auth_amount,
    byte_tickets.data_token,
    byte_tickets.time_opened,
    byte_tickets.time_closed,
    byte_tickets.card_hash,
    byte_tickets.state,
    byte_tickets.archived,
    byte_tickets.stamp,
    byte_tickets.last_update,
    byte_tickets.balance,
    byte_tickets.delta,
    byte_tickets.coupon_id,
    byte_tickets.coupon,
    byte_tickets.refund,
    byte_tickets.receipt,
    byte_tickets.campus_id,
    byte_tickets.amount_list_price,
    byte_tickets.notes,
    byte_tickets.time_door_opened,
    byte_tickets.time_door_closed,
    byte_tickets.client_name,
    byte_tickets.estd_num_users,
    byte_tickets.ts,
    byte_tickets.full_name,
    byte_tickets.door_opened_secs,
    byte_tickets.month,
    byte_tickets.week,
    byte_tickets.date,
    byte_tickets.dayofweek,
    byte_tickets.hour,
    byte_tickets.dowhour,
    byte_tickets.uniq_user
   FROM public.byte_tickets
  WHERE (byte_tickets.ts > (now() - '4 mons'::interval month));


ALTER TABLE public.byte_tickets_4months OWNER TO dbservice;

--
-- Name: byte_epcssold_4months; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_epcssold_4months AS
 SELECT o.order_id,
    o.first_name,
    o.last_name,
    o.kiosk_id,
    o.kiosk_title,
    o.email,
    o.amount_paid,
    o.payment_system,
    o.transaction_id,
    o.approval_code,
    o.status_code,
    o.status_message,
    o.status,
    o.batch_id,
    o.created,
    o.auth_amount,
    o.data_token,
    o.time_opened,
    o.time_closed,
    o.card_hash,
    o.state,
    o.archived,
    o.stamp,
    o.last_update,
    o.balance,
    o.delta,
    o.coupon_id,
    o.coupon,
    o.refund,
    o.receipt,
    o.campus_id,
    o.amount_list_price,
    o.notes,
    o.time_door_opened,
    o.time_door_closed,
    o.client_name,
    o.estd_num_users,
    o.ts,
    o.full_name,
    o.door_opened_secs,
    o.month,
    o.week,
    o.date,
    o.dayofweek,
    o.hour,
    o.dowhour,
    o.uniq_user,
    lp.epc,
    lp.label_order_id,
    lp.label_status,
    lp.label_price,
    lp.time_created,
    lp.time_added,
    lp.time_updated,
    lp.ts_created,
    lp.ts_added,
    lp.ts_updated,
    lp.label_kiosk_id,
    lp.product_id,
    lp.product_title,
    lp.product_archived,
    lp.product_vendor,
    lp.product_price,
    lp.product_cost,
    lp.product_shelf_life_days,
    lp.product_attributes,
    lp.product_categories,
    lp.consumer_category,
    lp.product_source
   FROM (public.byte_tickets_4months o
     JOIN public.byte_label_product lp ON (((lp.label_order_id)::text = (o.order_id)::text)))
  WHERE ((lp.label_status)::text = 'sold'::text);


ALTER TABLE public.byte_epcssold_4months OWNER TO dbservice;

--
-- Name: byte_tickets_4weeks; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_tickets_4weeks AS
 SELECT byte_tickets.order_id,
    byte_tickets.first_name,
    byte_tickets.last_name,
    byte_tickets.kiosk_id,
    byte_tickets.kiosk_title,
    byte_tickets.email,
    byte_tickets.amount_paid,
    byte_tickets.payment_system,
    byte_tickets.transaction_id,
    byte_tickets.approval_code,
    byte_tickets.status_code,
    byte_tickets.status_message,
    byte_tickets.status,
    byte_tickets.batch_id,
    byte_tickets.created,
    byte_tickets.auth_amount,
    byte_tickets.data_token,
    byte_tickets.time_opened,
    byte_tickets.time_closed,
    byte_tickets.card_hash,
    byte_tickets.state,
    byte_tickets.archived,
    byte_tickets.stamp,
    byte_tickets.last_update,
    byte_tickets.balance,
    byte_tickets.delta,
    byte_tickets.coupon_id,
    byte_tickets.coupon,
    byte_tickets.refund,
    byte_tickets.receipt,
    byte_tickets.campus_id,
    byte_tickets.amount_list_price,
    byte_tickets.notes,
    byte_tickets.time_door_opened,
    byte_tickets.time_door_closed,
    byte_tickets.client_name,
    byte_tickets.estd_num_users,
    byte_tickets.ts,
    byte_tickets.full_name,
    byte_tickets.door_opened_secs,
    byte_tickets.month,
    byte_tickets.week,
    byte_tickets.date,
    byte_tickets.dayofweek,
    byte_tickets.hour,
    byte_tickets.dowhour,
    byte_tickets.uniq_user
   FROM public.byte_tickets
  WHERE (byte_tickets.ts > (now() - '28 days'::interval day));


ALTER TABLE public.byte_tickets_4weeks OWNER TO dbservice;

--
-- Name: byte_epcssold_4weeks; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_epcssold_4weeks AS
 SELECT o.order_id,
    o.first_name,
    o.last_name,
    o.kiosk_id,
    o.kiosk_title,
    o.email,
    o.amount_paid,
    o.payment_system,
    o.transaction_id,
    o.approval_code,
    o.status_code,
    o.status_message,
    o.status,
    o.batch_id,
    o.created,
    o.auth_amount,
    o.data_token,
    o.time_opened,
    o.time_closed,
    o.card_hash,
    o.state,
    o.archived,
    o.stamp,
    o.last_update,
    o.balance,
    o.delta,
    o.coupon_id,
    o.coupon,
    o.refund,
    o.receipt,
    o.campus_id,
    o.amount_list_price,
    o.notes,
    o.time_door_opened,
    o.time_door_closed,
    o.client_name,
    o.estd_num_users,
    o.ts,
    o.full_name,
    o.door_opened_secs,
    o.month,
    o.week,
    o.date,
    o.dayofweek,
    o.hour,
    o.dowhour,
    o.uniq_user,
    lp.epc,
    lp.label_order_id,
    lp.label_status,
    lp.label_price,
    lp.time_created,
    lp.time_added,
    lp.time_updated,
    lp.ts_created,
    lp.ts_added,
    lp.ts_updated,
    lp.label_kiosk_id,
    lp.product_id,
    lp.product_title,
    lp.product_archived,
    lp.product_vendor,
    lp.product_price,
    lp.product_cost,
    lp.product_shelf_life_days,
    lp.product_attributes,
    lp.product_categories,
    lp.consumer_category,
    lp.product_source
   FROM (public.byte_tickets_4weeks o
     JOIN public.byte_label_product lp ON (((lp.label_order_id)::text = (o.order_id)::text)))
  WHERE ((lp.label_status)::text = 'sold'::text);


ALTER TABLE public.byte_epcssold_4weeks OWNER TO dbservice;

--
-- Name: byte_tickets_5days; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_tickets_5days AS
 SELECT byte_tickets.order_id,
    byte_tickets.first_name,
    byte_tickets.last_name,
    byte_tickets.kiosk_id,
    byte_tickets.kiosk_title,
    byte_tickets.email,
    byte_tickets.amount_paid,
    byte_tickets.payment_system,
    byte_tickets.transaction_id,
    byte_tickets.approval_code,
    byte_tickets.status_code,
    byte_tickets.status_message,
    byte_tickets.status,
    byte_tickets.batch_id,
    byte_tickets.created,
    byte_tickets.auth_amount,
    byte_tickets.data_token,
    byte_tickets.time_opened,
    byte_tickets.time_closed,
    byte_tickets.card_hash,
    byte_tickets.state,
    byte_tickets.archived,
    byte_tickets.stamp,
    byte_tickets.last_update,
    byte_tickets.balance,
    byte_tickets.delta,
    byte_tickets.coupon_id,
    byte_tickets.coupon,
    byte_tickets.refund,
    byte_tickets.receipt,
    byte_tickets.campus_id,
    byte_tickets.amount_list_price,
    byte_tickets.notes,
    byte_tickets.time_door_opened,
    byte_tickets.time_door_closed,
    byte_tickets.client_name,
    byte_tickets.estd_num_users,
    byte_tickets.ts,
    byte_tickets.full_name,
    byte_tickets.door_opened_secs,
    byte_tickets.month,
    byte_tickets.week,
    byte_tickets.date,
    byte_tickets.dayofweek,
    byte_tickets.hour,
    byte_tickets.dowhour,
    byte_tickets.uniq_user
   FROM public.byte_tickets
  WHERE (byte_tickets.ts > (now() - '5 days'::interval day));


ALTER TABLE public.byte_tickets_5days OWNER TO dbservice;

--
-- Name: byte_epcssold_5days; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_epcssold_5days AS
 SELECT o.order_id,
    o.first_name,
    o.last_name,
    o.kiosk_id,
    o.kiosk_title,
    o.email,
    o.amount_paid,
    o.payment_system,
    o.transaction_id,
    o.approval_code,
    o.status_code,
    o.status_message,
    o.status,
    o.batch_id,
    o.created,
    o.auth_amount,
    o.data_token,
    o.time_opened,
    o.time_closed,
    o.card_hash,
    o.state,
    o.archived,
    o.stamp,
    o.last_update,
    o.balance,
    o.delta,
    o.coupon_id,
    o.coupon,
    o.refund,
    o.receipt,
    o.campus_id,
    o.amount_list_price,
    o.notes,
    o.time_door_opened,
    o.time_door_closed,
    o.client_name,
    o.estd_num_users,
    o.ts,
    o.full_name,
    o.door_opened_secs,
    o.month,
    o.week,
    o.date,
    o.dayofweek,
    o.hour,
    o.dowhour,
    o.uniq_user,
    lp.epc,
    lp.label_order_id,
    lp.label_status,
    lp.label_price,
    lp.time_created,
    lp.time_added,
    lp.time_updated,
    lp.ts_created,
    lp.ts_added,
    lp.ts_updated,
    lp.label_kiosk_id,
    lp.product_id,
    lp.product_title,
    lp.product_archived,
    lp.product_vendor,
    lp.product_price,
    lp.product_cost,
    lp.product_shelf_life_days,
    lp.product_attributes,
    lp.product_categories,
    lp.consumer_category,
    lp.product_source
   FROM (public.byte_tickets_5days o
     JOIN public.byte_label_product lp ON (((lp.label_order_id)::text = (o.order_id)::text)))
  WHERE ((lp.label_status)::text = 'sold'::text);


ALTER TABLE public.byte_epcssold_5days OWNER TO dbservice;

--
-- Name: byte_tickets_5weeks; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_tickets_5weeks AS
 SELECT byte_tickets.order_id,
    byte_tickets.first_name,
    byte_tickets.last_name,
    byte_tickets.kiosk_id,
    byte_tickets.kiosk_title,
    byte_tickets.email,
    byte_tickets.amount_paid,
    byte_tickets.payment_system,
    byte_tickets.transaction_id,
    byte_tickets.approval_code,
    byte_tickets.status_code,
    byte_tickets.status_message,
    byte_tickets.status,
    byte_tickets.batch_id,
    byte_tickets.created,
    byte_tickets.auth_amount,
    byte_tickets.data_token,
    byte_tickets.time_opened,
    byte_tickets.time_closed,
    byte_tickets.card_hash,
    byte_tickets.state,
    byte_tickets.archived,
    byte_tickets.stamp,
    byte_tickets.last_update,
    byte_tickets.balance,
    byte_tickets.delta,
    byte_tickets.coupon_id,
    byte_tickets.coupon,
    byte_tickets.refund,
    byte_tickets.receipt,
    byte_tickets.campus_id,
    byte_tickets.amount_list_price,
    byte_tickets.notes,
    byte_tickets.time_door_opened,
    byte_tickets.time_door_closed,
    byte_tickets.client_name,
    byte_tickets.estd_num_users,
    byte_tickets.ts,
    byte_tickets.full_name,
    byte_tickets.door_opened_secs,
    byte_tickets.month,
    byte_tickets.week,
    byte_tickets.date,
    byte_tickets.dayofweek,
    byte_tickets.hour,
    byte_tickets.dowhour,
    byte_tickets.uniq_user
   FROM public.byte_tickets
  WHERE (byte_tickets.ts > (now() - '35 days'::interval day));


ALTER TABLE public.byte_tickets_5weeks OWNER TO dbservice;

--
-- Name: byte_epcssold_5weeks; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_epcssold_5weeks AS
 SELECT o.order_id,
    o.first_name,
    o.last_name,
    o.kiosk_id,
    o.kiosk_title,
    o.email,
    o.amount_paid,
    o.payment_system,
    o.transaction_id,
    o.approval_code,
    o.status_code,
    o.status_message,
    o.status,
    o.batch_id,
    o.created,
    o.auth_amount,
    o.data_token,
    o.time_opened,
    o.time_closed,
    o.card_hash,
    o.state,
    o.archived,
    o.stamp,
    o.last_update,
    o.balance,
    o.delta,
    o.coupon_id,
    o.coupon,
    o.refund,
    o.receipt,
    o.campus_id,
    o.amount_list_price,
    o.notes,
    o.time_door_opened,
    o.time_door_closed,
    o.client_name,
    o.estd_num_users,
    o.ts,
    o.full_name,
    o.door_opened_secs,
    o.month,
    o.week,
    o.date,
    o.dayofweek,
    o.hour,
    o.dowhour,
    o.uniq_user,
    lp.epc,
    lp.label_order_id,
    lp.label_status,
    lp.label_price,
    lp.time_created,
    lp.time_added,
    lp.time_updated,
    lp.ts_created,
    lp.ts_added,
    lp.ts_updated,
    lp.label_kiosk_id,
    lp.product_id,
    lp.product_title,
    lp.product_archived,
    lp.product_vendor,
    lp.product_price,
    lp.product_cost,
    lp.product_shelf_life_days,
    lp.product_attributes,
    lp.product_categories,
    lp.consumer_category,
    lp.product_source
   FROM (public.byte_tickets_5weeks o
     JOIN public.byte_label_product lp ON (((lp.label_order_id)::text = (o.order_id)::text)))
  WHERE ((lp.label_status)::text = 'sold'::text);


ALTER TABLE public.byte_epcssold_5weeks OWNER TO dbservice;

--
-- Name: byte_tickets_60days; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_tickets_60days AS
 SELECT byte_tickets.order_id,
    byte_tickets.first_name,
    byte_tickets.last_name,
    byte_tickets.kiosk_id,
    byte_tickets.kiosk_title,
    byte_tickets.email,
    byte_tickets.amount_paid,
    byte_tickets.payment_system,
    byte_tickets.transaction_id,
    byte_tickets.approval_code,
    byte_tickets.status_code,
    byte_tickets.status_message,
    byte_tickets.status,
    byte_tickets.batch_id,
    byte_tickets.created,
    byte_tickets.auth_amount,
    byte_tickets.data_token,
    byte_tickets.time_opened,
    byte_tickets.time_closed,
    byte_tickets.card_hash,
    byte_tickets.state,
    byte_tickets.archived,
    byte_tickets.stamp,
    byte_tickets.last_update,
    byte_tickets.balance,
    byte_tickets.delta,
    byte_tickets.coupon_id,
    byte_tickets.coupon,
    byte_tickets.refund,
    byte_tickets.receipt,
    byte_tickets.campus_id,
    byte_tickets.amount_list_price,
    byte_tickets.notes,
    byte_tickets.time_door_opened,
    byte_tickets.time_door_closed,
    byte_tickets.client_name,
    byte_tickets.estd_num_users,
    byte_tickets.ts,
    byte_tickets.full_name,
    byte_tickets.door_opened_secs,
    byte_tickets.month,
    byte_tickets.week,
    byte_tickets.date,
    byte_tickets.dayofweek,
    byte_tickets.hour,
    byte_tickets.dowhour,
    byte_tickets.uniq_user
   FROM public.byte_tickets
  WHERE (byte_tickets.ts > (now() - '60 days'::interval day));


ALTER TABLE public.byte_tickets_60days OWNER TO dbservice;

--
-- Name: byte_epcssold_60days; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_epcssold_60days AS
 SELECT o.order_id,
    o.first_name,
    o.last_name,
    o.kiosk_id,
    o.kiosk_title,
    o.email,
    o.amount_paid,
    o.payment_system,
    o.transaction_id,
    o.approval_code,
    o.status_code,
    o.status_message,
    o.status,
    o.batch_id,
    o.created,
    o.auth_amount,
    o.data_token,
    o.time_opened,
    o.time_closed,
    o.card_hash,
    o.state,
    o.archived,
    o.stamp,
    o.last_update,
    o.balance,
    o.delta,
    o.coupon_id,
    o.coupon,
    o.refund,
    o.receipt,
    o.campus_id,
    o.amount_list_price,
    o.notes,
    o.time_door_opened,
    o.time_door_closed,
    o.client_name,
    o.estd_num_users,
    o.ts,
    o.full_name,
    o.door_opened_secs,
    o.month,
    o.week,
    o.date,
    o.dayofweek,
    o.hour,
    o.dowhour,
    o.uniq_user,
    lp.epc,
    lp.label_order_id,
    lp.label_status,
    lp.label_price,
    lp.time_created,
    lp.time_added,
    lp.time_updated,
    lp.ts_created,
    lp.ts_added,
    lp.ts_updated,
    lp.label_kiosk_id,
    lp.product_id,
    lp.product_title,
    lp.product_archived,
    lp.product_vendor,
    lp.product_price,
    lp.product_cost,
    lp.product_shelf_life_days,
    lp.product_attributes,
    lp.product_categories,
    lp.consumer_category,
    lp.product_source
   FROM (public.byte_tickets_60days o
     JOIN public.byte_label_product lp ON (((lp.label_order_id)::text = (o.order_id)::text)))
  WHERE ((lp.label_status)::text = 'sold'::text);


ALTER TABLE public.byte_epcssold_60days OWNER TO dbservice;

--
-- Name: byte_tickets_6days; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_tickets_6days AS
 SELECT byte_tickets.order_id,
    byte_tickets.first_name,
    byte_tickets.last_name,
    byte_tickets.kiosk_id,
    byte_tickets.kiosk_title,
    byte_tickets.email,
    byte_tickets.amount_paid,
    byte_tickets.payment_system,
    byte_tickets.transaction_id,
    byte_tickets.approval_code,
    byte_tickets.status_code,
    byte_tickets.status_message,
    byte_tickets.status,
    byte_tickets.batch_id,
    byte_tickets.created,
    byte_tickets.auth_amount,
    byte_tickets.data_token,
    byte_tickets.time_opened,
    byte_tickets.time_closed,
    byte_tickets.card_hash,
    byte_tickets.state,
    byte_tickets.archived,
    byte_tickets.stamp,
    byte_tickets.last_update,
    byte_tickets.balance,
    byte_tickets.delta,
    byte_tickets.coupon_id,
    byte_tickets.coupon,
    byte_tickets.refund,
    byte_tickets.receipt,
    byte_tickets.campus_id,
    byte_tickets.amount_list_price,
    byte_tickets.notes,
    byte_tickets.time_door_opened,
    byte_tickets.time_door_closed,
    byte_tickets.client_name,
    byte_tickets.estd_num_users,
    byte_tickets.ts,
    byte_tickets.full_name,
    byte_tickets.door_opened_secs,
    byte_tickets.month,
    byte_tickets.week,
    byte_tickets.date,
    byte_tickets.dayofweek,
    byte_tickets.hour,
    byte_tickets.dowhour,
    byte_tickets.uniq_user
   FROM public.byte_tickets
  WHERE (byte_tickets.ts > (now() - '6 days'::interval day));


ALTER TABLE public.byte_tickets_6days OWNER TO dbservice;

--
-- Name: byte_epcssold_6days; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_epcssold_6days AS
 SELECT o.order_id,
    o.first_name,
    o.last_name,
    o.kiosk_id,
    o.kiosk_title,
    o.email,
    o.amount_paid,
    o.payment_system,
    o.transaction_id,
    o.approval_code,
    o.status_code,
    o.status_message,
    o.status,
    o.batch_id,
    o.created,
    o.auth_amount,
    o.data_token,
    o.time_opened,
    o.time_closed,
    o.card_hash,
    o.state,
    o.archived,
    o.stamp,
    o.last_update,
    o.balance,
    o.delta,
    o.coupon_id,
    o.coupon,
    o.refund,
    o.receipt,
    o.campus_id,
    o.amount_list_price,
    o.notes,
    o.time_door_opened,
    o.time_door_closed,
    o.client_name,
    o.estd_num_users,
    o.ts,
    o.full_name,
    o.door_opened_secs,
    o.month,
    o.week,
    o.date,
    o.dayofweek,
    o.hour,
    o.dowhour,
    o.uniq_user,
    lp.epc,
    lp.label_order_id,
    lp.label_status,
    lp.label_price,
    lp.time_created,
    lp.time_added,
    lp.time_updated,
    lp.ts_created,
    lp.ts_added,
    lp.ts_updated,
    lp.label_kiosk_id,
    lp.product_id,
    lp.product_title,
    lp.product_archived,
    lp.product_vendor,
    lp.product_price,
    lp.product_cost,
    lp.product_shelf_life_days,
    lp.product_attributes,
    lp.product_categories,
    lp.consumer_category,
    lp.product_source
   FROM (public.byte_tickets_6days o
     JOIN public.byte_label_product lp ON (((lp.label_order_id)::text = (o.order_id)::text)))
  WHERE ((lp.label_status)::text = 'sold'::text);


ALTER TABLE public.byte_epcssold_6days OWNER TO dbservice;

--
-- Name: byte_tickets_6months; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_tickets_6months AS
 SELECT byte_tickets.order_id,
    byte_tickets.first_name,
    byte_tickets.last_name,
    byte_tickets.kiosk_id,
    byte_tickets.kiosk_title,
    byte_tickets.email,
    byte_tickets.amount_paid,
    byte_tickets.payment_system,
    byte_tickets.transaction_id,
    byte_tickets.approval_code,
    byte_tickets.status_code,
    byte_tickets.status_message,
    byte_tickets.status,
    byte_tickets.batch_id,
    byte_tickets.created,
    byte_tickets.auth_amount,
    byte_tickets.data_token,
    byte_tickets.time_opened,
    byte_tickets.time_closed,
    byte_tickets.card_hash,
    byte_tickets.state,
    byte_tickets.archived,
    byte_tickets.stamp,
    byte_tickets.last_update,
    byte_tickets.balance,
    byte_tickets.delta,
    byte_tickets.coupon_id,
    byte_tickets.coupon,
    byte_tickets.refund,
    byte_tickets.receipt,
    byte_tickets.campus_id,
    byte_tickets.amount_list_price,
    byte_tickets.notes,
    byte_tickets.time_door_opened,
    byte_tickets.time_door_closed,
    byte_tickets.client_name,
    byte_tickets.estd_num_users,
    byte_tickets.ts,
    byte_tickets.full_name,
    byte_tickets.door_opened_secs,
    byte_tickets.month,
    byte_tickets.week,
    byte_tickets.date,
    byte_tickets.dayofweek,
    byte_tickets.hour,
    byte_tickets.dowhour,
    byte_tickets.uniq_user
   FROM public.byte_tickets
  WHERE (byte_tickets.ts > (now() - '6 mons'::interval month));


ALTER TABLE public.byte_tickets_6months OWNER TO dbservice;

--
-- Name: byte_epcssold_6months; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_epcssold_6months AS
 SELECT o.order_id,
    o.first_name,
    o.last_name,
    o.kiosk_id,
    o.kiosk_title,
    o.email,
    o.amount_paid,
    o.payment_system,
    o.transaction_id,
    o.approval_code,
    o.status_code,
    o.status_message,
    o.status,
    o.batch_id,
    o.created,
    o.auth_amount,
    o.data_token,
    o.time_opened,
    o.time_closed,
    o.card_hash,
    o.state,
    o.archived,
    o.stamp,
    o.last_update,
    o.balance,
    o.delta,
    o.coupon_id,
    o.coupon,
    o.refund,
    o.receipt,
    o.campus_id,
    o.amount_list_price,
    o.notes,
    o.time_door_opened,
    o.time_door_closed,
    o.client_name,
    o.estd_num_users,
    o.ts,
    o.full_name,
    o.door_opened_secs,
    o.month,
    o.week,
    o.date,
    o.dayofweek,
    o.hour,
    o.dowhour,
    o.uniq_user,
    lp.epc,
    lp.label_order_id,
    lp.label_status,
    lp.label_price,
    lp.time_created,
    lp.time_added,
    lp.time_updated,
    lp.ts_created,
    lp.ts_added,
    lp.ts_updated,
    lp.label_kiosk_id,
    lp.product_id,
    lp.product_title,
    lp.product_archived,
    lp.product_vendor,
    lp.product_price,
    lp.product_cost,
    lp.product_shelf_life_days,
    lp.product_attributes,
    lp.product_categories,
    lp.consumer_category,
    lp.product_source
   FROM (public.byte_tickets_6months o
     JOIN public.byte_label_product lp ON (((lp.label_order_id)::text = (o.order_id)::text)))
  WHERE ((lp.label_status)::text = 'sold'::text);


ALTER TABLE public.byte_epcssold_6months OWNER TO dbservice;

--
-- Name: byte_tickets_6weeks; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_tickets_6weeks AS
 SELECT byte_tickets.order_id,
    byte_tickets.first_name,
    byte_tickets.last_name,
    byte_tickets.kiosk_id,
    byte_tickets.kiosk_title,
    byte_tickets.email,
    byte_tickets.amount_paid,
    byte_tickets.payment_system,
    byte_tickets.transaction_id,
    byte_tickets.approval_code,
    byte_tickets.status_code,
    byte_tickets.status_message,
    byte_tickets.status,
    byte_tickets.batch_id,
    byte_tickets.created,
    byte_tickets.auth_amount,
    byte_tickets.data_token,
    byte_tickets.time_opened,
    byte_tickets.time_closed,
    byte_tickets.card_hash,
    byte_tickets.state,
    byte_tickets.archived,
    byte_tickets.stamp,
    byte_tickets.last_update,
    byte_tickets.balance,
    byte_tickets.delta,
    byte_tickets.coupon_id,
    byte_tickets.coupon,
    byte_tickets.refund,
    byte_tickets.receipt,
    byte_tickets.campus_id,
    byte_tickets.amount_list_price,
    byte_tickets.notes,
    byte_tickets.time_door_opened,
    byte_tickets.time_door_closed,
    byte_tickets.client_name,
    byte_tickets.estd_num_users,
    byte_tickets.ts,
    byte_tickets.full_name,
    byte_tickets.door_opened_secs,
    byte_tickets.month,
    byte_tickets.week,
    byte_tickets.date,
    byte_tickets.dayofweek,
    byte_tickets.hour,
    byte_tickets.dowhour,
    byte_tickets.uniq_user
   FROM public.byte_tickets
  WHERE (byte_tickets.ts > (now() - '42 days'::interval day));


ALTER TABLE public.byte_tickets_6weeks OWNER TO dbservice;

--
-- Name: byte_epcssold_6weeks; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_epcssold_6weeks AS
 SELECT o.order_id,
    o.first_name,
    o.last_name,
    o.kiosk_id,
    o.kiosk_title,
    o.email,
    o.amount_paid,
    o.payment_system,
    o.transaction_id,
    o.approval_code,
    o.status_code,
    o.status_message,
    o.status,
    o.batch_id,
    o.created,
    o.auth_amount,
    o.data_token,
    o.time_opened,
    o.time_closed,
    o.card_hash,
    o.state,
    o.archived,
    o.stamp,
    o.last_update,
    o.balance,
    o.delta,
    o.coupon_id,
    o.coupon,
    o.refund,
    o.receipt,
    o.campus_id,
    o.amount_list_price,
    o.notes,
    o.time_door_opened,
    o.time_door_closed,
    o.client_name,
    o.estd_num_users,
    o.ts,
    o.full_name,
    o.door_opened_secs,
    o.month,
    o.week,
    o.date,
    o.dayofweek,
    o.hour,
    o.dowhour,
    o.uniq_user,
    lp.epc,
    lp.label_order_id,
    lp.label_status,
    lp.label_price,
    lp.time_created,
    lp.time_added,
    lp.time_updated,
    lp.ts_created,
    lp.ts_added,
    lp.ts_updated,
    lp.label_kiosk_id,
    lp.product_id,
    lp.product_title,
    lp.product_archived,
    lp.product_vendor,
    lp.product_price,
    lp.product_cost,
    lp.product_shelf_life_days,
    lp.product_attributes,
    lp.product_categories,
    lp.consumer_category,
    lp.product_source
   FROM (public.byte_tickets_6weeks o
     JOIN public.byte_label_product lp ON (((lp.label_order_id)::text = (o.order_id)::text)))
  WHERE ((lp.label_status)::text = 'sold'::text);


ALTER TABLE public.byte_epcssold_6weeks OWNER TO dbservice;

--
-- Name: byte_tickets_7days; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_tickets_7days AS
 SELECT byte_tickets.order_id,
    byte_tickets.first_name,
    byte_tickets.last_name,
    byte_tickets.kiosk_id,
    byte_tickets.kiosk_title,
    byte_tickets.email,
    byte_tickets.amount_paid,
    byte_tickets.payment_system,
    byte_tickets.transaction_id,
    byte_tickets.approval_code,
    byte_tickets.status_code,
    byte_tickets.status_message,
    byte_tickets.status,
    byte_tickets.batch_id,
    byte_tickets.created,
    byte_tickets.auth_amount,
    byte_tickets.data_token,
    byte_tickets.time_opened,
    byte_tickets.time_closed,
    byte_tickets.card_hash,
    byte_tickets.state,
    byte_tickets.archived,
    byte_tickets.stamp,
    byte_tickets.last_update,
    byte_tickets.balance,
    byte_tickets.delta,
    byte_tickets.coupon_id,
    byte_tickets.coupon,
    byte_tickets.refund,
    byte_tickets.receipt,
    byte_tickets.campus_id,
    byte_tickets.amount_list_price,
    byte_tickets.notes,
    byte_tickets.time_door_opened,
    byte_tickets.time_door_closed,
    byte_tickets.client_name,
    byte_tickets.estd_num_users,
    byte_tickets.ts,
    byte_tickets.full_name,
    byte_tickets.door_opened_secs,
    byte_tickets.month,
    byte_tickets.week,
    byte_tickets.date,
    byte_tickets.dayofweek,
    byte_tickets.hour,
    byte_tickets.dowhour,
    byte_tickets.uniq_user
   FROM public.byte_tickets
  WHERE (byte_tickets.ts > (now() - '7 days'::interval day));


ALTER TABLE public.byte_tickets_7days OWNER TO dbservice;

--
-- Name: byte_epcssold_7days; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_epcssold_7days AS
 SELECT o.order_id,
    o.first_name,
    o.last_name,
    o.kiosk_id,
    o.kiosk_title,
    o.email,
    o.amount_paid,
    o.payment_system,
    o.transaction_id,
    o.approval_code,
    o.status_code,
    o.status_message,
    o.status,
    o.batch_id,
    o.created,
    o.auth_amount,
    o.data_token,
    o.time_opened,
    o.time_closed,
    o.card_hash,
    o.state,
    o.archived,
    o.stamp,
    o.last_update,
    o.balance,
    o.delta,
    o.coupon_id,
    o.coupon,
    o.refund,
    o.receipt,
    o.campus_id,
    o.amount_list_price,
    o.notes,
    o.time_door_opened,
    o.time_door_closed,
    o.client_name,
    o.estd_num_users,
    o.ts,
    o.full_name,
    o.door_opened_secs,
    o.month,
    o.week,
    o.date,
    o.dayofweek,
    o.hour,
    o.dowhour,
    o.uniq_user,
    lp.epc,
    lp.label_order_id,
    lp.label_status,
    lp.label_price,
    lp.time_created,
    lp.time_added,
    lp.time_updated,
    lp.ts_created,
    lp.ts_added,
    lp.ts_updated,
    lp.label_kiosk_id,
    lp.product_id,
    lp.product_title,
    lp.product_archived,
    lp.product_vendor,
    lp.product_price,
    lp.product_cost,
    lp.product_shelf_life_days,
    lp.product_attributes,
    lp.product_categories,
    lp.consumer_category,
    lp.product_source
   FROM (public.byte_tickets_7days o
     JOIN public.byte_label_product lp ON (((lp.label_order_id)::text = (o.order_id)::text)))
  WHERE ((lp.label_status)::text = 'sold'::text);


ALTER TABLE public.byte_epcssold_7days OWNER TO dbservice;

--
-- Name: byte_tickets_8weeks; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_tickets_8weeks AS
 SELECT byte_tickets.order_id,
    byte_tickets.first_name,
    byte_tickets.last_name,
    byte_tickets.kiosk_id,
    byte_tickets.kiosk_title,
    byte_tickets.email,
    byte_tickets.amount_paid,
    byte_tickets.payment_system,
    byte_tickets.transaction_id,
    byte_tickets.approval_code,
    byte_tickets.status_code,
    byte_tickets.status_message,
    byte_tickets.status,
    byte_tickets.batch_id,
    byte_tickets.created,
    byte_tickets.auth_amount,
    byte_tickets.data_token,
    byte_tickets.time_opened,
    byte_tickets.time_closed,
    byte_tickets.card_hash,
    byte_tickets.state,
    byte_tickets.archived,
    byte_tickets.stamp,
    byte_tickets.last_update,
    byte_tickets.balance,
    byte_tickets.delta,
    byte_tickets.coupon_id,
    byte_tickets.coupon,
    byte_tickets.refund,
    byte_tickets.receipt,
    byte_tickets.campus_id,
    byte_tickets.amount_list_price,
    byte_tickets.notes,
    byte_tickets.time_door_opened,
    byte_tickets.time_door_closed,
    byte_tickets.client_name,
    byte_tickets.estd_num_users,
    byte_tickets.ts,
    byte_tickets.full_name,
    byte_tickets.door_opened_secs,
    byte_tickets.month,
    byte_tickets.week,
    byte_tickets.date,
    byte_tickets.dayofweek,
    byte_tickets.hour,
    byte_tickets.dowhour,
    byte_tickets.uniq_user
   FROM public.byte_tickets
  WHERE (byte_tickets.ts > (now() - '56 days'::interval day));


ALTER TABLE public.byte_tickets_8weeks OWNER TO dbservice;

--
-- Name: byte_epcssold_8weeks; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_epcssold_8weeks AS
 SELECT o.order_id,
    o.first_name,
    o.last_name,
    o.kiosk_id,
    o.kiosk_title,
    o.email,
    o.amount_paid,
    o.payment_system,
    o.transaction_id,
    o.approval_code,
    o.status_code,
    o.status_message,
    o.status,
    o.batch_id,
    o.created,
    o.auth_amount,
    o.data_token,
    o.time_opened,
    o.time_closed,
    o.card_hash,
    o.state,
    o.archived,
    o.stamp,
    o.last_update,
    o.balance,
    o.delta,
    o.coupon_id,
    o.coupon,
    o.refund,
    o.receipt,
    o.campus_id,
    o.amount_list_price,
    o.notes,
    o.time_door_opened,
    o.time_door_closed,
    o.client_name,
    o.estd_num_users,
    o.ts,
    o.full_name,
    o.door_opened_secs,
    o.month,
    o.week,
    o.date,
    o.dayofweek,
    o.hour,
    o.dowhour,
    o.uniq_user,
    lp.epc,
    lp.label_order_id,
    lp.label_status,
    lp.label_price,
    lp.time_created,
    lp.time_added,
    lp.time_updated,
    lp.ts_created,
    lp.ts_added,
    lp.ts_updated,
    lp.label_kiosk_id,
    lp.product_id,
    lp.product_title,
    lp.product_archived,
    lp.product_vendor,
    lp.product_price,
    lp.product_cost,
    lp.product_shelf_life_days,
    lp.product_attributes,
    lp.product_categories,
    lp.consumer_category,
    lp.product_source
   FROM (public.byte_tickets_8weeks o
     JOIN public.byte_label_product lp ON (((lp.label_order_id)::text = (o.order_id)::text)))
  WHERE ((lp.label_status)::text = 'sold'::text);


ALTER TABLE public.byte_epcssold_8weeks OWNER TO dbservice;

--
-- Name: byte_tickets_90days; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_tickets_90days AS
 SELECT byte_tickets.order_id,
    byte_tickets.first_name,
    byte_tickets.last_name,
    byte_tickets.kiosk_id,
    byte_tickets.kiosk_title,
    byte_tickets.email,
    byte_tickets.amount_paid,
    byte_tickets.payment_system,
    byte_tickets.transaction_id,
    byte_tickets.approval_code,
    byte_tickets.status_code,
    byte_tickets.status_message,
    byte_tickets.status,
    byte_tickets.batch_id,
    byte_tickets.created,
    byte_tickets.auth_amount,
    byte_tickets.data_token,
    byte_tickets.time_opened,
    byte_tickets.time_closed,
    byte_tickets.card_hash,
    byte_tickets.state,
    byte_tickets.archived,
    byte_tickets.stamp,
    byte_tickets.last_update,
    byte_tickets.balance,
    byte_tickets.delta,
    byte_tickets.coupon_id,
    byte_tickets.coupon,
    byte_tickets.refund,
    byte_tickets.receipt,
    byte_tickets.campus_id,
    byte_tickets.amount_list_price,
    byte_tickets.notes,
    byte_tickets.time_door_opened,
    byte_tickets.time_door_closed,
    byte_tickets.client_name,
    byte_tickets.estd_num_users,
    byte_tickets.ts,
    byte_tickets.full_name,
    byte_tickets.door_opened_secs,
    byte_tickets.month,
    byte_tickets.week,
    byte_tickets.date,
    byte_tickets.dayofweek,
    byte_tickets.hour,
    byte_tickets.dowhour,
    byte_tickets.uniq_user
   FROM public.byte_tickets
  WHERE (byte_tickets.ts > (now() - '90 days'::interval day));


ALTER TABLE public.byte_tickets_90days OWNER TO dbservice;

--
-- Name: byte_epcssold_90days; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_epcssold_90days AS
 SELECT o.order_id,
    o.first_name,
    o.last_name,
    o.kiosk_id,
    o.kiosk_title,
    o.email,
    o.amount_paid,
    o.payment_system,
    o.transaction_id,
    o.approval_code,
    o.status_code,
    o.status_message,
    o.status,
    o.batch_id,
    o.created,
    o.auth_amount,
    o.data_token,
    o.time_opened,
    o.time_closed,
    o.card_hash,
    o.state,
    o.archived,
    o.stamp,
    o.last_update,
    o.balance,
    o.delta,
    o.coupon_id,
    o.coupon,
    o.refund,
    o.receipt,
    o.campus_id,
    o.amount_list_price,
    o.notes,
    o.time_door_opened,
    o.time_door_closed,
    o.client_name,
    o.estd_num_users,
    o.ts,
    o.full_name,
    o.door_opened_secs,
    o.month,
    o.week,
    o.date,
    o.dayofweek,
    o.hour,
    o.dowhour,
    o.uniq_user,
    lp.epc,
    lp.label_order_id,
    lp.label_status,
    lp.label_price,
    lp.time_created,
    lp.time_added,
    lp.time_updated,
    lp.ts_created,
    lp.ts_added,
    lp.ts_updated,
    lp.label_kiosk_id,
    lp.product_id,
    lp.product_title,
    lp.product_archived,
    lp.product_vendor,
    lp.product_price,
    lp.product_cost,
    lp.product_shelf_life_days,
    lp.product_attributes,
    lp.product_categories,
    lp.consumer_category,
    lp.product_source
   FROM (public.byte_tickets_90days o
     JOIN public.byte_label_product lp ON (((lp.label_order_id)::text = (o.order_id)::text)))
  WHERE ((lp.label_status)::text = 'sold'::text);


ALTER TABLE public.byte_epcssold_90days OWNER TO dbservice;

--
-- Name: byte_tickets_9months; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_tickets_9months AS
 SELECT byte_tickets.order_id,
    byte_tickets.first_name,
    byte_tickets.last_name,
    byte_tickets.kiosk_id,
    byte_tickets.kiosk_title,
    byte_tickets.email,
    byte_tickets.amount_paid,
    byte_tickets.payment_system,
    byte_tickets.transaction_id,
    byte_tickets.approval_code,
    byte_tickets.status_code,
    byte_tickets.status_message,
    byte_tickets.status,
    byte_tickets.batch_id,
    byte_tickets.created,
    byte_tickets.auth_amount,
    byte_tickets.data_token,
    byte_tickets.time_opened,
    byte_tickets.time_closed,
    byte_tickets.card_hash,
    byte_tickets.state,
    byte_tickets.archived,
    byte_tickets.stamp,
    byte_tickets.last_update,
    byte_tickets.balance,
    byte_tickets.delta,
    byte_tickets.coupon_id,
    byte_tickets.coupon,
    byte_tickets.refund,
    byte_tickets.receipt,
    byte_tickets.campus_id,
    byte_tickets.amount_list_price,
    byte_tickets.notes,
    byte_tickets.time_door_opened,
    byte_tickets.time_door_closed,
    byte_tickets.client_name,
    byte_tickets.estd_num_users,
    byte_tickets.ts,
    byte_tickets.full_name,
    byte_tickets.door_opened_secs,
    byte_tickets.month,
    byte_tickets.week,
    byte_tickets.date,
    byte_tickets.dayofweek,
    byte_tickets.hour,
    byte_tickets.dowhour,
    byte_tickets.uniq_user
   FROM public.byte_tickets
  WHERE (byte_tickets.ts > (now() - '9 mons'::interval month));


ALTER TABLE public.byte_tickets_9months OWNER TO dbservice;

--
-- Name: byte_epcssold_9months; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_epcssold_9months AS
 SELECT o.order_id,
    o.first_name,
    o.last_name,
    o.kiosk_id,
    o.kiosk_title,
    o.email,
    o.amount_paid,
    o.payment_system,
    o.transaction_id,
    o.approval_code,
    o.status_code,
    o.status_message,
    o.status,
    o.batch_id,
    o.created,
    o.auth_amount,
    o.data_token,
    o.time_opened,
    o.time_closed,
    o.card_hash,
    o.state,
    o.archived,
    o.stamp,
    o.last_update,
    o.balance,
    o.delta,
    o.coupon_id,
    o.coupon,
    o.refund,
    o.receipt,
    o.campus_id,
    o.amount_list_price,
    o.notes,
    o.time_door_opened,
    o.time_door_closed,
    o.client_name,
    o.estd_num_users,
    o.ts,
    o.full_name,
    o.door_opened_secs,
    o.month,
    o.week,
    o.date,
    o.dayofweek,
    o.hour,
    o.dowhour,
    o.uniq_user,
    lp.epc,
    lp.label_order_id,
    lp.label_status,
    lp.label_price,
    lp.time_created,
    lp.time_added,
    lp.time_updated,
    lp.ts_created,
    lp.ts_added,
    lp.ts_updated,
    lp.label_kiosk_id,
    lp.product_id,
    lp.product_title,
    lp.product_archived,
    lp.product_vendor,
    lp.product_price,
    lp.product_cost,
    lp.product_shelf_life_days,
    lp.product_attributes,
    lp.product_categories,
    lp.consumer_category,
    lp.product_source
   FROM (public.byte_tickets_9months o
     JOIN public.byte_label_product lp ON (((lp.label_order_id)::text = (o.order_id)::text)))
  WHERE ((lp.label_status)::text = 'sold'::text);


ALTER TABLE public.byte_epcssold_9months OWNER TO dbservice;

--
-- Name: byte_epcssold_fast; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_epcssold_fast AS
 SELECT byte_epcssold.order_id,
    byte_epcssold.first_name,
    byte_epcssold.last_name,
    byte_epcssold.kiosk_id,
    byte_epcssold.kiosk_title,
    byte_epcssold.email,
    byte_epcssold.amount_paid,
    byte_epcssold.payment_system,
    byte_epcssold.transaction_id,
    byte_epcssold.approval_code,
    byte_epcssold.status_code,
    byte_epcssold.status_message,
    byte_epcssold.status,
    byte_epcssold.batch_id,
    byte_epcssold.created,
    byte_epcssold.auth_amount,
    byte_epcssold.data_token,
    byte_epcssold.time_opened,
    byte_epcssold.time_closed,
    byte_epcssold.card_hash,
    byte_epcssold.state,
    byte_epcssold.archived,
    byte_epcssold.stamp,
    byte_epcssold.last_update,
    byte_epcssold.balance,
    byte_epcssold.delta,
    byte_epcssold.coupon_id,
    byte_epcssold.coupon,
    byte_epcssold.refund,
    byte_epcssold.receipt,
    byte_epcssold.campus_id,
    byte_epcssold.amount_list_price,
    byte_epcssold.notes,
    byte_epcssold.time_door_opened,
    byte_epcssold.time_door_closed,
    byte_epcssold.client_name,
    byte_epcssold.estd_num_users,
    byte_epcssold.ts,
    byte_epcssold.full_name,
    byte_epcssold.door_opened_secs,
    byte_epcssold.month,
    byte_epcssold.week,
    byte_epcssold.date,
    byte_epcssold.dayofweek,
    byte_epcssold.hour,
    byte_epcssold.dowhour,
    byte_epcssold.uniq_user,
    byte_epcssold.epc,
    byte_epcssold.label_order_id,
    byte_epcssold.label_status,
    byte_epcssold.label_price,
    byte_epcssold.time_created,
    byte_epcssold.time_added,
    byte_epcssold.time_updated,
    byte_epcssold.ts_created,
    byte_epcssold.ts_added,
    byte_epcssold.ts_updated,
    byte_epcssold.label_kiosk_id,
    byte_epcssold.product_id,
    byte_epcssold.product_title,
    byte_epcssold.product_archived,
    byte_epcssold.product_vendor,
    byte_epcssold.product_price,
    byte_epcssold.product_cost,
    byte_epcssold.product_shelf_life_days,
    byte_epcssold.product_attributes,
    byte_epcssold.product_categories,
    byte_epcssold.consumer_category,
    byte_epcssold.product_source
   FROM public.byte_epcssold;


ALTER TABLE public.byte_epcssold_fast OWNER TO dbservice;

--
-- Name: byte_feedback; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_feedback AS
 SELECT f.id,
    f.rate,
    f.order_id,
    f.message,
    f.taste,
    f.freshness,
    f.variety,
    f.value,
    f.ticket_created,
    date_trunc('month'::text, t.ts) AS month,
    date_trunc('week'::text, t.ts) AS week,
    date_trunc('day'::text, t.ts) AS date,
    date_trunc('hour'::text, t.ts) AS hour
   FROM (pantry.feedback f
     JOIN public.byte_tickets t ON (((f.order_id)::text = (t.order_id)::text)));


ALTER TABLE public.byte_feedback OWNER TO dbservice;

--
-- Name: byte_feedback_monthly; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_feedback_monthly AS
 SELECT t1.month,
    t1.avg_rating,
    t1.avg_value,
    t1.avg_taste,
    t1.avg_freshness,
    t1.avg_variety,
    ((1.0 * (t1.feedbacks)::numeric) / (t2.tix)::numeric) AS frac_feedbacks
   FROM (( SELECT byte_feedback.month,
            avg((1.0 * (byte_feedback.rate)::numeric)) AS avg_rating,
            avg(public.if((byte_feedback.value > 0), (1.0 * (byte_feedback.value)::numeric), NULL::numeric)) AS avg_value,
            avg(public.if((byte_feedback.taste > 0), (1.0 * (byte_feedback.taste)::numeric), NULL::numeric)) AS avg_taste,
            avg(public.if((byte_feedback.freshness > 0), (1.0 * (byte_feedback.freshness)::numeric), NULL::numeric)) AS avg_freshness,
            avg(public.if((byte_feedback.variety > 0), (1.0 * (byte_feedback.variety)::numeric), NULL::numeric)) AS avg_variety,
            count(*) AS feedbacks
           FROM public.byte_feedback
          WHERE (byte_feedback.month >= '2016-01-01 08:00:00+00'::timestamp with time zone)
          GROUP BY byte_feedback.month
          ORDER BY byte_feedback.month) t1
     JOIN ( SELECT byte_tickets.month,
            count(*) AS tix
           FROM public.byte_tickets
          GROUP BY byte_tickets.month) t2 ON ((t1.month = t2.month)));


ALTER TABLE public.byte_feedback_monthly OWNER TO dbservice;

--
-- Name: byte_feedback_weekly; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_feedback_weekly AS
 SELECT t1.week,
    t1.avg_rating,
    t1.avg_value,
    t1.avg_taste,
    t1.avg_freshness,
    t1.avg_variety,
    ((1.0 * (t1.feedbacks)::numeric) / (t2.tix)::numeric) AS frac_feedbacks
   FROM (( SELECT byte_feedback.week,
            avg((1.0 * (byte_feedback.rate)::numeric)) AS avg_rating,
            avg(public.if((byte_feedback.value > 0), (1.0 * (byte_feedback.value)::numeric), NULL::numeric)) AS avg_value,
            avg(public.if((byte_feedback.taste > 0), (1.0 * (byte_feedback.taste)::numeric), NULL::numeric)) AS avg_taste,
            avg(public.if((byte_feedback.freshness > 0), (1.0 * (byte_feedback.freshness)::numeric), NULL::numeric)) AS avg_freshness,
            avg(public.if((byte_feedback.variety > 0), (1.0 * (byte_feedback.variety)::numeric), NULL::numeric)) AS avg_variety,
            count(*) AS feedbacks
           FROM public.byte_feedback
          WHERE (byte_feedback.week >= '2016-01-01 08:00:00+00'::timestamp with time zone)
          GROUP BY byte_feedback.week
          ORDER BY byte_feedback.week) t1
     JOIN ( SELECT byte_tickets.week,
            count(*) AS tix
           FROM public.byte_tickets
          GROUP BY byte_tickets.week) t2 ON ((t1.week = t2.week)));


ALTER TABLE public.byte_feedback_weekly OWNER TO dbservice;

--
-- Name: byte_kiosks; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_kiosks AS
 SELECT kiosk.id,
    kiosk.campus_id,
    kiosk.serial,
    kiosk.title,
    kiosk.address,
    kiosk.location_x,
    kiosk.location_y,
    kiosk.gcm_id,
    kiosk.app_vname,
    kiosk.app_vcode,
    kiosk.archived,
    kiosk.creation_time,
    kiosk.deployment_time,
    kiosk.last_update,
    kiosk.client_name,
    kiosk.last_status,
    kiosk.last_inventory,
    kiosk.kiosk_name,
    kiosk.payment_start,
    kiosk.payment_stop,
    kiosk.features,
    kiosk.sales_tax,
    kiosk.default_fee_plan,
    kiosk.timezone,
    kiosk.estd_num_users,
    kiosk.tags,
    kiosk.publicly_accessible,
    kiosk.cardkey_required,
    kiosk.delivery_insns,
    kiosk.fridge_loc_info,
    kiosk.contact_first_name,
    kiosk.contact_last_name,
    kiosk.contact_email,
    kiosk.contact_phone,
    kiosk.accounting_email,
    kiosk.byte_discount,
    kiosk.subsidy_info,
    kiosk.subsidy_notes,
    kiosk.max_subscription,
    kiosk.delivery_window_mon,
    kiosk.delivery_window_tue,
    kiosk.delivery_window_wed,
    kiosk.delivery_window_thu,
    kiosk.delivery_window_fri,
    kiosk.delivery_window_sat,
    kiosk.delivery_window_sun,
    kiosk.notes,
    kiosk.components,
    kiosk.email_receipt_subject,
    kiosk.ops_team_notes,
    kiosk.geo,
    kiosk.server_url,
    kiosk.subscription_amount,
    kiosk.enable_reporting,
    kiosk.enable_monitoring,
    kiosk.employees_num,
    kiosk.kiosk_restrictions,
    ( SELECT date(to_timestamp((min("order".created))::double precision)) AS date
           FROM pantry."order"
          WHERE (("order".kiosk_id = kiosk.id) AND (("order".order_id)::text ~~ 'RE%'::text))) AS first_restock,
    ( SELECT date_trunc('month'::text, (to_timestamp((min("order".created))::double precision) + '1 mon'::interval)) AS date_trunc
           FROM pantry."order"
          WHERE (("order".kiosk_id = kiosk.id) AND (("order".order_id)::text ~~ 'RE%'::text))) AS first_full_month
   FROM pantry.kiosk
  WHERE ((kiosk.campus_id = 87) AND (kiosk.enable_reporting = 1));


ALTER TABLE public.byte_kiosks OWNER TO dbservice;

--
-- Name: inventory_current_lots; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.inventory_current_lots AS
 SELECT t2.date,
    t2.product_id,
    t2.kiosk_id,
    t2.units,
    (t2.date + ('1 day'::interval day * ((p.shelf_time - 1))::double precision)) AS expir_date,
    p.shelf_time AS shelf_life_days
   FROM (( SELECT t1.date,
            t1.product_id,
            t1.kiosk_id,
            count(DISTINCT t1.epc) AS units
           FROM ( SELECT date_trunc('day'::text, to_timestamp((label.time_updated)::double precision)) AS date,
                    label.id,
                    label.product_id,
                    label.epc,
                    label.is_generic_sku,
                    label.kiosk_id,
                    label.order_id,
                    label.status,
                    label.price,
                    label.cost,
                    label.time_created,
                    label.time_added,
                    label.time_updated,
                    label.notes
                   FROM pantry.label
                  WHERE ((label.status)::text = 'ok'::text)) t1
          WHERE (t1.date > (now() - '2 days'::interval day))
          GROUP BY t1.date, t1.product_id, t1.kiosk_id) t2
     JOIN pantry.product p ON ((t2.product_id = p.id)))
  ORDER BY t2.product_id, t2.kiosk_id, (t2.date + ('1 day'::interval day * ((p.shelf_time - 1))::double precision));


ALTER TABLE public.inventory_current_lots OWNER TO dbservice;

--
-- Name: inventory_current; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.inventory_current AS
 SELECT inventory_current_lots.kiosk_id,
    inventory_current_lots.product_id,
    sum(inventory_current_lots.units) AS units
   FROM public.inventory_current_lots
  GROUP BY inventory_current_lots.kiosk_id, inventory_current_lots.product_id;


ALTER TABLE public.inventory_current OWNER TO dbservice;

--
-- Name: byte_inventory_current; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_inventory_current AS
 SELECT ic.kiosk_id,
    ic.product_id,
    ic.units
   FROM (public.inventory_current ic
     JOIN public.byte_kiosks bk ON ((ic.kiosk_id = bk.id)));


ALTER TABLE public.byte_inventory_current OWNER TO dbservice;

--
-- Name: byte_inventory_current_lots; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_inventory_current_lots AS
 SELECT ic.date,
    ic.product_id,
    ic.kiosk_id,
    ic.units,
    ic.expir_date,
    ic.shelf_life_days
   FROM (public.inventory_current_lots ic
     JOIN public.byte_kiosks bk ON ((ic.kiosk_id = bk.id)));


ALTER TABLE public.byte_inventory_current_lots OWNER TO dbservice;

--
-- Name: inventory_history; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.inventory_history AS
 SELECT date_trunc('month'::text, t.ts) AS month,
    date_trunc('week'::text, t.ts) AS week,
    date_trunc('day'::text, t.ts) AS date,
    date_trunc('hour'::text, t.ts) AS hour,
    date_part('dow'::text, t.ts) AS dayofweek,
    t.ts,
    t.product_id,
    t.kiosk_id,
    t.qty,
    t.product_title,
    t.kiosk_title
   FROM ( SELECT to_timestamp((ih."time")::double precision) AS ts,
            ih.product_id,
            ih.kiosk_id,
            ih.qty,
            p.title AS product_title,
            k.title AS kiosk_title
           FROM ((pantry.inventory_history ih
             JOIN pantry.product p ON ((ih.product_id = p.id)))
             JOIN pantry.kiosk k ON ((ih.kiosk_id = k.id)))) t;


ALTER TABLE public.inventory_history OWNER TO dbservice;

--
-- Name: byte_inventory_history; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_inventory_history AS
 SELECT ih.month,
    ih.week,
    ih.date,
    ih.hour,
    ih.dayofweek,
    ih.ts,
    ih.product_id,
    ih.kiosk_id,
    ih.qty,
    ih.product_title,
    ih.kiosk_title
   FROM (public.inventory_history ih
     JOIN public.byte_kiosks bk ON ((ih.kiosk_id = bk.id)));


ALTER TABLE public.byte_inventory_history OWNER TO dbservice;

--
-- Name: byte_inventory_history_eod; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_inventory_history_eod AS
 SELECT ih.month,
    ih.week,
    ih.date,
    ih.hour,
    ih.dayofweek,
    ih.ts,
    ih.product_id,
    ih.kiosk_id,
    ih.qty,
    ih.product_title,
    ih.kiosk_title
   FROM ((public.inventory_history ih
     JOIN public.byte_kiosks bk ON ((ih.kiosk_id = bk.id)))
     JOIN ( SELECT byte_inventory_history.date,
            byte_inventory_history.kiosk_id,
            byte_inventory_history.product_id,
            max(byte_inventory_history.ts) AS maxts
           FROM public.byte_inventory_history
          GROUP BY byte_inventory_history.date, byte_inventory_history.kiosk_id, byte_inventory_history.product_id) ih_eod ON (((ih_eod.kiosk_id = ih.kiosk_id) AND (ih_eod.product_id = ih.product_id) AND (ih_eod.date = ih.date))))
  WHERE (((bk.title)::text !~~* 'burn%'::text) AND ((bk.title)::text !~~* 'test%'::text));


ALTER TABLE public.byte_inventory_history_eod OWNER TO dbservice;

--
-- Name: byte_inventory_history_eod_2wks; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_inventory_history_eod_2wks AS
 SELECT ih.month,
    ih.week,
    ih.date,
    ih.hour,
    ih.dayofweek,
    ih.ts,
    ih.product_id,
    ih.kiosk_id,
    ih.qty,
    ih.product_title,
    ih.kiosk_title
   FROM ((public.inventory_history ih
     JOIN public.byte_kiosks bk ON ((ih.kiosk_id = bk.id)))
     JOIN ( SELECT byte_inventory_history.date,
            byte_inventory_history.kiosk_id,
            byte_inventory_history.product_id,
            max(byte_inventory_history.ts) AS maxts
           FROM public.byte_inventory_history
          WHERE (byte_inventory_history.ts > (now() - '14 days'::interval day))
          GROUP BY byte_inventory_history.date, byte_inventory_history.kiosk_id, byte_inventory_history.product_id) ih_eod ON (((ih_eod.kiosk_id = ih.kiosk_id) AND (ih_eod.product_id = ih.product_id) AND (ih_eod.maxts = ih.ts) AND (ih.ts > (now() - '14 days'::interval day)))))
  WHERE (((bk.title)::text !~~* 'burn%'::text) AND ((bk.title)::text !~~* 'test%'::text));


ALTER TABLE public.byte_inventory_history_eod_2wks OWNER TO dbservice;

--
-- Name: byte_kiosks_date_non_new; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_kiosks_date_non_new AS
 SELECT kiosks_date_non_new.kiosk_id,
    to_timestamp((kiosks_date_non_new.new_ts)::double precision) AS new_ts
   FROM pantry.kiosks_date_non_new;


ALTER TABLE public.byte_kiosks_date_non_new OWNER TO dbservice;

--
-- Name: byte_restockings; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_restockings AS
 SELECT byte_orders.order_id,
    byte_orders.first_name,
    byte_orders.last_name,
    byte_orders.kiosk_id,
    byte_orders.kiosk_title,
    byte_orders.email,
    byte_orders.amount_paid,
    byte_orders.payment_system,
    byte_orders.transaction_id,
    byte_orders.approval_code,
    byte_orders.status_code,
    byte_orders.status_message,
    byte_orders.status,
    byte_orders.batch_id,
    byte_orders.created,
    byte_orders.auth_amount,
    byte_orders.data_token,
    byte_orders.time_opened,
    byte_orders.time_closed,
    byte_orders.card_hash,
    byte_orders.state,
    byte_orders.archived,
    byte_orders.stamp,
    byte_orders.last_update,
    byte_orders.balance,
    byte_orders.delta,
    byte_orders.coupon_id,
    byte_orders.coupon,
    byte_orders.refund,
    byte_orders.receipt,
    byte_orders.campus_id,
    byte_orders.amount_list_price,
    byte_orders.notes,
    byte_orders.time_door_opened,
    byte_orders.time_door_closed,
    byte_orders.client_name,
    byte_orders.estd_num_users,
    byte_orders.ts,
    byte_orders.full_name,
    byte_orders.door_opened_secs,
    byte_orders.month,
    byte_orders.week,
    byte_orders.date,
    byte_orders.dayofweek,
    byte_orders.hour,
    byte_orders.dowhour
   FROM public.byte_orders
  WHERE ((byte_orders.payment_system)::text = 'Restocking'::text);


ALTER TABLE public.byte_restockings OWNER TO dbservice;

--
-- Name: byte_kiosks_by_week; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_kiosks_by_week AS
 SELECT s.week,
    (count(DISTINCT public.if((s.ts >= k.new_ts), k.kiosk_id, 0)) - 1) AS num_old_kiosks,
    (count(DISTINCT public.if((s.ts < k.new_ts), k.kiosk_id, 0)) - 1) AS num_new_kiosks,
    count(DISTINCT k.kiosk_id) AS num_all_kiosks
   FROM (public.byte_restockings s
     JOIN public.byte_kiosks_date_non_new k ON ((s.kiosk_id = k.kiosk_id)))
  GROUP BY s.week
  ORDER BY s.week;


ALTER TABLE public.byte_kiosks_by_week OWNER TO dbservice;

--
-- Name: byte_kiosks_with_perm_subsidy; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_kiosks_with_perm_subsidy AS
 SELECT k.id,
    k.campus_id,
    k.serial,
    k.title,
    k.address,
    k.location_x,
    k.location_y,
    k.gcm_id,
    k.app_vname,
    k.app_vcode,
    k.archived,
    k.creation_time,
    k.deployment_time,
    k.last_update,
    k.client_name,
    k.last_status,
    k.last_inventory,
    k.kiosk_name,
    k.payment_start,
    k.payment_stop,
    k.features,
    k.sales_tax,
    k.default_fee_plan,
    k.timezone,
    k.estd_num_users,
    k.tags,
    k.publicly_accessible,
    k.cardkey_required,
    k.delivery_insns,
    k.fridge_loc_info,
    k.contact_first_name,
    k.contact_last_name,
    k.contact_email,
    k.contact_phone,
    k.accounting_email,
    k.byte_discount,
    k.subsidy_info,
    k.subsidy_notes,
    k.max_subscription,
    k.delivery_window_mon,
    k.delivery_window_tue,
    k.delivery_window_wed,
    k.delivery_window_thu,
    k.delivery_window_fri,
    k.delivery_window_sat,
    k.delivery_window_sun,
    k.notes,
    k.components,
    k.email_receipt_subject,
    k.ops_team_notes,
    k.geo,
    k.server_url,
    k.subscription_amount,
    k.enable_reporting,
    k.enable_monitoring,
    k.employees_num,
    k.kiosk_restrictions,
    k.first_restock,
    k.first_full_month
   FROM public.byte_kiosks k
  WHERE ((k.id IN ( SELECT discount.kiosk_id
           FROM pantry.discount)) OR ((k.id)::text IN ( SELECT regexp_split_to_table(string_agg((cron.kiosks)::text, ','::text), ','::text) AS regexp_split_to_table
           FROM pantry.cron
          WHERE ((cron.archived = 0) AND ((cron.command)::text = 'happy'::text) AND (cron.payload !~~ '%onetime":true%'::text) AND (cron.group_id = 80)))));


ALTER TABLE public.byte_kiosks_with_perm_subsidy OWNER TO dbservice;

--
-- Name: byte_kp_grid; Type: TABLE; Schema: public; Owner: dbservice
--

CREATE TABLE public.byte_kp_grid (
    hour_start timestamp(6) with time zone,
    hour_end timestamp(6) with time zone,
    dowhour double precision,
    kiosk_id bigint,
    product_id bigint
);


ALTER TABLE public.byte_kp_grid OWNER TO dbservice;

--
-- Name: byte_kp_grid2; Type: TABLE; Schema: public; Owner: dbservice
--

CREATE TABLE public.byte_kp_grid2 (
    hour_start timestamp(6) with time zone,
    hour_end timestamp(6) with time zone,
    dowhour double precision,
    kiosk_id integer,
    product_id integer
);


ALTER TABLE public.byte_kp_grid2 OWNER TO dbservice;

--
-- Name: byte_kp_oos; Type: TABLE; Schema: public; Owner: dbservice
--

CREATE TABLE public.byte_kp_oos (
    hour_start timestamp(6) with time zone,
    hour_end timestamp(6) with time zone,
    kiosk_id integer,
    product_id integer,
    ts timestamp(6) with time zone,
    restock_ts timestamp(6) with time zone,
    oos_min double precision
);


ALTER TABLE public.byte_kp_oos OWNER TO dbservice;

--
-- Name: byte_kp_oos_avgdowhour; Type: TABLE; Schema: public; Owner: dbservice
--

CREATE TABLE public.byte_kp_oos_avgdowhour (
    kiosk_id integer,
    product_id integer,
    dowhour double precision,
    avgminutes double precision
);


ALTER TABLE public.byte_kp_oos_avgdowhour OWNER TO dbservice;

--
-- Name: byte_kp_oos_grid; Type: TABLE; Schema: public; Owner: dbservice
--

CREATE TABLE public.byte_kp_oos_grid (
    sales_hour timestamp(6) with time zone,
    dowhour double precision,
    kiosk_id integer,
    product_id integer,
    oosminutes double precision
);


ALTER TABLE public.byte_kp_oos_grid OWNER TO dbservice;

--
-- Name: byte_kp_sales; Type: TABLE; Schema: public; Owner: dbservice
--

CREATE TABLE public.byte_kp_sales (
    kiosk_id bigint,
    product_id bigint,
    sales_hour timestamp(6) without time zone,
    cnt bigint
);


ALTER TABLE public.byte_kp_sales OWNER TO dbservice;

--
-- Name: byte_kp_sales_avgdowhour; Type: TABLE; Schema: public; Owner: dbservice
--

CREATE TABLE public.byte_kp_sales_avgdowhour (
    kiosk_id bigint,
    product_id bigint,
    dowhour double precision,
    avgsales numeric(28,6)
);


ALTER TABLE public.byte_kp_sales_avgdowhour OWNER TO dbservice;

--
-- Name: byte_kp_sales_first; Type: TABLE; Schema: public; Owner: dbservice
--

CREATE TABLE public.byte_kp_sales_first (
    kiosk_id bigint,
    product_id bigint,
    first_sale_hour timestamp(6) without time zone
);


ALTER TABLE public.byte_kp_sales_first OWNER TO dbservice;

--
-- Name: byte_kp_sales_grid; Type: TABLE; Schema: public; Owner: dbservice
--

CREATE TABLE public.byte_kp_sales_grid (
    sales_hour timestamp(6) with time zone,
    dowhour double precision,
    kiosk_id bigint,
    product_id bigint,
    cnt bigint
);


ALTER TABLE public.byte_kp_sales_grid OWNER TO dbservice;

--
-- Name: byte_label_product_fast; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_label_product_fast WITH (security_barrier='false') AS
 SELECT l.epc,
    l.order_id AS label_order_id,
    l.status AS label_status,
    l.price AS label_price,
    l.time_created,
    l.time_added,
    l.time_updated,
    to_timestamp((l.time_created)::double precision) AS ts_created,
    to_timestamp((l.time_added)::double precision) AS ts_added,
    to_timestamp((l.time_updated)::double precision) AS ts_updated,
    l.kiosk_id AS label_kiosk_id,
    p.id AS product_id,
    p.title AS product_title,
    p.archived AS product_archived,
    p.vendor AS product_vendor,
    p.price AS product_price,
    p.cost AS product_cost,
    p.shelf_life_days AS product_shelf_life_days,
    p.categories AS product_categories,
    p.consumer_category,
    p.source AS product_source,
    p.fc_title
   FROM (pantry.label l
     JOIN public.byte_products_fast p ON ((l.product_id = p.id)));


ALTER TABLE public.byte_label_product_fast OWNER TO dbservice;

--
-- Name: byte_product_stats_by_kiosk; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_product_stats_by_kiosk AS
 SELECT p.kiosk_id,
    p.product_id,
    p.is_new,
    p.is_popular
   FROM (pantry.product_stats_by_kiosk p
     JOIN public.byte_kiosks k ON ((p.kiosk_id = k.id)));


ALTER TABLE public.byte_product_stats_by_kiosk OWNER TO dbservice;

--
-- Name: byte_raw_orders; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_raw_orders AS
 SELECT all_raw_orders.order_id,
    all_raw_orders.first_name,
    all_raw_orders.last_name,
    all_raw_orders.kiosk_id,
    all_raw_orders.kiosk_title,
    all_raw_orders.email,
    all_raw_orders.amount_paid,
    all_raw_orders.payment_system,
    all_raw_orders.transaction_id,
    all_raw_orders.approval_code,
    all_raw_orders.status_code,
    all_raw_orders.status_message,
    all_raw_orders.status,
    all_raw_orders.batch_id,
    all_raw_orders.created,
    all_raw_orders.auth_amount,
    all_raw_orders.data_token,
    all_raw_orders.time_opened,
    all_raw_orders.time_closed,
    all_raw_orders.card_hash,
    all_raw_orders.state,
    all_raw_orders.archived,
    all_raw_orders.stamp,
    all_raw_orders.last_update,
    all_raw_orders.balance,
    all_raw_orders.delta,
    all_raw_orders.coupon_id,
    all_raw_orders.coupon,
    all_raw_orders.refund,
    all_raw_orders.receipt,
    all_raw_orders.campus_id,
    all_raw_orders.amount_list_price,
    all_raw_orders.notes,
    all_raw_orders.time_door_opened,
    all_raw_orders.time_door_closed,
    all_raw_orders.client_name,
    all_raw_orders.estd_num_users,
    all_raw_orders.ts,
    all_raw_orders.full_name,
    all_raw_orders.door_opened_secs
   FROM public.all_raw_orders
  WHERE (all_raw_orders.campus_id = 87);


ALTER TABLE public.byte_raw_orders OWNER TO dbservice;

--
-- Name: byte_restockings_labels; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_restockings_labels AS
 SELECT history_epc_order.order_id,
    history_epc_order.product_id,
    to_timestamp((min(history_epc_order."time"))::double precision) AS to_timestamp,
    min(k.id) AS kiosk_id,
    min((k.title)::text) AS title,
    count(*) AS count
   FROM (pantry.history_epc_order
     JOIN public.byte_kiosks k ON ((history_epc_order.kiosk_id = k.id)))
  WHERE ((history_epc_order.order_id)::text ~~ 'RE%'::text)
  GROUP BY history_epc_order.order_id, history_epc_order.product_id;


ALTER TABLE public.byte_restockings_labels OWNER TO dbservice;

--
-- Name: byte_sales_by_week; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_sales_by_week AS
 SELECT s.week,
    sum(public.if((s.ts >= k.new_ts), 1, 0)) AS sales_units_in_old_kiosks,
    sum(public.if((s.ts < k.new_ts), 1, 0)) AS sales_units_in_new_kiosks,
    count(*) AS sales_units_in_all_kiosks,
    sum(public.if((s.ts >= k.new_ts), s.product_price, 0.0)) AS sales_listprc_in_old_kiosks,
    sum(public.if((s.ts < k.new_ts), s.product_price, 0.0)) AS sales_listprc_in_new_kiosks,
    sum(s.product_price) AS sales_listprc_in_all_kiosks,
    sum(public.if((s.ts >= k.new_ts), s.label_price, 0.0)) AS sales_actualprc_in_old_kiosks,
    sum(public.if((s.ts < k.new_ts), s.label_price, 0.0)) AS sales_actualprc_in_new_kiosks,
    sum(s.label_price) AS sales_actualprc_in_all_kiosks,
    sum(public.if((s.ts >= k.new_ts), s.product_cost, 0.0)) AS cost_list_in_old_kiosks,
    sum(public.if((s.ts < k.new_ts), s.product_cost, 0.0)) AS cost_list_in_new_kiosks,
    sum(s.product_cost) AS cost_list_in_all_kiosks
   FROM (public.byte_epcssold s
     JOIN public.byte_kiosks_date_non_new k ON ((s.kiosk_id = k.kiosk_id)))
  GROUP BY s.week
  ORDER BY s.week DESC;


ALTER TABLE public.byte_sales_by_week OWNER TO dbservice;

--
-- Name: byte_spoilage; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_spoilage AS
 SELECT t.kiosk_id,
    t.order_id,
    t.epc,
    t.product_id,
    t.ts_added,
    t.ts_removed,
    t.id,
    t.title,
    t.description,
    t.tiny_description,
    t.short_description,
    t.medium_description,
    t.long_description,
    t.price,
    t.cost,
    t.shelf_time,
    t.campus_id,
    t.image,
    t.image_time,
    t.last_update,
    t.archived,
    t.taxable,
    t.allergens,
    t.attribute_names,
    t.categories,
    t.category_names,
    t.vendor,
    t.source,
    t.notes,
    t.total_cal,
    t.num_servings,
    t.ingredients,
    t.calories,
    t.proteins,
    t.sugar,
    t.carbohydrates,
    t.fat,
    t.consumer_category,
    t.ws_case_size,
    t.kiosk_ship_qty,
    t.ws_case_cost,
    t.pick_station,
    t.fc_title,
    t.pricing_tier,
    t.width_space,
    t.height_space,
    t.depth_space,
    t.slotted_width,
    t.tag_volume,
    t.delivery_option,
    t.kiosk_title,
    t.address,
    t.location_x,
    t.location_y,
    t.client_name,
    t.tags,
    t.estd_num_users,
    date_trunc('month'::text, t.ts_removed) AS month,
    date_trunc('week'::text, t.ts_removed) AS week,
    date_trunc('day'::text, t.ts_removed) AS date
   FROM ( SELECT s.kiosk_id,
            s.order_id,
            s.epc,
            s.product_id,
            to_timestamp((s.time_added)::double precision) AS ts_added,
            to_timestamp((s.time_removed)::double precision) AS ts_removed,
            p.id,
            p.title,
            p.description,
            p.tiny_description,
            p.short_description,
            p.medium_description,
            p.long_description,
            p.price,
            p.cost,
            p.shelf_time,
            p.campus_id,
            p.image,
            p.image_time,
            p.last_update,
            p.archived,
            p.taxable,
            p.allergens,
            p.attribute_names,
            p.categories,
            p.category_names,
            p.vendor,
            p.source,
            p.notes,
            p.total_cal,
            p.num_servings,
            p.ingredients,
            p.calories,
            p.proteins,
            p.sugar,
            p.carbohydrates,
            p.fat,
            p.consumer_category,
            p.ws_case_size,
            p.kiosk_ship_qty,
            p.ws_case_cost,
            p.pick_station,
            p.fc_title,
            p.pricing_tier,
            p.width_space,
            p.height_space,
            p.depth_space,
            p.slotted_width,
            p.tag_volume,
            p.delivery_option,
            k.title AS kiosk_title,
            k.address,
            k.location_x,
            k.location_y,
            k.client_name,
            k.tags,
            k.estd_num_users
           FROM ((pantry.spoilage s
             JOIN pantry.product p ON ((s.product_id = p.id)))
             JOIN pantry.kiosk k ON ((s.kiosk_id = k.id)))
          WHERE ((k.campus_id = 87) AND (s.order_id IS NOT NULL) AND (k.enable_reporting = 1))) t;


ALTER TABLE public.byte_spoilage OWNER TO dbservice;

--
-- Name: byte_spoilage_by_category_week_all; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_spoilage_by_category_week_all AS
 SELECT s.week,
    ((regexp_replace((s.consumer_category)::text, '[^a-zA-Z]+'::text, '_'::text, 'g'::text) || '_'::text) || 'cost_all'::text) AS cat_and_new,
    sum(s.cost) AS spoilage_cost
   FROM (public.byte_spoilage s
     JOIN public.byte_kiosks_date_non_new k ON ((s.kiosk_id = k.kiosk_id)))
  WHERE ((s.date >= '2016-01-01 08:00:00+00'::timestamp with time zone) AND (s.consumer_category IS NOT NULL))
  GROUP BY s.week, ((regexp_replace((s.consumer_category)::text, '[^a-zA-Z]+'::text, '_'::text, 'g'::text) || '_'::text) || 'cost_all'::text)
  ORDER BY s.week DESC, ((regexp_replace((s.consumer_category)::text, '[^a-zA-Z]+'::text, '_'::text, 'g'::text) || '_'::text) || 'cost_all'::text);


ALTER TABLE public.byte_spoilage_by_category_week_all OWNER TO dbservice;

--
-- Name: byte_spoilage_by_category_week_newold; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_spoilage_by_category_week_newold AS
 SELECT s.week,
    ((regexp_replace((s.consumer_category)::text, '[^a-zA-Z]+'::text, '_'::text, 'g'::text) || '_'::text) ||
        CASE
            WHEN (s.date >= k.new_ts) THEN 'cost_old'::text
            ELSE 'cost_new'::text
        END) AS cat_and_new,
    sum(s.cost) AS spoilage_cost
   FROM (public.byte_spoilage s
     JOIN public.byte_kiosks_date_non_new k ON ((s.kiosk_id = k.kiosk_id)))
  WHERE ((s.date >= '2016-01-01 08:00:00+00'::timestamp with time zone) AND (s.consumer_category IS NOT NULL))
  GROUP BY s.week, ((regexp_replace((s.consumer_category)::text, '[^a-zA-Z]+'::text, '_'::text, 'g'::text) || '_'::text) ||
        CASE
            WHEN (s.date >= k.new_ts) THEN 'cost_old'::text
            ELSE 'cost_new'::text
        END)
  ORDER BY s.week DESC, ((regexp_replace((s.consumer_category)::text, '[^a-zA-Z]+'::text, '_'::text, 'g'::text) || '_'::text) ||
        CASE
            WHEN (s.date >= k.new_ts) THEN 'cost_old'::text
            ELSE 'cost_new'::text
        END);


ALTER TABLE public.byte_spoilage_by_category_week_newold OWNER TO dbservice;

--
-- Name: byte_spoilage_by_category_week; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_spoilage_by_category_week AS
 SELECT t1.week,
    (regexp_replace(regexp_replace(t1.cat_and_new, '_cost1_'::text, '_per_'::text), '_all'::text, ''::text) || '_kiosk'::text) AS cat_and_new,
    (t1.spoilage_cost / (
        CASE
            WHEN (t1.cat_and_new ~~ '%new%'::text) THEN t2.num_new_kiosks
            WHEN (t1.cat_and_new ~~ '%old%'::text) THEN t2.num_old_kiosks
            ELSE t2.num_all_kiosks
        END)::numeric) AS spoilage_cost
   FROM (( SELECT byte_spoilage_by_category_week_newold.week,
            byte_spoilage_by_category_week_newold.cat_and_new,
            byte_spoilage_by_category_week_newold.spoilage_cost
           FROM public.byte_spoilage_by_category_week_newold
        UNION
         SELECT byte_spoilage_by_category_week_all.week,
            byte_spoilage_by_category_week_all.cat_and_new,
            byte_spoilage_by_category_week_all.spoilage_cost
           FROM public.byte_spoilage_by_category_week_all) t1
     LEFT JOIN public.byte_kiosks_by_week t2 ON ((t1.week = t2.week)));


ALTER TABLE public.byte_spoilage_by_category_week OWNER TO dbservice;

--
-- Name: byte_spoilage_by_category_week_crosstab; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_spoilage_by_category_week_crosstab AS
 SELECT ct.week,
    ct.breakfast_cost_per_old_kiosk,
    ct.breakfast_cost_per_new_kiosk,
    ct.breakfast_cost_per_kiosk,
    ct.burritos_cost_per_old_kiosk,
    ct.burritos_cost_per_new_kiosk,
    ct.burritos_cost_per_kiosk,
    ct.desserts_cost_per_old_kiosk,
    ct.desserts_cost_per_new_kiosk,
    ct.desserts_cost_per_kiosk,
    ct.drinks_cost_per_old_kiosk,
    ct.drinks_cost_per_new_kiosk,
    ct.drinks_cost_per_kiosk,
    ct.entrees_cost_per_old_kiosk,
    ct.entrees_cost_per_new_kiosk,
    ct.entrees_cost_per_kiosk,
    ct.sandwiches_wraps_cost_per_old_kiosk,
    ct.sandwiches_wraps_cost_per_new_kiosk,
    ct.sandwiches_wraps_cost_per_kiosk,
    ct.snacks_cost_per_old_kiosk,
    ct.snacks_cost_per_new_kiosk,
    ct.snacks_cost_per_kiosk,
    ct.soups_salads_cost_per_old_kiosk,
    ct.soups_salads_cost_per_new_kiosk,
    ct.soups_salads_cost_per_kiosk
   FROM public.crosstab('select to_char(week,''YYYY-MM-DD'') as week,cat_and_new,spoilage_cost from byte_spoilage_by_category_week order by week desc,cat_and_new desc'::text) ct(week text, breakfast_cost_per_old_kiosk numeric, breakfast_cost_per_new_kiosk numeric, breakfast_cost_per_kiosk numeric, burritos_cost_per_old_kiosk numeric, burritos_cost_per_new_kiosk numeric, burritos_cost_per_kiosk numeric, desserts_cost_per_old_kiosk numeric, desserts_cost_per_new_kiosk numeric, desserts_cost_per_kiosk numeric, drinks_cost_per_old_kiosk numeric, drinks_cost_per_new_kiosk numeric, drinks_cost_per_kiosk numeric, entrees_cost_per_old_kiosk numeric, entrees_cost_per_new_kiosk numeric, entrees_cost_per_kiosk numeric, sandwiches_wraps_cost_per_old_kiosk numeric, sandwiches_wraps_cost_per_new_kiosk numeric, sandwiches_wraps_cost_per_kiosk numeric, snacks_cost_per_old_kiosk numeric, snacks_cost_per_new_kiosk numeric, snacks_cost_per_kiosk numeric, soups_salads_cost_per_old_kiosk numeric, soups_salads_cost_per_new_kiosk numeric, soups_salads_cost_per_kiosk numeric);


ALTER TABLE public.byte_spoilage_by_category_week_crosstab OWNER TO dbservice;

--
-- Name: byte_spoilage_by_sku_2months; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_spoilage_by_sku_2months AS
 SELECT to_char(t2.first_sale, 'MM-DD'::text) AS first_sale,
    p.shelf_life_days AS shelf_days,
    t.spoiled,
    t2.sold,
    to_char(((1.0 * (t.spoiled)::numeric) / ((t2.sold + t.spoiled))::numeric), '0.000'::text) AS frac_spoiled,
    ((t2.sold)::numeric * p.price) AS revenue,
    ((t.spoiled)::numeric * p.cost) AS spoil_cost,
    to_char((((t.spoiled)::numeric * p.cost) / (((t2.sold)::numeric * p.price) + 0.001)), '0.000'::text) AS spoil_dolr_frac,
    t.product_id,
    p.categories,
    p.title
   FROM ((( SELECT byte_spoilage.product_id,
            count(*) AS spoiled
           FROM public.byte_spoilage
          WHERE (byte_spoilage.ts_removed > (now() - '2 mons'::interval month))
          GROUP BY byte_spoilage.product_id) t
     JOIN ( SELECT byte_epcssold_2months.product_id,
            min(byte_epcssold_2months.ts) AS first_sale,
            count(*) AS sold
           FROM public.byte_epcssold_2months
          GROUP BY byte_epcssold_2months.product_id) t2 ON ((t.product_id = t2.product_id)))
     JOIN public.byte_products p ON ((t2.product_id = p.id)))
  ORDER BY (to_char(((1.0 * (t.spoiled)::numeric) / ((t2.sold + t.spoiled))::numeric), '0.000'::text)) DESC;


ALTER TABLE public.byte_spoilage_by_sku_2months OWNER TO dbservice;

--
-- Name: byte_spoilage_by_week; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_spoilage_by_week AS
 SELECT s.week,
    sum(public.if((s.ts_removed > k.new_ts), 1, 0)) AS spoilage_units_in_old_kiosks,
    sum(public.if((s.ts_removed <= k.new_ts), 1, 0)) AS spoilage_units_in_new_kiosks,
    count(*) AS spoilage_units_in_all_kiosks,
    sum(public.if((s.ts_removed > k.new_ts), s.cost, 0.0)) AS spoilage_dolr_in_old_kiosks,
    sum(public.if((s.ts_removed <= k.new_ts), s.cost, 0.0)) AS spoilage_dolr_in_new_kiosks,
    sum(s.cost) AS spoilage_dolr_in_all_kiosks
   FROM (public.byte_spoilage s
     JOIN public.byte_kiosks_date_non_new k ON ((s.kiosk_id = k.kiosk_id)))
  WHERE (s.ts_removed >= '2016-01-01 08:00:00+00'::timestamp with time zone)
  GROUP BY s.week
  ORDER BY s.week DESC;


ALTER TABLE public.byte_spoilage_by_week OWNER TO dbservice;

--
-- Name: byte_stockouts; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_stockouts AS
 SELECT t.kiosk_id,
    t.order_id,
    t.product_id,
    t.ts,
    t.restock_ts,
    t.restock_order_id,
    t.id,
    t.title,
    t.description,
    t.tiny_description,
    t.short_description,
    t.medium_description,
    t.long_description,
    t.price,
    t.cost,
    t.shelf_time,
    t.campus_id,
    t.image,
    t.image_time,
    t.last_update,
    t.archived,
    t.taxable,
    t.allergens,
    t.attribute_names,
    t.categories,
    t.category_names,
    t.vendor,
    t.source,
    t.notes,
    t.total_cal,
    t.num_servings,
    t.ingredients,
    t.calories,
    t.proteins,
    t.sugar,
    t.carbohydrates,
    t.fat,
    t.consumer_category,
    t.ws_case_size,
    t.kiosk_ship_qty,
    t.ws_case_cost,
    t.pick_station,
    t.fc_title,
    t.pricing_tier,
    t.width_space,
    t.height_space,
    t.depth_space,
    t.slotted_width,
    t.tag_volume,
    t.delivery_option,
    t.kiosk_title,
    t.address,
    t.location_x,
    t.location_y,
    t.client_name,
    t.tags,
    t.estd_num_users,
    date_trunc('month'::text, t.ts) AS month,
    date_trunc('week'::text, t.ts) AS week,
    date_trunc('day'::text, t.ts) AS date
   FROM ( SELECT s.kiosk_id,
            s.order_id,
            s.product_id,
            to_timestamp((s."timestamp")::double precision) AS ts,
            to_timestamp((s.restock_timestamp)::double precision) AS restock_ts,
            s.restock_order_id,
            p.id,
            p.title,
            p.description,
            p.tiny_description,
            p.short_description,
            p.medium_description,
            p.long_description,
            p.price,
            p.cost,
            p.shelf_time,
            p.campus_id,
            p.image,
            p.image_time,
            p.last_update,
            p.archived,
            p.taxable,
            p.allergens,
            p.attribute_names,
            p.categories,
            p.category_names,
            p.vendor,
            p.source,
            p.notes,
            p.total_cal,
            p.num_servings,
            p.ingredients,
            p.calories,
            p.proteins,
            p.sugar,
            p.carbohydrates,
            p.fat,
            p.consumer_category,
            p.ws_case_size,
            p.kiosk_ship_qty,
            p.ws_case_cost,
            p.pick_station,
            p.fc_title,
            p.pricing_tier,
            p.width_space,
            p.height_space,
            p.depth_space,
            p.slotted_width,
            p.tag_volume,
            p.delivery_option,
            k.title AS kiosk_title,
            k.address,
            k.location_x,
            k.location_y,
            k.client_name,
            k.tags,
            k.estd_num_users
           FROM ((pantry.stockout s
             JOIN pantry.product p ON ((s.product_id = p.id)))
             JOIN public.byte_kiosks k ON ((s.kiosk_id = k.id)))
          WHERE (s.order_id IS NOT NULL)) t;


ALTER TABLE public.byte_stockouts OWNER TO dbservice;

--
-- Name: byte_stockouts_by_week; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_stockouts_by_week AS
 SELECT s.week,
    sum(public.if((s.ts >= k.new_ts), 1, 0)) AS stockout_units_in_old_kiosks,
    sum(public.if((s.ts < k.new_ts), 1, 0)) AS stockout_units_in_new_kiosks,
    count(*) AS stockout_units_in_all_kiosks,
    (sum(public.if((s.ts >= k.new_ts), (date_part('minute'::text, (s.restock_ts - s.ts)))::numeric, 0.0)) / 60.0) AS stockout_hrs_in_old_kiosks,
    (sum(public.if((s.ts < k.new_ts), (date_part('minute'::text, (s.restock_ts - s.ts)))::numeric, 0.0)) / 60.0) AS stockout_hrs_in_new_kiosks,
    sum((date_part('minute'::text, (s.restock_ts - s.ts)) / (60.0)::double precision)) AS stockout_hrs_in_all_kiosks
   FROM (public.byte_stockouts s
     JOIN public.byte_kiosks_date_non_new k ON ((s.kiosk_id = k.kiosk_id)))
  WHERE (s.ts >= '2016-01-01 08:00:00+00'::timestamp with time zone)
  GROUP BY s.week
  ORDER BY s.week DESC;


ALTER TABLE public.byte_stockouts_by_week OWNER TO dbservice;

--
-- Name: byte_spoilage_stockouts_by_week; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_spoilage_stockouts_by_week AS
 SELECT t1.week,
    ((t3.stockout_units_in_old_kiosks)::double precision / (t4.num_old_kiosks)::double precision) AS avg_stockout_units_per_old_kiosk,
    public.if((t4.num_new_kiosks > 0), ((t3.stockout_units_in_new_kiosks)::double precision / (t4.num_new_kiosks)::double precision), (0.0)::double precision) AS avg_stockout_units_per_new_kiosk,
    ((t3.stockout_units_in_all_kiosks)::double precision / (t4.num_all_kiosks)::double precision) AS avg_stockout_units_per_all_kiosk,
    (t3.stockout_hrs_in_old_kiosks / (t4.num_old_kiosks)::numeric) AS avg_stockout_hrs_per_old_kiosk,
    public.if((t4.num_new_kiosks > 0), ((t3.stockout_hrs_in_new_kiosks)::double precision / (t4.num_new_kiosks)::double precision), (0.0)::double precision) AS avg_stockout_hrs_per_new_kiosk,
    (t3.stockout_hrs_in_all_kiosks / (t4.num_all_kiosks)::double precision) AS avg_stockout_hrs_per_all_kiosk,
    (t2.spoilage_dolr_in_old_kiosks / t1.sales_listprc_in_old_kiosks) AS spoilage_frac_in_old_kiosks,
    public.if((t1.sales_listprc_in_new_kiosks > 0.0), ((t2.spoilage_dolr_in_new_kiosks)::double precision / (t1.sales_listprc_in_new_kiosks)::double precision), (0.0)::double precision) AS spoilage_frac_in_new_kiosks,
    (t2.spoilage_dolr_in_all_kiosks / t1.sales_listprc_in_all_kiosks) AS spoilage_frac_in_all_kiosks,
    t4.num_old_kiosks,
    t4.num_new_kiosks,
    t4.num_all_kiosks,
    t1.sales_units_in_old_kiosks,
    t1.sales_units_in_new_kiosks,
    t1.sales_units_in_all_kiosks,
    t1.sales_listprc_in_old_kiosks,
    t1.sales_listprc_in_new_kiosks,
    t1.sales_listprc_in_all_kiosks,
    t1.sales_actualprc_in_old_kiosks,
    t1.sales_actualprc_in_new_kiosks,
    t1.sales_actualprc_in_all_kiosks,
    t1.cost_list_in_old_kiosks,
    t1.cost_list_in_new_kiosks,
    t1.cost_list_in_all_kiosks,
    t3.stockout_units_in_old_kiosks,
    t3.stockout_units_in_new_kiosks,
    t3.stockout_units_in_all_kiosks,
    t3.stockout_hrs_in_old_kiosks,
    t3.stockout_hrs_in_new_kiosks,
    t3.stockout_hrs_in_all_kiosks,
    t2.spoilage_units_in_old_kiosks,
    t2.spoilage_units_in_new_kiosks,
    t2.spoilage_units_in_all_kiosks,
    t2.spoilage_dolr_in_old_kiosks,
    t2.spoilage_dolr_in_new_kiosks,
    t2.spoilage_dolr_in_all_kiosks
   FROM (((public.byte_sales_by_week t1
     JOIN public.byte_spoilage_by_week t2 ON ((t1.week = t2.week)))
     JOIN public.byte_stockouts_by_week t3 ON ((t1.week = t3.week)))
     JOIN public.byte_kiosks_by_week t4 ON ((t1.week = t4.week)))
  ORDER BY t1.week DESC;


ALTER TABLE public.byte_spoilage_stockouts_by_week OWNER TO dbservice;

--
-- Name: byte_stockouts_by_category_week_all; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_stockouts_by_category_week_all AS
 SELECT s.week,
    ((regexp_replace((s.consumer_category)::text, '[^a-zA-Z]+'::text, '_'::text, 'g'::text) || '_'::text) || 'hrs_all'::text) AS cat_and_new,
    sum((date_part('minute'::text, (s.restock_ts - s.ts)) / (60.0)::double precision)) AS stockout_hrs
   FROM (public.byte_stockouts s
     JOIN public.byte_kiosks_date_non_new k ON ((s.kiosk_id = k.kiosk_id)))
  WHERE ((s.ts >= '2016-01-01 08:00:00+00'::timestamp with time zone) AND (s.consumer_category IS NOT NULL))
  GROUP BY s.week, ((regexp_replace((s.consumer_category)::text, '[^a-zA-Z]+'::text, '_'::text, 'g'::text) || '_'::text) || 'hrs_all'::text)
  ORDER BY s.week DESC, ((regexp_replace((s.consumer_category)::text, '[^a-zA-Z]+'::text, '_'::text, 'g'::text) || '_'::text) || 'hrs_all'::text);


ALTER TABLE public.byte_stockouts_by_category_week_all OWNER TO dbservice;

--
-- Name: byte_stockouts_by_category_week_newold; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_stockouts_by_category_week_newold AS
 SELECT s.week,
    ((regexp_replace((s.consumer_category)::text, '[^a-zA-Z]+'::text, '_'::text, 'g'::text) || '_'::text) ||
        CASE
            WHEN (s.ts >= k.new_ts) THEN 'hrs_old'::text
            ELSE 'hrs_new'::text
        END) AS cat_and_new,
    sum((date_part('minute'::text, (s.restock_ts - s.ts)) / (60.0)::double precision)) AS stockout_hrs
   FROM (public.byte_stockouts s
     JOIN public.byte_kiosks_date_non_new k ON ((s.kiosk_id = k.kiosk_id)))
  WHERE ((s.ts >= '2016-01-01 08:00:00+00'::timestamp with time zone) AND (s.consumer_category IS NOT NULL))
  GROUP BY s.week, ((regexp_replace((s.consumer_category)::text, '[^a-zA-Z]+'::text, '_'::text, 'g'::text) || '_'::text) ||
        CASE
            WHEN (s.ts >= k.new_ts) THEN 'hrs_old'::text
            ELSE 'hrs_new'::text
        END)
  ORDER BY s.week DESC, ((regexp_replace((s.consumer_category)::text, '[^a-zA-Z]+'::text, '_'::text, 'g'::text) || '_'::text) ||
        CASE
            WHEN (s.ts >= k.new_ts) THEN 'hrs_old'::text
            ELSE 'hrs_new'::text
        END);


ALTER TABLE public.byte_stockouts_by_category_week_newold OWNER TO dbservice;

--
-- Name: byte_stockouts_by_category_week; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_stockouts_by_category_week AS
 SELECT t1.week,
    (regexp_replace(regexp_replace(t1.cat_and_new, '_hrs_'::text, '_per_'::text), '_all'::text, ''::text) || '_kiosk'::text) AS cat_and_new,
    (t1.stockout_hrs / (
        CASE
            WHEN (t1.cat_and_new ~~ '%new%'::text) THEN t2.num_new_kiosks
            WHEN (t1.cat_and_new ~~ '%old%'::text) THEN t2.num_old_kiosks
            ELSE t2.num_all_kiosks
        END)::double precision) AS stockout_hrs
   FROM (( SELECT byte_stockouts_by_category_week_newold.week,
            byte_stockouts_by_category_week_newold.cat_and_new,
            byte_stockouts_by_category_week_newold.stockout_hrs
           FROM public.byte_stockouts_by_category_week_newold
        UNION
         SELECT byte_stockouts_by_category_week_all.week,
            byte_stockouts_by_category_week_all.cat_and_new,
            byte_stockouts_by_category_week_all.stockout_hrs
           FROM public.byte_stockouts_by_category_week_all) t1
     LEFT JOIN public.byte_kiosks_by_week t2 ON ((t1.week = t2.week)));


ALTER TABLE public.byte_stockouts_by_category_week OWNER TO dbservice;

--
-- Name: byte_stockouts_by_category_week_crosstab; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_stockouts_by_category_week_crosstab AS
 SELECT ct.week,
    ct.breakfast_hrs_per_old_kiosk,
    ct.breakfast_hrs_per_new_kiosk,
    ct.breakfast_hrs_per_kiosk,
    ct.burritos_hrs_per_old_kiosk,
    ct.burritos_hrs_per_new_kiosk,
    ct.burritos_hrs_per_kiosk,
    ct.desserts_hrs_per_old_kiosk,
    ct.desserts_hrs_per_new_kiosk,
    ct.desserts_hrs_per_kiosk,
    ct.drinks_hrs_per_old_kiosk,
    ct.drinks_hrs_per_new_kiosk,
    ct.drinks_hrs_per_kiosk,
    ct.entrees_hrs_per_old_kiosk,
    ct.entrees_hrs_per_new_kiosk,
    ct.entrees_hrs_per_kiosk,
    ct.sandwiches_wraps_hrs_per_old_kiosk,
    ct.sandwiches_wraps_hrs_per_new_kiosk,
    ct.sandwiches_wraps_hrs_per_kiosk,
    ct.snacks_hrs_per_old_kiosk,
    ct.snacks_hrs_per_new_kiosk,
    ct.snacks_hrs_per_kiosk,
    ct.soups_salads_hrs_per_old_kiosk,
    ct.soups_salads_hrs_per_new_kiosk,
    ct.soups_salads_hrs_per_kiosk
   FROM public.crosstab('select to_char(week,''YYYY-MM-DD'') as week,cat_and_new,stockout_hrs from byte_stockouts_by_category_week order by week desc,cat_and_new desc'::text) ct(week text, breakfast_hrs_per_old_kiosk double precision, breakfast_hrs_per_new_kiosk double precision, breakfast_hrs_per_kiosk double precision, burritos_hrs_per_old_kiosk double precision, burritos_hrs_per_new_kiosk double precision, burritos_hrs_per_kiosk double precision, desserts_hrs_per_old_kiosk double precision, desserts_hrs_per_new_kiosk double precision, desserts_hrs_per_kiosk double precision, drinks_hrs_per_old_kiosk double precision, drinks_hrs_per_new_kiosk double precision, drinks_hrs_per_kiosk double precision, entrees_hrs_per_old_kiosk double precision, entrees_hrs_per_new_kiosk double precision, entrees_hrs_per_kiosk double precision, sandwiches_wraps_hrs_per_old_kiosk double precision, sandwiches_wraps_hrs_per_new_kiosk double precision, sandwiches_wraps_hrs_per_kiosk double precision, snacks_hrs_per_old_kiosk double precision, snacks_hrs_per_new_kiosk double precision, snacks_hrs_per_kiosk double precision, soups_salads_hrs_per_old_kiosk double precision, soups_salads_hrs_per_new_kiosk double precision, soups_salads_hrs_per_kiosk double precision);


ALTER TABLE public.byte_stockouts_by_category_week_crosstab OWNER TO dbservice;

--
-- Name: byte_tickets_labels; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_tickets_labels AS
 SELECT o.order_id,
    o.first_name,
    o.last_name,
    o.kiosk_id,
    o.kiosk_title,
    o.email,
    o.amount_paid,
    o.payment_system,
    o.transaction_id,
    o.approval_code,
    o.status_code,
    o.status_message,
    o.status,
    o.batch_id,
    o.created,
    o.auth_amount,
    o.data_token,
    o.time_opened,
    o.time_closed,
    o.card_hash,
    o.state,
    o.archived,
    o.stamp,
    o.last_update,
    o.balance,
    o.delta,
    o.coupon_id,
    o.coupon,
    o.refund,
    o.receipt,
    o.campus_id,
    o.amount_list_price,
    o.notes,
    o.time_door_opened,
    o.time_door_closed,
    o.client_name,
    o.estd_num_users,
    o.ts,
    o.full_name,
    o.door_opened_secs,
    o.month,
    o.week,
    o.date,
    o.dayofweek,
    o.hour,
    o.dowhour,
    o.uniq_user,
    l.epc AS label_epc,
    l.status AS label_status,
    l.time_created AS label_time_created
   FROM (pantry.label l
     JOIN public.byte_tickets o ON (((o.order_id)::text = (l.order_id)::text)));


ALTER TABLE public.byte_tickets_labels OWNER TO dbservice;

--
-- Name: byte_tickets_today; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_tickets_today AS
 SELECT byte_tickets.order_id,
    byte_tickets.first_name,
    byte_tickets.last_name,
    byte_tickets.kiosk_id,
    byte_tickets.kiosk_title,
    byte_tickets.email,
    byte_tickets.amount_paid,
    byte_tickets.payment_system,
    byte_tickets.transaction_id,
    byte_tickets.approval_code,
    byte_tickets.status_code,
    byte_tickets.status_message,
    byte_tickets.status,
    byte_tickets.batch_id,
    byte_tickets.created,
    byte_tickets.auth_amount,
    byte_tickets.data_token,
    byte_tickets.time_opened,
    byte_tickets.time_closed,
    byte_tickets.card_hash,
    byte_tickets.state,
    byte_tickets.archived,
    byte_tickets.stamp,
    byte_tickets.last_update,
    byte_tickets.balance,
    byte_tickets.delta,
    byte_tickets.coupon_id,
    byte_tickets.coupon,
    byte_tickets.refund,
    byte_tickets.receipt,
    byte_tickets.campus_id,
    byte_tickets.amount_list_price,
    byte_tickets.notes,
    byte_tickets.time_door_opened,
    byte_tickets.time_door_closed,
    byte_tickets.client_name,
    byte_tickets.estd_num_users,
    byte_tickets.ts,
    byte_tickets.full_name,
    byte_tickets.door_opened_secs,
    byte_tickets.month,
    byte_tickets.week,
    byte_tickets.date,
    byte_tickets.dayofweek,
    byte_tickets.hour,
    byte_tickets.dowhour,
    byte_tickets.uniq_user
   FROM public.byte_tickets
  WHERE (byte_tickets.ts > date_trunc('day'::text, ('now'::text)::timestamp without time zone));


ALTER TABLE public.byte_tickets_today OWNER TO dbservice;

--
-- Name: byte_tickets_yesterday; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_tickets_yesterday AS
 SELECT byte_tickets.order_id,
    byte_tickets.first_name,
    byte_tickets.last_name,
    byte_tickets.kiosk_id,
    byte_tickets.kiosk_title,
    byte_tickets.email,
    byte_tickets.amount_paid,
    byte_tickets.payment_system,
    byte_tickets.transaction_id,
    byte_tickets.approval_code,
    byte_tickets.status_code,
    byte_tickets.status_message,
    byte_tickets.status,
    byte_tickets.batch_id,
    byte_tickets.created,
    byte_tickets.auth_amount,
    byte_tickets.data_token,
    byte_tickets.time_opened,
    byte_tickets.time_closed,
    byte_tickets.card_hash,
    byte_tickets.state,
    byte_tickets.archived,
    byte_tickets.stamp,
    byte_tickets.last_update,
    byte_tickets.balance,
    byte_tickets.delta,
    byte_tickets.coupon_id,
    byte_tickets.coupon,
    byte_tickets.refund,
    byte_tickets.receipt,
    byte_tickets.campus_id,
    byte_tickets.amount_list_price,
    byte_tickets.notes,
    byte_tickets.time_door_opened,
    byte_tickets.time_door_closed,
    byte_tickets.client_name,
    byte_tickets.estd_num_users,
    byte_tickets.ts,
    byte_tickets.full_name,
    byte_tickets.door_opened_secs,
    byte_tickets.month,
    byte_tickets.week,
    byte_tickets.date,
    byte_tickets.dayofweek,
    byte_tickets.hour,
    byte_tickets.dowhour,
    byte_tickets.uniq_user
   FROM public.byte_tickets
  WHERE ((byte_tickets.ts >= (date_trunc('day'::text, ('now'::text)::timestamp without time zone) - '1 day'::interval day)) AND (byte_tickets.ts <= date_trunc('day'::text, ('now'::text)::timestamp without time zone)));


ALTER TABLE public.byte_tickets_yesterday OWNER TO dbservice;

--
-- Name: byte_users_multiple_fridges; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_users_multiple_fridges AS
 SELECT t.email_50chars,
    t.last_trans,
    t.cnt,
    t.clients
   FROM ( SELECT "left"((o.email)::text, 50) AS email_50chars,
            max(o.ts) AS last_trans,
            count(DISTINCT o.client_name) AS cnt,
            string_agg(DISTINCT (o.client_name)::text, ';'::text) AS clients
           FROM public.byte_tickets_1year o
          WHERE (((o.client_name)::text <> ALL (ARRAY[('Byte'::character varying)::text, ('Byte Foods'::character varying)::text, ('Byte Foods Inc'::character varying)::text, ('unknown or test'::character varying)::text, ('Megan Mokri'::character varying)::text, (''::character varying)::text])) AND ((o.email)::text <> ALL (ARRAY[('no@no.com'::character varying)::text, ('a@a.com'::character varying)::text])) AND ((o.email)::text !~~ '%pantry%'::text) AND ((o.email)::text !~~ '%bytefoods%'::text) AND ((o.email)::text <> ''::text))
          GROUP BY o.email) t
  WHERE ((t.clients <> 'ARE;Veracyte'::text) AND (t.cnt > 1) AND (t.last_trans > (now() - '3 mons'::interval month)))
  ORDER BY t.clients, t.email_50chars;


ALTER TABLE public.byte_users_multiple_fridges OWNER TO dbservice;

--
-- Name: byte_users_products_4months; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_users_products_4months AS
 SELECT t1.full_name,
    t1.products
   FROM ( SELECT btrim(byte_epcssold_4months.full_name) AS full_name,
            public.sort(array_agg(DISTINCT (byte_epcssold_4months.product_id)::integer)) AS products
           FROM public.byte_epcssold_4months
          WHERE ((btrim(byte_epcssold_4months.full_name) ~~ '% %'::text) AND (byte_epcssold_4months.full_name <> ''::text))
          GROUP BY byte_epcssold_4months.full_name) t1
  WHERE (array_length(t1.products, 1) > 1);


ALTER TABLE public.byte_users_products_4months OWNER TO dbservice;

--
-- Name: bytecodelog; Type: TABLE; Schema: public; Owner: dbservice
--

CREATE TABLE public.bytecodelog (
    email text NOT NULL,
    bytecode character(6) NOT NULL,
    created_at bigint NOT NULL,
    duration integer NOT NULL,
    expires_at bigint NOT NULL
);


ALTER TABLE public.bytecodelog OWNER TO dbservice;

--
-- Name: campaigns; Type: TABLE; Schema: public; Owner: dbservice
--

CREATE TABLE public.campaigns (
    campaign_id integer NOT NULL,
    title character varying(128),
    description character varying(250),
    owner character varying(24)
);


ALTER TABLE public.campaigns OWNER TO dbservice;

--
-- Name: campaigns_campaign_id_seq; Type: SEQUENCE; Schema: public; Owner: dbservice
--

CREATE SEQUENCE public.campaigns_campaign_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.campaigns_campaign_id_seq OWNER TO dbservice;

--
-- Name: campaigns_campaign_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: dbservice
--

ALTER SEQUENCE public.campaigns_campaign_id_seq OWNED BY public.campaigns.campaign_id;


--
-- Name: cogs_by_category_120d; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.cogs_by_category_120d AS
 SELECT byte_epcssold_120days.consumer_category,
    sum(byte_epcssold_120days.product_cost) AS cogs_120d,
    sum(public.if(((byte_epcssold_120days.ts >= (now() - '30 days'::interval day)) AND (byte_epcssold_120days.ts <= (now() - '00:00:00'::interval day))), byte_epcssold_120days.product_cost, 0.0)) AS cogs_0d_30d,
    sum(public.if(((byte_epcssold_120days.ts >= (now() - '60 days'::interval day)) AND (byte_epcssold_120days.ts <= (now() - '30 days'::interval day))), byte_epcssold_120days.product_cost, 0.0)) AS cogs_30d_60d,
    sum(public.if(((byte_epcssold_120days.ts >= (now() - '90 days'::interval day)) AND (byte_epcssold_120days.ts <= (now() - '60 days'::interval day))), byte_epcssold_120days.product_cost, 0.0)) AS cogs_60d_90d,
    sum(public.if(((byte_epcssold_120days.ts >= (now() - '120 days'::interval day)) AND (byte_epcssold_120days.ts <= (now() - '90 days'::interval day))), byte_epcssold_120days.product_cost, 0.0)) AS cogs_90d_120d
   FROM public.byte_epcssold_120days
  GROUP BY byte_epcssold_120days.consumer_category;


ALTER TABLE public.cogs_by_category_120d OWNER TO dbservice;

--
-- Name: sales_by_category_120d; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.sales_by_category_120d AS
 SELECT byte_epcssold_120days.consumer_category,
    sum(byte_epcssold_120days.product_price) AS sales_120d,
    sum(public.if(((byte_epcssold_120days.ts >= (now() - '30 days'::interval day)) AND (byte_epcssold_120days.ts <= (now() - '00:00:00'::interval day))), byte_epcssold_120days.product_price, 0.0)) AS sales_0d_30d,
    sum(public.if(((byte_epcssold_120days.ts >= (now() - '60 days'::interval day)) AND (byte_epcssold_120days.ts <= (now() - '30 days'::interval day))), byte_epcssold_120days.product_price, 0.0)) AS sales_30d_60d,
    sum(public.if(((byte_epcssold_120days.ts >= (now() - '90 days'::interval day)) AND (byte_epcssold_120days.ts <= (now() - '60 days'::interval day))), byte_epcssold_120days.product_price, 0.0)) AS sales_60d_90d,
    sum(public.if(((byte_epcssold_120days.ts >= (now() - '120 days'::interval day)) AND (byte_epcssold_120days.ts <= (now() - '90 days'::interval day))), byte_epcssold_120days.product_price, 0.0)) AS sales_90d_120d
   FROM public.byte_epcssold_120days
  GROUP BY byte_epcssold_120days.consumer_category;


ALTER TABLE public.sales_by_category_120d OWNER TO dbservice;

--
-- Name: spoilage_by_category_120d; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.spoilage_by_category_120d AS
 SELECT byte_spoilage.consumer_category,
    sum(byte_spoilage.cost) AS spoilage_120d,
    sum(public.if(((byte_spoilage.ts_removed >= (now() - '30 days'::interval day)) AND (byte_spoilage.ts_removed <= (now() - '00:00:00'::interval day))), byte_spoilage.cost, 0.0)) AS spoilage_0d_30d,
    sum(public.if(((byte_spoilage.ts_removed >= (now() - '60 days'::interval day)) AND (byte_spoilage.ts_removed <= (now() - '30 days'::interval day))), byte_spoilage.cost, 0.0)) AS spoilage_30d_60d,
    sum(public.if(((byte_spoilage.ts_removed >= (now() - '90 days'::interval day)) AND (byte_spoilage.ts_removed <= (now() - '60 days'::interval day))), byte_spoilage.cost, 0.0)) AS spoilage_60d_90d,
    sum(public.if(((byte_spoilage.ts_removed >= (now() - '120 days'::interval day)) AND (byte_spoilage.ts_removed <= (now() - '90 days'::interval day))), byte_spoilage.cost, 0.0)) AS spoilage_90d_120d
   FROM public.byte_spoilage
  WHERE (byte_spoilage.ts_removed > (now() - '120 days'::interval day))
  GROUP BY byte_spoilage.consumer_category;


ALTER TABLE public.spoilage_by_category_120d OWNER TO dbservice;

--
-- Name: category_stats_120d; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.category_stats_120d AS
 SELECT t1.consumer_category,
    t1.sales_0d_30d,
    t1.sales_30d_60d,
    t1.sales_60d_90d,
    t1.sales_90d_120d,
    t2.cogs_0d_30d,
    t2.cogs_30d_60d,
    t2.cogs_60d_90d,
    t2.cogs_90d_120d,
    t3.spoilage_0d_30d,
    t3.spoilage_30d_60d,
    t3.spoilage_60d_90d,
    t3.spoilage_90d_120d
   FROM ((public.sales_by_category_120d t1
     LEFT JOIN public.cogs_by_category_120d t2 ON (((t1.consumer_category)::text = (t2.consumer_category)::text)))
     LEFT JOIN public.spoilage_by_category_120d t3 ON (((t2.consumer_category)::text = (t3.consumer_category)::text)));


ALTER TABLE public.category_stats_120d OWNER TO dbservice;

--
-- Name: customer_campaigns; Type: TABLE; Schema: public; Owner: dbservice
--

CREATE TABLE public.customer_campaigns (
    customer_id integer NOT NULL,
    campaign_id integer NOT NULL,
    coupon_id character varying(14),
    status character varying(3),
    opt_out timestamp(6) with time zone,
    last_update timestamp(6) with time zone
);


ALTER TABLE public.customer_campaigns OWNER TO dbservice;

--
-- Name: customers; Type: TABLE; Schema: public; Owner: dbservice
--

CREATE TABLE public.customers (
    customer_id integer NOT NULL,
    email_address character varying(64),
    full_name character varying(64),
    kiosks integer,
    last_buy timestamp(6) with time zone,
    alt_email_address character varying(250),
    cardhash character varying(250),
    opt_out timestamp(6) with time zone,
    last_update timestamp(6) with time zone,
    editkey character varying(12),
    first_name character varying(64),
    last_name character varying(64)
);


ALTER TABLE public.customers OWNER TO dbservice;

--
-- Name: customers_customer_id_seq; Type: SEQUENCE; Schema: public; Owner: dbservice
--

CREATE SEQUENCE public.customers_customer_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.customers_customer_id_seq OWNER TO dbservice;

--
-- Name: customers_customer_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: dbservice
--

ALTER SEQUENCE public.customers_customer_id_seq OWNED BY public.customers.customer_id;


--
-- Name: dashboard_monthly_stats; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.dashboard_monthly_stats AS
 SELECT byte_epcssold.month,
    count(DISTINCT byte_epcssold.epc) AS units,
    count(DISTINCT byte_epcssold.client_name) AS active_byte_customers,
    count(DISTINCT byte_epcssold.product_id) AS active_skus,
    count(DISTINCT byte_epcssold.product_vendor) AS active_brands,
    count(DISTINCT byte_epcssold.card_hash) AS cards,
    count(DISTINCT regexp_replace(byte_epcssold.full_name, '^(.).+? (.+)'::text, ' '::text)) AS estd_uniq_usernames,
    count(DISTINCT byte_epcssold.email) AS unique_emails,
    count(DISTINCT byte_epcssold.order_id) AS tickets,
    count(DISTINCT
        CASE
            WHEN ((byte_epcssold.email IS NULL) OR ((byte_epcssold.email)::text = ''::text)) THEN ''::character varying
            ELSE byte_epcssold.order_id
        END) AS tickets_w_email
   FROM public.byte_epcssold
  GROUP BY byte_epcssold.month
  ORDER BY byte_epcssold.month;


ALTER TABLE public.dashboard_monthly_stats OWNER TO dbservice;

--
-- Name: dashboard_weekly_stats; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.dashboard_weekly_stats AS
 SELECT t1.week,
    ((t2.stockout_units_in_old_kiosks)::double precision / (((t1.num_old_kiosks)::numeric + 0.01))::double precision) AS avg_stockouts_per_old_kiosk,
    ((t2.stockout_units_in_new_kiosks)::double precision / (((t1.num_new_kiosks)::numeric + 0.01))::double precision) AS avg_stockouts_per_new_kiosk,
    ((t2.stockout_units_in_all_kiosks)::double precision / (t1.num_all_kiosks)::double precision) AS avg_stockouts_per_kiosk,
    ((t2.stockout_hrs_in_old_kiosks)::double precision / (((t1.num_old_kiosks)::numeric + 0.01))::double precision) AS avg_stockout_hrs_per_old_kiosk,
    ((t2.stockout_hrs_in_new_kiosks)::double precision / (((t1.num_new_kiosks)::numeric + 0.01))::double precision) AS avg_stockout_hrs_per_new_kiosk,
    (t2.stockout_hrs_in_all_kiosks / (t1.num_all_kiosks)::double precision) AS avg_stockout_hrs_per_kiosk
   FROM (public.byte_kiosks_by_week t1
     JOIN public.byte_stockouts_by_week t2 ON ((t1.week = t2.week)))
  ORDER BY t1.week;


ALTER TABLE public.dashboard_weekly_stats OWNER TO dbservice;

--
-- Name: date_hours_2016; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.date_hours_2016 AS
 SELECT generate_series(('2016-01-01'::date)::timestamp with time zone, ('2017-01-01'::date)::timestamp with time zone, '01:00:00'::interval) AS hour_start,
    (generate_series(('2016-01-01'::date)::timestamp with time zone, ('2017-01-01'::date)::timestamp with time zone, '01:00:00'::interval) + '01:00:00'::interval) AS hour_end;


ALTER TABLE public.date_hours_2016 OWNER TO dbservice;

--
-- Name: lastwk_hrs; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.lastwk_hrs AS
 SELECT ts.ts
   FROM generate_series((now() - '7 days'::interval day), now(), '01:00:00'::interval) ts(ts);


ALTER TABLE public.lastwk_hrs OWNER TO dbservice;

--
-- Name: dowhours; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.dowhours AS
 SELECT DISTINCT public.dowhour(lastwk_hrs.ts) AS dowhour
   FROM public.lastwk_hrs
  ORDER BY (public.dowhour(lastwk_hrs.ts));


ALTER TABLE public.dowhours OWNER TO dbservice;

--
-- Name: stockout_avg_kiosk_cat_sales_dowhour; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.stockout_avg_kiosk_cat_sales_dowhour AS
 WITH _unused AS (
         SELECT 1
        ), epcs_sold_recently AS (
         SELECT e.kiosk_id,
            e.product_id,
            e.label_price,
            e.consumer_category AS cat,
            e.dowhour
           FROM public.byte_epcssold_fast e
          WHERE (e.ts > (now() - '45 days'::interval))
        ), _avg_kiosk_sales_dowhour AS (
         SELECT epcs_sold_recently.kiosk_id,
            epcs_sold_recently.dowhour,
            sum(epcs_sold_recently.label_price) AS sales,
            count(*) AS cnt,
            (sum(epcs_sold_recently.label_price) / (count(*))::numeric) AS avg_kiosk_sales
           FROM epcs_sold_recently
          GROUP BY epcs_sold_recently.kiosk_id, epcs_sold_recently.dowhour
        ), _avg_sku_sales_dowhour AS (
         SELECT epcs_sold_recently.product_id,
            epcs_sold_recently.dowhour,
            sum(epcs_sold_recently.label_price) AS sales,
            count(*) AS cnt,
            (sum(epcs_sold_recently.label_price) / (count(*))::numeric) AS avg_sku_sales
           FROM epcs_sold_recently
          GROUP BY epcs_sold_recently.product_id, epcs_sold_recently.dowhour
        ), avg_kiosk_sales_dowhour AS (
         SELECT dh.dowhour,
            s.kiosk_id,
            s.avg_kiosk_sales
           FROM (public.dowhours dh
             JOIN _avg_kiosk_sales_dowhour s ON ((dh.dowhour = s.dowhour)))
        ), avg_sku_sales_dowhour AS (
         SELECT dh.dowhour,
            s.product_id,
            s.avg_sku_sales
           FROM (public.dowhours dh
             JOIN _avg_sku_sales_dowhour s ON ((dh.dowhour = s.dowhour)))
        ), _avg_cat_sales_dowhour AS (
         SELECT p.consumer_category AS cat,
            ss.dowhour,
            (sum(ss.sales) / sum(ss.cnt)) AS avg_cat_sales
           FROM (_avg_sku_sales_dowhour ss
             JOIN pantry.product p ON ((ss.product_id = p.id)))
          GROUP BY p.consumer_category, ss.dowhour
        ), avg_cat_sales_dowhour AS (
         SELECT dh.dowhour,
            s.cat,
            s.avg_cat_sales
           FROM (public.dowhours dh
             LEFT JOIN _avg_cat_sales_dowhour s ON ((dh.dowhour = s.dowhour)))
        ), stockout_avg_kiosk_cat_sales_dowhour AS (
         SELECT DISTINCT e.kiosk_id,
            e.cat,
            ss.dowhour,
            (COALESCE(ss.avg_cat_sales, 1.0) * COALESCE(ks.avg_kiosk_sales, 1.0)) AS avg_cat_kiosk_sales,
            ss.avg_cat_sales,
            ks.avg_kiosk_sales
           FROM ((epcs_sold_recently e
             LEFT JOIN avg_cat_sales_dowhour ss ON (((e.cat)::text = (ss.cat)::text)))
             FULL JOIN avg_kiosk_sales_dowhour ks ON (((e.kiosk_id = ks.kiosk_id) AND (ss.dowhour = ks.dowhour))))
        )
 SELECT stockout_avg_kiosk_cat_sales_dowhour.kiosk_id,
    stockout_avg_kiosk_cat_sales_dowhour.cat,
    stockout_avg_kiosk_cat_sales_dowhour.dowhour,
    stockout_avg_kiosk_cat_sales_dowhour.avg_cat_kiosk_sales,
    stockout_avg_kiosk_cat_sales_dowhour.avg_cat_sales,
    stockout_avg_kiosk_cat_sales_dowhour.avg_kiosk_sales
   FROM stockout_avg_kiosk_cat_sales_dowhour;


ALTER TABLE public.stockout_avg_kiosk_cat_sales_dowhour OWNER TO dbservice;

--
-- Name: stockout_dowhours; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.stockout_dowhours AS
 WITH _unused AS (
         SELECT 1
        ), stockouts AS (
         SELECT byte_stockouts.kiosk_id,
            byte_stockouts.product_id,
            byte_stockouts.consumer_category AS cat,
            byte_stockouts.ts AS stockout_ts,
            COALESCE(byte_stockouts.restock_ts, now()) AS restock_ts
           FROM public.byte_stockouts
          WHERE (byte_stockouts.ts > (now() - '7 days'::interval day))
        ), stockout_dowhours AS (
         SELECT s.kiosk_id,
            s.product_id,
            s.cat,
            lw.ts,
            s.restock_ts,
            public.dowhour(lw.ts) AS dowhour,
            (s.restock_ts - s.stockout_ts) AS stockout_len
           FROM stockouts s,
            public.lastwk_hrs lw
          WHERE ((s.stockout_ts <= lw.ts) AND (lw.ts < s.restock_ts))
        )
 SELECT stockout_dowhours.kiosk_id,
    stockout_dowhours.product_id,
    stockout_dowhours.cat,
    stockout_dowhours.ts,
    stockout_dowhours.restock_ts,
    stockout_dowhours.dowhour,
    stockout_dowhours.stockout_len
   FROM stockout_dowhours;


ALTER TABLE public.stockout_dowhours OWNER TO dbservice;

--
-- Name: stockout_dowhours_weighted; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.stockout_dowhours_weighted AS
 WITH _unused AS (
         SELECT 1
        ), stockout_dowhours_weighted AS (
         SELECT st.kiosk_id,
            st.product_id,
            st.cat,
            st.ts,
            st.restock_ts,
            st.dowhour,
            st.stockout_len,
            sa.avg_cat_kiosk_sales,
            sa.avg_cat_sales,
            sa.avg_kiosk_sales
           FROM (public.stockout_dowhours st
             JOIN public.stockout_avg_kiosk_cat_sales_dowhour sa ON (((st.dowhour = sa.dowhour) AND (st.kiosk_id = sa.kiosk_id) AND ((st.cat)::text = (sa.cat)::text))))
        )
 SELECT stockout_dowhours_weighted.kiosk_id,
    stockout_dowhours_weighted.product_id,
    stockout_dowhours_weighted.cat,
    stockout_dowhours_weighted.ts,
    stockout_dowhours_weighted.restock_ts,
    stockout_dowhours_weighted.dowhour,
    stockout_dowhours_weighted.stockout_len,
    stockout_dowhours_weighted.avg_cat_kiosk_sales,
    stockout_dowhours_weighted.avg_cat_sales,
    stockout_dowhours_weighted.avg_kiosk_sales
   FROM stockout_dowhours_weighted;


ALTER TABLE public.stockout_dowhours_weighted OWNER TO dbservice;

--
-- Name: dbg_stockout_dowhours_weighted; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.dbg_stockout_dowhours_weighted AS
 SELECT stockout_dowhours_weighted.kiosk_id,
    stockout_dowhours_weighted.product_id,
    stockout_dowhours_weighted.cat,
    public.fmt_ts(stockout_dowhours_weighted.ts) AS ts,
    public.fmt_ts(stockout_dowhours_weighted.restock_ts) AS restock_ts,
    stockout_dowhours_weighted.dowhour,
    public.interval_hours(stockout_dowhours_weighted.stockout_len) AS stockout_hrs,
    (stockout_dowhours_weighted.avg_cat_kiosk_sales)::numeric(6,2) AS avg_cat_kiosk_sales,
    (stockout_dowhours_weighted.avg_cat_sales)::numeric(6,2) AS avg_cat_sales,
    (stockout_dowhours_weighted.avg_kiosk_sales)::numeric(6,2) AS avg_kiosk_sales
   FROM public.stockout_dowhours_weighted
  ORDER BY stockout_dowhours_weighted.kiosk_id, stockout_dowhours_weighted.product_id, (public.fmt_ts(stockout_dowhours_weighted.ts));


ALTER TABLE public.dbg_stockout_dowhours_weighted OWNER TO dbservice;

--
-- Name: dbg_stockout_dowhours_weighted_stats; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.dbg_stockout_dowhours_weighted_stats AS
 SELECT count(*) AS count,
    count(DISTINCT stockout_dowhours_weighted.kiosk_id) AS kiosks,
    count(DISTINCT stockout_dowhours_weighted.product_id) AS products,
    count(DISTINCT stockout_dowhours_weighted.dowhour) AS dowhours,
    count(DISTINCT stockout_dowhours_weighted.cat) AS cats
   FROM public.stockout_dowhours_weighted;


ALTER TABLE public.dbg_stockout_dowhours_weighted_stats OWNER TO dbservice;

--
-- Name: stockout_runs_weighted; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.stockout_runs_weighted AS
 WITH _unused AS (
         SELECT 1
        ), stockout_runs_weighted AS (
         SELECT st.kiosk_id,
            st.product_id,
            st.stockout_len,
            min(st.ts) AS ts,
            max(st.restock_ts) AS restock_ts,
            min((st.cat)::text) AS cat,
            sum(sa.avg_cat_kiosk_sales) AS avg_cat_kiosk_sales,
            sum(sa.avg_cat_sales) AS avg_cat_sales,
            sum(sa.avg_kiosk_sales) AS avg_kiosk_sales
           FROM (public.stockout_dowhours st
             JOIN public.stockout_avg_kiosk_cat_sales_dowhour sa ON (((st.dowhour = sa.dowhour) AND (st.kiosk_id = sa.kiosk_id) AND ((st.cat)::text = (sa.cat)::text))))
          GROUP BY st.kiosk_id, st.product_id, st.stockout_len
        )
 SELECT stockout_runs_weighted.kiosk_id,
    stockout_runs_weighted.product_id,
    stockout_runs_weighted.stockout_len,
    stockout_runs_weighted.ts,
    stockout_runs_weighted.restock_ts,
    stockout_runs_weighted.cat,
    stockout_runs_weighted.avg_cat_kiosk_sales,
    stockout_runs_weighted.avg_cat_sales,
    stockout_runs_weighted.avg_kiosk_sales
   FROM stockout_runs_weighted;


ALTER TABLE public.stockout_runs_weighted OWNER TO dbservice;

--
-- Name: dbg_stockout_runs_weighted; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.dbg_stockout_runs_weighted AS
 SELECT stockout_runs_weighted.kiosk_id,
    stockout_runs_weighted.product_id,
    stockout_runs_weighted.cat,
    public.fmt_ts(stockout_runs_weighted.ts) AS stockout_ts,
    public.fmt_ts(stockout_runs_weighted.restock_ts) AS restock_ts,
    public.interval_hours(stockout_runs_weighted.stockout_len) AS stockout_hrs,
    (stockout_runs_weighted.avg_cat_kiosk_sales)::numeric(8,2) AS avg_cat_kiosk_sales,
    (stockout_runs_weighted.avg_cat_sales)::numeric(8,2) AS avg_cat_sales,
    (stockout_runs_weighted.avg_kiosk_sales)::numeric(8,2) AS avg_kiosk_sales
   FROM public.stockout_runs_weighted
  ORDER BY stockout_runs_weighted.kiosk_id, stockout_runs_weighted.product_id, stockout_runs_weighted.ts;


ALTER TABLE public.dbg_stockout_runs_weighted OWNER TO dbservice;

--
-- Name: stockout_weighted; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.stockout_weighted AS
 WITH _unused AS (
         SELECT 1
        ), stockout_weighted AS (
         SELECT stockout_runs_weighted.kiosk_id,
            stockout_runs_weighted.product_id,
            min(stockout_runs_weighted.cat) AS cat,
            sum(stockout_runs_weighted.stockout_len) AS stockout_len,
            sum(stockout_runs_weighted.avg_cat_kiosk_sales) AS avg_cat_kiosk_sales,
            sum(stockout_runs_weighted.avg_cat_sales) AS avg_cat_sales,
            sum(stockout_runs_weighted.avg_kiosk_sales) AS avg_kiosk_sales
           FROM public.stockout_runs_weighted
          GROUP BY stockout_runs_weighted.kiosk_id, stockout_runs_weighted.product_id
        )
 SELECT stockout_weighted.kiosk_id,
    stockout_weighted.product_id,
    stockout_weighted.cat,
    stockout_weighted.stockout_len,
    stockout_weighted.avg_cat_kiosk_sales,
    stockout_weighted.avg_cat_sales,
    stockout_weighted.avg_kiosk_sales
   FROM stockout_weighted;


ALTER TABLE public.stockout_weighted OWNER TO dbservice;

--
-- Name: dbg_stockout_weighted; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.dbg_stockout_weighted AS
 SELECT stockout_weighted.kiosk_id,
    stockout_weighted.product_id,
    stockout_weighted.cat,
    public.interval_hours(stockout_weighted.stockout_len) AS stockout_hrs,
    (stockout_weighted.avg_cat_kiosk_sales)::numeric(8,2) AS avg_cat_kiosk_sales,
    (stockout_weighted.avg_cat_sales)::numeric(8,2) AS avg_cat_sales,
    (stockout_weighted.avg_kiosk_sales)::numeric(8,2) AS avg_kiosk_sales
   FROM public.stockout_weighted
  ORDER BY stockout_weighted.kiosk_id, stockout_weighted.product_id, stockout_weighted.cat;


ALTER TABLE public.dbg_stockout_weighted OWNER TO dbservice;

--
-- Name: dbg_stockout_weighted_stats; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.dbg_stockout_weighted_stats AS
 SELECT count(*) AS count,
    count(DISTINCT stockout_dowhours.kiosk_id) AS kiosks,
    count(DISTINCT stockout_dowhours.product_id) AS products,
    count(DISTINCT stockout_dowhours.dowhour) AS dowhours,
    count(DISTINCT stockout_dowhours.cat) AS cats
   FROM public.stockout_dowhours;


ALTER TABLE public.dbg_stockout_weighted_stats OWNER TO dbservice;

--
-- Name: dp_epcssold; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.dp_epcssold AS
 SELECT byte_epcssold.order_id,
    byte_epcssold.first_name,
    byte_epcssold.last_name,
    byte_epcssold.kiosk_id,
    byte_epcssold.kiosk_title,
    byte_epcssold.email,
    byte_epcssold.amount_paid,
    byte_epcssold.payment_system,
    byte_epcssold.transaction_id,
    byte_epcssold.approval_code,
    byte_epcssold.status_code,
    byte_epcssold.status_message,
    byte_epcssold.status,
    byte_epcssold.batch_id,
    byte_epcssold.created,
    byte_epcssold.auth_amount,
    byte_epcssold.data_token,
    byte_epcssold.time_opened,
    byte_epcssold.time_closed,
    byte_epcssold.card_hash,
    byte_epcssold.state,
    byte_epcssold.archived,
    byte_epcssold.stamp,
    byte_epcssold.last_update,
    byte_epcssold.balance,
    byte_epcssold.delta,
    byte_epcssold.coupon_id,
    byte_epcssold.coupon,
    byte_epcssold.refund,
    byte_epcssold.receipt,
    byte_epcssold.campus_id,
    byte_epcssold.amount_list_price,
    byte_epcssold.notes,
    byte_epcssold.time_door_opened,
    byte_epcssold.time_door_closed,
    byte_epcssold.client_name,
    byte_epcssold.estd_num_users,
    byte_epcssold.ts,
    byte_epcssold.full_name,
    byte_epcssold.door_opened_secs,
    byte_epcssold.month,
    byte_epcssold.week,
    byte_epcssold.date,
    byte_epcssold.dayofweek,
    byte_epcssold.hour,
    byte_epcssold.dowhour,
    byte_epcssold.uniq_user,
    byte_epcssold.epc,
    byte_epcssold.label_order_id,
    byte_epcssold.label_status,
    byte_epcssold.label_price,
    byte_epcssold.time_created,
    byte_epcssold.time_added,
    byte_epcssold.time_updated,
    byte_epcssold.ts_created,
    byte_epcssold.ts_added,
    byte_epcssold.ts_updated,
    byte_epcssold.label_kiosk_id,
    byte_epcssold.product_id,
    byte_epcssold.product_title,
    byte_epcssold.product_archived,
    byte_epcssold.product_vendor,
    byte_epcssold.product_price,
    byte_epcssold.product_cost,
    byte_epcssold.product_shelf_life_days,
    byte_epcssold.product_attributes,
    byte_epcssold.product_categories,
    byte_epcssold.consumer_category,
    byte_epcssold.product_source
   FROM public.byte_epcssold;


ALTER TABLE public.dp_epcssold OWNER TO dbservice;

--
-- Name: dp_epcssold_2015; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.dp_epcssold_2015 AS
 SELECT dp_epcssold.order_id,
    dp_epcssold.first_name,
    dp_epcssold.last_name,
    dp_epcssold.kiosk_id,
    dp_epcssold.kiosk_title,
    dp_epcssold.email,
    dp_epcssold.amount_paid,
    dp_epcssold.payment_system,
    dp_epcssold.transaction_id,
    dp_epcssold.approval_code,
    dp_epcssold.status_code,
    dp_epcssold.status_message,
    dp_epcssold.status,
    dp_epcssold.batch_id,
    dp_epcssold.created,
    dp_epcssold.auth_amount,
    dp_epcssold.data_token,
    dp_epcssold.time_opened,
    dp_epcssold.time_closed,
    dp_epcssold.card_hash,
    dp_epcssold.state,
    dp_epcssold.archived,
    dp_epcssold.stamp,
    dp_epcssold.last_update,
    dp_epcssold.balance,
    dp_epcssold.delta,
    dp_epcssold.coupon_id,
    dp_epcssold.coupon,
    dp_epcssold.refund,
    dp_epcssold.receipt,
    dp_epcssold.campus_id,
    dp_epcssold.amount_list_price,
    dp_epcssold.notes,
    dp_epcssold.time_door_opened,
    dp_epcssold.time_door_closed,
    dp_epcssold.client_name,
    dp_epcssold.estd_num_users,
    dp_epcssold.ts,
    dp_epcssold.full_name,
    dp_epcssold.door_opened_secs,
    dp_epcssold.month,
    dp_epcssold.week,
    dp_epcssold.date,
    dp_epcssold.dayofweek,
    dp_epcssold.hour,
    dp_epcssold.dowhour,
    dp_epcssold.uniq_user,
    dp_epcssold.epc,
    dp_epcssold.label_order_id,
    dp_epcssold.label_status,
    dp_epcssold.label_price,
    dp_epcssold.time_created,
    dp_epcssold.time_added,
    dp_epcssold.time_updated,
    dp_epcssold.ts_created,
    dp_epcssold.ts_added,
    dp_epcssold.ts_updated,
    dp_epcssold.label_kiosk_id,
    dp_epcssold.product_id,
    dp_epcssold.product_title,
    dp_epcssold.product_archived,
    dp_epcssold.product_vendor,
    dp_epcssold.product_price,
    dp_epcssold.product_cost,
    dp_epcssold.product_shelf_life_days,
    dp_epcssold.product_attributes,
    dp_epcssold.product_categories,
    dp_epcssold.consumer_category,
    dp_epcssold.product_source
   FROM public.dp_epcssold
  WHERE ((dp_epcssold.ts >= '2015-01-01 08:00:00+00'::timestamp with time zone) AND (dp_epcssold.ts <= '2016-01-01 08:00:00+00'::timestamp with time zone));


ALTER TABLE public.dp_epcssold_2015 OWNER TO dbservice;

--
-- Name: dp_epcssold_2016; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.dp_epcssold_2016 AS
 SELECT dp_epcssold.order_id,
    dp_epcssold.first_name,
    dp_epcssold.last_name,
    dp_epcssold.kiosk_id,
    dp_epcssold.kiosk_title,
    dp_epcssold.email,
    dp_epcssold.amount_paid,
    dp_epcssold.payment_system,
    dp_epcssold.transaction_id,
    dp_epcssold.approval_code,
    dp_epcssold.status_code,
    dp_epcssold.status_message,
    dp_epcssold.status,
    dp_epcssold.batch_id,
    dp_epcssold.created,
    dp_epcssold.auth_amount,
    dp_epcssold.data_token,
    dp_epcssold.time_opened,
    dp_epcssold.time_closed,
    dp_epcssold.card_hash,
    dp_epcssold.state,
    dp_epcssold.archived,
    dp_epcssold.stamp,
    dp_epcssold.last_update,
    dp_epcssold.balance,
    dp_epcssold.delta,
    dp_epcssold.coupon_id,
    dp_epcssold.coupon,
    dp_epcssold.refund,
    dp_epcssold.receipt,
    dp_epcssold.campus_id,
    dp_epcssold.amount_list_price,
    dp_epcssold.notes,
    dp_epcssold.time_door_opened,
    dp_epcssold.time_door_closed,
    dp_epcssold.client_name,
    dp_epcssold.estd_num_users,
    dp_epcssold.ts,
    dp_epcssold.full_name,
    dp_epcssold.door_opened_secs,
    dp_epcssold.month,
    dp_epcssold.week,
    dp_epcssold.date,
    dp_epcssold.dayofweek,
    dp_epcssold.hour,
    dp_epcssold.dowhour,
    dp_epcssold.uniq_user,
    dp_epcssold.epc,
    dp_epcssold.label_order_id,
    dp_epcssold.label_status,
    dp_epcssold.label_price,
    dp_epcssold.time_created,
    dp_epcssold.time_added,
    dp_epcssold.time_updated,
    dp_epcssold.ts_created,
    dp_epcssold.ts_added,
    dp_epcssold.ts_updated,
    dp_epcssold.label_kiosk_id,
    dp_epcssold.product_id,
    dp_epcssold.product_title,
    dp_epcssold.product_archived,
    dp_epcssold.product_vendor,
    dp_epcssold.product_price,
    dp_epcssold.product_cost,
    dp_epcssold.product_shelf_life_days,
    dp_epcssold.product_attributes,
    dp_epcssold.product_categories,
    dp_epcssold.consumer_category,
    dp_epcssold.product_source
   FROM public.dp_epcssold
  WHERE ((dp_epcssold.ts >= '2016-01-01 08:00:00+00'::timestamp with time zone) AND (dp_epcssold.ts <= '2017-01-01 08:00:00+00'::timestamp with time zone));


ALTER TABLE public.dp_epcssold_2016 OWNER TO dbservice;

--
-- Name: dp_epcssold_2017; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.dp_epcssold_2017 AS
 SELECT dp_epcssold.order_id,
    dp_epcssold.first_name,
    dp_epcssold.last_name,
    dp_epcssold.kiosk_id,
    dp_epcssold.kiosk_title,
    dp_epcssold.email,
    dp_epcssold.amount_paid,
    dp_epcssold.payment_system,
    dp_epcssold.transaction_id,
    dp_epcssold.approval_code,
    dp_epcssold.status_code,
    dp_epcssold.status_message,
    dp_epcssold.status,
    dp_epcssold.batch_id,
    dp_epcssold.created,
    dp_epcssold.auth_amount,
    dp_epcssold.data_token,
    dp_epcssold.time_opened,
    dp_epcssold.time_closed,
    dp_epcssold.card_hash,
    dp_epcssold.state,
    dp_epcssold.archived,
    dp_epcssold.stamp,
    dp_epcssold.last_update,
    dp_epcssold.balance,
    dp_epcssold.delta,
    dp_epcssold.coupon_id,
    dp_epcssold.coupon,
    dp_epcssold.refund,
    dp_epcssold.receipt,
    dp_epcssold.campus_id,
    dp_epcssold.amount_list_price,
    dp_epcssold.notes,
    dp_epcssold.time_door_opened,
    dp_epcssold.time_door_closed,
    dp_epcssold.client_name,
    dp_epcssold.estd_num_users,
    dp_epcssold.ts,
    dp_epcssold.full_name,
    dp_epcssold.door_opened_secs,
    dp_epcssold.month,
    dp_epcssold.week,
    dp_epcssold.date,
    dp_epcssold.dayofweek,
    dp_epcssold.hour,
    dp_epcssold.dowhour,
    dp_epcssold.uniq_user,
    dp_epcssold.epc,
    dp_epcssold.label_order_id,
    dp_epcssold.label_status,
    dp_epcssold.label_price,
    dp_epcssold.time_created,
    dp_epcssold.time_added,
    dp_epcssold.time_updated,
    dp_epcssold.ts_created,
    dp_epcssold.ts_added,
    dp_epcssold.ts_updated,
    dp_epcssold.label_kiosk_id,
    dp_epcssold.product_id,
    dp_epcssold.product_title,
    dp_epcssold.product_archived,
    dp_epcssold.product_vendor,
    dp_epcssold.product_price,
    dp_epcssold.product_cost,
    dp_epcssold.product_shelf_life_days,
    dp_epcssold.product_attributes,
    dp_epcssold.product_categories,
    dp_epcssold.consumer_category,
    dp_epcssold.product_source
   FROM public.dp_epcssold
  WHERE ((dp_epcssold.ts >= '2017-01-01 08:00:00+00'::timestamp with time zone) AND (dp_epcssold.ts <= '2018-01-01 08:00:00+00'::timestamp with time zone));


ALTER TABLE public.dp_epcssold_2017 OWNER TO dbservice;

--
-- Name: dp_epcssold_4weeks; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.dp_epcssold_4weeks AS
 SELECT dp_epcssold.order_id,
    dp_epcssold.first_name,
    dp_epcssold.last_name,
    dp_epcssold.kiosk_id,
    dp_epcssold.kiosk_title,
    dp_epcssold.email,
    dp_epcssold.amount_paid,
    dp_epcssold.payment_system,
    dp_epcssold.transaction_id,
    dp_epcssold.approval_code,
    dp_epcssold.status_code,
    dp_epcssold.status_message,
    dp_epcssold.status,
    dp_epcssold.batch_id,
    dp_epcssold.created,
    dp_epcssold.auth_amount,
    dp_epcssold.data_token,
    dp_epcssold.time_opened,
    dp_epcssold.time_closed,
    dp_epcssold.card_hash,
    dp_epcssold.state,
    dp_epcssold.archived,
    dp_epcssold.stamp,
    dp_epcssold.last_update,
    dp_epcssold.balance,
    dp_epcssold.delta,
    dp_epcssold.coupon_id,
    dp_epcssold.coupon,
    dp_epcssold.refund,
    dp_epcssold.receipt,
    dp_epcssold.campus_id,
    dp_epcssold.amount_list_price,
    dp_epcssold.notes,
    dp_epcssold.time_door_opened,
    dp_epcssold.time_door_closed,
    dp_epcssold.client_name,
    dp_epcssold.estd_num_users,
    dp_epcssold.ts,
    dp_epcssold.full_name,
    dp_epcssold.door_opened_secs,
    dp_epcssold.month,
    dp_epcssold.week,
    dp_epcssold.date,
    dp_epcssold.dayofweek,
    dp_epcssold.hour,
    dp_epcssold.dowhour,
    dp_epcssold.uniq_user,
    dp_epcssold.epc,
    dp_epcssold.label_order_id,
    dp_epcssold.label_status,
    dp_epcssold.label_price,
    dp_epcssold.time_created,
    dp_epcssold.time_added,
    dp_epcssold.time_updated,
    dp_epcssold.ts_created,
    dp_epcssold.ts_added,
    dp_epcssold.ts_updated,
    dp_epcssold.label_kiosk_id,
    dp_epcssold.product_id,
    dp_epcssold.product_title,
    dp_epcssold.product_archived,
    dp_epcssold.product_vendor,
    dp_epcssold.product_price,
    dp_epcssold.product_cost,
    dp_epcssold.product_shelf_life_days,
    dp_epcssold.product_attributes,
    dp_epcssold.product_categories,
    dp_epcssold.consumer_category,
    dp_epcssold.product_source
   FROM public.dp_epcssold
  WHERE (dp_epcssold.ts > (now() - '28 days'::interval day));


ALTER TABLE public.dp_epcssold_4weeks OWNER TO dbservice;

--
-- Name: dp_epcssold_8weeks; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.dp_epcssold_8weeks AS
 SELECT dp_epcssold.order_id,
    dp_epcssold.first_name,
    dp_epcssold.last_name,
    dp_epcssold.kiosk_id,
    dp_epcssold.kiosk_title,
    dp_epcssold.email,
    dp_epcssold.amount_paid,
    dp_epcssold.payment_system,
    dp_epcssold.transaction_id,
    dp_epcssold.approval_code,
    dp_epcssold.status_code,
    dp_epcssold.status_message,
    dp_epcssold.status,
    dp_epcssold.batch_id,
    dp_epcssold.created,
    dp_epcssold.auth_amount,
    dp_epcssold.data_token,
    dp_epcssold.time_opened,
    dp_epcssold.time_closed,
    dp_epcssold.card_hash,
    dp_epcssold.state,
    dp_epcssold.archived,
    dp_epcssold.stamp,
    dp_epcssold.last_update,
    dp_epcssold.balance,
    dp_epcssold.delta,
    dp_epcssold.coupon_id,
    dp_epcssold.coupon,
    dp_epcssold.refund,
    dp_epcssold.receipt,
    dp_epcssold.campus_id,
    dp_epcssold.amount_list_price,
    dp_epcssold.notes,
    dp_epcssold.time_door_opened,
    dp_epcssold.time_door_closed,
    dp_epcssold.client_name,
    dp_epcssold.estd_num_users,
    dp_epcssold.ts,
    dp_epcssold.full_name,
    dp_epcssold.door_opened_secs,
    dp_epcssold.month,
    dp_epcssold.week,
    dp_epcssold.date,
    dp_epcssold.dayofweek,
    dp_epcssold.hour,
    dp_epcssold.dowhour,
    dp_epcssold.uniq_user,
    dp_epcssold.epc,
    dp_epcssold.label_order_id,
    dp_epcssold.label_status,
    dp_epcssold.label_price,
    dp_epcssold.time_created,
    dp_epcssold.time_added,
    dp_epcssold.time_updated,
    dp_epcssold.ts_created,
    dp_epcssold.ts_added,
    dp_epcssold.ts_updated,
    dp_epcssold.label_kiosk_id,
    dp_epcssold.product_id,
    dp_epcssold.product_title,
    dp_epcssold.product_archived,
    dp_epcssold.product_vendor,
    dp_epcssold.product_price,
    dp_epcssold.product_cost,
    dp_epcssold.product_shelf_life_days,
    dp_epcssold.product_attributes,
    dp_epcssold.product_categories,
    dp_epcssold.consumer_category,
    dp_epcssold.product_source
   FROM public.dp_epcssold
  WHERE (dp_epcssold.ts > (now() - '56 days'::interval day));


ALTER TABLE public.dp_epcssold_8weeks OWNER TO dbservice;

--
-- Name: dp_inventory_current; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.dp_inventory_current AS
 SELECT byte_inventory_current.kiosk_id,
    byte_inventory_current.product_id,
    byte_inventory_current.units
   FROM public.byte_inventory_current;


ALTER TABLE public.dp_inventory_current OWNER TO dbservice;

--
-- Name: dp_inventory_history; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.dp_inventory_history AS
 SELECT byte_inventory_history.month,
    byte_inventory_history.week,
    byte_inventory_history.date,
    byte_inventory_history.hour,
    byte_inventory_history.dayofweek,
    byte_inventory_history.ts,
    byte_inventory_history.product_id,
    byte_inventory_history.kiosk_id,
    byte_inventory_history.qty,
    byte_inventory_history.product_title,
    byte_inventory_history.kiosk_title
   FROM public.byte_inventory_history;


ALTER TABLE public.dp_inventory_history OWNER TO dbservice;

--
-- Name: dp_kiosks; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.dp_kiosks AS
 SELECT byte_kiosks.id,
    byte_kiosks.title,
    byte_kiosks.client_name,
    byte_kiosks.address,
    byte_kiosks.location_x,
    byte_kiosks.location_y,
    byte_kiosks.archived,
    to_timestamp((byte_kiosks.creation_time)::double precision) AS creation_ts,
    to_timestamp((byte_kiosks.deployment_time)::double precision) AS deployment_ts,
    byte_kiosks.timezone,
    byte_kiosks.estd_num_users
   FROM public.byte_kiosks;


ALTER TABLE public.dp_kiosks OWNER TO dbservice;

--
-- Name: dp_products; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.dp_products AS
 SELECT byte_products.id,
    byte_products.title,
    byte_products.vendor,
    byte_products.price,
    byte_products.cost,
    byte_products.shelf_life_days,
    byte_products.attributes,
    byte_products.categories
   FROM public.byte_products;


ALTER TABLE public.dp_products OWNER TO dbservice;

--
-- Name: dp_spoilage; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.dp_spoilage AS
 SELECT byte_spoilage.kiosk_id,
    byte_spoilage.order_id,
    byte_spoilage.epc,
    byte_spoilage.product_id,
    byte_spoilage.ts_added,
    byte_spoilage.ts_removed,
    byte_spoilage.id,
    byte_spoilage.title,
    byte_spoilage.description,
    byte_spoilage.tiny_description,
    byte_spoilage.short_description,
    byte_spoilage.medium_description,
    byte_spoilage.long_description,
    byte_spoilage.price,
    byte_spoilage.cost,
    byte_spoilage.shelf_time,
    byte_spoilage.campus_id,
    byte_spoilage.image,
    byte_spoilage.image_time,
    byte_spoilage.last_update,
    byte_spoilage.archived,
    byte_spoilage.taxable,
    byte_spoilage.allergens,
    byte_spoilage.attribute_names,
    byte_spoilage.categories,
    byte_spoilage.category_names,
    byte_spoilage.vendor,
    byte_spoilage.source,
    byte_spoilage.notes,
    byte_spoilage.total_cal,
    byte_spoilage.num_servings,
    byte_spoilage.ingredients,
    byte_spoilage.calories,
    byte_spoilage.proteins,
    byte_spoilage.sugar,
    byte_spoilage.carbohydrates,
    byte_spoilage.fat,
    byte_spoilage.consumer_category,
    byte_spoilage.ws_case_size,
    byte_spoilage.kiosk_ship_qty,
    byte_spoilage.ws_case_cost,
    byte_spoilage.pick_station,
    byte_spoilage.fc_title,
    byte_spoilage.pricing_tier,
    byte_spoilage.width_space,
    byte_spoilage.height_space,
    byte_spoilage.depth_space,
    byte_spoilage.slotted_width,
    byte_spoilage.tag_volume,
    byte_spoilage.delivery_option,
    byte_spoilage.kiosk_title,
    byte_spoilage.address,
    byte_spoilage.location_x,
    byte_spoilage.location_y,
    byte_spoilage.client_name,
    byte_spoilage.tags,
    byte_spoilage.estd_num_users,
    byte_spoilage.month,
    byte_spoilage.week,
    byte_spoilage.date
   FROM public.byte_spoilage;


ALTER TABLE public.dp_spoilage OWNER TO dbservice;

--
-- Name: dp_spoilage_2016; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.dp_spoilage_2016 AS
 SELECT dp_spoilage.kiosk_id,
    dp_spoilage.order_id,
    dp_spoilage.epc,
    dp_spoilage.product_id,
    dp_spoilage.ts_added,
    dp_spoilage.ts_removed,
    dp_spoilage.id,
    dp_spoilage.title,
    dp_spoilage.description,
    dp_spoilage.tiny_description,
    dp_spoilage.short_description,
    dp_spoilage.medium_description,
    dp_spoilage.long_description,
    dp_spoilage.price,
    dp_spoilage.cost,
    dp_spoilage.shelf_time,
    dp_spoilage.campus_id,
    dp_spoilage.image,
    dp_spoilage.image_time,
    dp_spoilage.last_update,
    dp_spoilage.archived,
    dp_spoilage.taxable,
    dp_spoilage.allergens,
    dp_spoilage.attribute_names,
    dp_spoilage.categories,
    dp_spoilage.category_names,
    dp_spoilage.vendor,
    dp_spoilage.source,
    dp_spoilage.notes,
    dp_spoilage.total_cal,
    dp_spoilage.num_servings,
    dp_spoilage.ingredients,
    dp_spoilage.calories,
    dp_spoilage.proteins,
    dp_spoilage.sugar,
    dp_spoilage.carbohydrates,
    dp_spoilage.fat,
    dp_spoilage.consumer_category,
    dp_spoilage.ws_case_size,
    dp_spoilage.kiosk_ship_qty,
    dp_spoilage.ws_case_cost,
    dp_spoilage.pick_station,
    dp_spoilage.fc_title,
    dp_spoilage.pricing_tier,
    dp_spoilage.width_space,
    dp_spoilage.height_space,
    dp_spoilage.depth_space,
    dp_spoilage.slotted_width,
    dp_spoilage.tag_volume,
    dp_spoilage.delivery_option,
    dp_spoilage.kiosk_title,
    dp_spoilage.address,
    dp_spoilage.location_x,
    dp_spoilage.location_y,
    dp_spoilage.client_name,
    dp_spoilage.tags,
    dp_spoilage.estd_num_users,
    dp_spoilage.month,
    dp_spoilage.week,
    dp_spoilage.date
   FROM public.dp_spoilage
  WHERE ((dp_spoilage.ts_removed >= '2016-01-01 08:00:00+00'::timestamp with time zone) AND (dp_spoilage.ts_removed <= '2017-01-01 08:00:00+00'::timestamp with time zone));


ALTER TABLE public.dp_spoilage_2016 OWNER TO dbservice;

--
-- Name: dp_spoilage_2017; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.dp_spoilage_2017 AS
 SELECT dp_spoilage.kiosk_id,
    dp_spoilage.order_id,
    dp_spoilage.epc,
    dp_spoilage.product_id,
    dp_spoilage.ts_added,
    dp_spoilage.ts_removed,
    dp_spoilage.id,
    dp_spoilage.title,
    dp_spoilage.description,
    dp_spoilage.tiny_description,
    dp_spoilage.short_description,
    dp_spoilage.medium_description,
    dp_spoilage.long_description,
    dp_spoilage.price,
    dp_spoilage.cost,
    dp_spoilage.shelf_time,
    dp_spoilage.campus_id,
    dp_spoilage.image,
    dp_spoilage.image_time,
    dp_spoilage.last_update,
    dp_spoilage.archived,
    dp_spoilage.taxable,
    dp_spoilage.allergens,
    dp_spoilage.attribute_names,
    dp_spoilage.categories,
    dp_spoilage.category_names,
    dp_spoilage.vendor,
    dp_spoilage.source,
    dp_spoilage.notes,
    dp_spoilage.total_cal,
    dp_spoilage.num_servings,
    dp_spoilage.ingredients,
    dp_spoilage.calories,
    dp_spoilage.proteins,
    dp_spoilage.sugar,
    dp_spoilage.carbohydrates,
    dp_spoilage.fat,
    dp_spoilage.consumer_category,
    dp_spoilage.ws_case_size,
    dp_spoilage.kiosk_ship_qty,
    dp_spoilage.ws_case_cost,
    dp_spoilage.pick_station,
    dp_spoilage.fc_title,
    dp_spoilage.pricing_tier,
    dp_spoilage.width_space,
    dp_spoilage.height_space,
    dp_spoilage.depth_space,
    dp_spoilage.slotted_width,
    dp_spoilage.tag_volume,
    dp_spoilage.delivery_option,
    dp_spoilage.kiosk_title,
    dp_spoilage.address,
    dp_spoilage.location_x,
    dp_spoilage.location_y,
    dp_spoilage.client_name,
    dp_spoilage.tags,
    dp_spoilage.estd_num_users,
    dp_spoilage.month,
    dp_spoilage.week,
    dp_spoilage.date
   FROM public.dp_spoilage
  WHERE ((dp_spoilage.ts_removed >= '2017-01-01 08:00:00+00'::timestamp with time zone) AND (dp_spoilage.ts_removed <= '2018-01-01 08:00:00+00'::timestamp with time zone));


ALTER TABLE public.dp_spoilage_2017 OWNER TO dbservice;

--
-- Name: dp_spoilage_4weeks; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.dp_spoilage_4weeks AS
 SELECT dp_spoilage.kiosk_id,
    dp_spoilage.order_id,
    dp_spoilage.epc,
    dp_spoilage.product_id,
    dp_spoilage.ts_added,
    dp_spoilage.ts_removed,
    dp_spoilage.id,
    dp_spoilage.title,
    dp_spoilage.description,
    dp_spoilage.tiny_description,
    dp_spoilage.short_description,
    dp_spoilage.medium_description,
    dp_spoilage.long_description,
    dp_spoilage.price,
    dp_spoilage.cost,
    dp_spoilage.shelf_time,
    dp_spoilage.campus_id,
    dp_spoilage.image,
    dp_spoilage.image_time,
    dp_spoilage.last_update,
    dp_spoilage.archived,
    dp_spoilage.taxable,
    dp_spoilage.allergens,
    dp_spoilage.attribute_names,
    dp_spoilage.categories,
    dp_spoilage.category_names,
    dp_spoilage.vendor,
    dp_spoilage.source,
    dp_spoilage.notes,
    dp_spoilage.total_cal,
    dp_spoilage.num_servings,
    dp_spoilage.ingredients,
    dp_spoilage.calories,
    dp_spoilage.proteins,
    dp_spoilage.sugar,
    dp_spoilage.carbohydrates,
    dp_spoilage.fat,
    dp_spoilage.consumer_category,
    dp_spoilage.ws_case_size,
    dp_spoilage.kiosk_ship_qty,
    dp_spoilage.ws_case_cost,
    dp_spoilage.pick_station,
    dp_spoilage.fc_title,
    dp_spoilage.pricing_tier,
    dp_spoilage.width_space,
    dp_spoilage.height_space,
    dp_spoilage.depth_space,
    dp_spoilage.slotted_width,
    dp_spoilage.tag_volume,
    dp_spoilage.delivery_option,
    dp_spoilage.kiosk_title,
    dp_spoilage.address,
    dp_spoilage.location_x,
    dp_spoilage.location_y,
    dp_spoilage.client_name,
    dp_spoilage.tags,
    dp_spoilage.estd_num_users,
    dp_spoilage.month,
    dp_spoilage.week,
    dp_spoilage.date
   FROM public.dp_spoilage
  WHERE (dp_spoilage.ts_removed > (now() - '28 days'::interval day));


ALTER TABLE public.dp_spoilage_4weeks OWNER TO dbservice;

--
-- Name: dp_spoilage_8weeks; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.dp_spoilage_8weeks AS
 SELECT dp_spoilage.kiosk_id,
    dp_spoilage.order_id,
    dp_spoilage.epc,
    dp_spoilage.product_id,
    dp_spoilage.ts_added,
    dp_spoilage.ts_removed,
    dp_spoilage.id,
    dp_spoilage.title,
    dp_spoilage.description,
    dp_spoilage.tiny_description,
    dp_spoilage.short_description,
    dp_spoilage.medium_description,
    dp_spoilage.long_description,
    dp_spoilage.price,
    dp_spoilage.cost,
    dp_spoilage.shelf_time,
    dp_spoilage.campus_id,
    dp_spoilage.image,
    dp_spoilage.image_time,
    dp_spoilage.last_update,
    dp_spoilage.archived,
    dp_spoilage.taxable,
    dp_spoilage.allergens,
    dp_spoilage.attribute_names,
    dp_spoilage.categories,
    dp_spoilage.category_names,
    dp_spoilage.vendor,
    dp_spoilage.source,
    dp_spoilage.notes,
    dp_spoilage.total_cal,
    dp_spoilage.num_servings,
    dp_spoilage.ingredients,
    dp_spoilage.calories,
    dp_spoilage.proteins,
    dp_spoilage.sugar,
    dp_spoilage.carbohydrates,
    dp_spoilage.fat,
    dp_spoilage.consumer_category,
    dp_spoilage.ws_case_size,
    dp_spoilage.kiosk_ship_qty,
    dp_spoilage.ws_case_cost,
    dp_spoilage.pick_station,
    dp_spoilage.fc_title,
    dp_spoilage.pricing_tier,
    dp_spoilage.width_space,
    dp_spoilage.height_space,
    dp_spoilage.depth_space,
    dp_spoilage.slotted_width,
    dp_spoilage.tag_volume,
    dp_spoilage.delivery_option,
    dp_spoilage.kiosk_title,
    dp_spoilage.address,
    dp_spoilage.location_x,
    dp_spoilage.location_y,
    dp_spoilage.client_name,
    dp_spoilage.tags,
    dp_spoilage.estd_num_users,
    dp_spoilage.month,
    dp_spoilage.week,
    dp_spoilage.date
   FROM public.dp_spoilage
  WHERE (dp_spoilage.ts_removed > (now() - '56 days'::interval day));


ALTER TABLE public.dp_spoilage_8weeks OWNER TO dbservice;

--
-- Name: dp_spoilage_daily_sold_join; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.dp_spoilage_daily_sold_join AS
 SELECT COALESCE(t1.date, t2.date) AS date,
    COALESCE((t1.kiosk_id)::bigint, t2.kiosk_id) AS kiosk_id,
    COALESCE((t1.product_id)::bigint, t2.product_id) AS product_id,
    COALESCE(t1.spoiled, (0)::bigint) AS spoiled,
    COALESCE(t2.sold, (0)::bigint) AS sold
   FROM (( SELECT s.date,
            s.kiosk_id,
            s.product_id,
            count(*) AS spoiled
           FROM public.dp_spoilage s
          GROUP BY s.date, s.kiosk_id, s.product_id) t1
     FULL JOIN ( SELECT dp_epcssold.date,
            dp_epcssold.kiosk_id,
            dp_epcssold.product_id,
            count(*) AS sold
           FROM public.dp_epcssold
          GROUP BY dp_epcssold.date, dp_epcssold.kiosk_id, dp_epcssold.product_id) t2 ON (((t1.product_id = t2.product_id) AND (t1.date = t2.date) AND (t1.kiosk_id = t2.kiosk_id))));


ALTER TABLE public.dp_spoilage_daily_sold_join OWNER TO dbservice;

--
-- Name: dp_spoilage_daily_kiosk_product_pct; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.dp_spoilage_daily_kiosk_product_pct AS
 SELECT t.date,
    t.kiosk_id,
    t.product_id,
    t.spoiled,
    t.sold,
    t.product_title,
    t.kiosk_title,
    t.unit_price,
    t.unit_cost,
    t.spoiled_frac_units,
    t.revenue,
    t.cost,
    t.spoilage_frac,
    t.new_kiosk,
    (t.revenue - t.cost) AS net_profit
   FROM ( SELECT dpssj.date,
            dpssj.kiosk_id,
            dpssj.product_id,
            dpssj.spoiled,
            dpssj.sold,
            p.title AS product_title,
            k.title AS kiosk_title,
            p.price AS unit_price,
            p.cost AS unit_cost,
            public.frac((dpssj.spoiled)::numeric, (dpssj.sold)::numeric) AS spoiled_frac_units,
            ((dpssj.sold)::numeric * p.price) AS revenue,
            (((dpssj.spoiled + dpssj.sold))::numeric * p.cost) AS cost,
            public.if((dpssj.sold = 0), (9999.0)::double precision, (div(((dpssj.spoiled)::numeric * p.cost), ((dpssj.sold)::numeric * p.price)))::double precision) AS spoilage_frac,
            (dpssj.date < COALESCE(knn.new_ts, now())) AS new_kiosk
           FROM (((public.dp_spoilage_daily_sold_join dpssj
             LEFT JOIN pantry.product p ON ((dpssj.product_id = p.id)))
             LEFT JOIN public.byte_kiosks k ON ((dpssj.kiosk_id = k.id)))
             LEFT JOIN public.byte_kiosks_date_non_new knn ON ((k.id = knn.kiosk_id)))
          WHERE (dpssj.date >= '2016-01-01 08:00:00+00'::timestamp with time zone)) t
  ORDER BY t.date DESC;


ALTER TABLE public.dp_spoilage_daily_kiosk_product_pct OWNER TO dbservice;

--
-- Name: dp_spoilage_daily_kiosk_pct; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.dp_spoilage_daily_kiosk_pct AS
 SELECT dp_spoilage_daily_kiosk_product_pct.date,
    dp_spoilage_daily_kiosk_product_pct.kiosk_id,
    sum(dp_spoilage_daily_kiosk_product_pct.spoiled) AS spoiled_units,
    sum(dp_spoilage_daily_kiosk_product_pct.sold) AS sold_units,
    public.frac(sum(dp_spoilage_daily_kiosk_product_pct.spoiled), sum(dp_spoilage_daily_kiosk_product_pct.sold)) AS spoiled_frac_units,
    sum(dp_spoilage_daily_kiosk_product_pct.revenue) AS revenue,
    sum(dp_spoilage_daily_kiosk_product_pct.cost) AS cost,
    sum(((dp_spoilage_daily_kiosk_product_pct.spoiled)::numeric * dp_spoilage_daily_kiosk_product_pct.unit_cost)) AS spoilage_dolr,
    sum(dp_spoilage_daily_kiosk_product_pct.net_profit) AS net_profit,
    public.if((sum(dp_spoilage_daily_kiosk_product_pct.sold) = (0)::numeric), 9999.0, (sum(((dp_spoilage_daily_kiosk_product_pct.spoiled)::numeric * dp_spoilage_daily_kiosk_product_pct.unit_cost)) / sum(dp_spoilage_daily_kiosk_product_pct.revenue))) AS spoilage_frac,
    min((dp_spoilage_daily_kiosk_product_pct.kiosk_title)::text) AS kiosk_title,
    bool_and(dp_spoilage_daily_kiosk_product_pct.new_kiosk) AS new_kiosk
   FROM public.dp_spoilage_daily_kiosk_product_pct
  GROUP BY dp_spoilage_daily_kiosk_product_pct.date, dp_spoilage_daily_kiosk_product_pct.kiosk_id
  ORDER BY dp_spoilage_daily_kiosk_product_pct.kiosk_id, dp_spoilage_daily_kiosk_product_pct.date DESC;


ALTER TABLE public.dp_spoilage_daily_kiosk_pct OWNER TO dbservice;

--
-- Name: dp_spoilage_daily_pct; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.dp_spoilage_daily_pct AS
 SELECT dp_spoilage_daily_kiosk_product_pct.date,
    dp_spoilage_daily_kiosk_product_pct.new_kiosk,
    sum(dp_spoilage_daily_kiosk_product_pct.spoiled) AS spoiled_units,
    sum(dp_spoilage_daily_kiosk_product_pct.sold) AS sold_units,
    public.frac(sum(dp_spoilage_daily_kiosk_product_pct.spoiled), sum(dp_spoilage_daily_kiosk_product_pct.sold)) AS spoiled_frac_units,
    sum(dp_spoilage_daily_kiosk_product_pct.revenue) AS revenue,
    sum(dp_spoilage_daily_kiosk_product_pct.cost) AS cost,
    sum(((dp_spoilage_daily_kiosk_product_pct.spoiled)::numeric * dp_spoilage_daily_kiosk_product_pct.unit_cost)) AS spoilage_dolr,
    sum((dp_spoilage_daily_kiosk_product_pct.revenue - dp_spoilage_daily_kiosk_product_pct.cost)) AS net_profit,
    public.if((sum(dp_spoilage_daily_kiosk_product_pct.sold) = (0)::numeric), 9999.0, (sum(((dp_spoilage_daily_kiosk_product_pct.spoiled)::numeric * dp_spoilage_daily_kiosk_product_pct.unit_cost)) / sum(dp_spoilage_daily_kiosk_product_pct.revenue))) AS spoilage_frac_dolr
   FROM public.dp_spoilage_daily_kiosk_product_pct
  GROUP BY dp_spoilage_daily_kiosk_product_pct.date, dp_spoilage_daily_kiosk_product_pct.new_kiosk
  ORDER BY dp_spoilage_daily_kiosk_product_pct.date DESC, dp_spoilage_daily_kiosk_product_pct.new_kiosk;


ALTER TABLE public.dp_spoilage_daily_pct OWNER TO dbservice;

--
-- Name: dp_spoilage_daily_product_pct; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.dp_spoilage_daily_product_pct AS
 SELECT dp_spoilage_daily_kiosk_product_pct.date,
    dp_spoilage_daily_kiosk_product_pct.product_id,
    dp_spoilage_daily_kiosk_product_pct.new_kiosk,
    sum(dp_spoilage_daily_kiosk_product_pct.spoiled) AS spoiled_units,
    sum(dp_spoilage_daily_kiosk_product_pct.sold) AS sold_units,
    public.frac(sum(dp_spoilage_daily_kiosk_product_pct.spoiled), sum(dp_spoilage_daily_kiosk_product_pct.sold)) AS spoiled_frac_units,
    sum(dp_spoilage_daily_kiosk_product_pct.revenue) AS revenue,
    sum(dp_spoilage_daily_kiosk_product_pct.cost) AS cost,
    sum(((dp_spoilage_daily_kiosk_product_pct.spoiled)::numeric * dp_spoilage_daily_kiosk_product_pct.unit_cost)) AS spoilage_dolr,
    sum(dp_spoilage_daily_kiosk_product_pct.net_profit) AS net_profit,
    public.if((sum(dp_spoilage_daily_kiosk_product_pct.sold) = (0)::numeric), 9999.0, (sum(((dp_spoilage_daily_kiosk_product_pct.spoiled)::numeric * dp_spoilage_daily_kiosk_product_pct.unit_cost)) / sum(dp_spoilage_daily_kiosk_product_pct.revenue))) AS spoilage_frac_dolr
   FROM public.dp_spoilage_daily_kiosk_product_pct
  GROUP BY dp_spoilage_daily_kiosk_product_pct.date, dp_spoilage_daily_kiosk_product_pct.product_id, dp_spoilage_daily_kiosk_product_pct.new_kiosk
  ORDER BY dp_spoilage_daily_kiosk_product_pct.product_id, dp_spoilage_daily_kiosk_product_pct.date DESC, dp_spoilage_daily_kiosk_product_pct.new_kiosk;


ALTER TABLE public.dp_spoilage_daily_product_pct OWNER TO dbservice;

--
-- Name: dp_spoilage_monthly_sold_join; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.dp_spoilage_monthly_sold_join AS
 SELECT COALESCE(t1.month, t2.month) AS month,
    COALESCE((t1.kiosk_id)::bigint, t2.kiosk_id) AS kiosk_id,
    COALESCE((t1.product_id)::bigint, t2.product_id) AS product_id,
    COALESCE(t1.spoiled, (0)::bigint) AS spoiled,
    COALESCE(t2.sold, (0)::bigint) AS sold
   FROM (( SELECT s.month,
            s.kiosk_id,
            s.product_id,
            count(*) AS spoiled
           FROM public.dp_spoilage s
          GROUP BY s.month, s.kiosk_id, s.product_id) t1
     FULL JOIN ( SELECT dp_epcssold.month,
            dp_epcssold.kiosk_id,
            dp_epcssold.product_id,
            count(*) AS sold
           FROM public.dp_epcssold
          GROUP BY dp_epcssold.month, dp_epcssold.kiosk_id, dp_epcssold.product_id) t2 ON (((t1.product_id = t2.product_id) AND (t1.month = t2.month) AND (t1.kiosk_id = t2.kiosk_id))));


ALTER TABLE public.dp_spoilage_monthly_sold_join OWNER TO dbservice;

--
-- Name: dp_spoilage_monthly_calc; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.dp_spoilage_monthly_calc AS
 SELECT dpssj.month,
    dpssj.kiosk_id,
    dpssj.product_id,
    dpssj.spoiled,
    dpssj.sold,
    p.title AS product_title,
    k.title AS kiosk_title,
    p.price AS unit_price,
    p.cost AS unit_cost,
    public.frac((dpssj.spoiled)::numeric, (dpssj.sold)::numeric) AS spoiled_frac_units,
    ((dpssj.sold)::numeric * p.price) AS revenue,
    (((dpssj.spoiled + dpssj.sold))::numeric * p.cost) AS cost,
    public.if((dpssj.sold = 0), 9999.0, (((1.0 * (dpssj.spoiled)::numeric) * p.cost) / ((dpssj.sold)::numeric * p.price))) AS spoilage_frac,
    (dpssj.month < knn.new_ts) AS new_kiosk
   FROM (((public.dp_spoilage_monthly_sold_join dpssj
     JOIN pantry.product p ON ((dpssj.product_id = p.id)))
     JOIN public.byte_kiosks k ON ((dpssj.kiosk_id = k.id)))
     JOIN public.byte_kiosks_date_non_new knn ON ((k.id = knn.kiosk_id)))
  WHERE (dpssj.month >= '2016-01-01 08:00:00+00'::timestamp with time zone)
  ORDER BY dpssj.month DESC;


ALTER TABLE public.dp_spoilage_monthly_calc OWNER TO dbservice;

--
-- Name: dp_spoilage_monthly_kiosk_product_pct; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.dp_spoilage_monthly_kiosk_product_pct AS
 SELECT dp_spoilage_monthly_calc.month,
    dp_spoilage_monthly_calc.kiosk_id,
    dp_spoilage_monthly_calc.product_id,
    dp_spoilage_monthly_calc.spoiled,
    dp_spoilage_monthly_calc.sold,
    dp_spoilage_monthly_calc.product_title,
    dp_spoilage_monthly_calc.kiosk_title,
    dp_spoilage_monthly_calc.unit_price,
    dp_spoilage_monthly_calc.unit_cost,
    dp_spoilage_monthly_calc.spoiled_frac_units,
    dp_spoilage_monthly_calc.revenue,
    dp_spoilage_monthly_calc.cost,
    dp_spoilage_monthly_calc.spoilage_frac,
    dp_spoilage_monthly_calc.new_kiosk,
    (dp_spoilage_monthly_calc.revenue - dp_spoilage_monthly_calc.cost) AS net_profit
   FROM public.dp_spoilage_monthly_calc;


ALTER TABLE public.dp_spoilage_monthly_kiosk_product_pct OWNER TO dbservice;

--
-- Name: dp_spoilage_monthly_kiosk_pct; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.dp_spoilage_monthly_kiosk_pct AS
 SELECT dp_spoilage_monthly_kiosk_product_pct.month,
    dp_spoilage_monthly_kiosk_product_pct.kiosk_id,
    sum(dp_spoilage_monthly_kiosk_product_pct.spoiled) AS spoiled_units,
    sum(dp_spoilage_monthly_kiosk_product_pct.sold) AS sold_units,
    public.frac(sum(dp_spoilage_monthly_kiosk_product_pct.spoiled), sum(dp_spoilage_monthly_kiosk_product_pct.sold)) AS spoiled_frac_units,
    sum(dp_spoilage_monthly_kiosk_product_pct.revenue) AS revenue,
    sum(dp_spoilage_monthly_kiosk_product_pct.cost) AS cost,
    sum(((dp_spoilage_monthly_kiosk_product_pct.spoiled)::numeric * dp_spoilage_monthly_kiosk_product_pct.unit_cost)) AS spoilage_dolr,
    sum(dp_spoilage_monthly_kiosk_product_pct.net_profit) AS net_profit,
    public.if((sum(dp_spoilage_monthly_kiosk_product_pct.sold) = (0)::numeric), 9999.0, (sum(((dp_spoilage_monthly_kiosk_product_pct.spoiled)::numeric * dp_spoilage_monthly_kiosk_product_pct.unit_cost)) / sum(dp_spoilage_monthly_kiosk_product_pct.revenue))) AS spoilage_frac_dolr
   FROM public.dp_spoilage_monthly_kiosk_product_pct
  GROUP BY dp_spoilage_monthly_kiosk_product_pct.month, dp_spoilage_monthly_kiosk_product_pct.kiosk_id
  ORDER BY dp_spoilage_monthly_kiosk_product_pct.kiosk_id, dp_spoilage_monthly_kiosk_product_pct.month DESC;


ALTER TABLE public.dp_spoilage_monthly_kiosk_pct OWNER TO dbservice;

--
-- Name: dp_spoilage_monthly_pct; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.dp_spoilage_monthly_pct AS
 SELECT dp_spoilage_monthly_kiosk_product_pct.month,
    sum(dp_spoilage_monthly_kiosk_product_pct.spoiled) AS spoiled_units,
    sum(dp_spoilage_monthly_kiosk_product_pct.sold) AS sold_units,
    public.frac(sum(dp_spoilage_monthly_kiosk_product_pct.spoiled), sum(dp_spoilage_monthly_kiosk_product_pct.sold)) AS spoiled_frac_units,
    sum(dp_spoilage_monthly_kiosk_product_pct.revenue) AS revenue,
    sum(dp_spoilage_monthly_kiosk_product_pct.cost) AS cost,
    sum(((dp_spoilage_monthly_kiosk_product_pct.spoiled)::numeric * dp_spoilage_monthly_kiosk_product_pct.unit_cost)) AS spoilage_dolr,
    sum(dp_spoilage_monthly_kiosk_product_pct.net_profit) AS net_profit,
    (sum(((dp_spoilage_monthly_kiosk_product_pct.spoiled)::numeric * dp_spoilage_monthly_kiosk_product_pct.unit_cost)) / sum(((dp_spoilage_monthly_kiosk_product_pct.sold)::numeric * dp_spoilage_monthly_kiosk_product_pct.unit_price))) AS spoilage_frac_dolr
   FROM public.dp_spoilage_monthly_kiosk_product_pct
  GROUP BY dp_spoilage_monthly_kiosk_product_pct.month
  ORDER BY dp_spoilage_monthly_kiosk_product_pct.month DESC;


ALTER TABLE public.dp_spoilage_monthly_pct OWNER TO dbservice;

--
-- Name: dp_spoilage_monthly_product_pct; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.dp_spoilage_monthly_product_pct AS
 SELECT dp_spoilage_monthly_kiosk_product_pct.month,
    dp_spoilage_monthly_kiosk_product_pct.product_id,
    sum(dp_spoilage_monthly_kiosk_product_pct.spoiled) AS spoiled_units,
    sum(dp_spoilage_monthly_kiosk_product_pct.sold) AS sold_units,
    public.frac(sum(dp_spoilage_monthly_kiosk_product_pct.spoiled), sum(dp_spoilage_monthly_kiosk_product_pct.sold)) AS spoiled_frac_units,
    sum(dp_spoilage_monthly_kiosk_product_pct.revenue) AS revenue,
    sum(dp_spoilage_monthly_kiosk_product_pct.cost) AS cost,
    sum(((dp_spoilage_monthly_kiosk_product_pct.spoiled)::numeric * dp_spoilage_monthly_kiosk_product_pct.unit_cost)) AS spoilage_dolr,
    sum(dp_spoilage_monthly_kiosk_product_pct.net_profit) AS net_profit,
    public.if((sum(dp_spoilage_monthly_kiosk_product_pct.sold) = (0)::numeric), 9999.0, (sum(((dp_spoilage_monthly_kiosk_product_pct.spoiled)::numeric * dp_spoilage_monthly_kiosk_product_pct.unit_cost)) / sum(dp_spoilage_monthly_kiosk_product_pct.revenue))) AS spoilage_frac_dolr
   FROM public.dp_spoilage_monthly_kiosk_product_pct
  GROUP BY dp_spoilage_monthly_kiosk_product_pct.month, dp_spoilage_monthly_kiosk_product_pct.product_id
  ORDER BY dp_spoilage_monthly_kiosk_product_pct.product_id, dp_spoilage_monthly_kiosk_product_pct.month DESC;


ALTER TABLE public.dp_spoilage_monthly_product_pct OWNER TO dbservice;

--
-- Name: dp_spoilage_weekly_sold_join; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.dp_spoilage_weekly_sold_join AS
 SELECT date_trunc('week'::text, dp_spoilage_daily_sold_join.date) AS week,
    dp_spoilage_daily_sold_join.kiosk_id,
    dp_spoilage_daily_sold_join.product_id,
    sum(dp_spoilage_daily_sold_join.spoiled) AS spoiled,
    sum(dp_spoilage_daily_sold_join.sold) AS sold,
    count(DISTINCT dp_spoilage_daily_sold_join.date) AS days_in_week
   FROM public.dp_spoilage_daily_sold_join
  GROUP BY (date_trunc('week'::text, dp_spoilage_daily_sold_join.date)), dp_spoilage_daily_sold_join.kiosk_id, dp_spoilage_daily_sold_join.product_id;


ALTER TABLE public.dp_spoilage_weekly_sold_join OWNER TO dbservice;

--
-- Name: dp_spoilage_weekly_kiosk_product_pct; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.dp_spoilage_weekly_kiosk_product_pct AS
 SELECT t.week,
    t.kiosk_id,
    t.product_id,
    t.spoiled,
    t.sold,
    t.days_in_week,
    t.product_title,
    t.kiosk_title,
    t.unit_price,
    t.unit_cost,
    t.spoiled_frac_units,
    t.revenue,
    t.cost,
    t.spoilage_frac,
    t.new_kiosk,
    (t.revenue - t.cost) AS net_profit
   FROM ( SELECT dpssj.week,
            dpssj.kiosk_id,
            dpssj.product_id,
            dpssj.spoiled,
            dpssj.sold,
            dpssj.days_in_week,
            p.title AS product_title,
            k.title AS kiosk_title,
            p.price AS unit_price,
            p.cost AS unit_cost,
            public.frac(dpssj.spoiled, dpssj.sold) AS spoiled_frac_units,
            (dpssj.sold * p.price) AS revenue,
            ((dpssj.spoiled + dpssj.sold) * p.cost) AS cost,
            public.if((dpssj.sold = (0)::numeric), (9999.0)::double precision, (div((dpssj.spoiled * p.cost), (dpssj.sold * p.price)))::double precision) AS spoilage_frac,
            (dpssj.week < knn.new_ts) AS new_kiosk
           FROM (((public.dp_spoilage_weekly_sold_join dpssj
             JOIN pantry.product p ON ((dpssj.product_id = p.id)))
             JOIN public.byte_kiosks k ON ((dpssj.kiosk_id = k.id)))
             JOIN public.byte_kiosks_date_non_new knn ON ((k.id = knn.kiosk_id)))
          WHERE (dpssj.week >= '2016-01-01 08:00:00+00'::timestamp with time zone)) t
  ORDER BY t.week DESC;


ALTER TABLE public.dp_spoilage_weekly_kiosk_product_pct OWNER TO dbservice;

--
-- Name: dp_spoilage_weekly_kiosk_pct; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.dp_spoilage_weekly_kiosk_pct AS
 SELECT dp_spoilage_weekly_kiosk_product_pct.week,
    dp_spoilage_weekly_kiosk_product_pct.kiosk_id,
    sum(dp_spoilage_weekly_kiosk_product_pct.spoiled) AS spoiled_units,
    sum(dp_spoilage_weekly_kiosk_product_pct.sold) AS sold_units,
    public.frac(sum(dp_spoilage_weekly_kiosk_product_pct.spoiled), sum(dp_spoilage_weekly_kiosk_product_pct.sold)) AS spoiled_frac_units,
    sum(dp_spoilage_weekly_kiosk_product_pct.revenue) AS revenue,
    sum(dp_spoilage_weekly_kiosk_product_pct.cost) AS cost,
    sum((dp_spoilage_weekly_kiosk_product_pct.spoiled * dp_spoilage_weekly_kiosk_product_pct.unit_cost)) AS spoilage_dolr,
    sum(dp_spoilage_weekly_kiosk_product_pct.net_profit) AS net_profit,
    public.if((sum(dp_spoilage_weekly_kiosk_product_pct.sold) = (0)::numeric), 9999.0, (sum((dp_spoilage_weekly_kiosk_product_pct.spoiled * dp_spoilage_weekly_kiosk_product_pct.unit_cost)) / sum(dp_spoilage_weekly_kiosk_product_pct.revenue))) AS spoilage_frac,
    min((dp_spoilage_weekly_kiosk_product_pct.kiosk_title)::text) AS kiosk_title,
    bool_and(dp_spoilage_weekly_kiosk_product_pct.new_kiosk) AS new_kiosk
   FROM public.dp_spoilage_weekly_kiosk_product_pct
  GROUP BY dp_spoilage_weekly_kiosk_product_pct.week, dp_spoilage_weekly_kiosk_product_pct.kiosk_id
  ORDER BY dp_spoilage_weekly_kiosk_product_pct.kiosk_id, dp_spoilage_weekly_kiosk_product_pct.week DESC;


ALTER TABLE public.dp_spoilage_weekly_kiosk_pct OWNER TO dbservice;

--
-- Name: dp_spoilage_weekly_pct; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.dp_spoilage_weekly_pct AS
 SELECT dp_spoilage_weekly_kiosk_product_pct.week,
    dp_spoilage_weekly_kiosk_product_pct.new_kiosk,
    sum(dp_spoilage_weekly_kiosk_product_pct.spoiled) AS spoiled_units,
    sum(dp_spoilage_weekly_kiosk_product_pct.sold) AS sold_units,
    public.frac(sum(dp_spoilage_weekly_kiosk_product_pct.spoiled), sum(dp_spoilage_weekly_kiosk_product_pct.sold)) AS spoiled_frac_units,
    sum(dp_spoilage_weekly_kiosk_product_pct.revenue) AS revenue,
    sum(dp_spoilage_weekly_kiosk_product_pct.cost) AS cost,
    sum((dp_spoilage_weekly_kiosk_product_pct.spoiled * dp_spoilage_weekly_kiosk_product_pct.unit_cost)) AS spoilage_dolr,
    sum(dp_spoilage_weekly_kiosk_product_pct.net_profit) AS net_profit,
    public.if((sum(dp_spoilage_weekly_kiosk_product_pct.sold) = (0)::numeric), 9999.0, (sum((dp_spoilage_weekly_kiosk_product_pct.spoiled * dp_spoilage_weekly_kiosk_product_pct.unit_cost)) / sum(dp_spoilage_weekly_kiosk_product_pct.revenue))) AS spoilage_frac_dolr
   FROM public.dp_spoilage_weekly_kiosk_product_pct
  GROUP BY dp_spoilage_weekly_kiosk_product_pct.week, dp_spoilage_weekly_kiosk_product_pct.new_kiosk
  ORDER BY dp_spoilage_weekly_kiosk_product_pct.week DESC, dp_spoilage_weekly_kiosk_product_pct.new_kiosk;


ALTER TABLE public.dp_spoilage_weekly_pct OWNER TO dbservice;

--
-- Name: dp_spoilage_weekly_product_pct; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.dp_spoilage_weekly_product_pct AS
 SELECT dp_spoilage_weekly_kiosk_product_pct.week,
    dp_spoilage_weekly_kiosk_product_pct.product_id,
    dp_spoilage_weekly_kiosk_product_pct.new_kiosk,
    sum(dp_spoilage_weekly_kiosk_product_pct.spoiled) AS spoiled_units,
    sum(dp_spoilage_weekly_kiosk_product_pct.sold) AS sold_units,
    public.frac(sum(dp_spoilage_weekly_kiosk_product_pct.spoiled), sum(dp_spoilage_weekly_kiosk_product_pct.sold)) AS spoiled_frac_units,
    sum(dp_spoilage_weekly_kiosk_product_pct.revenue) AS revenue,
    sum(dp_spoilage_weekly_kiosk_product_pct.cost) AS cost,
    sum((dp_spoilage_weekly_kiosk_product_pct.spoiled * dp_spoilage_weekly_kiosk_product_pct.unit_cost)) AS spoilage_dolr,
    sum(dp_spoilage_weekly_kiosk_product_pct.net_profit) AS net_profit,
    public.if((sum(dp_spoilage_weekly_kiosk_product_pct.sold) = (0)::numeric), 9999.0, (sum((dp_spoilage_weekly_kiosk_product_pct.spoiled * dp_spoilage_weekly_kiosk_product_pct.unit_cost)) / sum(dp_spoilage_weekly_kiosk_product_pct.revenue))) AS spoilage_frac_dolr
   FROM public.dp_spoilage_weekly_kiosk_product_pct
  GROUP BY dp_spoilage_weekly_kiosk_product_pct.week, dp_spoilage_weekly_kiosk_product_pct.product_id, dp_spoilage_weekly_kiosk_product_pct.new_kiosk
  ORDER BY dp_spoilage_weekly_kiosk_product_pct.product_id, dp_spoilage_weekly_kiosk_product_pct.week DESC, dp_spoilage_weekly_kiosk_product_pct.new_kiosk;


ALTER TABLE public.dp_spoilage_weekly_product_pct OWNER TO dbservice;

--
-- Name: dp_stockouts; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.dp_stockouts AS
 SELECT byte_stockouts.kiosk_id,
    byte_stockouts.order_id,
    byte_stockouts.product_id,
    byte_stockouts.ts,
    byte_stockouts.restock_ts,
    byte_stockouts.restock_order_id,
    byte_stockouts.id,
    byte_stockouts.title,
    byte_stockouts.description,
    byte_stockouts.tiny_description,
    byte_stockouts.short_description,
    byte_stockouts.medium_description,
    byte_stockouts.long_description,
    byte_stockouts.price,
    byte_stockouts.cost,
    byte_stockouts.shelf_time,
    byte_stockouts.campus_id,
    byte_stockouts.image,
    byte_stockouts.image_time,
    byte_stockouts.last_update,
    byte_stockouts.archived,
    byte_stockouts.taxable,
    byte_stockouts.allergens,
    byte_stockouts.attribute_names,
    byte_stockouts.categories,
    byte_stockouts.category_names,
    byte_stockouts.vendor,
    byte_stockouts.source,
    byte_stockouts.notes,
    byte_stockouts.total_cal,
    byte_stockouts.num_servings,
    byte_stockouts.ingredients,
    byte_stockouts.calories,
    byte_stockouts.proteins,
    byte_stockouts.sugar,
    byte_stockouts.carbohydrates,
    byte_stockouts.fat,
    byte_stockouts.consumer_category,
    byte_stockouts.ws_case_size,
    byte_stockouts.kiosk_ship_qty,
    byte_stockouts.ws_case_cost,
    byte_stockouts.pick_station,
    byte_stockouts.fc_title,
    byte_stockouts.pricing_tier,
    byte_stockouts.width_space,
    byte_stockouts.height_space,
    byte_stockouts.depth_space,
    byte_stockouts.slotted_width,
    byte_stockouts.tag_volume,
    byte_stockouts.delivery_option,
    byte_stockouts.kiosk_title,
    byte_stockouts.address,
    byte_stockouts.location_x,
    byte_stockouts.location_y,
    byte_stockouts.client_name,
    byte_stockouts.tags,
    byte_stockouts.estd_num_users,
    byte_stockouts.month,
    byte_stockouts.week,
    byte_stockouts.date
   FROM public.byte_stockouts;


ALTER TABLE public.dp_stockouts OWNER TO dbservice;

--
-- Name: dp_stockouts_2016; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.dp_stockouts_2016 AS
 SELECT dp_stockouts.kiosk_id,
    dp_stockouts.order_id,
    dp_stockouts.product_id,
    dp_stockouts.ts,
    dp_stockouts.restock_ts,
    dp_stockouts.restock_order_id,
    dp_stockouts.id,
    dp_stockouts.title,
    dp_stockouts.description,
    dp_stockouts.tiny_description,
    dp_stockouts.short_description,
    dp_stockouts.medium_description,
    dp_stockouts.long_description,
    dp_stockouts.price,
    dp_stockouts.cost,
    dp_stockouts.shelf_time,
    dp_stockouts.campus_id,
    dp_stockouts.image,
    dp_stockouts.image_time,
    dp_stockouts.last_update,
    dp_stockouts.archived,
    dp_stockouts.taxable,
    dp_stockouts.allergens,
    dp_stockouts.attribute_names,
    dp_stockouts.categories,
    dp_stockouts.category_names,
    dp_stockouts.vendor,
    dp_stockouts.source,
    dp_stockouts.notes,
    dp_stockouts.total_cal,
    dp_stockouts.num_servings,
    dp_stockouts.ingredients,
    dp_stockouts.calories,
    dp_stockouts.proteins,
    dp_stockouts.sugar,
    dp_stockouts.carbohydrates,
    dp_stockouts.fat,
    dp_stockouts.consumer_category,
    dp_stockouts.ws_case_size,
    dp_stockouts.kiosk_ship_qty,
    dp_stockouts.ws_case_cost,
    dp_stockouts.pick_station,
    dp_stockouts.fc_title,
    dp_stockouts.pricing_tier,
    dp_stockouts.width_space,
    dp_stockouts.height_space,
    dp_stockouts.depth_space,
    dp_stockouts.slotted_width,
    dp_stockouts.tag_volume,
    dp_stockouts.delivery_option,
    dp_stockouts.kiosk_title,
    dp_stockouts.address,
    dp_stockouts.location_x,
    dp_stockouts.location_y,
    dp_stockouts.client_name,
    dp_stockouts.tags,
    dp_stockouts.estd_num_users,
    dp_stockouts.month,
    dp_stockouts.week,
    dp_stockouts.date
   FROM public.dp_stockouts
  WHERE ((dp_stockouts.ts >= '2016-01-01 08:00:00+00'::timestamp with time zone) AND (dp_stockouts.ts <= '2017-01-01 08:00:00+00'::timestamp with time zone));


ALTER TABLE public.dp_stockouts_2016 OWNER TO dbservice;

--
-- Name: dp_stockouts_2017; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.dp_stockouts_2017 AS
 SELECT dp_stockouts.kiosk_id,
    dp_stockouts.order_id,
    dp_stockouts.product_id,
    dp_stockouts.ts,
    dp_stockouts.restock_ts,
    dp_stockouts.restock_order_id,
    dp_stockouts.id,
    dp_stockouts.title,
    dp_stockouts.description,
    dp_stockouts.tiny_description,
    dp_stockouts.short_description,
    dp_stockouts.medium_description,
    dp_stockouts.long_description,
    dp_stockouts.price,
    dp_stockouts.cost,
    dp_stockouts.shelf_time,
    dp_stockouts.campus_id,
    dp_stockouts.image,
    dp_stockouts.image_time,
    dp_stockouts.last_update,
    dp_stockouts.archived,
    dp_stockouts.taxable,
    dp_stockouts.allergens,
    dp_stockouts.attribute_names,
    dp_stockouts.categories,
    dp_stockouts.category_names,
    dp_stockouts.vendor,
    dp_stockouts.source,
    dp_stockouts.notes,
    dp_stockouts.total_cal,
    dp_stockouts.num_servings,
    dp_stockouts.ingredients,
    dp_stockouts.calories,
    dp_stockouts.proteins,
    dp_stockouts.sugar,
    dp_stockouts.carbohydrates,
    dp_stockouts.fat,
    dp_stockouts.consumer_category,
    dp_stockouts.ws_case_size,
    dp_stockouts.kiosk_ship_qty,
    dp_stockouts.ws_case_cost,
    dp_stockouts.pick_station,
    dp_stockouts.fc_title,
    dp_stockouts.pricing_tier,
    dp_stockouts.width_space,
    dp_stockouts.height_space,
    dp_stockouts.depth_space,
    dp_stockouts.slotted_width,
    dp_stockouts.tag_volume,
    dp_stockouts.delivery_option,
    dp_stockouts.kiosk_title,
    dp_stockouts.address,
    dp_stockouts.location_x,
    dp_stockouts.location_y,
    dp_stockouts.client_name,
    dp_stockouts.tags,
    dp_stockouts.estd_num_users,
    dp_stockouts.month,
    dp_stockouts.week,
    dp_stockouts.date
   FROM public.dp_stockouts
  WHERE ((dp_stockouts.ts >= '2017-01-01 08:00:00+00'::timestamp with time zone) AND (dp_stockouts.ts <= '2018-01-01 08:00:00+00'::timestamp with time zone));


ALTER TABLE public.dp_stockouts_2017 OWNER TO dbservice;

--
-- Name: dp_stockouts_4weeks; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.dp_stockouts_4weeks AS
 SELECT dp_stockouts.kiosk_id,
    dp_stockouts.order_id,
    dp_stockouts.product_id,
    dp_stockouts.ts,
    dp_stockouts.restock_ts,
    dp_stockouts.restock_order_id,
    dp_stockouts.id,
    dp_stockouts.title,
    dp_stockouts.description,
    dp_stockouts.tiny_description,
    dp_stockouts.short_description,
    dp_stockouts.medium_description,
    dp_stockouts.long_description,
    dp_stockouts.price,
    dp_stockouts.cost,
    dp_stockouts.shelf_time,
    dp_stockouts.campus_id,
    dp_stockouts.image,
    dp_stockouts.image_time,
    dp_stockouts.last_update,
    dp_stockouts.archived,
    dp_stockouts.taxable,
    dp_stockouts.allergens,
    dp_stockouts.attribute_names,
    dp_stockouts.categories,
    dp_stockouts.category_names,
    dp_stockouts.vendor,
    dp_stockouts.source,
    dp_stockouts.notes,
    dp_stockouts.total_cal,
    dp_stockouts.num_servings,
    dp_stockouts.ingredients,
    dp_stockouts.calories,
    dp_stockouts.proteins,
    dp_stockouts.sugar,
    dp_stockouts.carbohydrates,
    dp_stockouts.fat,
    dp_stockouts.consumer_category,
    dp_stockouts.ws_case_size,
    dp_stockouts.kiosk_ship_qty,
    dp_stockouts.ws_case_cost,
    dp_stockouts.pick_station,
    dp_stockouts.fc_title,
    dp_stockouts.pricing_tier,
    dp_stockouts.width_space,
    dp_stockouts.height_space,
    dp_stockouts.depth_space,
    dp_stockouts.slotted_width,
    dp_stockouts.tag_volume,
    dp_stockouts.delivery_option,
    dp_stockouts.kiosk_title,
    dp_stockouts.address,
    dp_stockouts.location_x,
    dp_stockouts.location_y,
    dp_stockouts.client_name,
    dp_stockouts.tags,
    dp_stockouts.estd_num_users,
    dp_stockouts.month,
    dp_stockouts.week,
    dp_stockouts.date
   FROM public.dp_stockouts
  WHERE (dp_stockouts.ts > (now() - '28 days'::interval day));


ALTER TABLE public.dp_stockouts_4weeks OWNER TO dbservice;

--
-- Name: dp_stockouts_8weeks; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.dp_stockouts_8weeks AS
 SELECT dp_stockouts.kiosk_id,
    dp_stockouts.order_id,
    dp_stockouts.product_id,
    dp_stockouts.ts,
    dp_stockouts.restock_ts,
    dp_stockouts.restock_order_id,
    dp_stockouts.id,
    dp_stockouts.title,
    dp_stockouts.description,
    dp_stockouts.tiny_description,
    dp_stockouts.short_description,
    dp_stockouts.medium_description,
    dp_stockouts.long_description,
    dp_stockouts.price,
    dp_stockouts.cost,
    dp_stockouts.shelf_time,
    dp_stockouts.campus_id,
    dp_stockouts.image,
    dp_stockouts.image_time,
    dp_stockouts.last_update,
    dp_stockouts.archived,
    dp_stockouts.taxable,
    dp_stockouts.allergens,
    dp_stockouts.attribute_names,
    dp_stockouts.categories,
    dp_stockouts.category_names,
    dp_stockouts.vendor,
    dp_stockouts.source,
    dp_stockouts.notes,
    dp_stockouts.total_cal,
    dp_stockouts.num_servings,
    dp_stockouts.ingredients,
    dp_stockouts.calories,
    dp_stockouts.proteins,
    dp_stockouts.sugar,
    dp_stockouts.carbohydrates,
    dp_stockouts.fat,
    dp_stockouts.consumer_category,
    dp_stockouts.ws_case_size,
    dp_stockouts.kiosk_ship_qty,
    dp_stockouts.ws_case_cost,
    dp_stockouts.pick_station,
    dp_stockouts.fc_title,
    dp_stockouts.pricing_tier,
    dp_stockouts.width_space,
    dp_stockouts.height_space,
    dp_stockouts.depth_space,
    dp_stockouts.slotted_width,
    dp_stockouts.tag_volume,
    dp_stockouts.delivery_option,
    dp_stockouts.kiosk_title,
    dp_stockouts.address,
    dp_stockouts.location_x,
    dp_stockouts.location_y,
    dp_stockouts.client_name,
    dp_stockouts.tags,
    dp_stockouts.estd_num_users,
    dp_stockouts.month,
    dp_stockouts.week,
    dp_stockouts.date
   FROM public.dp_stockouts
  WHERE (dp_stockouts.ts > (now() - '56 days'::interval day));


ALTER TABLE public.dp_stockouts_8weeks OWNER TO dbservice;

--
-- Name: dp_stockouts_weekly_sold_join; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.dp_stockouts_weekly_sold_join AS
 SELECT COALESCE(t1.week, t2.week) AS week,
    COALESCE((t1.kiosk_id)::bigint, t2.kiosk_id) AS kiosk_id,
    COALESCE((t1.product_id)::bigint, t2.product_id) AS product_id,
    COALESCE(t1.spoiled, (0)::bigint) AS spoiled,
    COALESCE(t2.sold, (0)::bigint) AS sold,
    t2.days_in_week
   FROM (( SELECT s.week,
            s.kiosk_id,
            s.product_id,
            count(*) AS spoiled
           FROM public.dp_stockouts s
          GROUP BY s.week, s.kiosk_id, s.product_id) t1
     FULL JOIN ( SELECT dp_epcssold.week,
            dp_epcssold.kiosk_id,
            dp_epcssold.product_id,
            count(DISTINCT dp_epcssold.date) AS days_in_week,
            count(*) AS sold
           FROM public.dp_epcssold
          GROUP BY dp_epcssold.week, dp_epcssold.kiosk_id, dp_epcssold.product_id) t2 ON (((t1.product_id = t2.product_id) AND (t1.week = t2.week) AND (t1.kiosk_id = t2.kiosk_id))));


ALTER TABLE public.dp_stockouts_weekly_sold_join OWNER TO dbservice;

--
-- Name: dp_stockouts_weekly_calc; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.dp_stockouts_weekly_calc AS
 SELECT dpssj.week,
    dpssj.kiosk_id,
    dpssj.product_id,
    dpssj.spoiled,
    dpssj.sold,
    dpssj.days_in_week,
    p.title AS product_title,
    k.title AS kiosk_title,
    p.price AS unit_price,
    p.cost AS unit_cost,
    public.frac((dpssj.spoiled)::numeric, (dpssj.sold)::numeric) AS spoiled_frac_units,
    ((dpssj.sold)::numeric * p.price) AS revenue,
    (((dpssj.spoiled + dpssj.sold))::numeric * p.cost) AS cost,
    public.if((dpssj.sold = 0), 9999.0, div(((dpssj.spoiled)::numeric * p.cost), ((dpssj.sold)::numeric * p.price))) AS stockouts_frac,
    (dpssj.week < knn.new_ts) AS new_kiosk
   FROM (((public.dp_stockouts_weekly_sold_join dpssj
     JOIN pantry.product p ON ((dpssj.product_id = p.id)))
     JOIN public.byte_kiosks k ON ((dpssj.kiosk_id = k.id)))
     JOIN public.byte_kiosks_date_non_new knn ON ((k.id = knn.kiosk_id)))
  WHERE (dpssj.week >= '2016-01-01 08:00:00+00'::timestamp with time zone)
  ORDER BY dpssj.week DESC;


ALTER TABLE public.dp_stockouts_weekly_calc OWNER TO dbservice;

--
-- Name: dp_stockouts_weekly_kiosk_product_pct; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.dp_stockouts_weekly_kiosk_product_pct AS
 SELECT dp_stockouts_weekly_calc.week,
    dp_stockouts_weekly_calc.kiosk_id,
    dp_stockouts_weekly_calc.product_id,
    dp_stockouts_weekly_calc.spoiled,
    dp_stockouts_weekly_calc.sold,
    dp_stockouts_weekly_calc.days_in_week,
    dp_stockouts_weekly_calc.product_title,
    dp_stockouts_weekly_calc.kiosk_title,
    dp_stockouts_weekly_calc.unit_price,
    dp_stockouts_weekly_calc.unit_cost,
    dp_stockouts_weekly_calc.spoiled_frac_units,
    dp_stockouts_weekly_calc.revenue,
    dp_stockouts_weekly_calc.cost,
    dp_stockouts_weekly_calc.stockouts_frac,
    dp_stockouts_weekly_calc.new_kiosk,
    (dp_stockouts_weekly_calc.revenue - dp_stockouts_weekly_calc.cost) AS net_profit
   FROM public.dp_stockouts_weekly_calc;


ALTER TABLE public.dp_stockouts_weekly_kiosk_product_pct OWNER TO dbservice;

--
-- Name: dp_stockouts_weekly_kiosk_pct; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.dp_stockouts_weekly_kiosk_pct AS
 SELECT dp_stockouts_weekly_kiosk_product_pct.week,
    dp_stockouts_weekly_kiosk_product_pct.kiosk_id,
    bool_and(dp_stockouts_weekly_kiosk_product_pct.new_kiosk) AS new_kiosk,
    max(dp_stockouts_weekly_kiosk_product_pct.days_in_week) AS days_in_week,
    sum(dp_stockouts_weekly_kiosk_product_pct.spoiled) AS spoiled_units,
    sum(dp_stockouts_weekly_kiosk_product_pct.sold) AS sold_units,
    public.frac(sum(dp_stockouts_weekly_kiosk_product_pct.spoiled), sum(dp_stockouts_weekly_kiosk_product_pct.sold)) AS spoiled_frac_units,
    sum(dp_stockouts_weekly_kiosk_product_pct.revenue) AS revenue,
    sum(dp_stockouts_weekly_kiosk_product_pct.cost) AS cost,
    sum(((dp_stockouts_weekly_kiosk_product_pct.spoiled)::numeric * dp_stockouts_weekly_kiosk_product_pct.unit_cost)) AS stockouts_dolr,
    sum(dp_stockouts_weekly_kiosk_product_pct.net_profit) AS net_profit,
    (sum(((dp_stockouts_weekly_kiosk_product_pct.spoiled)::numeric * dp_stockouts_weekly_kiosk_product_pct.unit_cost)) / (0.0001 + sum(dp_stockouts_weekly_kiosk_product_pct.revenue))) AS stockouts_frac_dolr
   FROM public.dp_stockouts_weekly_kiosk_product_pct
  GROUP BY dp_stockouts_weekly_kiosk_product_pct.week, dp_stockouts_weekly_kiosk_product_pct.kiosk_id
  ORDER BY dp_stockouts_weekly_kiosk_product_pct.kiosk_id, dp_stockouts_weekly_kiosk_product_pct.week DESC;


ALTER TABLE public.dp_stockouts_weekly_kiosk_pct OWNER TO dbservice;

--
-- Name: dp_stockouts_weekly_pct; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.dp_stockouts_weekly_pct AS
 SELECT dp_stockouts_weekly_kiosk_product_pct.week,
    dp_stockouts_weekly_kiosk_product_pct.new_kiosk,
    max(dp_stockouts_weekly_kiosk_product_pct.days_in_week) AS days_in_week,
    sum(dp_stockouts_weekly_kiosk_product_pct.spoiled) AS spoiled_units,
    sum(dp_stockouts_weekly_kiosk_product_pct.sold) AS sold_units,
    public.frac(sum(dp_stockouts_weekly_kiosk_product_pct.spoiled), sum(dp_stockouts_weekly_kiosk_product_pct.sold)) AS spoiled_frac_units,
    sum(dp_stockouts_weekly_kiosk_product_pct.revenue) AS revenue,
    sum(dp_stockouts_weekly_kiosk_product_pct.cost) AS cost,
    sum(((dp_stockouts_weekly_kiosk_product_pct.spoiled)::numeric * dp_stockouts_weekly_kiosk_product_pct.unit_cost)) AS stockouts_dolr,
    sum(dp_stockouts_weekly_kiosk_product_pct.net_profit) AS net_profit,
    (sum(((dp_stockouts_weekly_kiosk_product_pct.spoiled)::numeric * dp_stockouts_weekly_kiosk_product_pct.unit_cost)) / (0.0001 + sum(((dp_stockouts_weekly_kiosk_product_pct.sold)::numeric * dp_stockouts_weekly_kiosk_product_pct.unit_price)))) AS stockouts_frac_dolr
   FROM public.dp_stockouts_weekly_kiosk_product_pct
  GROUP BY dp_stockouts_weekly_kiosk_product_pct.week, dp_stockouts_weekly_kiosk_product_pct.new_kiosk
  ORDER BY dp_stockouts_weekly_kiosk_product_pct.week, dp_stockouts_weekly_kiosk_product_pct.new_kiosk DESC;


ALTER TABLE public.dp_stockouts_weekly_pct OWNER TO dbservice;

--
-- Name: dp_stockouts_weekly_product_pct; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.dp_stockouts_weekly_product_pct AS
 SELECT dp_stockouts_weekly_kiosk_product_pct.week,
    dp_stockouts_weekly_kiosk_product_pct.product_id,
    dp_stockouts_weekly_kiosk_product_pct.new_kiosk,
    max(dp_stockouts_weekly_kiosk_product_pct.days_in_week) AS days_in_week,
    sum(dp_stockouts_weekly_kiosk_product_pct.spoiled) AS spoiled_units,
    sum(dp_stockouts_weekly_kiosk_product_pct.sold) AS sold_units,
    public.frac(sum(dp_stockouts_weekly_kiosk_product_pct.spoiled), sum(dp_stockouts_weekly_kiosk_product_pct.sold)) AS spoiled_frac_units,
    sum(dp_stockouts_weekly_kiosk_product_pct.revenue) AS revenue,
    sum(dp_stockouts_weekly_kiosk_product_pct.cost) AS cost,
    sum(((dp_stockouts_weekly_kiosk_product_pct.spoiled)::numeric * dp_stockouts_weekly_kiosk_product_pct.unit_cost)) AS stockouts_dolr,
    sum(dp_stockouts_weekly_kiosk_product_pct.net_profit) AS net_profit,
    (sum(((dp_stockouts_weekly_kiosk_product_pct.spoiled)::numeric * dp_stockouts_weekly_kiosk_product_pct.unit_cost)) / (0.0001 + sum(dp_stockouts_weekly_kiosk_product_pct.revenue))) AS stockouts_frac_dolr
   FROM public.dp_stockouts_weekly_kiosk_product_pct
  GROUP BY dp_stockouts_weekly_kiosk_product_pct.week, dp_stockouts_weekly_kiosk_product_pct.product_id, dp_stockouts_weekly_kiosk_product_pct.new_kiosk
  ORDER BY dp_stockouts_weekly_kiosk_product_pct.product_id, dp_stockouts_weekly_kiosk_product_pct.new_kiosk, dp_stockouts_weekly_kiosk_product_pct.week DESC;


ALTER TABLE public.dp_stockouts_weekly_product_pct OWNER TO dbservice;

--
-- Name: inm_kiosk_weekly_sale; Type: TABLE; Schema: public; Owner: dbservice
--

CREATE TABLE public.inm_kiosk_weekly_sale (
    key character varying(8000) NOT NULL,
    kiosk_id integer,
    woy integer,
    units_sold integer
);


ALTER TABLE public.inm_kiosk_weekly_sale OWNER TO dbservice;

--
-- Name: int_kiosk_weekly_sale; Type: TABLE; Schema: public; Owner: dbservice
--

CREATE TABLE public.int_kiosk_weekly_sale (
    key character varying(8000) NOT NULL,
    kiosk_id integer,
    woy integer,
    units_sold integer
);


ALTER TABLE public.int_kiosk_weekly_sale OWNER TO dbservice;

--
-- Name: kiosk; Type: TABLE; Schema: public; Owner: dbservice
--

CREATE TABLE public.kiosk (
    id integer NOT NULL,
    title character varying(8000)
);


ALTER TABLE public.kiosk OWNER TO dbservice;

--
-- Name: kiosk_first_seen; Type: TABLE; Schema: public; Owner: dbservice
--

CREATE TABLE public.kiosk_first_seen (
    kiosk_id bigint,
    "time" bigint
);


ALTER TABLE public.kiosk_first_seen OWNER TO dbservice;

--
-- Name: kiosk_id_seq; Type: SEQUENCE; Schema: public; Owner: dbservice
--

CREATE SEQUENCE public.kiosk_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.kiosk_id_seq OWNER TO dbservice;

--
-- Name: kiosk_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: dbservice
--

ALTER SEQUENCE public.kiosk_id_seq OWNED BY public.kiosk.id;


--
-- Name: kiosk_sales_by_dayofweek; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.kiosk_sales_by_dayofweek AS
 SELECT t.kiosk_id,
    t.min_ts,
    t.sun_pct,
    t.mon_pct,
    t.tue_pct,
    t.wed_pct,
    t.thu_pct,
    t.fri_pct,
    t.sat_pct,
    t.weekend_pct,
    t.title
   FROM ( SELECT t_1.kiosk_id,
            min(t_1.ts) AS min_ts,
            ((sum(public.if((t_1.dayofweek = (0)::double precision), t_1.amount_list_price, 0.0)) / sum(t_1.amount_list_price)))::numeric(6,3) AS sun_pct,
            ((sum(public.if((t_1.dayofweek = (1)::double precision), t_1.amount_list_price, 0.0)) / sum(t_1.amount_list_price)))::numeric(6,3) AS mon_pct,
            ((sum(public.if((t_1.dayofweek = (2)::double precision), t_1.amount_list_price, 0.0)) / sum(t_1.amount_list_price)))::numeric(6,3) AS tue_pct,
            ((sum(public.if((t_1.dayofweek = (3)::double precision), t_1.amount_list_price, 0.0)) / sum(t_1.amount_list_price)))::numeric(6,3) AS wed_pct,
            ((sum(public.if((t_1.dayofweek = (4)::double precision), t_1.amount_list_price, 0.0)) / sum(t_1.amount_list_price)))::numeric(6,3) AS thu_pct,
            ((sum(public.if((t_1.dayofweek = (5)::double precision), t_1.amount_list_price, 0.0)) / sum(t_1.amount_list_price)))::numeric(6,3) AS fri_pct,
            ((sum(public.if((t_1.dayofweek = (6)::double precision), t_1.amount_list_price, 0.0)) / sum(t_1.amount_list_price)))::numeric(6,3) AS sat_pct,
            ((sum(public.if((t_1.dayofweek = ANY (ARRAY[(0)::double precision, (6)::double precision])), t_1.amount_list_price, 0.0)) / sum(t_1.amount_list_price)))::numeric(6,3) AS weekend_pct,
            min((t_1.kiosk_title)::text) AS title
           FROM ((public.byte_tickets_6months t_1
             JOIN public.byte_kiosks_date_non_new knn ON ((t_1.kiosk_id = knn.kiosk_id)))
             JOIN public.byte_kiosks k ON ((t_1.kiosk_id = k.id)))
          WHERE ((k.archived = 0) AND (t_1.ts >= knn.new_ts))
          GROUP BY t_1.kiosk_id) t
  WHERE (t.min_ts < (now() - '30 days'::interval day))
  ORDER BY t.weekend_pct DESC;


ALTER TABLE public.kiosk_sales_by_dayofweek OWNER TO dbservice;

--
-- Name: kiosk_status; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.kiosk_status AS
 SELECT tmp.id,
    tmp.kiosk_id,
    tmp.kiosk_temperature,
    tmp.kiosk_temperature_count,
    tmp.kit_temperature,
    tmp.temperature_tags,
    tmp.kiosk_temperature_source,
    tmp.power,
    tmp.battery_level,
    tmp.rfid_0,
    tmp.rfid_1,
    tmp.rfid_2,
    tmp.rfid_3,
    tmp.rfid_4,
    tmp.rfid_5,
    tmp.rfid_6,
    tmp.rfid_7,
    tmp."time",
    tmp.modem_signal_percentage,
    tmp.modem_signal_type,
    tmp.ip,
    tmp.notes,
    tmp.app_uptime,
    tmp.system_uptime,
    tmp.is_locked,
    tmp.campus_id,
    tmp.ts_10min,
    tmp.title,
    tmp.ts_utc,
    tmp.ts,
    date_trunc('day'::text, tmp.ts_10min) AS date
   FROM ( SELECT ks.id,
            ks.kiosk_id,
            ks.kiosk_temperature,
            ks.kiosk_temperature_count,
            ks.kit_temperature,
            ks.temperature_tags,
            ks.kiosk_temperature_source,
            ks.power,
            ks.battery_level,
            ks.rfid_0,
            ks.rfid_1,
            ks.rfid_2,
            ks.rfid_3,
            ks.rfid_4,
            ks.rfid_5,
            ks.rfid_6,
            ks.rfid_7,
            ks."time",
            ks.modem_signal_percentage,
            ks.modem_signal_type,
            ks.ip,
            ks.notes,
            ks.app_uptime,
            ks.system_uptime,
            ks.is_locked,
            k.campus_id,
            public.epoch_round(ks."time", '00:10:00'::interval minute) AS ts_10min,
            k.title,
            to_timestamp((ks."time")::double precision) AS ts_utc,
            to_timestamp((ks."time")::double precision) AS ts
           FROM (pantry.kiosk_status ks
             JOIN pantry.kiosk k ON ((ks.kiosk_id = k.id)))) tmp;


ALTER TABLE public.kiosk_status OWNER TO dbservice;

--
-- Name: latest_label_records; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.latest_label_records AS
 SELECT l.id,
    l.product_id,
    l.epc,
    l.is_generic_sku,
    l.kiosk_id,
    l.order_id,
    l.status,
    l.price,
    l.cost,
    l.time_created,
    l.time_added,
    l.time_updated,
    l.notes
   FROM (pantry.label l
     JOIN ( SELECT max(label.id) AS id
           FROM pantry.label
          GROUP BY label.epc) t ON ((l.id = t.id)));


ALTER TABLE public.latest_label_records OWNER TO dbservice;

--
-- Name: mkt_camp_20170111_sku_revival_sonoma; Type: TABLE; Schema: public; Owner: dbservice
--

CREATE TABLE public.mkt_camp_20170111_sku_revival_sonoma (
    "Kiosk name" text,
    "Email address" text,
    "Record Type" text,
    "Lifecycle Stage" text,
    "Coupon" text
);


ALTER TABLE public.mkt_camp_20170111_sku_revival_sonoma OWNER TO dbservice;

--
-- Name: mkt_camp_20170123_whats_new_in_kiosk; Type: TABLE; Schema: public; Owner: dbservice
--

CREATE TABLE public.mkt_camp_20170123_whats_new_in_kiosk (
    "Kiosk name" text,
    "Email address" text,
    "Record Type" text,
    "Lifecycle Stage" text,
    "Coupon" text
);


ALTER TABLE public.mkt_camp_20170123_whats_new_in_kiosk OWNER TO dbservice;

--
-- Name: pantry.kiosk; Type: TABLE; Schema: public; Owner: dbservice
--

CREATE TABLE public."pantry.kiosk" (
    id integer NOT NULL,
    title character varying(8000)
);


ALTER TABLE public."pantry.kiosk" OWNER TO dbservice;

--
-- Name: pantry.kiosk_id_seq; Type: SEQUENCE; Schema: public; Owner: dbservice
--

CREATE SEQUENCE public."pantry.kiosk_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public."pantry.kiosk_id_seq" OWNER TO dbservice;

--
-- Name: pantry.kiosk_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: dbservice
--

ALTER SEQUENCE public."pantry.kiosk_id_seq" OWNED BY public."pantry.kiosk".id;


--
-- Name: sales_by_shelflife_120d; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.sales_by_shelflife_120d AS
 SELECT public.if((byte_epcssold_120days.product_shelf_life_days > 30), 999, byte_epcssold_120days.product_shelf_life_days) AS shelf_life,
    sum(byte_epcssold_120days.product_price) AS sales
   FROM public.byte_epcssold_120days
  GROUP BY (public.if((byte_epcssold_120days.product_shelf_life_days > 30), 999, byte_epcssold_120days.product_shelf_life_days))
  ORDER BY (public.if((byte_epcssold_120days.product_shelf_life_days > 30), 999, byte_epcssold_120days.product_shelf_life_days));


ALTER TABLE public.sales_by_shelflife_120d OWNER TO dbservice;

--
-- Name: sales_by_shelflife_30d; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.sales_by_shelflife_30d AS
 SELECT public.if((byte_epcssold_30days.product_shelf_life_days > 30), 999, byte_epcssold_30days.product_shelf_life_days) AS shelf_life,
    sum(byte_epcssold_30days.product_price) AS sales
   FROM public.byte_epcssold_30days
  GROUP BY (public.if((byte_epcssold_30days.product_shelf_life_days > 30), 999, byte_epcssold_30days.product_shelf_life_days))
  ORDER BY (public.if((byte_epcssold_30days.product_shelf_life_days > 30), 999, byte_epcssold_30days.product_shelf_life_days));


ALTER TABLE public.sales_by_shelflife_30d OWNER TO dbservice;

--
-- Name: sales_by_shelflife_45d; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.sales_by_shelflife_45d AS
 SELECT public.if((byte_epcssold_45days.product_shelf_life_days > 30), 999, byte_epcssold_45days.product_shelf_life_days) AS shelf_life,
    sum(byte_epcssold_45days.product_price) AS sales
   FROM public.byte_epcssold_45days
  GROUP BY (public.if((byte_epcssold_45days.product_shelf_life_days > 30), 999, byte_epcssold_45days.product_shelf_life_days))
  ORDER BY (public.if((byte_epcssold_45days.product_shelf_life_days > 30), 999, byte_epcssold_45days.product_shelf_life_days));


ALTER TABLE public.sales_by_shelflife_45d OWNER TO dbservice;

--
-- Name: spoilage_by_shelflife_120d; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.spoilage_by_shelflife_120d AS
 SELECT public.if((byte_spoilage.shelf_time > 30), 999, byte_spoilage.shelf_time) AS shelf_life,
    sum(byte_spoilage.cost) AS spoilage_dolr
   FROM public.byte_spoilage
  WHERE (byte_spoilage.ts_removed > (now() - '120 days'::interval day))
  GROUP BY (public.if((byte_spoilage.shelf_time > 30), 999, byte_spoilage.shelf_time))
  ORDER BY (public.if((byte_spoilage.shelf_time > 30), 999, byte_spoilage.shelf_time));


ALTER TABLE public.spoilage_by_shelflife_120d OWNER TO dbservice;

--
-- Name: spoilage_by_shelflife_30d; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.spoilage_by_shelflife_30d AS
 SELECT public.if((byte_spoilage.shelf_time > 30), 999, byte_spoilage.shelf_time) AS shelf_life,
    sum(byte_spoilage.cost) AS spoilage_dolr
   FROM public.byte_spoilage
  WHERE (byte_spoilage.ts_removed > (now() - '30 days'::interval day))
  GROUP BY (public.if((byte_spoilage.shelf_time > 30), 999, byte_spoilage.shelf_time))
  ORDER BY (public.if((byte_spoilage.shelf_time > 30), 999, byte_spoilage.shelf_time));


ALTER TABLE public.spoilage_by_shelflife_30d OWNER TO dbservice;

--
-- Name: spoilage_by_shelflife_45d; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.spoilage_by_shelflife_45d AS
 SELECT public.if((byte_spoilage.shelf_time > 30), 999, byte_spoilage.shelf_time) AS shelf_life,
    sum(byte_spoilage.cost) AS spoilage_dolr
   FROM public.byte_spoilage
  WHERE (byte_spoilage.ts_removed > (now() - '45 days'::interval day))
  GROUP BY (public.if((byte_spoilage.shelf_time > 30), 999, byte_spoilage.shelf_time))
  ORDER BY (public.if((byte_spoilage.shelf_time > 30), 999, byte_spoilage.shelf_time));


ALTER TABLE public.spoilage_by_shelflife_45d OWNER TO dbservice;

--
-- Name: spoilagepct_by_shelflife_120d; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.spoilagepct_by_shelflife_120d AS
 SELECT t1.shelf_life,
    sum(t1.sales) AS sales,
    sum(t2.spoilage_dolr) AS spoilage_dolr,
    public.if((sum(t2.spoilage_dolr) > 0.0), (sum(t2.spoilage_dolr) / sum(t1.sales)), 0.0) AS spoilage_frac
   FROM (public.sales_by_shelflife_120d t1
     JOIN public.spoilage_by_shelflife_120d t2 ON ((t1.shelf_life = t2.shelf_life)))
  GROUP BY t1.shelf_life
  ORDER BY t1.shelf_life;


ALTER TABLE public.spoilagepct_by_shelflife_120d OWNER TO dbservice;

--
-- Name: spoilagepct_by_shelflife_30d; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.spoilagepct_by_shelflife_30d AS
 SELECT t1.shelf_life,
    sum(t1.sales) AS sales,
    sum(t2.spoilage_dolr) AS spoilage_dolr,
    public.if((sum(t2.spoilage_dolr) > 0.0), (sum(t2.spoilage_dolr) / sum(t1.sales)), 0.0) AS spoilage_frac
   FROM (public.sales_by_shelflife_30d t1
     JOIN public.spoilage_by_shelflife_30d t2 ON ((t1.shelf_life = t2.shelf_life)))
  GROUP BY t1.shelf_life
  ORDER BY t1.shelf_life;


ALTER TABLE public.spoilagepct_by_shelflife_30d OWNER TO dbservice;

--
-- Name: spoilagepct_by_shelflife_45d; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.spoilagepct_by_shelflife_45d AS
 SELECT t1.shelf_life,
    sum(t1.sales) AS sales,
    sum(t2.spoilage_dolr) AS spoilage_dolr,
    public.if((sum(t2.spoilage_dolr) > 0.0), (sum(t2.spoilage_dolr) / sum(t1.sales)), 0.0) AS spoilage_frac
   FROM (public.sales_by_shelflife_45d t1
     JOIN public.spoilage_by_shelflife_45d t2 ON ((t1.shelf_life = t2.shelf_life)))
  GROUP BY t1.shelf_life
  ORDER BY t1.shelf_life;


ALTER TABLE public.spoilagepct_by_shelflife_45d OWNER TO dbservice;

--
-- Name: sys_activity; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.sys_activity AS
 SELECT pg_stat_activity.datname,
    pg_stat_activity.pid,
    pg_stat_activity.usename,
    pg_stat_activity.application_name,
    pg_stat_activity.client_addr,
    pg_stat_activity.client_hostname,
    pg_stat_activity.client_port,
    pg_stat_activity.query,
    pg_stat_activity.state
   FROM pg_stat_activity;


ALTER TABLE public.sys_activity OWNER TO dbservice;

--
-- Name: sys_conninfo; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.sys_conninfo AS
 SELECT pg_stat_activity.usename,
    count(*) AS count
   FROM pg_stat_activity
  GROUP BY pg_stat_activity.usename;


ALTER TABLE public.sys_conninfo OWNER TO dbservice;

--
-- Name: sys_slow_queries; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.sys_slow_queries AS
 SELECT ((pg_stat_statements.total_time / (1000)::double precision) / (60)::double precision) AS total_minutes,
    (pg_stat_statements.total_time / (pg_stat_statements.calls)::double precision) AS average_time,
    pg_stat_statements.query
   FROM public.pg_stat_statements
  ORDER BY ((pg_stat_statements.total_time / (1000)::double precision) / (60)::double precision);


ALTER TABLE public.sys_slow_queries OWNER TO dbservice;

--
-- Name: sys_table_sizes; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.sys_table_sizes AS
 SELECT (((n.nspname)::text || '.'::text) || (c.relname)::text) AS relation,
    pg_size_pretty(pg_relation_size((c.oid)::regclass)) AS size
   FROM (pg_class c
     LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace)))
  WHERE (n.nspname <> ALL (ARRAY['pg_catalog'::name, 'information_schema'::name]))
  ORDER BY (pg_relation_size((c.oid)::regclass)) DESC;


ALTER TABLE public.sys_table_sizes OWNER TO dbservice;

--
-- Name: sys_uptime; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.sys_uptime AS
 SELECT (now() - pg_stat_activity.backend_start) AS uptime
   FROM pg_stat_activity
  WHERE (pg_stat_activity.pid = pg_backend_pid());


ALTER TABLE public.sys_uptime OWNER TO dbservice;

--
-- Name: tmp_dormant; Type: TABLE; Schema: public; Owner: dbservice
--

CREATE TABLE public.tmp_dormant (
    email character varying(255)
);


ALTER TABLE public.tmp_dormant OWNER TO dbservice;

--
-- Name: tmp_dormant2; Type: TABLE; Schema: public; Owner: dbservice
--

CREATE TABLE public.tmp_dormant2 (
    email character varying(255),
    dayssincepurchase integer,
    kiosk character varying(255),
    couponcode character varying(20),
    couponamount numeric(28,6)
);


ALTER TABLE public.tmp_dormant2 OWNER TO dbservice;

--
-- Name: tmp_reboots_log; Type: TABLE; Schema: public; Owner: dbservice
--

CREATE TABLE public.tmp_reboots_log (
    ts timestamp(6) with time zone,
    kiosk_id integer,
    ipaddr text,
    reason text
);


ALTER TABLE public.tmp_reboots_log OWNER TO dbservice;

--
-- Name: track_dashboard; Type: TABLE; Schema: public; Owner: dbservice
--

CREATE TABLE public.track_dashboard (
    date timestamp(6) with time zone,
    sum_amount_paid numeric(28,6),
    sum_list_price numeric(28,6),
    byte_kiosks bigint,
    byte_fridge_uptime numeric(28,6),
    major_byte_outages bigint,
    licensee_kiosks bigint,
    avg_inv_dolr numeric(28,6),
    avg_inv_units numeric(28,6),
    units_sold bigint,
    active_byte_customers bigint,
    active_skus bigint,
    active_brands bigint,
    cards bigint,
    estd_uniq_usernames bigint,
    unique_emails bigint,
    tickets bigint,
    tickets_w_email bigint,
    id integer NOT NULL,
    create_ts timestamp(6) with time zone
);


ALTER TABLE public.track_dashboard OWNER TO dbservice;

--
-- Name: track_dashboard_id_seq; Type: SEQUENCE; Schema: public; Owner: dbservice
--

CREATE SEQUENCE public.track_dashboard_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.track_dashboard_id_seq OWNER TO dbservice;

--
-- Name: track_dashboard_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: dbservice
--

ALTER SEQUENCE public.track_dashboard_id_seq OWNED BY public.track_dashboard.id;


--
-- Name: track_inventory; Type: TABLE; Schema: public; Owner: dbservice
--

CREATE TABLE public.track_inventory (
    kiosk_id bigint,
    kiosk character varying(138),
    product character varying(381),
    sku bigint,
    cost numeric(6,2),
    inventory_count bigint,
    inventory_value numeric(28,6),
    "current_date" timestamp(6) with time zone,
    id integer NOT NULL,
    create_ts timestamp(6) with time zone
);


ALTER TABLE public.track_inventory OWNER TO dbservice;

--
-- Name: track_inventory_id_seq; Type: SEQUENCE; Schema: public; Owner: dbservice
--

CREATE SEQUENCE public.track_inventory_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.track_inventory_id_seq OWNER TO dbservice;

--
-- Name: track_inventory_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: dbservice
--

ALTER SEQUENCE public.track_inventory_id_seq OWNED BY public.track_inventory.id;


--
-- Name: user_retention_10weeks; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.user_retention_10weeks AS
 SELECT user_retention_by_week.week,
    user_retention_by_week.num_consumers,
    user_retention_by_week.repeat_consumers,
    user_retention_by_week.num_tickets,
    user_retention_by_week.sum_amount_list_price,
    user_retention_by_week.sum_amount_paid,
    user_retention_by_week.num_repeat_tickets,
    user_retention_by_week.sum_repeat_amount_list_price,
    user_retention_by_week.sum_repeat_amount_paid,
    user_retention_by_week.frac_users_retained,
    user_retention_by_week.frac_tickets_retained,
    user_retention_by_week.frac_listprice_retained,
    user_retention_by_week.frac_amountpaid_retained,
    user_retention_by_week.old_week,
    user_retention_by_week.old_num_consumers,
    user_retention_by_week.old_repeat_consumers,
    user_retention_by_week.old_num_tickets,
    user_retention_by_week.old_sum_amount_list_price,
    user_retention_by_week.old_sum_amount_paid
   FROM public.user_retention_by_week(10) user_retention_by_week(week, num_consumers, repeat_consumers, num_tickets, sum_amount_list_price, sum_amount_paid, num_repeat_tickets, sum_repeat_amount_list_price, sum_repeat_amount_paid, frac_users_retained, frac_tickets_retained, frac_listprice_retained, frac_amountpaid_retained, old_week, old_num_consumers, old_repeat_consumers, old_num_tickets, old_sum_amount_list_price, old_sum_amount_paid);


ALTER TABLE public.user_retention_10weeks OWNER TO dbservice;

--
-- Name: user_retention_12months; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.user_retention_12months AS
 SELECT user_retention_by_month.month,
    user_retention_by_month.num_consumers,
    user_retention_by_month.repeat_consumers,
    user_retention_by_month.num_tickets,
    user_retention_by_month.sum_amount_list_price,
    user_retention_by_month.sum_amount_paid,
    user_retention_by_month.num_repeat_tickets,
    user_retention_by_month.sum_repeat_amount_list_price,
    user_retention_by_month.sum_repeat_amount_paid,
    user_retention_by_month.frac_users_retained,
    user_retention_by_month.frac_tickets_retained,
    user_retention_by_month.frac_listprice_retained,
    user_retention_by_month.frac_amountpaid_retained,
    user_retention_by_month.old_month,
    user_retention_by_month.old_num_consumers,
    user_retention_by_month.old_repeat_consumers,
    user_retention_by_month.old_num_tickets,
    user_retention_by_month.old_sum_amount_list_price,
    user_retention_by_month.old_sum_amount_paid
   FROM public.user_retention_by_month(12) user_retention_by_month(month, num_consumers, repeat_consumers, num_tickets, sum_amount_list_price, sum_amount_paid, num_repeat_tickets, sum_repeat_amount_list_price, sum_repeat_amount_paid, frac_users_retained, frac_tickets_retained, frac_listprice_retained, frac_amountpaid_retained, old_month, old_num_consumers, old_repeat_consumers, old_num_tickets, old_sum_amount_list_price, old_sum_amount_paid);


ALTER TABLE public.user_retention_12months OWNER TO dbservice;

--
-- Name: user_retention_12weeks; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.user_retention_12weeks AS
 SELECT user_retention_by_week.week,
    user_retention_by_week.num_consumers,
    user_retention_by_week.repeat_consumers,
    user_retention_by_week.num_tickets,
    user_retention_by_week.sum_amount_list_price,
    user_retention_by_week.sum_amount_paid,
    user_retention_by_week.num_repeat_tickets,
    user_retention_by_week.sum_repeat_amount_list_price,
    user_retention_by_week.sum_repeat_amount_paid,
    user_retention_by_week.frac_users_retained,
    user_retention_by_week.frac_tickets_retained,
    user_retention_by_week.frac_listprice_retained,
    user_retention_by_week.frac_amountpaid_retained,
    user_retention_by_week.old_week,
    user_retention_by_week.old_num_consumers,
    user_retention_by_week.old_repeat_consumers,
    user_retention_by_week.old_num_tickets,
    user_retention_by_week.old_sum_amount_list_price,
    user_retention_by_week.old_sum_amount_paid
   FROM public.user_retention_by_week(12) user_retention_by_week(week, num_consumers, repeat_consumers, num_tickets, sum_amount_list_price, sum_amount_paid, num_repeat_tickets, sum_repeat_amount_list_price, sum_repeat_amount_paid, frac_users_retained, frac_tickets_retained, frac_listprice_retained, frac_amountpaid_retained, old_week, old_num_consumers, old_repeat_consumers, old_num_tickets, old_sum_amount_list_price, old_sum_amount_paid);


ALTER TABLE public.user_retention_12weeks OWNER TO dbservice;

--
-- Name: user_retention_1month; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.user_retention_1month AS
 SELECT user_retention_by_month.month,
    user_retention_by_month.num_consumers,
    user_retention_by_month.repeat_consumers,
    user_retention_by_month.num_tickets,
    user_retention_by_month.sum_amount_list_price,
    user_retention_by_month.sum_amount_paid,
    user_retention_by_month.num_repeat_tickets,
    user_retention_by_month.sum_repeat_amount_list_price,
    user_retention_by_month.sum_repeat_amount_paid,
    user_retention_by_month.frac_users_retained,
    user_retention_by_month.frac_tickets_retained,
    user_retention_by_month.frac_listprice_retained,
    user_retention_by_month.frac_amountpaid_retained,
    user_retention_by_month.old_month,
    user_retention_by_month.old_num_consumers,
    user_retention_by_month.old_repeat_consumers,
    user_retention_by_month.old_num_tickets,
    user_retention_by_month.old_sum_amount_list_price,
    user_retention_by_month.old_sum_amount_paid
   FROM public.user_retention_by_month(1) user_retention_by_month(month, num_consumers, repeat_consumers, num_tickets, sum_amount_list_price, sum_amount_paid, num_repeat_tickets, sum_repeat_amount_list_price, sum_repeat_amount_paid, frac_users_retained, frac_tickets_retained, frac_listprice_retained, frac_amountpaid_retained, old_month, old_num_consumers, old_repeat_consumers, old_num_tickets, old_sum_amount_list_price, old_sum_amount_paid);


ALTER TABLE public.user_retention_1month OWNER TO dbservice;

--
-- Name: user_retention_1week; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.user_retention_1week AS
 SELECT user_retention_by_week.week,
    user_retention_by_week.num_consumers,
    user_retention_by_week.repeat_consumers,
    user_retention_by_week.num_tickets,
    user_retention_by_week.sum_amount_list_price,
    user_retention_by_week.sum_amount_paid,
    user_retention_by_week.num_repeat_tickets,
    user_retention_by_week.sum_repeat_amount_list_price,
    user_retention_by_week.sum_repeat_amount_paid,
    user_retention_by_week.frac_users_retained,
    user_retention_by_week.frac_tickets_retained,
    user_retention_by_week.frac_listprice_retained,
    user_retention_by_week.frac_amountpaid_retained,
    user_retention_by_week.old_week,
    user_retention_by_week.old_num_consumers,
    user_retention_by_week.old_repeat_consumers,
    user_retention_by_week.old_num_tickets,
    user_retention_by_week.old_sum_amount_list_price,
    user_retention_by_week.old_sum_amount_paid
   FROM public.user_retention_by_week(1) user_retention_by_week(week, num_consumers, repeat_consumers, num_tickets, sum_amount_list_price, sum_amount_paid, num_repeat_tickets, sum_repeat_amount_list_price, sum_repeat_amount_paid, frac_users_retained, frac_tickets_retained, frac_listprice_retained, frac_amountpaid_retained, old_week, old_num_consumers, old_repeat_consumers, old_num_tickets, old_sum_amount_list_price, old_sum_amount_paid);


ALTER TABLE public.user_retention_1week OWNER TO dbservice;

--
-- Name: user_retention_26weeks; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.user_retention_26weeks AS
 SELECT user_retention_by_week.week,
    user_retention_by_week.num_consumers,
    user_retention_by_week.repeat_consumers,
    user_retention_by_week.num_tickets,
    user_retention_by_week.sum_amount_list_price,
    user_retention_by_week.sum_amount_paid,
    user_retention_by_week.num_repeat_tickets,
    user_retention_by_week.sum_repeat_amount_list_price,
    user_retention_by_week.sum_repeat_amount_paid,
    user_retention_by_week.frac_users_retained,
    user_retention_by_week.frac_tickets_retained,
    user_retention_by_week.frac_listprice_retained,
    user_retention_by_week.frac_amountpaid_retained,
    user_retention_by_week.old_week,
    user_retention_by_week.old_num_consumers,
    user_retention_by_week.old_repeat_consumers,
    user_retention_by_week.old_num_tickets,
    user_retention_by_week.old_sum_amount_list_price,
    user_retention_by_week.old_sum_amount_paid
   FROM public.user_retention_by_week(26) user_retention_by_week(week, num_consumers, repeat_consumers, num_tickets, sum_amount_list_price, sum_amount_paid, num_repeat_tickets, sum_repeat_amount_list_price, sum_repeat_amount_paid, frac_users_retained, frac_tickets_retained, frac_listprice_retained, frac_amountpaid_retained, old_week, old_num_consumers, old_repeat_consumers, old_num_tickets, old_sum_amount_list_price, old_sum_amount_paid);


ALTER TABLE public.user_retention_26weeks OWNER TO dbservice;

--
-- Name: user_retention_2months; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.user_retention_2months AS
 SELECT user_retention_by_month.month,
    user_retention_by_month.num_consumers,
    user_retention_by_month.repeat_consumers,
    user_retention_by_month.num_tickets,
    user_retention_by_month.sum_amount_list_price,
    user_retention_by_month.sum_amount_paid,
    user_retention_by_month.num_repeat_tickets,
    user_retention_by_month.sum_repeat_amount_list_price,
    user_retention_by_month.sum_repeat_amount_paid,
    user_retention_by_month.frac_users_retained,
    user_retention_by_month.frac_tickets_retained,
    user_retention_by_month.frac_listprice_retained,
    user_retention_by_month.frac_amountpaid_retained,
    user_retention_by_month.old_month,
    user_retention_by_month.old_num_consumers,
    user_retention_by_month.old_repeat_consumers,
    user_retention_by_month.old_num_tickets,
    user_retention_by_month.old_sum_amount_list_price,
    user_retention_by_month.old_sum_amount_paid
   FROM public.user_retention_by_month(2) user_retention_by_month(month, num_consumers, repeat_consumers, num_tickets, sum_amount_list_price, sum_amount_paid, num_repeat_tickets, sum_repeat_amount_list_price, sum_repeat_amount_paid, frac_users_retained, frac_tickets_retained, frac_listprice_retained, frac_amountpaid_retained, old_month, old_num_consumers, old_repeat_consumers, old_num_tickets, old_sum_amount_list_price, old_sum_amount_paid);


ALTER TABLE public.user_retention_2months OWNER TO dbservice;

--
-- Name: user_retention_2weeks; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.user_retention_2weeks AS
 SELECT user_retention_by_week.week,
    user_retention_by_week.num_consumers,
    user_retention_by_week.repeat_consumers,
    user_retention_by_week.num_tickets,
    user_retention_by_week.sum_amount_list_price,
    user_retention_by_week.sum_amount_paid,
    user_retention_by_week.num_repeat_tickets,
    user_retention_by_week.sum_repeat_amount_list_price,
    user_retention_by_week.sum_repeat_amount_paid,
    user_retention_by_week.frac_users_retained,
    user_retention_by_week.frac_tickets_retained,
    user_retention_by_week.frac_listprice_retained,
    user_retention_by_week.frac_amountpaid_retained,
    user_retention_by_week.old_week,
    user_retention_by_week.old_num_consumers,
    user_retention_by_week.old_repeat_consumers,
    user_retention_by_week.old_num_tickets,
    user_retention_by_week.old_sum_amount_list_price,
    user_retention_by_week.old_sum_amount_paid
   FROM public.user_retention_by_week(2) user_retention_by_week(week, num_consumers, repeat_consumers, num_tickets, sum_amount_list_price, sum_amount_paid, num_repeat_tickets, sum_repeat_amount_list_price, sum_repeat_amount_paid, frac_users_retained, frac_tickets_retained, frac_listprice_retained, frac_amountpaid_retained, old_week, old_num_consumers, old_repeat_consumers, old_num_tickets, old_sum_amount_list_price, old_sum_amount_paid);


ALTER TABLE public.user_retention_2weeks OWNER TO dbservice;

--
-- Name: user_retention_3months; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.user_retention_3months AS
 SELECT user_retention_by_month.month,
    user_retention_by_month.num_consumers,
    user_retention_by_month.repeat_consumers,
    user_retention_by_month.num_tickets,
    user_retention_by_month.sum_amount_list_price,
    user_retention_by_month.sum_amount_paid,
    user_retention_by_month.num_repeat_tickets,
    user_retention_by_month.sum_repeat_amount_list_price,
    user_retention_by_month.sum_repeat_amount_paid,
    user_retention_by_month.frac_users_retained,
    user_retention_by_month.frac_tickets_retained,
    user_retention_by_month.frac_listprice_retained,
    user_retention_by_month.frac_amountpaid_retained,
    user_retention_by_month.old_month,
    user_retention_by_month.old_num_consumers,
    user_retention_by_month.old_repeat_consumers,
    user_retention_by_month.old_num_tickets,
    user_retention_by_month.old_sum_amount_list_price,
    user_retention_by_month.old_sum_amount_paid
   FROM public.user_retention_by_month(3) user_retention_by_month(month, num_consumers, repeat_consumers, num_tickets, sum_amount_list_price, sum_amount_paid, num_repeat_tickets, sum_repeat_amount_list_price, sum_repeat_amount_paid, frac_users_retained, frac_tickets_retained, frac_listprice_retained, frac_amountpaid_retained, old_month, old_num_consumers, old_repeat_consumers, old_num_tickets, old_sum_amount_list_price, old_sum_amount_paid);


ALTER TABLE public.user_retention_3months OWNER TO dbservice;

--
-- Name: user_retention_3weeks; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.user_retention_3weeks AS
 SELECT user_retention_by_week.week,
    user_retention_by_week.num_consumers,
    user_retention_by_week.repeat_consumers,
    user_retention_by_week.num_tickets,
    user_retention_by_week.sum_amount_list_price,
    user_retention_by_week.sum_amount_paid,
    user_retention_by_week.num_repeat_tickets,
    user_retention_by_week.sum_repeat_amount_list_price,
    user_retention_by_week.sum_repeat_amount_paid,
    user_retention_by_week.frac_users_retained,
    user_retention_by_week.frac_tickets_retained,
    user_retention_by_week.frac_listprice_retained,
    user_retention_by_week.frac_amountpaid_retained,
    user_retention_by_week.old_week,
    user_retention_by_week.old_num_consumers,
    user_retention_by_week.old_repeat_consumers,
    user_retention_by_week.old_num_tickets,
    user_retention_by_week.old_sum_amount_list_price,
    user_retention_by_week.old_sum_amount_paid
   FROM public.user_retention_by_week(3) user_retention_by_week(week, num_consumers, repeat_consumers, num_tickets, sum_amount_list_price, sum_amount_paid, num_repeat_tickets, sum_repeat_amount_list_price, sum_repeat_amount_paid, frac_users_retained, frac_tickets_retained, frac_listprice_retained, frac_amountpaid_retained, old_week, old_num_consumers, old_repeat_consumers, old_num_tickets, old_sum_amount_list_price, old_sum_amount_paid);


ALTER TABLE public.user_retention_3weeks OWNER TO dbservice;

--
-- Name: user_retention_4months; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.user_retention_4months AS
 SELECT user_retention_by_month.month,
    user_retention_by_month.num_consumers,
    user_retention_by_month.repeat_consumers,
    user_retention_by_month.num_tickets,
    user_retention_by_month.sum_amount_list_price,
    user_retention_by_month.sum_amount_paid,
    user_retention_by_month.num_repeat_tickets,
    user_retention_by_month.sum_repeat_amount_list_price,
    user_retention_by_month.sum_repeat_amount_paid,
    user_retention_by_month.frac_users_retained,
    user_retention_by_month.frac_tickets_retained,
    user_retention_by_month.frac_listprice_retained,
    user_retention_by_month.frac_amountpaid_retained,
    user_retention_by_month.old_month,
    user_retention_by_month.old_num_consumers,
    user_retention_by_month.old_repeat_consumers,
    user_retention_by_month.old_num_tickets,
    user_retention_by_month.old_sum_amount_list_price,
    user_retention_by_month.old_sum_amount_paid
   FROM public.user_retention_by_month(4) user_retention_by_month(month, num_consumers, repeat_consumers, num_tickets, sum_amount_list_price, sum_amount_paid, num_repeat_tickets, sum_repeat_amount_list_price, sum_repeat_amount_paid, frac_users_retained, frac_tickets_retained, frac_listprice_retained, frac_amountpaid_retained, old_month, old_num_consumers, old_repeat_consumers, old_num_tickets, old_sum_amount_list_price, old_sum_amount_paid);


ALTER TABLE public.user_retention_4months OWNER TO dbservice;

--
-- Name: user_retention_4weeks; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.user_retention_4weeks AS
 SELECT user_retention_by_week.week,
    user_retention_by_week.num_consumers,
    user_retention_by_week.repeat_consumers,
    user_retention_by_week.num_tickets,
    user_retention_by_week.sum_amount_list_price,
    user_retention_by_week.sum_amount_paid,
    user_retention_by_week.num_repeat_tickets,
    user_retention_by_week.sum_repeat_amount_list_price,
    user_retention_by_week.sum_repeat_amount_paid,
    user_retention_by_week.frac_users_retained,
    user_retention_by_week.frac_tickets_retained,
    user_retention_by_week.frac_listprice_retained,
    user_retention_by_week.frac_amountpaid_retained,
    user_retention_by_week.old_week,
    user_retention_by_week.old_num_consumers,
    user_retention_by_week.old_repeat_consumers,
    user_retention_by_week.old_num_tickets,
    user_retention_by_week.old_sum_amount_list_price,
    user_retention_by_week.old_sum_amount_paid
   FROM public.user_retention_by_week(4) user_retention_by_week(week, num_consumers, repeat_consumers, num_tickets, sum_amount_list_price, sum_amount_paid, num_repeat_tickets, sum_repeat_amount_list_price, sum_repeat_amount_paid, frac_users_retained, frac_tickets_retained, frac_listprice_retained, frac_amountpaid_retained, old_week, old_num_consumers, old_repeat_consumers, old_num_tickets, old_sum_amount_list_price, old_sum_amount_paid);


ALTER TABLE public.user_retention_4weeks OWNER TO dbservice;

--
-- Name: user_retention_52weeks; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.user_retention_52weeks AS
 SELECT user_retention_by_week.week,
    user_retention_by_week.num_consumers,
    user_retention_by_week.repeat_consumers,
    user_retention_by_week.num_tickets,
    user_retention_by_week.sum_amount_list_price,
    user_retention_by_week.sum_amount_paid,
    user_retention_by_week.num_repeat_tickets,
    user_retention_by_week.sum_repeat_amount_list_price,
    user_retention_by_week.sum_repeat_amount_paid,
    user_retention_by_week.frac_users_retained,
    user_retention_by_week.frac_tickets_retained,
    user_retention_by_week.frac_listprice_retained,
    user_retention_by_week.frac_amountpaid_retained,
    user_retention_by_week.old_week,
    user_retention_by_week.old_num_consumers,
    user_retention_by_week.old_repeat_consumers,
    user_retention_by_week.old_num_tickets,
    user_retention_by_week.old_sum_amount_list_price,
    user_retention_by_week.old_sum_amount_paid
   FROM public.user_retention_by_week(52) user_retention_by_week(week, num_consumers, repeat_consumers, num_tickets, sum_amount_list_price, sum_amount_paid, num_repeat_tickets, sum_repeat_amount_list_price, sum_repeat_amount_paid, frac_users_retained, frac_tickets_retained, frac_listprice_retained, frac_amountpaid_retained, old_week, old_num_consumers, old_repeat_consumers, old_num_tickets, old_sum_amount_list_price, old_sum_amount_paid);


ALTER TABLE public.user_retention_52weeks OWNER TO dbservice;

--
-- Name: user_retention_6months; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.user_retention_6months AS
 SELECT user_retention_by_month.month,
    user_retention_by_month.num_consumers,
    user_retention_by_month.repeat_consumers,
    user_retention_by_month.num_tickets,
    user_retention_by_month.sum_amount_list_price,
    user_retention_by_month.sum_amount_paid,
    user_retention_by_month.num_repeat_tickets,
    user_retention_by_month.sum_repeat_amount_list_price,
    user_retention_by_month.sum_repeat_amount_paid,
    user_retention_by_month.frac_users_retained,
    user_retention_by_month.frac_tickets_retained,
    user_retention_by_month.frac_listprice_retained,
    user_retention_by_month.frac_amountpaid_retained,
    user_retention_by_month.old_month,
    user_retention_by_month.old_num_consumers,
    user_retention_by_month.old_repeat_consumers,
    user_retention_by_month.old_num_tickets,
    user_retention_by_month.old_sum_amount_list_price,
    user_retention_by_month.old_sum_amount_paid
   FROM public.user_retention_by_month(6) user_retention_by_month(month, num_consumers, repeat_consumers, num_tickets, sum_amount_list_price, sum_amount_paid, num_repeat_tickets, sum_repeat_amount_list_price, sum_repeat_amount_paid, frac_users_retained, frac_tickets_retained, frac_listprice_retained, frac_amountpaid_retained, old_month, old_num_consumers, old_repeat_consumers, old_num_tickets, old_sum_amount_list_price, old_sum_amount_paid);


ALTER TABLE public.user_retention_6months OWNER TO dbservice;

--
-- Name: user_retention_6weeks; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.user_retention_6weeks AS
 SELECT user_retention_by_week.week,
    user_retention_by_week.num_consumers,
    user_retention_by_week.repeat_consumers,
    user_retention_by_week.num_tickets,
    user_retention_by_week.sum_amount_list_price,
    user_retention_by_week.sum_amount_paid,
    user_retention_by_week.num_repeat_tickets,
    user_retention_by_week.sum_repeat_amount_list_price,
    user_retention_by_week.sum_repeat_amount_paid,
    user_retention_by_week.frac_users_retained,
    user_retention_by_week.frac_tickets_retained,
    user_retention_by_week.frac_listprice_retained,
    user_retention_by_week.frac_amountpaid_retained,
    user_retention_by_week.old_week,
    user_retention_by_week.old_num_consumers,
    user_retention_by_week.old_repeat_consumers,
    user_retention_by_week.old_num_tickets,
    user_retention_by_week.old_sum_amount_list_price,
    user_retention_by_week.old_sum_amount_paid
   FROM public.user_retention_by_week(6) user_retention_by_week(week, num_consumers, repeat_consumers, num_tickets, sum_amount_list_price, sum_amount_paid, num_repeat_tickets, sum_repeat_amount_list_price, sum_repeat_amount_paid, frac_users_retained, frac_tickets_retained, frac_listprice_retained, frac_amountpaid_retained, old_week, old_num_consumers, old_repeat_consumers, old_num_tickets, old_sum_amount_list_price, old_sum_amount_paid);


ALTER TABLE public.user_retention_6weeks OWNER TO dbservice;

--
-- Name: user_retention_8weeks; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.user_retention_8weeks AS
 SELECT user_retention_by_week.week,
    user_retention_by_week.num_consumers,
    user_retention_by_week.repeat_consumers,
    user_retention_by_week.num_tickets,
    user_retention_by_week.sum_amount_list_price,
    user_retention_by_week.sum_amount_paid,
    user_retention_by_week.num_repeat_tickets,
    user_retention_by_week.sum_repeat_amount_list_price,
    user_retention_by_week.sum_repeat_amount_paid,
    user_retention_by_week.frac_users_retained,
    user_retention_by_week.frac_tickets_retained,
    user_retention_by_week.frac_listprice_retained,
    user_retention_by_week.frac_amountpaid_retained,
    user_retention_by_week.old_week,
    user_retention_by_week.old_num_consumers,
    user_retention_by_week.old_repeat_consumers,
    user_retention_by_week.old_num_tickets,
    user_retention_by_week.old_sum_amount_list_price,
    user_retention_by_week.old_sum_amount_paid
   FROM public.user_retention_by_week(8) user_retention_by_week(week, num_consumers, repeat_consumers, num_tickets, sum_amount_list_price, sum_amount_paid, num_repeat_tickets, sum_repeat_amount_list_price, sum_repeat_amount_paid, frac_users_retained, frac_tickets_retained, frac_listprice_retained, frac_amountpaid_retained, old_week, old_num_consumers, old_repeat_consumers, old_num_tickets, old_sum_amount_list_price, old_sum_amount_paid);


ALTER TABLE public.user_retention_8weeks OWNER TO dbservice;

--
-- Name: user_retention_9months; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.user_retention_9months AS
 SELECT user_retention_by_month.month,
    user_retention_by_month.num_consumers,
    user_retention_by_month.repeat_consumers,
    user_retention_by_month.num_tickets,
    user_retention_by_month.sum_amount_list_price,
    user_retention_by_month.sum_amount_paid,
    user_retention_by_month.num_repeat_tickets,
    user_retention_by_month.sum_repeat_amount_list_price,
    user_retention_by_month.sum_repeat_amount_paid,
    user_retention_by_month.frac_users_retained,
    user_retention_by_month.frac_tickets_retained,
    user_retention_by_month.frac_listprice_retained,
    user_retention_by_month.frac_amountpaid_retained,
    user_retention_by_month.old_month,
    user_retention_by_month.old_num_consumers,
    user_retention_by_month.old_repeat_consumers,
    user_retention_by_month.old_num_tickets,
    user_retention_by_month.old_sum_amount_list_price,
    user_retention_by_month.old_sum_amount_paid
   FROM public.user_retention_by_month(9) user_retention_by_month(month, num_consumers, repeat_consumers, num_tickets, sum_amount_list_price, sum_amount_paid, num_repeat_tickets, sum_repeat_amount_list_price, sum_repeat_amount_paid, frac_users_retained, frac_tickets_retained, frac_listprice_retained, frac_amountpaid_retained, old_month, old_num_consumers, old_repeat_consumers, old_num_tickets, old_sum_amount_list_price, old_sum_amount_paid);


ALTER TABLE public.user_retention_9months OWNER TO dbservice;

--
-- Name: user_retention_tickets; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.user_retention_tickets AS
 SELECT byte_tickets.week,
    byte_tickets.month,
    (((byte_tickets.client_name)::text || '--'::text) || byte_tickets.uniq_user) AS consumer_id,
    byte_tickets.amount_list_price,
    byte_tickets.amount_paid
   FROM public.byte_tickets
  WHERE (byte_tickets.uniq_user <> ALL (ARRAY['F.OfflineMode'::text, 'F.Complimentary'::text]));


ALTER TABLE public.user_retention_tickets OWNER TO dbservice;

--
-- Name: valid_bytecodes; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.valid_bytecodes AS
 SELECT bytecodelog.email,
    bytecodelog.bytecode,
    to_timestamp((bytecodelog.created_at)::double precision) AS created_at,
    bytecodelog.duration,
    to_timestamp((bytecodelog.expires_at)::double precision) AS expires_at
   FROM public.bytecodelog
  WHERE ((bytecodelog.expires_at)::double precision >= date_part('epoch'::text, now()))
  ORDER BY (to_timestamp((bytecodelog.expires_at)::double precision)) DESC;


ALTER TABLE public.valid_bytecodes OWNER TO dbservice;

--
-- Name: dependency; Type: VIEW; Schema: report; Owner: dbservice
--

CREATE VIEW report.dependency AS
 WITH RECURSIVE preference AS (
         SELECT 10 AS max_depth,
            16384 AS min_oid,
            '^(londiste|pgq|pg_toast)'::text AS schema_exclusion,
            '^pg_(conversion|language|ts_(dict|template))'::text AS class_exclusion,
            '{"SCHEMA":"00", "TABLE":"01", "TABLE CONSTRAINT":"02", "DEFAULT VALUE":"03",
        "INDEX":"05", "SEQUENCE":"06", "TRIGGER":"07", "FUNCTION":"08",
        "VIEW":"10", "MATERIALIZED VIEW":"11", "FOREIGN TABLE":"12"}'::json AS type_sort_orders
        ), dependency_pair AS (
         SELECT dep.objid,
            array_agg(dep.objsubid ORDER BY dep.objsubid) AS objsubids,
            upper(obj.type) AS object_type,
            COALESCE(obj.schema, "substring"(obj.identity, '(\w+?)\.'::text), ''::text) AS object_schema,
            obj.name AS object_name,
            obj.identity AS object_identity,
            dep.refobjid,
            array_agg(dep.refobjsubid ORDER BY dep.refobjsubid) AS refobjsubids,
            upper(refobj.type) AS refobj_type,
            COALESCE(
                CASE
                    WHEN (refobj.type = 'schema'::text) THEN refobj.identity
                    ELSE refobj.schema
                END, "substring"(refobj.identity, '(\w+?)\.'::text), ''::text) AS refobj_schema,
            refobj.name AS refobj_name,
            refobj.identity AS refobj_identity,
                CASE dep.deptype
                    WHEN 'n'::"char" THEN 'normal'::text
                    WHEN 'a'::"char" THEN 'automatic'::text
                    WHEN 'i'::"char" THEN 'internal'::text
                    WHEN 'e'::"char" THEN 'extension'::text
                    WHEN 'p'::"char" THEN 'pinned'::text
                    ELSE NULL::text
                END AS dependency_type
           FROM pg_depend dep,
            LATERAL pg_identify_object(dep.classid, dep.objid, 0) obj(type, schema, name, identity),
            LATERAL pg_identify_object(dep.refclassid, dep.refobjid, 0) refobj(type, schema, name, identity),
            preference
          WHERE ((dep.deptype = ANY ('{n,a}'::"char"[])) AND (dep.objid >= (preference.min_oid)::oid) AND ((dep.refobjid >= (preference.min_oid)::oid) OR (dep.refobjid = (2200)::oid)) AND (COALESCE(obj.schema, "substring"(obj.identity, '(\w+?)\.'::text), ''::text) !~ preference.schema_exclusion) AND (COALESCE(
                CASE
                    WHEN (refobj.type = 'schema'::text) THEN refobj.identity
                    ELSE refobj.schema
                END, "substring"(refobj.identity, '(\w+?)\.'::text), ''::text) !~ preference.schema_exclusion))
          GROUP BY dep.objid, obj.type, obj.schema, obj.name, obj.identity, dep.refobjid, refobj.type, refobj.schema, refobj.name, refobj.identity, dep.deptype
        ), dependency_hierarchy AS (
         SELECT DISTINCT 0 AS level,
            root.refobjid AS objid,
            root.refobj_type AS object_type,
            root.refobj_identity AS object_identity,
            NULL::text AS dependency_type,
            ARRAY[root.refobjid] AS dependency_chain,
            ARRAY[concat((preference.type_sort_orders ->> root.refobj_type), root.refobj_type, ':', root.refobj_identity)] AS dependency_sort_chain
           FROM dependency_pair root,
            preference
          WHERE ((NOT (EXISTS ( SELECT 'x'::text
                   FROM dependency_pair branch
                  WHERE (branch.objid = root.refobjid)))) AND (root.refobj_schema !~ preference.schema_exclusion))
        UNION ALL
         SELECT (parent.level + 1) AS level,
            child.objid,
            child.object_type,
            child.object_identity,
            child.dependency_type,
            (parent.dependency_chain || child.objid),
            (parent.dependency_sort_chain || concat((preference.type_sort_orders ->> child.object_type), child.object_type, ':', child.object_identity))
           FROM (dependency_pair child
             JOIN dependency_hierarchy parent ON ((parent.objid = child.refobjid))),
            preference
          WHERE ((parent.level < preference.max_depth) AND (child.object_schema !~ preference.schema_exclusion) AND (child.refobj_schema !~ preference.schema_exclusion) AND (NOT (child.objid = ANY (parent.dependency_chain))))
        )
 SELECT dependency_hierarchy.level,
    dependency_hierarchy.objid,
    dependency_hierarchy.object_type,
    dependency_hierarchy.object_identity,
    dependency_hierarchy.dependency_type,
    dependency_hierarchy.dependency_chain,
    dependency_hierarchy.dependency_sort_chain
   FROM dependency_hierarchy
  ORDER BY dependency_hierarchy.dependency_chain;


ALTER TABLE report.dependency OWNER TO dbservice;

--
-- Name: current_inventory; Type: VIEW; Schema: rptg; Owner: dbservice
--

CREATE VIEW rptg.current_inventory AS
 SELECT spoiled_data.epc,
    spoiled_data.kiosk_id,
    spoiled_data.product_id,
    spoiled_data.time_added,
    spoiled_data.cost,
    spoiled_data.price,
    spoiled_data.kiosk_campus_id,
    spoiled_data.product_campus_id,
    spoiled_data.enable_reporting
   FROM ( SELECT unique_epcs.epc,
            all_epc_data.kiosk_id,
            all_epc_data.product_id,
            to_timestamp((all_epc_data.time_added)::double precision) AS time_added,
            all_epc_data.cost,
            all_epc_data.price,
            all_epc_data.kiosk_campus_id,
            all_epc_data.product_campus_id,
            all_epc_data.enable_reporting
           FROM (( SELECT l.epc,
                    max(l.time_added) AS time_added
                   FROM ((pantry.label l
                     JOIN pantry.kiosk k ON ((k.id = l.kiosk_id)))
                     JOIN pantry.product p ON ((p.id = l.product_id)))
                  WHERE (((l.status)::text = 'ok'::text) AND (l.order_id IS NULL))
                  GROUP BY l.epc) unique_epcs
             LEFT JOIN ( SELECT l.epc,
                    l.product_id,
                    l.time_added,
                    p.cost,
                    p.price,
                    l.kiosk_id,
                    k.campus_id AS kiosk_campus_id,
                    p.campus_id AS product_campus_id,
                    k.enable_reporting
                   FROM ((pantry.label l
                     JOIN pantry.kiosk k ON ((k.id = l.kiosk_id)))
                     JOIN pantry.product p ON ((p.id = l.product_id)))
                  WHERE (((l.status)::text = 'ok'::text) AND (l.order_id IS NULL))) all_epc_data ON ((((unique_epcs.epc)::text = (all_epc_data.epc)::text) AND (unique_epcs.time_added = all_epc_data.time_added))))) spoiled_data
  WHERE ((NOT ((spoiled_data.epc)::text IN ( SELECT l.epc
           FROM (((pantry.label l
             JOIN pantry.kiosk k ON ((k.id = l.kiosk_id)))
             JOIN pantry.product p ON ((p.id = l.product_id)))
             JOIN pantry."order" o ON (((o.order_id)::text = (l.order_id)::text)))
          WHERE (((to_timestamp((o.created)::double precision))::date >= ( SELECT ((now() - '1 mon'::interval))::date AS date)) AND ((to_timestamp((o.created)::double precision))::date <= ( SELECT ((now() + '1 mon'::interval))::date AS date)) AND ((l.status)::text = 'sold'::text) AND ((l.order_id)::text !~~ 'RE%'::text) AND (l.order_id IS NOT NULL))))) AND (NOT ((spoiled_data.epc)::text IN ( SELECT l.epc
           FROM (((pantry.label l
             JOIN pantry.kiosk k ON ((k.id = l.kiosk_id)))
             JOIN pantry.product p ON ((p.id = l.product_id)))
             JOIN pantry."order" o ON (((o.order_id)::text = (l.order_id)::text)))
          WHERE (((to_timestamp((o.created)::double precision))::date >= ( SELECT ((now() - '1 mon'::interval))::date AS date)) AND ((to_timestamp((o.created)::double precision))::date <= ( SELECT ((now() + '1 mon'::interval))::date AS date)) AND ((l.status)::text = 'sold'::text) AND ((l.order_id)::text ~~ 'RE%'::text))))));


ALTER TABLE rptg.current_inventory OWNER TO dbservice;

--
-- Name: temp_yann_boardq3; Type: TABLE; Schema: rptg; Owner: dbservice
--

CREATE TABLE rptg.temp_yann_boardq3 (
    year double precision,
    month double precision,
    month_year text,
    product_id bigint,
    title character varying(381),
    sku_group character varying(765),
    consumer_category character varying(6000),
    "?column?" text,
    kiosk_w_sales bigint,
    units_sold_per_kiosk double precision,
    kiosk_week_sales_fix double precision,
    price numeric(5,2),
    cost numeric(5,2),
    unit_margin double precision,
    count_sales bigint,
    sales_list_price numeric,
    ttl_cost double precision,
    units_unsold double precision,
    cost_unsold double precision,
    units_lost bigint,
    cost_lost numeric,
    lost_percent double precision,
    rfid_cost double precision
);


ALTER TABLE rptg.temp_yann_boardq3 OWNER TO dbservice;

--
-- Name: temp_yann_q1; Type: TABLE; Schema: rptg; Owner: dbservice
--

CREATE TABLE rptg.temp_yann_q1 (
    year double precision,
    month double precision,
    month_year text,
    kiosk_id bigint,
    title character varying(138),
    client_name character varying(765),
    geo character varying(9),
    monthly_subscription bigint,
    coalesced_sales_list_price numeric,
    byte_discount double precision,
    sales_after_discount double precision,
    coalesced_total_food_cost numeric,
    coalesced_total_unsold_cost numeric,
    coalesced_total_lost_cost numeric,
    subsidy character varying(150)
);


ALTER TABLE rptg.temp_yann_q1 OWNER TO dbservice;

--
-- Name: accounting_bkup_20200204_partial; Type: TABLE; Schema: test; Owner: dbservice
--

CREATE TABLE test.accounting_bkup_20200204_partial (
    id bigint,
    date character varying(45),
    kiosk_id bigint,
    campus_id bigint,
    sales_ipc numeric(6,2),
    sales_fp numeric(6,2),
    sales_cs numeric(6,2),
    sales_cp numeric(6,2),
    tags_got bigint,
    tags_spent bigint,
    timezone smallint,
    sales_tax numeric(4,2),
    sales_tax_ipc numeric(6,2),
    sales_tax_fp numeric(6,2),
    sales_tax_cs numeric(6,2),
    sales_tax_cp numeric(6,2),
    prepaid bigint,
    current_fee bigint,
    next_fee bigint,
    recalculated_fee numeric(6,2),
    prepaid_day bigint,
    next_fee_from character varying(45),
    fee_connectivity numeric(5,2)
);


ALTER TABLE test.accounting_bkup_20200204_partial OWNER TO dbservice;

--
-- Name: accounting_partial_backup_20191101; Type: TABLE; Schema: test; Owner: dbservice
--

CREATE TABLE test.accounting_partial_backup_20191101 (
    id bigint,
    date character varying(45),
    kiosk_id bigint,
    campus_id bigint,
    sales_ipc numeric(6,2),
    sales_fp numeric(6,2),
    sales_cs numeric(6,2),
    sales_cp numeric(6,2),
    tags_got bigint,
    tags_spent bigint,
    timezone smallint,
    sales_tax numeric(4,2),
    sales_tax_ipc numeric(6,2),
    sales_tax_fp numeric(6,2),
    sales_tax_cs numeric(6,2),
    sales_tax_cp numeric(6,2),
    prepaid bigint,
    current_fee bigint,
    next_fee bigint,
    recalculated_fee numeric(6,2),
    prepaid_day bigint,
    next_fee_from character varying(45),
    fee_connectivity numeric(5,2)
);


ALTER TABLE test.accounting_partial_backup_20191101 OWNER TO dbservice;

--
-- Name: accounting_partial_bkup_20200131; Type: TABLE; Schema: test; Owner: dbservice
--

CREATE TABLE test.accounting_partial_bkup_20200131 (
    id bigint,
    date character varying(45),
    kiosk_id bigint,
    campus_id bigint,
    sales_ipc numeric(6,2),
    sales_fp numeric(6,2),
    sales_cs numeric(6,2),
    sales_cp numeric(6,2),
    tags_got bigint,
    tags_spent bigint,
    timezone smallint,
    sales_tax numeric(4,2),
    sales_tax_ipc numeric(6,2),
    sales_tax_fp numeric(6,2),
    sales_tax_cs numeric(6,2),
    sales_tax_cp numeric(6,2),
    prepaid bigint,
    current_fee bigint,
    next_fee bigint,
    recalculated_fee numeric(6,2),
    prepaid_day bigint,
    next_fee_from character varying(45),
    fee_connectivity numeric(5,2)
);


ALTER TABLE test.accounting_partial_bkup_20200131 OWNER TO dbservice;

--
-- Name: backup_eng_2669_order; Type: TABLE; Schema: test; Owner: dbservice
--

CREATE TABLE test.backup_eng_2669_order (
    order_id character varying(45),
    first_name character varying(45),
    last_name character varying(45),
    kiosk_id bigint,
    kiosk_title character varying(46),
    email character varying(127),
    amount_paid numeric(6,2),
    payment_system character varying(45),
    transaction_id character varying(45),
    approval_code character varying(45),
    status_code character varying(45),
    status_message character varying(45),
    status character varying(45),
    batch_id character varying(15),
    created bigint,
    auth_amount character varying(7),
    data_token character varying(2047),
    time_opened bigint,
    time_closed bigint,
    card_hash character varying(88),
    state character varying(15),
    archived bigint,
    stamp bigint,
    last_update bigint,
    balance numeric(7,2),
    delta character varying(4),
    coupon_id bigint,
    coupon character varying(45),
    refund numeric(6,2),
    receipt bigint,
    campus_id bigint,
    amount_list_price numeric(6,2),
    time_door_opened bigint,
    time_door_closed bigint,
    notes text
);


ALTER TABLE test.backup_eng_2669_order OWNER TO dbservice;

--
-- Name: campus_20190605; Type: TABLE; Schema: test; Owner: dbservice
--

CREATE TABLE test.campus_20190605 (
    id bigint,
    title character varying(45),
    timezone character varying(50),
    archived integer
);


ALTER TABLE test.campus_20190605 OWNER TO dbservice;

--
-- Name: campus_20190620; Type: TABLE; Schema: test; Owner: dbservice
--

CREATE TABLE test.campus_20190620 (
    id bigint,
    title character varying(45),
    timezone character varying(50),
    archived integer
);


ALTER TABLE test.campus_20190620 OWNER TO dbservice;

--
-- Name: cron_broken; Type: TABLE; Schema: test; Owner: dbservice
--

CREATE TABLE test.cron_broken (
    id integer,
    "time" character varying(300),
    kiosks character varying(30000),
    command character varying(300),
    payload text,
    trigger_id integer,
    dependencies character varying(300),
    user_id integer,
    raw_task text,
    active integer,
    group_id integer,
    timezone character varying(210),
    archived integer
);


ALTER TABLE test.cron_broken OWNER TO dbservice;

--
-- Name: discount_20190614; Type: TABLE; Schema: test; Owner: dbservice
--

CREATE TABLE test.discount_20190614 (
    id bigint,
    kiosk_id bigint,
    product_id bigint,
    value integer,
    type character varying(10),
    end_time integer,
    cron_task_id integer
);


ALTER TABLE test.discount_20190614 OWNER TO dbservice;

--
-- Name: eng2903; Type: TABLE; Schema: test; Owner: dbservice
--

CREATE TABLE test.eng2903 (
    order_id character varying(45) NOT NULL
);


ALTER TABLE test.eng2903 OWNER TO dbservice;

--
-- Name: fee_rate_bkup_20200131; Type: TABLE; Schema: test; Owner: dbservice
--

CREATE TABLE test.fee_rate_bkup_20200131 (
    id bigint,
    fee_lease numeric(6,2),
    fee_tags numeric(3,2),
    fee_ipc numeric(5,4),
    bi_monthly smallint,
    archived smallint,
    custom smallint,
    prepaid_amount bigint,
    name character varying(128)
);


ALTER TABLE test.fee_rate_bkup_20200131 OWNER TO dbservice;

--
-- Name: kiosk; Type: TABLE; Schema: test; Owner: dbservice
--

CREATE TABLE test.kiosk (
    id bigint,
    campus_id bigint,
    serial character varying(45),
    title character varying(46),
    address character varying(127),
    location_x numeric(9,6),
    location_y numeric(9,6),
    gcm_id character varying(255),
    app_vname character varying(63),
    app_vcode integer,
    archived bigint,
    creation_time bigint,
    deployment_time bigint,
    last_update bigint,
    client_name character varying(255),
    last_status bigint,
    last_inventory bigint,
    kiosk_name character varying(255),
    payment_start bigint,
    payment_stop bigint,
    features character varying(255),
    sales_tax smallint,
    default_fee_plan bigint,
    timezone character varying(50),
    estd_num_users bigint,
    tags character varying(255),
    publicly_accessible bigint,
    cardkey_required bigint,
    delivery_insns character varying(65535),
    fridge_loc_info character varying(65535),
    contact_first_name character varying(65535),
    contact_last_name character varying(65535),
    contact_email character varying(65535),
    contact_phone character varying(65535),
    accounting_email character varying(65535),
    byte_discount character varying(255),
    subsidy_info character varying(50),
    subsidy_notes character varying(65535),
    max_subscription character varying(50),
    delivery_window_mon character varying(50),
    delivery_window_tue character varying(50),
    delivery_window_wed character varying(50),
    delivery_window_thu character varying(50),
    delivery_window_fri character varying(50),
    delivery_window_sat character varying(50),
    delivery_window_sun character varying(50),
    notes character varying(2000),
    components text,
    email_receipt_subject character varying(255),
    ops_team_notes character varying(65535),
    geo character varying(3),
    server_url character varying(127),
    subscription_amount numeric(8,2),
    enable_reporting bigint,
    enable_monitoring bigint,
    employees_num bigint,
    kiosk_restrictions character varying(2000)
);


ALTER TABLE test.kiosk OWNER TO dbservice;

--
-- Name: kiosk_20190605; Type: TABLE; Schema: test; Owner: dbservice
--

CREATE TABLE test.kiosk_20190605 (
    id bigint,
    campus_id bigint,
    serial character varying(45),
    title character varying(46),
    address character varying(127),
    location_x numeric(9,6),
    location_y numeric(9,6),
    gcm_id character varying(255),
    app_vname character varying(63),
    app_vcode integer,
    archived bigint,
    creation_time bigint,
    deployment_time bigint,
    last_update bigint,
    client_name character varying(255),
    last_status bigint,
    last_inventory bigint,
    kiosk_name character varying(255),
    payment_start bigint,
    payment_stop bigint,
    features character varying(255),
    sales_tax smallint,
    default_fee_plan bigint,
    timezone character varying(50),
    estd_num_users bigint,
    tags character varying(255),
    publicly_accessible bigint,
    cardkey_required bigint,
    delivery_insns character varying(65535),
    fridge_loc_info character varying(65535),
    contact_first_name character varying(65535),
    contact_last_name character varying(65535),
    contact_email character varying(65535),
    contact_phone character varying(65535),
    accounting_email character varying(65535),
    byte_discount character varying(255),
    subsidy_info character varying(50),
    subsidy_notes character varying(65535),
    max_subscription character varying(50),
    delivery_window_mon character varying(50),
    delivery_window_tue character varying(50),
    delivery_window_wed character varying(50),
    delivery_window_thu character varying(50),
    delivery_window_fri character varying(50),
    delivery_window_sat character varying(50),
    delivery_window_sun character varying(50),
    notes character varying(2000),
    components text,
    email_receipt_subject character varying(255),
    ops_team_notes character varying(65535),
    geo character varying(3),
    server_url character varying(127),
    subscription_amount numeric(8,2),
    enable_reporting bigint,
    enable_monitoring bigint,
    employees_num bigint,
    kiosk_restrictions character varying(2000)
);


ALTER TABLE test.kiosk_20190605 OWNER TO dbservice;

--
-- Name: kiosk_20190606; Type: TABLE; Schema: test; Owner: dbservice
--

CREATE TABLE test.kiosk_20190606 (
    id bigint,
    campus_id bigint,
    serial character varying(45),
    title character varying(46),
    address character varying(127),
    location_x numeric(9,6),
    location_y numeric(9,6),
    gcm_id character varying(255),
    app_vname character varying(63),
    app_vcode integer,
    archived bigint,
    creation_time bigint,
    deployment_time bigint,
    last_update bigint,
    client_name character varying(255),
    last_status bigint,
    last_inventory bigint,
    kiosk_name character varying(255),
    payment_start bigint,
    payment_stop bigint,
    features character varying(255),
    sales_tax smallint,
    default_fee_plan bigint,
    timezone character varying(50),
    estd_num_users bigint,
    tags character varying(255),
    publicly_accessible bigint,
    cardkey_required bigint,
    delivery_insns character varying(65535),
    fridge_loc_info character varying(65535),
    contact_first_name character varying(65535),
    contact_last_name character varying(65535),
    contact_email character varying(65535),
    contact_phone character varying(65535),
    accounting_email character varying(65535),
    byte_discount character varying(255),
    subsidy_info character varying(50),
    subsidy_notes character varying(65535),
    max_subscription character varying(50),
    delivery_window_mon character varying(50),
    delivery_window_tue character varying(50),
    delivery_window_wed character varying(50),
    delivery_window_thu character varying(50),
    delivery_window_fri character varying(50),
    delivery_window_sat character varying(50),
    delivery_window_sun character varying(50),
    notes character varying(2000),
    components text,
    email_receipt_subject character varying(255),
    ops_team_notes character varying(65535),
    geo character varying(3),
    server_url character varying(127),
    subscription_amount numeric(8,2),
    enable_reporting bigint,
    enable_monitoring bigint,
    employees_num bigint,
    kiosk_restrictions character varying(2000)
);


ALTER TABLE test.kiosk_20190606 OWNER TO dbservice;

--
-- Name: kiosk_20190611; Type: TABLE; Schema: test; Owner: dbservice
--

CREATE TABLE test.kiosk_20190611 (
    id bigint,
    campus_id bigint,
    serial character varying(45),
    title character varying(46),
    address character varying(127),
    location_x numeric(9,6),
    location_y numeric(9,6),
    gcm_id character varying(255),
    app_vname character varying(63),
    app_vcode integer,
    archived bigint,
    creation_time bigint,
    deployment_time bigint,
    last_update bigint,
    client_name character varying(255),
    last_status bigint,
    last_inventory bigint,
    kiosk_name character varying(255),
    payment_start bigint,
    payment_stop bigint,
    features character varying(255),
    sales_tax smallint,
    default_fee_plan bigint,
    timezone character varying(50),
    estd_num_users bigint,
    tags character varying(255),
    publicly_accessible bigint,
    cardkey_required bigint,
    delivery_insns character varying(65535),
    fridge_loc_info character varying(65535),
    contact_first_name character varying(65535),
    contact_last_name character varying(65535),
    contact_email character varying(65535),
    contact_phone character varying(65535),
    accounting_email character varying(65535),
    byte_discount character varying(255),
    subsidy_info character varying(50),
    subsidy_notes character varying(65535),
    max_subscription character varying(50),
    delivery_window_mon character varying(50),
    delivery_window_tue character varying(50),
    delivery_window_wed character varying(50),
    delivery_window_thu character varying(50),
    delivery_window_fri character varying(50),
    delivery_window_sat character varying(50),
    delivery_window_sun character varying(50),
    notes character varying(2000),
    components text,
    email_receipt_subject character varying(255),
    ops_team_notes character varying(65535),
    geo character varying(3),
    server_url character varying(127),
    subscription_amount numeric(8,2),
    enable_reporting bigint,
    enable_monitoring bigint,
    employees_num bigint,
    kiosk_restrictions character varying(2000)
);


ALTER TABLE test.kiosk_20190611 OWNER TO dbservice;

--
-- Name: kiosk_20190612; Type: TABLE; Schema: test; Owner: dbservice
--

CREATE TABLE test.kiosk_20190612 (
    id bigint,
    campus_id bigint,
    serial character varying(45),
    title character varying(46),
    address character varying(127),
    location_x numeric(9,6),
    location_y numeric(9,6),
    gcm_id character varying(255),
    app_vname character varying(63),
    app_vcode integer,
    archived bigint,
    creation_time bigint,
    deployment_time bigint,
    last_update bigint,
    client_name character varying(255),
    last_status bigint,
    last_inventory bigint,
    kiosk_name character varying(255),
    payment_start bigint,
    payment_stop bigint,
    features character varying(255),
    sales_tax smallint,
    default_fee_plan bigint,
    timezone character varying(50),
    estd_num_users bigint,
    tags character varying(255),
    publicly_accessible bigint,
    cardkey_required bigint,
    delivery_insns character varying(65535),
    fridge_loc_info character varying(65535),
    contact_first_name character varying(65535),
    contact_last_name character varying(65535),
    contact_email character varying(65535),
    contact_phone character varying(65535),
    accounting_email character varying(65535),
    byte_discount character varying(255),
    subsidy_info character varying(50),
    subsidy_notes character varying(65535),
    max_subscription character varying(50),
    delivery_window_mon character varying(50),
    delivery_window_tue character varying(50),
    delivery_window_wed character varying(50),
    delivery_window_thu character varying(50),
    delivery_window_fri character varying(50),
    delivery_window_sat character varying(50),
    delivery_window_sun character varying(50),
    notes character varying(2000),
    components text,
    email_receipt_subject character varying(255),
    ops_team_notes character varying(65535),
    geo character varying(3),
    server_url character varying(127),
    subscription_amount numeric(8,2),
    enable_reporting bigint,
    enable_monitoring bigint,
    employees_num bigint,
    kiosk_restrictions character varying(2000)
);


ALTER TABLE test.kiosk_20190612 OWNER TO dbservice;

--
-- Name: kiosk_20190918; Type: TABLE; Schema: test; Owner: dbservice
--

CREATE TABLE test.kiosk_20190918 (
    id bigint,
    campus_id bigint,
    serial character varying(45),
    title character varying(46),
    address character varying(127),
    location_x numeric(9,6),
    location_y numeric(9,6),
    gcm_id character varying(255),
    app_vname character varying(63),
    app_vcode integer,
    archived bigint,
    creation_time bigint,
    deployment_time bigint,
    last_update bigint,
    client_name character varying(255),
    last_status bigint,
    last_inventory bigint,
    kiosk_name character varying(255),
    payment_start bigint,
    payment_stop bigint,
    features character varying(255),
    sales_tax smallint,
    default_fee_plan bigint,
    timezone character varying(50),
    estd_num_users bigint,
    tags character varying(255),
    publicly_accessible bigint,
    cardkey_required bigint,
    delivery_insns character varying(65535),
    fridge_loc_info character varying(65535),
    contact_first_name character varying(65535),
    contact_last_name character varying(65535),
    contact_email character varying(65535),
    contact_phone character varying(65535),
    accounting_email character varying(65535),
    byte_discount character varying(255),
    subsidy_info character varying(50),
    subsidy_notes character varying(65535),
    max_subscription character varying(50),
    delivery_window_mon character varying(50),
    delivery_window_tue character varying(50),
    delivery_window_wed character varying(50),
    delivery_window_thu character varying(50),
    delivery_window_fri character varying(50),
    delivery_window_sat character varying(50),
    delivery_window_sun character varying(50),
    notes character varying(2000),
    components text,
    email_receipt_subject character varying(255),
    ops_team_notes character varying(65535),
    geo character varying(3),
    server_url character varying(127),
    subscription_amount numeric(8,2),
    enable_reporting bigint,
    enable_monitoring bigint,
    employees_num bigint,
    kiosk_restrictions character varying(2000)
);


ALTER TABLE test.kiosk_20190918 OWNER TO dbservice;

--
-- Name: kiosk_20200304; Type: TABLE; Schema: test; Owner: dbservice
--

CREATE TABLE test.kiosk_20200304 (
    id integer,
    title character varying(8000)
);


ALTER TABLE test.kiosk_20200304 OWNER TO dbservice;

--
-- Name: kiosk_bkup_20200204; Type: TABLE; Schema: test; Owner: dbservice
--

CREATE TABLE test.kiosk_bkup_20200204 (
    id bigint,
    campus_id bigint,
    serial character varying(45),
    title character varying(46),
    address character varying(127),
    location_x numeric(9,6),
    location_y numeric(9,6),
    gcm_id character varying(255),
    app_vname character varying(63),
    app_vcode integer,
    archived bigint,
    creation_time bigint,
    deployment_time bigint,
    last_update bigint,
    client_name character varying(255),
    last_status bigint,
    last_inventory bigint,
    kiosk_name character varying(255),
    payment_start bigint,
    payment_stop bigint,
    features character varying(255),
    sales_tax smallint,
    default_fee_plan bigint,
    timezone character varying(50),
    estd_num_users bigint,
    tags character varying(255),
    publicly_accessible bigint,
    cardkey_required bigint,
    delivery_insns character varying(65535),
    fridge_loc_info character varying(65535),
    contact_first_name character varying(65535),
    contact_last_name character varying(65535),
    contact_email character varying(65535),
    contact_phone character varying(65535),
    accounting_email character varying(65535),
    byte_discount character varying(255),
    subsidy_info character varying(50),
    subsidy_notes character varying(65535),
    max_subscription character varying(50),
    delivery_window_mon character varying(50),
    delivery_window_tue character varying(50),
    delivery_window_wed character varying(50),
    delivery_window_thu character varying(50),
    delivery_window_fri character varying(50),
    delivery_window_sat character varying(50),
    delivery_window_sun character varying(50),
    notes character varying(2000),
    components text,
    email_receipt_subject character varying(255),
    ops_team_notes character varying(65535),
    geo character varying(3),
    server_url character varying(127),
    subscription_amount numeric(8,2),
    enable_reporting bigint,
    enable_monitoring bigint,
    employees_num bigint,
    kiosk_restrictions character varying(2000)
);


ALTER TABLE test.kiosk_bkup_20200204 OWNER TO dbservice;

--
-- Name: kiosk_payment_start; Type: TABLE; Schema: test; Owner: dbservice
--

CREATE TABLE test.kiosk_payment_start (
    id integer NOT NULL,
    start_date_str text
);


ALTER TABLE test.kiosk_payment_start OWNER TO dbservice;

--
-- Name: kiosk_serial_20190916; Type: TABLE; Schema: test; Owner: dbservice
--

CREATE TABLE test.kiosk_serial_20190916 (
    id bigint NOT NULL,
    serial character varying(45)
);


ALTER TABLE test.kiosk_serial_20190916 OWNER TO dbservice;

--
-- Name: locked_kiosk_by_command; Type: TABLE; Schema: test; Owner: dbservice
--

CREATE TABLE test.locked_kiosk_by_command (
    lock_ts_string text,
    kiosk_id integer,
    lock_ts timestamp with time zone
);


ALTER TABLE test.locked_kiosk_by_command OWNER TO dbservice;

--
-- Name: locked_kiosk_via_pw; Type: TABLE; Schema: test; Owner: dbservice
--

CREATE TABLE test.locked_kiosk_via_pw (
    lock_ts_string text,
    kiosk_id integer,
    lock_ts timestamp with time zone
);


ALTER TABLE test.locked_kiosk_via_pw OWNER TO dbservice;

--
-- Name: lost_wall_clock_orders; Type: TABLE; Schema: test; Owner: dbservice
--

CREATE TABLE test.lost_wall_clock_orders (
    order_id text
);


ALTER TABLE test.lost_wall_clock_orders OWNER TO dbservice;

--
-- Name: november_order; Type: TABLE; Schema: test; Owner: dbservice
--

CREATE TABLE test.november_order (
    order_id text
);


ALTER TABLE test.november_order OWNER TO dbservice;

--
-- Name: order_complimentary_eng_2292; Type: TABLE; Schema: test; Owner: dbservice
--

CREATE TABLE test.order_complimentary_eng_2292 (
    order_id character varying(45) NOT NULL
);


ALTER TABLE test.order_complimentary_eng_2292 OWNER TO dbservice;

--
-- Name: order_epc_pending_sync; Type: TABLE; Schema: test; Owner: dbservice
--

CREATE TABLE test.order_epc_pending_sync (
    epc character varying(24) NOT NULL,
    order_id text
);


ALTER TABLE test.order_epc_pending_sync OWNER TO dbservice;

--
-- Name: order_with_1970_and_2000_dates; Type: TABLE; Schema: test; Owner: dbservice
--

CREATE TABLE test.order_with_1970_and_2000_dates (
    order_id character varying(45),
    first_name character varying(45),
    last_name character varying(45),
    kiosk_id bigint,
    kiosk_title character varying(46),
    email character varying(127),
    amount_paid numeric(6,2),
    payment_system character varying(45),
    transaction_id character varying(45),
    approval_code character varying(45),
    status_code character varying(45),
    status_message character varying(45),
    status character varying(45),
    batch_id character varying(15),
    created bigint,
    auth_amount character varying(7),
    data_token character varying(2047),
    time_opened bigint,
    time_closed bigint,
    card_hash character varying(88),
    state character varying(15),
    archived bigint,
    stamp bigint,
    last_update bigint,
    balance numeric(7,2),
    delta character varying(4),
    coupon_id bigint,
    coupon character varying(45),
    refund numeric(6,2),
    receipt bigint,
    campus_id bigint,
    amount_list_price numeric(6,2),
    time_door_opened bigint,
    time_door_closed bigint,
    notes text
);


ALTER TABLE test.order_with_1970_and_2000_dates OWNER TO dbservice;

--
-- Name: reauth_2019_07_priced_finalized_orders; Type: TABLE; Schema: test; Owner: dbservice
--

CREATE TABLE test.reauth_2019_07_priced_finalized_orders (
    order_id character varying(45) NOT NULL
);


ALTER TABLE test.reauth_2019_07_priced_finalized_orders OWNER TO dbservice;

--
-- Name: request_log_epc_order; Type: TABLE; Schema: test; Owner: dbservice
--

CREATE TABLE test.request_log_epc_order (
    epc character varying(24) NOT NULL,
    order_id text,
    ts timestamp without time zone NOT NULL
);


ALTER TABLE test.request_log_epc_order OWNER TO dbservice;

--
-- Name: request_log_order; Type: TABLE; Schema: test; Owner: dbservice
--

CREATE TABLE test.request_log_order (
    order_id text NOT NULL
);


ALTER TABLE test.request_log_order OWNER TO dbservice;

--
-- Name: request_log_sold_epc; Type: TABLE; Schema: test; Owner: dbservice
--

CREATE TABLE test.request_log_sold_epc (
    id integer NOT NULL,
    epc character varying(24) NOT NULL,
    order_id text,
    kiosk_id bigint,
    direction character varying(16) NOT NULL,
    reason text,
    ts timestamp without time zone NOT NULL
);


ALTER TABLE test.request_log_sold_epc OWNER TO dbservice;

--
-- Name: request_log_sold_epc_id_seq; Type: SEQUENCE; Schema: test; Owner: dbservice
--

CREATE SEQUENCE test.request_log_sold_epc_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE test.request_log_sold_epc_id_seq OWNER TO dbservice;

--
-- Name: request_log_sold_epc_id_seq; Type: SEQUENCE OWNED BY; Schema: test; Owner: dbservice
--

ALTER SEQUENCE test.request_log_sold_epc_id_seq OWNED BY test.request_log_sold_epc.id;


--
-- Name: temp_pending; Type: TABLE; Schema: test; Owner: dbservice
--

CREATE TABLE test.temp_pending (
    epc character varying(24) NOT NULL,
    order_id text
);


ALTER TABLE test.temp_pending OWNER TO dbservice;

--
-- Name: transactions_pending_sync; Type: TABLE; Schema: test; Owner: dbservice
--

CREATE TABLE test.transactions_pending_sync (
    id integer NOT NULL,
    epc character varying(24) NOT NULL,
    order_id text,
    kiosk_id bigint,
    direction character varying(16) NOT NULL,
    reason text,
    ts timestamp without time zone NOT NULL
);


ALTER TABLE test.transactions_pending_sync OWNER TO dbservice;

--
-- Name: transactions_pending_sync_id_seq; Type: SEQUENCE; Schema: test; Owner: dbservice
--

CREATE SEQUENCE test.transactions_pending_sync_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE test.transactions_pending_sync_id_seq OWNER TO dbservice;

--
-- Name: transactions_pending_sync_id_seq; Type: SEQUENCE OWNED BY; Schema: test; Owner: dbservice
--

ALTER SEQUENCE test.transactions_pending_sync_id_seq OWNED BY test.transactions_pending_sync.id;


--
-- Name: vantiv_20190801; Type: TABLE; Schema: test; Owner: dbservice
--

CREATE TABLE test.vantiv_20190801 (
    "Merchant DBA" text,
    transactionid integer,
    name text,
    terminalid text,
    approvalnumber text,
    expirationmonth integer,
    expirationyear integer,
    expressresponsecode integer,
    expressresponsemessage text,
    originalauthorizedamount integer,
    referencenumber text,
    ticketnumber integer,
    transactionamount numeric,
    transactionstatus text,
    transactiontype text,
    cardnumbermasked text,
    cardlogo text,
    cardtype text,
    trackdatapresent text,
    expresstransactiondate integer,
    expresstransactiontime integer,
    merchantcategorycode integer,
    cardinputcode integer
);


ALTER TABLE test.vantiv_20190801 OWNER TO dbservice;

--
-- Name: vantiv_20190801b; Type: TABLE; Schema: test; Owner: dbservice
--

CREATE TABLE test.vantiv_20190801b (
    "Merchant DBA" text,
    transactionid integer,
    name text,
    terminalid text,
    approvalnumber text,
    expirationmonth integer,
    expirationyear integer,
    expressresponsecode integer,
    expressresponsemessage text,
    originalauthorizedamount numeric,
    referencenumber text,
    ticketnumber integer,
    transactionamount numeric,
    transactionstatus text,
    transactiontype text,
    cardnumbermasked text,
    cardlogo text,
    cardtype text,
    trackdatapresent text,
    expresstransactiondate integer,
    expresstransactiontime integer,
    merchantcategorycode integer,
    cardinputcode integer
);


ALTER TABLE test.vantiv_20190801b OWNER TO dbservice;

--
-- Name: deps_saved_ddl; Type: TABLE; Schema: util; Owner: dbservice
--

CREATE TABLE util.deps_saved_ddl (
    deps_id integer NOT NULL,
    deps_view_schema character varying(255),
    deps_view_name character varying(255),
    deps_ddl_to_run text
);


ALTER TABLE util.deps_saved_ddl OWNER TO dbservice;

--
-- Name: TABLE deps_saved_ddl; Type: COMMENT; Schema: util; Owner: dbservice
--

COMMENT ON TABLE util.deps_saved_ddl IS 'part of save/drop/restore dependent views suite: table to store DDL of dependent views';


--
-- Name: deps_saved_ddl_deps_id_seq; Type: SEQUENCE; Schema: util; Owner: dbservice
--

CREATE SEQUENCE util.deps_saved_ddl_deps_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE util.deps_saved_ddl_deps_id_seq OWNER TO dbservice;

--
-- Name: deps_saved_ddl_deps_id_seq; Type: SEQUENCE OWNED BY; Schema: util; Owner: dbservice
--

ALTER SEQUENCE util.deps_saved_ddl_deps_id_seq OWNED BY util.deps_saved_ddl.deps_id;


--
-- Name: pick_demand id; Type: DEFAULT; Schema: beta; Owner: dbservice
--

ALTER TABLE ONLY beta.pick_demand ALTER COLUMN id SET DEFAULT nextval('beta.pick_demand_id_seq'::regclass);


--
-- Name: temp_test id; Type: DEFAULT; Schema: beta; Owner: dbservice
--

ALTER TABLE ONLY beta.temp_test ALTER COLUMN id SET DEFAULT nextval('beta.temp_test_id_seq'::regclass);


--
-- Name: temp_test2 id; Type: DEFAULT; Schema: beta; Owner: dbservice
--

ALTER TABLE ONLY beta.temp_test2 ALTER COLUMN id SET DEFAULT nextval('beta.temp_test2_id_seq'::regclass);


--
-- Name: product_property_def id; Type: DEFAULT; Schema: inm; Owner: dbservice
--

ALTER TABLE ONLY inm.product_property_def ALTER COLUMN id SET DEFAULT nextval('inm.product_property_def_id_seq'::regclass);


--
-- Name: card_fact id; Type: DEFAULT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.card_fact ALTER COLUMN id SET DEFAULT nextval('mixalot.card_fact_id_seq'::regclass);


--
-- Name: card_product_fact id; Type: DEFAULT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.card_product_fact ALTER COLUMN id SET DEFAULT nextval('mixalot.card_product_fact_id_seq'::regclass);


--
-- Name: history_order_pipeline id; Type: DEFAULT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.history_order_pipeline ALTER COLUMN id SET DEFAULT nextval('mixalot.history_order_id_seq'::regclass);


--
-- Name: inm_data id; Type: DEFAULT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.inm_data ALTER COLUMN id SET DEFAULT nextval('mixalot.inm_data_id_seq'::regclass);


--
-- Name: kiosk_contents id; Type: DEFAULT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.kiosk_contents ALTER COLUMN id SET DEFAULT nextval('mixalot.kiosk_contents_id_seq'::regclass);


--
-- Name: kiosk_fact id; Type: DEFAULT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.kiosk_fact ALTER COLUMN id SET DEFAULT nextval('mixalot.kiosk_fact_id_seq'::regclass);


--
-- Name: log id; Type: DEFAULT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.log ALTER COLUMN id SET DEFAULT nextval('mixalot.log_id_seq'::regclass);


--
-- Name: merchandising_slot id; Type: DEFAULT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.merchandising_slot ALTER COLUMN id SET DEFAULT nextval('mixalot.merchandising_slot_id_seq'::regclass);


--
-- Name: merchandising_slot_def id; Type: DEFAULT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.merchandising_slot_def ALTER COLUMN id SET DEFAULT nextval('mixalot.merchandising_slot_def_id_seq'::regclass);


--
-- Name: order_fact id; Type: DEFAULT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.order_fact ALTER COLUMN id SET DEFAULT nextval('mixalot.order_fact_id_seq'::regclass);


--
-- Name: product_fact id; Type: DEFAULT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.product_fact ALTER COLUMN id SET DEFAULT nextval('mixalot.product_fact_id_seq'::regclass);


--
-- Name: product_kiosk_fact id; Type: DEFAULT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.product_kiosk_fact ALTER COLUMN id SET DEFAULT nextval('mixalot.product_kiosk_fact_id_seq'::regclass);


--
-- Name: server id; Type: DEFAULT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.server ALTER COLUMN id SET DEFAULT nextval('mixalot.server_id_seq'::regclass);


--
-- Name: sku_group id; Type: DEFAULT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.sku_group ALTER COLUMN id SET DEFAULT nextval('mixalot.sku_group_id_seq'::regclass);


--
-- Name: sku_group_def id; Type: DEFAULT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.sku_group_def ALTER COLUMN id SET DEFAULT nextval('mixalot.sku_group_def_id_seq'::regclass);


--
-- Name: sku_group_member id; Type: DEFAULT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.sku_group_member ALTER COLUMN id SET DEFAULT nextval('mixalot.sku_group_member_id_seq'::regclass);


--
-- Name: sku_property_def id; Type: DEFAULT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.sku_property_def ALTER COLUMN id SET DEFAULT nextval('mixalot.sku_attribute_def_id_seq'::regclass);


--
-- Name: temp_test id; Type: DEFAULT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.temp_test ALTER COLUMN id SET DEFAULT nextval('mixalot.temp_test_id_seq'::regclass);


--
-- Name: test_time id; Type: DEFAULT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.test_time ALTER COLUMN id SET DEFAULT nextval('mixalot.test_time_id_seq'::regclass);


--
-- Name: tmp_discount_applied id; Type: DEFAULT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.tmp_discount_applied ALTER COLUMN id SET DEFAULT nextval('mixalot.tmp_discount_applied_id_seq'::regclass);


--
-- Name: tmp_kiosk_status id; Type: DEFAULT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.tmp_kiosk_status ALTER COLUMN id SET DEFAULT nextval('mixalot.tmp_kiosk_status_id_seq'::regclass);


--
-- Name: tmp_unit id; Type: DEFAULT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.tmp_unit ALTER COLUMN id SET DEFAULT nextval('mixalot.lineitem_id_seq'::regclass);


--
-- Name: accounting id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.accounting ALTER COLUMN id SET DEFAULT nextval('pantry.accounting_id_seq'::regclass);


--
-- Name: bad_timestamp id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.bad_timestamp ALTER COLUMN id SET DEFAULT nextval('pantry.bad_timestamp_id_seq'::regclass);


--
-- Name: campus id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.campus ALTER COLUMN id SET DEFAULT nextval('pantry.campus_id_seq'::regclass);


--
-- Name: campus_attribute id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.campus_attribute ALTER COLUMN id SET DEFAULT nextval('pantry.campus_attribute_id_seq'::regclass);


--
-- Name: card id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.card ALTER COLUMN id SET DEFAULT nextval('pantry.card_id_seq'::regclass);


--
-- Name: contract id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.contract ALTER COLUMN id SET DEFAULT nextval('pantry.contract_id_seq'::regclass);


--
-- Name: coupon id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.coupon ALTER COLUMN id SET DEFAULT nextval('pantry.coupon_id_seq'::regclass);


--
-- Name: cron id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.cron ALTER COLUMN id SET DEFAULT nextval('pantry.cron_id_seq'::regclass);


--
-- Name: currency_symbol id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.currency_symbol ALTER COLUMN id SET DEFAULT nextval('pantry.currency_symbol_id_seq'::regclass);


--
-- Name: delivery_schedule id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.delivery_schedule ALTER COLUMN id SET DEFAULT nextval('pantry.delivery_schedule_id_seq'::regclass);


--
-- Name: discount id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.discount ALTER COLUMN id SET DEFAULT nextval('pantry.discount_id_seq'::regclass);


--
-- Name: discount_applied id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.discount_applied ALTER COLUMN id SET DEFAULT nextval('pantry.discount_applied_id_seq'::regclass);


--
-- Name: discount_history id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.discount_history ALTER COLUMN id SET DEFAULT nextval('pantry.discount_history_id_seq'::regclass);


--
-- Name: email id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.email ALTER COLUMN id SET DEFAULT nextval('pantry.email_id_seq'::regclass);


--
-- Name: empty_transaction id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.empty_transaction ALTER COLUMN id SET DEFAULT nextval('pantry.empty_transaction_id_seq'::regclass);


--
-- Name: event id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.event ALTER COLUMN id SET DEFAULT nextval('pantry.event_id_seq'::regclass);


--
-- Name: facing_category id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.facing_category ALTER COLUMN id SET DEFAULT nextval('pantry.facing_category_id_seq'::regclass);


--
-- Name: fee_rates id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.fee_rates ALTER COLUMN id SET DEFAULT nextval('pantry.fee_rates_id_seq'::regclass);


--
-- Name: feedback id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.feedback ALTER COLUMN id SET DEFAULT nextval('pantry.feedback_id_seq'::regclass);


--
-- Name: global_attribute_def id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.global_attribute_def ALTER COLUMN id SET DEFAULT nextval('pantry.global_attribute_def_id_seq'::regclass);


--
-- Name: group id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry."group" ALTER COLUMN id SET DEFAULT nextval('pantry.group_id_seq'::regclass);


--
-- Name: history id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.history ALTER COLUMN id SET DEFAULT nextval('pantry.history_id_seq'::regclass);


--
-- Name: history_epc_order id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.history_epc_order ALTER COLUMN id SET DEFAULT nextval('pantry.history_epc_order_id_seq'::regclass);


--
-- Name: inventory_history id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.inventory_history ALTER COLUMN id SET DEFAULT nextval('pantry.inventory_history_id_seq'::regclass);


--
-- Name: inventory_request id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.inventory_request ALTER COLUMN id SET DEFAULT nextval('pantry.inventory_request_id_seq'::regclass);


--
-- Name: kiosk id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.kiosk ALTER COLUMN id SET DEFAULT nextval('pantry.kiosk_id_seq'::regclass);


--
-- Name: kiosk_attribute id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.kiosk_attribute ALTER COLUMN id SET DEFAULT nextval('pantry.kiosk_attribute_id_seq'::regclass);


--
-- Name: kiosk_audit_log id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.kiosk_audit_log ALTER COLUMN id SET DEFAULT nextval('pantry.kiosk_audit_log_id_seq'::regclass);


--
-- Name: kiosk_catalog_downloads id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.kiosk_catalog_downloads ALTER COLUMN id SET DEFAULT nextval('pantry.kiosk_catalog_downloads_id_seq'::regclass);


--
-- Name: kiosk_components_history id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.kiosk_components_history ALTER COLUMN id SET DEFAULT nextval('pantry.kiosk_components_history_id_seq'::regclass);


--
-- Name: kiosk_device id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.kiosk_device ALTER COLUMN id SET DEFAULT nextval('pantry.kiosk_device_id_seq'::regclass);


--
-- Name: kiosk_status id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.kiosk_status ALTER COLUMN id SET DEFAULT nextval('pantry.kiosk_status_id_seq'::regclass);


--
-- Name: kiosks_date_non_new id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.kiosks_date_non_new ALTER COLUMN id SET DEFAULT nextval('pantry.kiosks_date_non_new_id_seq'::regclass);


--
-- Name: label id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.label ALTER COLUMN id SET DEFAULT nextval('pantry.label_id_seq'::regclass);


--
-- Name: label_order id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.label_order ALTER COLUMN id SET DEFAULT nextval('pantry.label_order_id_seq'::regclass);


--
-- Name: last_kiosk_status id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.last_kiosk_status ALTER COLUMN id SET DEFAULT nextval('pantry.last_kiosk_status_id_seq'::regclass);


--
-- Name: manual_adjustment id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.manual_adjustment ALTER COLUMN id SET DEFAULT nextval('pantry.manual_adjustment_id_seq'::regclass);


--
-- Name: nutrition_filter id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.nutrition_filter ALTER COLUMN id SET DEFAULT nextval('pantry.nutrition_filter_id_seq'::regclass);


--
-- Name: order_meta id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.order_meta ALTER COLUMN id SET DEFAULT nextval('pantry.order_meta_id_seq'::regclass);


--
-- Name: par_history id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.par_history ALTER COLUMN id SET DEFAULT nextval('pantry.par_history_id_seq'::regclass);


--
-- Name: payment_order id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.payment_order ALTER COLUMN id SET DEFAULT nextval('pantry.payment_order_id_seq'::regclass);


--
-- Name: permission id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.permission ALTER COLUMN id SET DEFAULT nextval('pantry.permission_id_seq'::regclass);


--
-- Name: pick_list_row id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.pick_list_row ALTER COLUMN id SET DEFAULT nextval('pantry.pick_list_row_id_seq'::regclass);


--
-- Name: product id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.product ALTER COLUMN id SET DEFAULT nextval('pantry.product_id_seq'::regclass);


--
-- Name: product_categories id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.product_categories ALTER COLUMN id SET DEFAULT nextval('pantry.product_categories_id_seq'::regclass);


--
-- Name: product_history id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.product_history ALTER COLUMN id SET DEFAULT nextval('pantry.product_history_id_seq'::regclass);


--
-- Name: product_kiosk_price_offset id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.product_kiosk_price_offset ALTER COLUMN id SET DEFAULT nextval('pantry.product_kiosk_price_offset_id_seq'::regclass);


--
-- Name: product_request id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.product_request ALTER COLUMN id SET DEFAULT nextval('pantry.product_request_id_seq'::regclass);


--
-- Name: restock_item id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.restock_item ALTER COLUMN id SET DEFAULT nextval('pantry.restock_item_id_seq'::regclass);


--
-- Name: role id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.role ALTER COLUMN id SET DEFAULT nextval('pantry.role_id_seq'::regclass);


--
-- Name: spoilage id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.spoilage ALTER COLUMN id SET DEFAULT nextval('pantry.spoilage_id_seq'::regclass);


--
-- Name: stockout id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.stockout ALTER COLUMN id SET DEFAULT nextval('pantry.stockout_id_seq'::regclass);


--
-- Name: tag id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.tag ALTER COLUMN id SET DEFAULT nextval('pantry.tag_id_seq'::regclass);


--
-- Name: temperature_tag_history id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.temperature_tag_history ALTER COLUMN id SET DEFAULT nextval('pantry.temperature_tag_history_id_seq'::regclass);


--
-- Name: transact_comp id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.transact_comp ALTER COLUMN id SET DEFAULT nextval('pantry.transact_comp_id_seq'::regclass);


--
-- Name: transact_express id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.transact_express ALTER COLUMN id SET DEFAULT nextval('pantry.transact_express_id_seq'::regclass);


--
-- Name: transact_fp id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.transact_fp ALTER COLUMN id SET DEFAULT nextval('pantry.transact_fp_id_seq'::regclass);


--
-- Name: transact_ipc id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.transact_ipc ALTER COLUMN id SET DEFAULT nextval('pantry.transact_ipc_id_seq'::regclass);


--
-- Name: user id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry."user" ALTER COLUMN id SET DEFAULT nextval('pantry.user_id_seq'::regclass);


--
-- Name: awsdms_ddl_audit c_key; Type: DEFAULT; Schema: public; Owner: dbservice
--

ALTER TABLE ONLY public.awsdms_ddl_audit ALTER COLUMN c_key SET DEFAULT nextval('public.awsdms_ddl_audit_c_key_seq'::regclass);


--
-- Name: awsdms_heartbeat hb_key; Type: DEFAULT; Schema: public; Owner: dbservice
--

ALTER TABLE ONLY public.awsdms_heartbeat ALTER COLUMN hb_key SET DEFAULT nextval('public.awsdms_heartbeat_hb_key_seq'::regclass);


--
-- Name: campaigns campaign_id; Type: DEFAULT; Schema: public; Owner: dbservice
--

ALTER TABLE ONLY public.campaigns ALTER COLUMN campaign_id SET DEFAULT nextval('public.campaigns_campaign_id_seq'::regclass);


--
-- Name: customers customer_id; Type: DEFAULT; Schema: public; Owner: dbservice
--

ALTER TABLE ONLY public.customers ALTER COLUMN customer_id SET DEFAULT nextval('public.customers_customer_id_seq'::regclass);


--
-- Name: kiosk id; Type: DEFAULT; Schema: public; Owner: dbservice
--

ALTER TABLE ONLY public.kiosk ALTER COLUMN id SET DEFAULT nextval('public.kiosk_id_seq'::regclass);


--
-- Name: pantry.kiosk id; Type: DEFAULT; Schema: public; Owner: dbservice
--

ALTER TABLE ONLY public."pantry.kiosk" ALTER COLUMN id SET DEFAULT nextval('public."pantry.kiosk_id_seq"'::regclass);


--
-- Name: track_dashboard id; Type: DEFAULT; Schema: public; Owner: dbservice
--

ALTER TABLE ONLY public.track_dashboard ALTER COLUMN id SET DEFAULT nextval('public.track_dashboard_id_seq'::regclass);


--
-- Name: track_inventory id; Type: DEFAULT; Schema: public; Owner: dbservice
--

ALTER TABLE ONLY public.track_inventory ALTER COLUMN id SET DEFAULT nextval('public.track_inventory_id_seq'::regclass);


--
-- Name: request_log_sold_epc id; Type: DEFAULT; Schema: test; Owner: dbservice
--

ALTER TABLE ONLY test.request_log_sold_epc ALTER COLUMN id SET DEFAULT nextval('test.request_log_sold_epc_id_seq'::regclass);


--
-- Name: transactions_pending_sync id; Type: DEFAULT; Schema: test; Owner: dbservice
--

ALTER TABLE ONLY test.transactions_pending_sync ALTER COLUMN id SET DEFAULT nextval('test.transactions_pending_sync_id_seq'::regclass);


--
-- Name: deps_saved_ddl deps_id; Type: DEFAULT; Schema: util; Owner: dbservice
--

ALTER TABLE ONLY util.deps_saved_ddl ALTER COLUMN deps_id SET DEFAULT nextval('util.deps_saved_ddl_deps_id_seq'::regclass);


--
-- Name: kiosk_sku_group_manual_scale kiosk_sku_group_manual_scale_pkey; Type: CONSTRAINT; Schema: beta; Owner: dbservice
--

ALTER TABLE ONLY beta.kiosk_sku_group_manual_scale
    ADD CONSTRAINT kiosk_sku_group_manual_scale_pkey PRIMARY KEY (kiosk_id, fc_title);


--
-- Name: missing_hash missing_hash_pkey; Type: CONSTRAINT; Schema: beta; Owner: dbservice
--

ALTER TABLE ONLY beta.missing_hash
    ADD CONSTRAINT missing_hash_pkey PRIMARY KEY (order_id);


--
-- Name: pick_demand pick_demand_pkey; Type: CONSTRAINT; Schema: beta; Owner: dbservice
--

ALTER TABLE ONLY beta.pick_demand
    ADD CONSTRAINT pick_demand_pkey PRIMARY KEY (id);


--
-- Name: sku_group_control sku_group_control_pkey; Type: CONSTRAINT; Schema: beta; Owner: dbservice
--

ALTER TABLE ONLY beta.sku_group_control
    ADD CONSTRAINT sku_group_control_pkey PRIMARY KEY (fc_title);


--
-- Name: temp_nutrition_filter temp_nutrition_filter_pkey; Type: CONSTRAINT; Schema: beta; Owner: dbservice
--

ALTER TABLE ONLY beta.temp_nutrition_filter
    ADD CONSTRAINT temp_nutrition_filter_pkey PRIMARY KEY (id);


--
-- Name: temp_product temp_product_pkey; Type: CONSTRAINT; Schema: beta; Owner: dbservice
--

ALTER TABLE ONLY beta.temp_product
    ADD CONSTRAINT temp_product_pkey PRIMARY KEY (id);


--
-- Name: temp_sku_group_attribute temp_sku_group_attribute_pkey; Type: CONSTRAINT; Schema: beta; Owner: dbservice
--

ALTER TABLE ONLY beta.temp_sku_group_attribute
    ADD CONSTRAINT temp_sku_group_attribute_pkey PRIMARY KEY (title);


--
-- Name: temp_test2 temp_test2_pkey; Type: CONSTRAINT; Schema: beta; Owner: dbservice
--

ALTER TABLE ONLY beta.temp_test2
    ADD CONSTRAINT temp_test2_pkey PRIMARY KEY (id);


--
-- Name: temp_test temp_test_pkey; Type: CONSTRAINT; Schema: beta; Owner: dbservice
--

ALTER TABLE ONLY beta.temp_test
    ADD CONSTRAINT temp_test_pkey PRIMARY KEY (id);


--
-- Name: warehouse_inventory_history warehouse_inventory_history_pkey; Type: CONSTRAINT; Schema: beta; Owner: dbservice
--

ALTER TABLE ONLY beta.warehouse_inventory_history
    ADD CONSTRAINT warehouse_inventory_history_pkey PRIMARY KEY (date_, sku);


--
-- Name: accounting accounting_pkey; Type: CONSTRAINT; Schema: develop; Owner: dbservice
--

ALTER TABLE ONLY develop.accounting
    ADD CONSTRAINT accounting_pkey PRIMARY KEY (id);


--
-- Name: campus campus_pkey; Type: CONSTRAINT; Schema: develop; Owner: dbservice
--

ALTER TABLE ONLY develop.campus
    ADD CONSTRAINT campus_pkey PRIMARY KEY (id);


--
-- Name: card card_pkey; Type: CONSTRAINT; Schema: develop; Owner: dbservice
--

ALTER TABLE ONLY develop.card
    ADD CONSTRAINT card_pkey PRIMARY KEY (id);


--
-- Name: contract contract_pkey; Type: CONSTRAINT; Schema: develop; Owner: dbservice
--

ALTER TABLE ONLY develop.contract
    ADD CONSTRAINT contract_pkey PRIMARY KEY (id);


--
-- Name: coupon coupon_pkey; Type: CONSTRAINT; Schema: develop; Owner: dbservice
--

ALTER TABLE ONLY develop.coupon
    ADD CONSTRAINT coupon_pkey PRIMARY KEY (id);


--
-- Name: cron cron_pkey; Type: CONSTRAINT; Schema: develop; Owner: dbservice
--

ALTER TABLE ONLY develop.cron
    ADD CONSTRAINT cron_pkey PRIMARY KEY (id);


--
-- Name: current_label_status_365days current_label_status_365days_pkey; Type: CONSTRAINT; Schema: develop; Owner: dbservice
--

ALTER TABLE ONLY develop.current_label_status_365days
    ADD CONSTRAINT current_label_status_365days_pkey PRIMARY KEY (epc);


--
-- Name: discount_history discount_history_pkey; Type: CONSTRAINT; Schema: develop; Owner: dbservice
--

ALTER TABLE ONLY develop.discount_history
    ADD CONSTRAINT discount_history_pkey PRIMARY KEY (id);


--
-- Name: discount discount_pkey; Type: CONSTRAINT; Schema: develop; Owner: dbservice
--

ALTER TABLE ONLY develop.discount
    ADD CONSTRAINT discount_pkey PRIMARY KEY (id);


--
-- Name: event event_pkey; Type: CONSTRAINT; Schema: develop; Owner: dbservice
--

ALTER TABLE ONLY develop.event
    ADD CONSTRAINT event_pkey PRIMARY KEY (id);


--
-- Name: fee_rates fee_rates_pkey; Type: CONSTRAINT; Schema: develop; Owner: dbservice
--

ALTER TABLE ONLY develop.fee_rates
    ADD CONSTRAINT fee_rates_pkey PRIMARY KEY (id);


--
-- Name: feedback feedback_pkey; Type: CONSTRAINT; Schema: develop; Owner: dbservice
--

ALTER TABLE ONLY develop.feedback
    ADD CONSTRAINT feedback_pkey PRIMARY KEY (id);


--
-- Name: group_campus group_campus_pkey; Type: CONSTRAINT; Schema: develop; Owner: dbservice
--

ALTER TABLE ONLY develop.group_campus
    ADD CONSTRAINT group_campus_pkey PRIMARY KEY (group_id, campus_id);


--
-- Name: group group_pkey; Type: CONSTRAINT; Schema: develop; Owner: dbservice
--

ALTER TABLE ONLY develop."group"
    ADD CONSTRAINT group_pkey PRIMARY KEY (id);


--
-- Name: history_epc_order history_epc_order_pkey; Type: CONSTRAINT; Schema: develop; Owner: dbservice
--

ALTER TABLE ONLY develop.history_epc_order
    ADD CONSTRAINT history_epc_order_pkey PRIMARY KEY (id);


--
-- Name: history history_pkey; Type: CONSTRAINT; Schema: develop; Owner: dbservice
--

ALTER TABLE ONLY develop.history
    ADD CONSTRAINT history_pkey PRIMARY KEY (id);


--
-- Name: inventory_history inventory_history_pkey; Type: CONSTRAINT; Schema: develop; Owner: dbservice
--

ALTER TABLE ONLY develop.inventory_history
    ADD CONSTRAINT inventory_history_pkey PRIMARY KEY (id);


--
-- Name: kiosk_par_level kiosk_par_level_pkey; Type: CONSTRAINT; Schema: develop; Owner: dbservice
--

ALTER TABLE ONLY develop.kiosk_par_level
    ADD CONSTRAINT kiosk_par_level_pkey PRIMARY KEY (kiosk_id, product_id);


--
-- Name: kiosk kiosk_pkey; Type: CONSTRAINT; Schema: develop; Owner: dbservice
--

ALTER TABLE ONLY develop.kiosk
    ADD CONSTRAINT kiosk_pkey PRIMARY KEY (id);


--
-- Name: kiosk_status kiosk_status_pkey; Type: CONSTRAINT; Schema: develop; Owner: dbservice
--

ALTER TABLE ONLY develop.kiosk_status
    ADD CONSTRAINT kiosk_status_pkey PRIMARY KEY (id);


--
-- Name: label_order label_order_pkey; Type: CONSTRAINT; Schema: develop; Owner: dbservice
--

ALTER TABLE ONLY develop.label_order
    ADD CONSTRAINT label_order_pkey PRIMARY KEY (id);


--
-- Name: label label_pkey; Type: CONSTRAINT; Schema: develop; Owner: dbservice
--

ALTER TABLE ONLY develop.label
    ADD CONSTRAINT label_pkey PRIMARY KEY (id);


--
-- Name: last_kiosk_status last_kiosk_status_pkey; Type: CONSTRAINT; Schema: develop; Owner: dbservice
--

ALTER TABLE ONLY develop.last_kiosk_status
    ADD CONSTRAINT last_kiosk_status_pkey PRIMARY KEY (id);


--
-- Name: manual_adjustment manual_adjustment_pkey; Type: CONSTRAINT; Schema: develop; Owner: dbservice
--

ALTER TABLE ONLY develop.manual_adjustment
    ADD CONSTRAINT manual_adjustment_pkey PRIMARY KEY (id);


--
-- Name: order order_pkey; Type: CONSTRAINT; Schema: develop; Owner: dbservice
--

ALTER TABLE ONLY develop."order"
    ADD CONSTRAINT order_pkey PRIMARY KEY (order_id);


--
-- Name: par_history par_history_pkey; Type: CONSTRAINT; Schema: develop; Owner: dbservice
--

ALTER TABLE ONLY develop.par_history
    ADD CONSTRAINT par_history_pkey PRIMARY KEY (id);


--
-- Name: permission_mapping permission_mapping_pkey; Type: CONSTRAINT; Schema: develop; Owner: dbservice
--

ALTER TABLE ONLY develop.permission_mapping
    ADD CONSTRAINT permission_mapping_pkey PRIMARY KEY (role_id, permission_id);


--
-- Name: permission permission_pkey; Type: CONSTRAINT; Schema: develop; Owner: dbservice
--

ALTER TABLE ONLY develop.permission
    ADD CONSTRAINT permission_pkey PRIMARY KEY (id);


--
-- Name: product_history product_history_pkey; Type: CONSTRAINT; Schema: develop; Owner: dbservice
--

ALTER TABLE ONLY develop.product_history
    ADD CONSTRAINT product_history_pkey PRIMARY KEY (id);


--
-- Name: product product_pkey; Type: CONSTRAINT; Schema: develop; Owner: dbservice
--

ALTER TABLE ONLY develop.product
    ADD CONSTRAINT product_pkey PRIMARY KEY (id);


--
-- Name: ro_order ro_order_pkey; Type: CONSTRAINT; Schema: develop; Owner: dbservice
--

ALTER TABLE ONLY develop.ro_order
    ADD CONSTRAINT ro_order_pkey PRIMARY KEY (order_id);


--
-- Name: role_mapping role_mapping_pkey; Type: CONSTRAINT; Schema: develop; Owner: dbservice
--

ALTER TABLE ONLY develop.role_mapping
    ADD CONSTRAINT role_mapping_pkey PRIMARY KEY (role_id, parent_id);


--
-- Name: role role_pkey; Type: CONSTRAINT; Schema: develop; Owner: dbservice
--

ALTER TABLE ONLY develop.role
    ADD CONSTRAINT role_pkey PRIMARY KEY (id);


--
-- Name: sessions sessions_pkey; Type: CONSTRAINT; Schema: develop; Owner: dbservice
--

ALTER TABLE ONLY develop.sessions
    ADD CONSTRAINT sessions_pkey PRIMARY KEY (sid);


--
-- Name: spoilage spoilage_pkey; Type: CONSTRAINT; Schema: develop; Owner: dbservice
--

ALTER TABLE ONLY develop.spoilage
    ADD CONSTRAINT spoilage_pkey PRIMARY KEY (id);


--
-- Name: tag tag_pkey; Type: CONSTRAINT; Schema: develop; Owner: dbservice
--

ALTER TABLE ONLY develop.tag
    ADD CONSTRAINT tag_pkey PRIMARY KEY (id);


--
-- Name: temp temp_pkey; Type: CONSTRAINT; Schema: develop; Owner: dbservice
--

ALTER TABLE ONLY develop.temp
    ADD CONSTRAINT temp_pkey PRIMARY KEY (id);


--
-- Name: timezone_mapping timezone_mapping_pkey; Type: CONSTRAINT; Schema: develop; Owner: dbservice
--

ALTER TABLE ONLY develop.timezone_mapping
    ADD CONSTRAINT timezone_mapping_pkey PRIMARY KEY (id);


--
-- Name: transact_comp transact_comp_pkey; Type: CONSTRAINT; Schema: develop; Owner: dbservice
--

ALTER TABLE ONLY develop.transact_comp
    ADD CONSTRAINT transact_comp_pkey PRIMARY KEY (id);


--
-- Name: transact_cs transact_cs_pkey; Type: CONSTRAINT; Schema: develop; Owner: dbservice
--

ALTER TABLE ONLY develop.transact_cs
    ADD CONSTRAINT transact_cs_pkey PRIMARY KEY (id);


--
-- Name: transact_fp transact_fp_pkey; Type: CONSTRAINT; Schema: develop; Owner: dbservice
--

ALTER TABLE ONLY develop.transact_fp
    ADD CONSTRAINT transact_fp_pkey PRIMARY KEY (id);


--
-- Name: transact_ipc transact_ipc_pkey; Type: CONSTRAINT; Schema: develop; Owner: dbservice
--

ALTER TABLE ONLY develop.transact_ipc
    ADD CONSTRAINT transact_ipc_pkey PRIMARY KEY (id);


--
-- Name: unused_user_mapping unused_user_mapping_pkey; Type: CONSTRAINT; Schema: develop; Owner: dbservice
--

ALTER TABLE ONLY develop.unused_user_mapping
    ADD CONSTRAINT unused_user_mapping_pkey PRIMARY KEY (user_id, role_id);


--
-- Name: user user_pkey; Type: CONSTRAINT; Schema: develop; Owner: dbservice
--

ALTER TABLE ONLY develop."user"
    ADD CONSTRAINT user_pkey PRIMARY KEY (id);


--
-- Name: tmp_payment_information tmp_payment_information_pkey; Type: CONSTRAINT; Schema: fnrenames; Owner: dbservice
--

ALTER TABLE ONLY fnrenames.tmp_payment_information
    ADD CONSTRAINT tmp_payment_information_pkey PRIMARY KEY (order_id);


--
-- Name: bringg_delivery bringg_delivery_pkey; Type: CONSTRAINT; Schema: inm; Owner: dbservice
--

ALTER TABLE ONLY inm.bringg_delivery
    ADD CONSTRAINT bringg_delivery_pkey PRIMARY KEY (task_id);


--
-- Name: configuration configuration_pkey; Type: CONSTRAINT; Schema: inm; Owner: dbservice
--

ALTER TABLE ONLY inm.configuration
    ADD CONSTRAINT configuration_pkey PRIMARY KEY (setting);


--
-- Name: kiosk_attribute kiosk_attribute_pkey; Type: CONSTRAINT; Schema: inm; Owner: dbservice
--

ALTER TABLE ONLY inm.kiosk_attribute
    ADD CONSTRAINT kiosk_attribute_pkey PRIMARY KEY (id);


--
-- Name: kiosk_control kiosk_control_pkey; Type: CONSTRAINT; Schema: inm; Owner: dbservice
--

ALTER TABLE ONLY inm.kiosk_control
    ADD CONSTRAINT kiosk_control_pkey PRIMARY KEY (kiosk_id);


--
-- Name: kiosk_product_disabled kiosk_product_enabled_pkey; Type: CONSTRAINT; Schema: inm; Owner: dbservice
--

ALTER TABLE ONLY inm.kiosk_product_disabled
    ADD CONSTRAINT kiosk_product_enabled_pkey PRIMARY KEY (kiosk_id, product_id);


--
-- Name: kiosk_restriction_by_product kiosk_restriction_by_product_pkey; Type: CONSTRAINT; Schema: inm; Owner: dbservice
--

ALTER TABLE ONLY inm.kiosk_restriction_by_product
    ADD CONSTRAINT kiosk_restriction_by_product_pkey PRIMARY KEY (kiosk_id, product_id);


--
-- Name: kiosk_restriction_by_property kiosk_restriction_by_property_pkey; Type: CONSTRAINT; Schema: inm; Owner: dbservice
--

ALTER TABLE ONLY inm.kiosk_restriction_by_property
    ADD CONSTRAINT kiosk_restriction_by_property_pkey PRIMARY KEY (kiosk_id, property_id);


--
-- Name: kiosk_restriction_by_sku kiosk_restriction_by_sku_pkey; Type: CONSTRAINT; Schema: inm; Owner: dbservice
--

ALTER TABLE ONLY inm.kiosk_restriction_by_sku
    ADD CONSTRAINT kiosk_restriction_by_sku_pkey PRIMARY KEY (kiosk_id, sku_id);


--
-- Name: kiosk_sku_group_manual_scale kiosk_sku_group_manual_scale_pkey; Type: CONSTRAINT; Schema: inm; Owner: dbservice
--

ALTER TABLE ONLY inm.kiosk_sku_group_manual_scale
    ADD CONSTRAINT kiosk_sku_group_manual_scale_pkey PRIMARY KEY (kiosk_id, sku_group_id);


--
-- Name: pick_allocation pick_allocation_pkey; Type: CONSTRAINT; Schema: inm; Owner: dbservice
--

ALTER TABLE ONLY inm.pick_allocation
    ADD CONSTRAINT pick_allocation_pkey PRIMARY KEY (pick_date, route_date, kiosk_id, sku_id);


--
-- Name: pick_demand pick_demand_pkey; Type: CONSTRAINT; Schema: inm; Owner: dbservice
--

ALTER TABLE ONLY inm.pick_demand
    ADD CONSTRAINT pick_demand_pkey PRIMARY KEY (pick_date, route_date, kiosk_id, sku_group_id);


--
-- Name: pick_inventory pick_inventory_pkey; Type: CONSTRAINT; Schema: inm; Owner: dbservice
--

ALTER TABLE ONLY inm.pick_inventory
    ADD CONSTRAINT pick_inventory_pkey PRIMARY KEY (pick_date, route_date, kiosk_id, sku_group_id);


--
-- Name: pick_list pick_list_pkey; Type: CONSTRAINT; Schema: inm; Owner: dbservice
--

ALTER TABLE ONLY inm.pick_list
    ADD CONSTRAINT pick_list_pkey PRIMARY KEY (pick_date);


--
-- Name: pick_preference_kiosk_sku pick_preference_kiosk_sku_pkey; Type: CONSTRAINT; Schema: inm; Owner: dbservice
--

ALTER TABLE ONLY inm.pick_preference_kiosk_sku
    ADD CONSTRAINT pick_preference_kiosk_sku_pkey PRIMARY KEY (kiosk_id, sku_id);


--
-- Name: pick_priority_kiosk pick_priority_kiosk_pkey; Type: CONSTRAINT; Schema: inm; Owner: dbservice
--

ALTER TABLE ONLY inm.pick_priority_kiosk
    ADD CONSTRAINT pick_priority_kiosk_pkey PRIMARY KEY (kiosk_id);


--
-- Name: pick_priority_sku pick_priority_sku_pkey; Type: CONSTRAINT; Schema: inm; Owner: dbservice
--

ALTER TABLE ONLY inm.pick_priority_sku
    ADD CONSTRAINT pick_priority_sku_pkey PRIMARY KEY (sku_id);


--
-- Name: pick_rejection pick_rejection_pkey; Type: CONSTRAINT; Schema: inm; Owner: dbservice
--

ALTER TABLE ONLY inm.pick_rejection
    ADD CONSTRAINT pick_rejection_pkey PRIMARY KEY (pick_date, route_date, kiosk_id, item_id, item_type, reason);


--
-- Name: pick_route pick_route_pkey; Type: CONSTRAINT; Schema: inm; Owner: dbservice
--

ALTER TABLE ONLY inm.pick_route
    ADD CONSTRAINT pick_route_pkey PRIMARY KEY (pick_date, kiosk_id, route_date);


--
-- Name: pick_substitution pick_substitution_pkey; Type: CONSTRAINT; Schema: inm; Owner: dbservice
--

ALTER TABLE ONLY inm.pick_substitution
    ADD CONSTRAINT pick_substitution_pkey PRIMARY KEY (substituting_sku_group_id, substituted_sku_group_id, pick_date);


--
-- Name: product_property_def product_property_def_name_value_key; Type: CONSTRAINT; Schema: inm; Owner: dbservice
--

ALTER TABLE ONLY inm.product_property_def
    ADD CONSTRAINT product_property_def_name_value_key UNIQUE (name, value);


--
-- Name: product_property_def product_property_def_pkey; Type: CONSTRAINT; Schema: inm; Owner: dbservice
--

ALTER TABLE ONLY inm.product_property_def
    ADD CONSTRAINT product_property_def_pkey PRIMARY KEY (id);


--
-- Name: product_property product_property_pkey; Type: CONSTRAINT; Schema: inm; Owner: dbservice
--

ALTER TABLE ONLY inm.product_property
    ADD CONSTRAINT product_property_pkey PRIMARY KEY (product_id, property_id);


--
-- Name: sku_def sku_def_pkey; Type: CONSTRAINT; Schema: inm; Owner: dbservice
--

ALTER TABLE ONLY inm.sku_def
    ADD CONSTRAINT sku_def_pkey PRIMARY KEY (id);


--
-- Name: sku_group_attribute sku_group_attribute_pkey; Type: CONSTRAINT; Schema: inm; Owner: dbservice
--

ALTER TABLE ONLY inm.sku_group_attribute
    ADD CONSTRAINT sku_group_attribute_pkey PRIMARY KEY (id);


--
-- Name: sku_group_attribute sku_group_attribute_title_key; Type: CONSTRAINT; Schema: inm; Owner: dbservice
--

ALTER TABLE ONLY inm.sku_group_attribute
    ADD CONSTRAINT sku_group_attribute_title_key UNIQUE (title);


--
-- Name: sku_group_control sku_group_control_pkey; Type: CONSTRAINT; Schema: inm; Owner: dbservice
--

ALTER TABLE ONLY inm.sku_group_control
    ADD CONSTRAINT sku_group_control_pkey PRIMARY KEY (sku_group_id);


--
-- Name: sku_group sku_group_pkey; Type: CONSTRAINT; Schema: inm; Owner: dbservice
--

ALTER TABLE ONLY inm.sku_group
    ADD CONSTRAINT sku_group_pkey PRIMARY KEY (id);


--
-- Name: sku_property_def sku_property_def_pkey; Type: CONSTRAINT; Schema: inm; Owner: dbservice
--

ALTER TABLE ONLY inm.sku_property_def
    ADD CONSTRAINT sku_property_def_pkey PRIMARY KEY (id);


--
-- Name: sku_property sku_property_pkey; Type: CONSTRAINT; Schema: inm; Owner: dbservice
--

ALTER TABLE ONLY inm.sku_property
    ADD CONSTRAINT sku_property_pkey PRIMARY KEY (sku_id, property_id);


--
-- Name: warehouse_inventory warehouse_inventory_pkey; Type: CONSTRAINT; Schema: inm; Owner: dbservice
--

ALTER TABLE ONLY inm.warehouse_inventory
    ADD CONSTRAINT warehouse_inventory_pkey PRIMARY KEY (inventory_date, product_id);


--
-- Name: kiosk_control kiosk_control_pkey; Type: CONSTRAINT; Schema: inm_backup; Owner: dbservice
--

ALTER TABLE ONLY inm_backup.kiosk_control
    ADD CONSTRAINT kiosk_control_pkey PRIMARY KEY (kiosk_id);


--
-- Name: kiosk_control kiosk_control_pkey; Type: CONSTRAINT; Schema: inm_beta; Owner: dbservice
--

ALTER TABLE ONLY inm_beta.kiosk_control
    ADD CONSTRAINT kiosk_control_pkey PRIMARY KEY (kiosk_id);


--
-- Name: kiosk_product_disabled kiosk_product_enabled_pkey; Type: CONSTRAINT; Schema: inm_beta; Owner: dbservice
--

ALTER TABLE ONLY inm_beta.kiosk_product_disabled
    ADD CONSTRAINT kiosk_product_enabled_pkey PRIMARY KEY (kiosk_id, product_id);


--
-- Name: kiosk_restriction_by_product kiosk_restriction_by_product_pkey; Type: CONSTRAINT; Schema: inm_beta; Owner: dbservice
--

ALTER TABLE ONLY inm_beta.kiosk_restriction_by_product
    ADD CONSTRAINT kiosk_restriction_by_product_pkey PRIMARY KEY (kiosk_id, product_id);


--
-- Name: kiosk_restriction_by_property kiosk_restriction_by_property_pkey; Type: CONSTRAINT; Schema: inm_beta; Owner: dbservice
--

ALTER TABLE ONLY inm_beta.kiosk_restriction_by_property
    ADD CONSTRAINT kiosk_restriction_by_property_pkey PRIMARY KEY (kiosk_id, property_id);


--
-- Name: kiosk_sku_group_manual_scale kiosk_sku_group_manual_scale_pkey; Type: CONSTRAINT; Schema: inm_beta; Owner: dbservice
--

ALTER TABLE ONLY inm_beta.kiosk_sku_group_manual_scale
    ADD CONSTRAINT kiosk_sku_group_manual_scale_pkey PRIMARY KEY (kiosk_id, sku_group_id);


--
-- Name: pick_allocation pick_allocation_pkey; Type: CONSTRAINT; Schema: inm_beta; Owner: dbservice
--

ALTER TABLE ONLY inm_beta.pick_allocation
    ADD CONSTRAINT pick_allocation_pkey PRIMARY KEY (pick_date, route_date, kiosk_id, sku_id);


--
-- Name: pick_demand pick_demand_pkey; Type: CONSTRAINT; Schema: inm_beta; Owner: dbservice
--

ALTER TABLE ONLY inm_beta.pick_demand
    ADD CONSTRAINT pick_demand_pkey PRIMARY KEY (pick_date, route_date, kiosk_id, sku_group_id);


--
-- Name: pick_inventory pick_inventory_pkey; Type: CONSTRAINT; Schema: inm_beta; Owner: dbservice
--

ALTER TABLE ONLY inm_beta.pick_inventory
    ADD CONSTRAINT pick_inventory_pkey PRIMARY KEY (pick_date, route_date, kiosk_id, sku_group_id);


--
-- Name: pick_list pick_list_pkey; Type: CONSTRAINT; Schema: inm_beta; Owner: dbservice
--

ALTER TABLE ONLY inm_beta.pick_list
    ADD CONSTRAINT pick_list_pkey PRIMARY KEY (pick_date);


--
-- Name: pick_preference_kiosk_sku pick_preference_kiosk_sku_pkey; Type: CONSTRAINT; Schema: inm_beta; Owner: dbservice
--

ALTER TABLE ONLY inm_beta.pick_preference_kiosk_sku
    ADD CONSTRAINT pick_preference_kiosk_sku_pkey PRIMARY KEY (kiosk_id, sku_id);


--
-- Name: pick_priority_kiosk pick_priority_kiosk_pkey; Type: CONSTRAINT; Schema: inm_beta; Owner: dbservice
--

ALTER TABLE ONLY inm_beta.pick_priority_kiosk
    ADD CONSTRAINT pick_priority_kiosk_pkey PRIMARY KEY (kiosk_id);


--
-- Name: pick_priority_sku pick_priority_sku_pkey; Type: CONSTRAINT; Schema: inm_beta; Owner: dbservice
--

ALTER TABLE ONLY inm_beta.pick_priority_sku
    ADD CONSTRAINT pick_priority_sku_pkey PRIMARY KEY (sku_id);


--
-- Name: pick_rejection pick_rejection_pkey; Type: CONSTRAINT; Schema: inm_beta; Owner: dbservice
--

ALTER TABLE ONLY inm_beta.pick_rejection
    ADD CONSTRAINT pick_rejection_pkey PRIMARY KEY (pick_date, route_date, kiosk_id, item_id, item_type, reason);


--
-- Name: pick_route pick_route_pkey; Type: CONSTRAINT; Schema: inm_beta; Owner: dbservice
--

ALTER TABLE ONLY inm_beta.pick_route
    ADD CONSTRAINT pick_route_pkey PRIMARY KEY (pick_date, kiosk_id, route_date);


--
-- Name: pick_substitution pick_substitution_pkey; Type: CONSTRAINT; Schema: inm_beta; Owner: dbservice
--

ALTER TABLE ONLY inm_beta.pick_substitution
    ADD CONSTRAINT pick_substitution_pkey PRIMARY KEY (substituting_sku_group_id, substituted_sku_group_id, pick_date);


--
-- Name: sku_group_control sku_group_control_pkey; Type: CONSTRAINT; Schema: inm_beta; Owner: dbservice
--

ALTER TABLE ONLY inm_beta.sku_group_control
    ADD CONSTRAINT sku_group_control_pkey PRIMARY KEY (sku_group_id);


--
-- Name: sku_group sku_group_pkey; Type: CONSTRAINT; Schema: inm_beta; Owner: dbservice
--

ALTER TABLE ONLY inm_beta.sku_group
    ADD CONSTRAINT sku_group_pkey PRIMARY KEY (id);


--
-- Name: warehouse_inventory warehouse_inventory_pkey; Type: CONSTRAINT; Schema: inm_beta; Owner: dbservice
--

ALTER TABLE ONLY inm_beta.warehouse_inventory
    ADD CONSTRAINT warehouse_inventory_pkey PRIMARY KEY (inventory_date, product_id);


--
-- Name: kiosk_audit kiosk_audit_pkey; Type: CONSTRAINT; Schema: inm_test; Owner: dbservice
--

ALTER TABLE ONLY inm_test.kiosk_audit
    ADD CONSTRAINT kiosk_audit_pkey PRIMARY KEY (kid);


--
-- Name: kiosk_par_level kiosk_par_level_pkey; Type: CONSTRAINT; Schema: inm_test; Owner: dbservice
--

ALTER TABLE ONLY inm_test.kiosk_par_level
    ADD CONSTRAINT kiosk_par_level_pkey PRIMARY KEY (kiosk_id, product_id);


--
-- Name: pick_allocation pick_allocation_pkey; Type: CONSTRAINT; Schema: inm_test; Owner: dbservice
--

ALTER TABLE ONLY inm_test.pick_allocation
    ADD CONSTRAINT pick_allocation_pkey PRIMARY KEY (pick_date, route_date, kiosk_id, sku_id);


--
-- Name: pick_demand pick_demand_pkey; Type: CONSTRAINT; Schema: inm_test; Owner: dbservice
--

ALTER TABLE ONLY inm_test.pick_demand
    ADD CONSTRAINT pick_demand_pkey PRIMARY KEY (pick_date, route_date, kiosk_id, sku_group_id);


--
-- Name: pick_inventory pick_inventory_pkey; Type: CONSTRAINT; Schema: inm_test; Owner: dbservice
--

ALTER TABLE ONLY inm_test.pick_inventory
    ADD CONSTRAINT pick_inventory_pkey PRIMARY KEY (pick_date, route_date, kiosk_id, sku_group_id);


--
-- Name: pick_rejection pick_rejection_pkey; Type: CONSTRAINT; Schema: inm_test; Owner: dbservice
--

ALTER TABLE ONLY inm_test.pick_rejection
    ADD CONSTRAINT pick_rejection_pkey PRIMARY KEY (pick_date, route_date, kiosk_id, item_id, item_type, reason);


--
-- Name: pick_route pick_route_pkey; Type: CONSTRAINT; Schema: inm_test; Owner: dbservice
--

ALTER TABLE ONLY inm_test.pick_route
    ADD CONSTRAINT pick_route_pkey PRIMARY KEY (pick_date, kiosk_id, route_date);


--
-- Name: pick_substitution pick_substitution_pkey; Type: CONSTRAINT; Schema: inm_test; Owner: dbservice
--

ALTER TABLE ONLY inm_test.pick_substitution
    ADD CONSTRAINT pick_substitution_pkey PRIMARY KEY (substituting_sku_group_id, substituted_sku_group_id, pick_date);


--
-- Name: restricted restricted_pkey; Type: CONSTRAINT; Schema: inm_test; Owner: dbservice
--

ALTER TABLE ONLY inm_test.restricted
    ADD CONSTRAINT restricted_pkey PRIMARY KEY (kid, sku_id);


--
-- Name: test_hours test_hours_pkey; Type: CONSTRAINT; Schema: inm_test; Owner: dbservice
--

ALTER TABLE ONLY inm_test.test_hours
    ADD CONSTRAINT test_hours_pkey PRIMARY KEY (h);


--
-- Name: test test_pkey; Type: CONSTRAINT; Schema: inm_test; Owner: dbservice
--

ALTER TABLE ONLY inm_test.test
    ADD CONSTRAINT test_pkey PRIMARY KEY (id);


--
-- Name: card_fact card_fact_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.card_fact
    ADD CONSTRAINT card_fact_pkey PRIMARY KEY (id);


--
-- Name: card_product_fact card_product_fact_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.card_product_fact
    ADD CONSTRAINT card_product_fact_pkey PRIMARY KEY (id);


--
-- Name: discount_rule discount_rule_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.discount_rule
    ADD CONSTRAINT discount_rule_pkey PRIMARY KEY (id);


--
-- Name: gsheet_cache gsheet_cache_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.gsheet_cache
    ADD CONSTRAINT gsheet_cache_pkey PRIMARY KEY (id);


--
-- Name: gsheets_kiosk_restriction gsheets_kiosk_restriction_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.gsheets_kiosk_restriction
    ADD CONSTRAINT gsheets_kiosk_restriction_pkey PRIMARY KEY (kiosk_id, restriction);


--
-- Name: history_order_pipeline history_order_pipeline_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.history_order_pipeline
    ADD CONSTRAINT history_order_pipeline_pkey PRIMARY KEY (id);


--
-- Name: inm_data inm_data_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.inm_data
    ADD CONSTRAINT inm_data_pkey PRIMARY KEY (id);


--
-- Name: inm_gsheets_kiosk_restriction inm_gsheets_kiosk_restriction_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.inm_gsheets_kiosk_restriction
    ADD CONSTRAINT inm_gsheets_kiosk_restriction_pkey PRIMARY KEY (kiosk_id, restriction);


--
-- Name: kiosk_contents kiosk_contents_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.kiosk_contents
    ADD CONSTRAINT kiosk_contents_pkey PRIMARY KEY (id);


--
-- Name: kiosk_fact kiosk_fact_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.kiosk_fact
    ADD CONSTRAINT kiosk_fact_pkey PRIMARY KEY (id);


--
-- Name: kiosk kiosk_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.kiosk
    ADD CONSTRAINT kiosk_pkey PRIMARY KEY (kiosk_id);


--
-- Name: kiosk_restriction_by_property kiosk_restriction_by_property_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.kiosk_restriction_by_property
    ADD CONSTRAINT kiosk_restriction_by_property_pkey PRIMARY KEY (kiosk_id, property_id);


--
-- Name: kiosk_restriction_by_sku kiosk_restriction_by_sku_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.kiosk_restriction_by_sku
    ADD CONSTRAINT kiosk_restriction_by_sku_pkey PRIMARY KEY (kiosk_id, sku_id);


--
-- Name: kiosk_restriction kiosk_restriction_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.kiosk_restriction
    ADD CONSTRAINT kiosk_restriction_pkey PRIMARY KEY (kiosk_id, sku_id);


--
-- Name: last_kiosk_status last_kiosk_status_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.last_kiosk_status
    ADD CONSTRAINT last_kiosk_status_pkey PRIMARY KEY (id);


--
-- Name: log log_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.log
    ADD CONSTRAINT log_pkey PRIMARY KEY (id);


--
-- Name: merchandising_slot_def merchandising_slot_def_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.merchandising_slot_def
    ADD CONSTRAINT merchandising_slot_def_pkey PRIMARY KEY (id);


--
-- Name: merchandising_slot merchandising_slot_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.merchandising_slot
    ADD CONSTRAINT merchandising_slot_pkey PRIMARY KEY (id);


--
-- Name: merchandising_slot_sku_group merchandising_slot_sku_group_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.merchandising_slot_sku_group
    ADD CONSTRAINT merchandising_slot_sku_group_pkey PRIMARY KEY (sku_group_id);


--
-- Name: merchandising_slot merchandising_slot_title_key; Type: CONSTRAINT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.merchandising_slot
    ADD CONSTRAINT merchandising_slot_title_key UNIQUE (title);


--
-- Name: order_fact order_fact_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.order_fact
    ADD CONSTRAINT order_fact_pkey PRIMARY KEY (id);


--
-- Name: pick pick_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.pick
    ADD CONSTRAINT pick_pkey PRIMARY KEY (sku_id, kiosk_id, pick_date);


--
-- Name: pick_preference_kiosk_sku pick_preference_kiosk_sku_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.pick_preference_kiosk_sku
    ADD CONSTRAINT pick_preference_kiosk_sku_pkey PRIMARY KEY (kiosk_id, sku_id);


--
-- Name: pick_priority_kiosk pick_priority_kiosk_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.pick_priority_kiosk
    ADD CONSTRAINT pick_priority_kiosk_pkey PRIMARY KEY (kiosk_id);


--
-- Name: pick_priority_sku pick_priority_sku_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.pick_priority_sku
    ADD CONSTRAINT pick_priority_sku_pkey PRIMARY KEY (sku_id);


--
-- Name: product_fact product_fact_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.product_fact
    ADD CONSTRAINT product_fact_pkey PRIMARY KEY (id);


--
-- Name: product_kiosk_fact product_kiosk_fact_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.product_kiosk_fact
    ADD CONSTRAINT product_kiosk_fact_pkey PRIMARY KEY (id);


--
-- Name: request_log request_log_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.request_log
    ADD CONSTRAINT request_log_pkey PRIMARY KEY (request_uuid);


--
-- Name: route route_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.route
    ADD CONSTRAINT route_pkey PRIMARY KEY (route_date_time, driver_name);


--
-- Name: route_stop route_stop_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.route_stop
    ADD CONSTRAINT route_stop_pkey PRIMARY KEY (route_date_time, driver_name, location_name, schedule_at);


--
-- Name: server server_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.server
    ADD CONSTRAINT server_pkey PRIMARY KEY (id);


--
-- Name: sku_def sku_def_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.sku_def
    ADD CONSTRAINT sku_def_pkey PRIMARY KEY (id);


--
-- Name: sku_group_def sku_group_def_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.sku_group_def
    ADD CONSTRAINT sku_group_def_pkey PRIMARY KEY (id);


--
-- Name: sku_group_member sku_group_member_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.sku_group_member
    ADD CONSTRAINT sku_group_member_pkey PRIMARY KEY (id);


--
-- Name: sku_group sku_group_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.sku_group
    ADD CONSTRAINT sku_group_pkey PRIMARY KEY (id);


--
-- Name: sku_group_sku sku_group_sku_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.sku_group_sku
    ADD CONSTRAINT sku_group_sku_pkey PRIMARY KEY (sku_id, sku_group_id);


--
-- Name: sku_property_def sku_property_def_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.sku_property_def
    ADD CONSTRAINT sku_property_def_pkey PRIMARY KEY (id);


--
-- Name: sku_property sku_property_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.sku_property
    ADD CONSTRAINT sku_property_pkey PRIMARY KEY (sku_id, property_id);


--
-- Name: tally tally_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.tally
    ADD CONSTRAINT tally_pkey PRIMARY KEY (n);


--
-- Name: temp_kiosk_restriction temp_kiosk_restriction_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.temp_kiosk_restriction
    ADD CONSTRAINT temp_kiosk_restriction_pkey PRIMARY KEY (kiosk_id, restriction);


--
-- Name: temp_ms_to_sg temp_ms_to_sg_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.temp_ms_to_sg
    ADD CONSTRAINT temp_ms_to_sg_pkey PRIMARY KEY (sgroup);


--
-- Name: temp_sku_group_volume temp_sku_group_volume_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.temp_sku_group_volume
    ADD CONSTRAINT temp_sku_group_volume_pkey PRIMARY KEY (title);


--
-- Name: temp_sku_to_skugroup temp_sku_to_skugroup_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.temp_sku_to_skugroup
    ADD CONSTRAINT temp_sku_to_skugroup_pkey PRIMARY KEY (sku);


--
-- Name: temp_test temp_test_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.temp_test
    ADD CONSTRAINT temp_test_pkey PRIMARY KEY (id);


--
-- Name: tmp_discount_applied tmp_discount_applied_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.tmp_discount_applied
    ADD CONSTRAINT tmp_discount_applied_pkey PRIMARY KEY (id);


--
-- Name: tmp_kiosk_status tmp_kiosk_status_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.tmp_kiosk_status
    ADD CONSTRAINT tmp_kiosk_status_pkey PRIMARY KEY (id);


--
-- Name: tmp_transact tmp_transact_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.tmp_transact
    ADD CONSTRAINT tmp_transact_pkey PRIMARY KEY (order_id);


--
-- Name: tmp_unit tmp_unit_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.tmp_unit
    ADD CONSTRAINT tmp_unit_pkey PRIMARY KEY (id);


--
-- Name: warehouse_order_history warehouse_order_history_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.warehouse_order_history
    ADD CONSTRAINT warehouse_order_history_pkey PRIMARY KEY (sku, order_date, delivery_date, qty);


--
-- Name: cron_state cron_state_pkey; Type: CONSTRAINT; Schema: monitor; Owner: dbservice
--

ALTER TABLE ONLY monitor.cron_state
    ADD CONSTRAINT cron_state_pkey PRIMARY KEY (key);


--
-- Name: opt_connect opt_connect_pkey; Type: CONSTRAINT; Schema: monitor; Owner: dbservice
--

ALTER TABLE ONLY monitor.opt_connect
    ADD CONSTRAINT opt_connect_pkey PRIMARY KEY (date_time, summit_id);


--
-- Name: accounting accounting_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.accounting
    ADD CONSTRAINT accounting_pkey PRIMARY KEY (id);


--
-- Name: bad_timestamp bad_timestamp_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.bad_timestamp
    ADD CONSTRAINT bad_timestamp_pkey PRIMARY KEY (id);


--
-- Name: campus_assets campus_assets_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.campus_assets
    ADD CONSTRAINT campus_assets_pkey PRIMARY KEY (campus_id);


--
-- Name: campus_attribute campus_attribute_campus_id_key_id_key; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.campus_attribute
    ADD CONSTRAINT campus_attribute_campus_id_key_id_key UNIQUE (campus_id, key_id);


--
-- Name: campus_attribute campus_attribute_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.campus_attribute
    ADD CONSTRAINT campus_attribute_pkey PRIMARY KEY (id);


--
-- Name: campus campus_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.campus
    ADD CONSTRAINT campus_pkey PRIMARY KEY (id);


--
-- Name: card card_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.card
    ADD CONSTRAINT card_pkey PRIMARY KEY (id);


--
-- Name: contract contract_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.contract
    ADD CONSTRAINT contract_pkey PRIMARY KEY (id);


--
-- Name: coupon coupon_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.coupon
    ADD CONSTRAINT coupon_pkey PRIMARY KEY (id);


--
-- Name: cron cron_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.cron
    ADD CONSTRAINT cron_pkey PRIMARY KEY (id);


--
-- Name: currency_symbol currency_symbol_code_key; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.currency_symbol
    ADD CONSTRAINT currency_symbol_code_key UNIQUE (code);


--
-- Name: currency_symbol currency_symbol_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.currency_symbol
    ADD CONSTRAINT currency_symbol_pkey PRIMARY KEY (id);


--
-- Name: current_label_status_365days current_label_status_365days_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.current_label_status_365days
    ADD CONSTRAINT current_label_status_365days_pkey PRIMARY KEY (epc);


--
-- Name: dc_inventory dc_inventory_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.dc_inventory
    ADD CONSTRAINT dc_inventory_pkey PRIMARY KEY (product_id);


--
-- Name: delivery_schedule delivery_schedule_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.delivery_schedule
    ADD CONSTRAINT delivery_schedule_pkey PRIMARY KEY (id);


--
-- Name: discount_applied discount_applied_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.discount_applied
    ADD CONSTRAINT discount_applied_pkey PRIMARY KEY (id);


--
-- Name: discount_history discount_history_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.discount_history
    ADD CONSTRAINT discount_history_pkey PRIMARY KEY (id);


--
-- Name: discount discount_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.discount
    ADD CONSTRAINT discount_pkey PRIMARY KEY (id);


--
-- Name: email email_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.email
    ADD CONSTRAINT email_pkey PRIMARY KEY (id);


--
-- Name: empty_transaction empty_transaction_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.empty_transaction
    ADD CONSTRAINT empty_transaction_pkey PRIMARY KEY (id);


--
-- Name: event event_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.event
    ADD CONSTRAINT event_pkey PRIMARY KEY (id);


--
-- Name: facing_category facing_category_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.facing_category
    ADD CONSTRAINT facing_category_pkey PRIMARY KEY (id);


--
-- Name: fee_rates fee_rates_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.fee_rates
    ADD CONSTRAINT fee_rates_pkey PRIMARY KEY (id);


--
-- Name: feedback feedback_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.feedback
    ADD CONSTRAINT feedback_pkey PRIMARY KEY (id);


--
-- Name: global_attribute_def global_attribute_def_key_key; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.global_attribute_def
    ADD CONSTRAINT global_attribute_def_key_key UNIQUE (key);


--
-- Name: global_attribute_def global_attribute_def_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.global_attribute_def
    ADD CONSTRAINT global_attribute_def_pkey PRIMARY KEY (id);


--
-- Name: group_campus group_campus_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.group_campus
    ADD CONSTRAINT group_campus_pkey PRIMARY KEY (group_id, campus_id);


--
-- Name: group group_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry."group"
    ADD CONSTRAINT group_pkey PRIMARY KEY (id);


--
-- Name: history_campus_attribute history_campus_attribute_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.history_campus_attribute
    ADD CONSTRAINT history_campus_attribute_pkey PRIMARY KEY (id);


--
-- Name: history_epc_order history_epc_order_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.history_epc_order
    ADD CONSTRAINT history_epc_order_pkey PRIMARY KEY (id);


--
-- Name: history_global_attribute_def history_global_attribute_def_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.history_global_attribute_def
    ADD CONSTRAINT history_global_attribute_def_pkey PRIMARY KEY (id);


--
-- Name: history_kiosk_attribute history_kiosk_attribute_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.history_kiosk_attribute
    ADD CONSTRAINT history_kiosk_attribute_pkey PRIMARY KEY (id);


--
-- Name: history_kiosk_device history_kiosk_device_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.history_kiosk_device
    ADD CONSTRAINT history_kiosk_device_pkey PRIMARY KEY (id);


--
-- Name: history_kiosk_service_version history_kiosk_service_version_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.history_kiosk_service_version
    ADD CONSTRAINT history_kiosk_service_version_pkey PRIMARY KEY (id);


--
-- Name: history history_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.history
    ADD CONSTRAINT history_pkey PRIMARY KEY (id);


--
-- Name: inventory_history inventory_history_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.inventory_history
    ADD CONSTRAINT inventory_history_pkey PRIMARY KEY (id);


--
-- Name: inventory_request inventory_request_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.inventory_request
    ADD CONSTRAINT inventory_request_pkey PRIMARY KEY (id);


--
-- Name: kiosk_attribute kiosk_attribute_kiosk_id_key_id_key; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.kiosk_attribute
    ADD CONSTRAINT kiosk_attribute_kiosk_id_key_id_key UNIQUE (kiosk_id, key_id);


--
-- Name: kiosk_attribute kiosk_attribute_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.kiosk_attribute
    ADD CONSTRAINT kiosk_attribute_pkey PRIMARY KEY (id);


--
-- Name: kiosk_audit_log kiosk_audit_log_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.kiosk_audit_log
    ADD CONSTRAINT kiosk_audit_log_pkey PRIMARY KEY (id);


--
-- Name: kiosk_catalog_downloads kiosk_catalog_downloads_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.kiosk_catalog_downloads
    ADD CONSTRAINT kiosk_catalog_downloads_pkey PRIMARY KEY (id);


--
-- Name: kiosk_components_history kiosk_components_history_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.kiosk_components_history
    ADD CONSTRAINT kiosk_components_history_pkey PRIMARY KEY (id);


--
-- Name: kiosk_device kiosk_device_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.kiosk_device
    ADD CONSTRAINT kiosk_device_pkey PRIMARY KEY (kiosk_id);


--
-- Name: kiosk_par_level kiosk_par_level_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.kiosk_par_level
    ADD CONSTRAINT kiosk_par_level_pkey PRIMARY KEY (kiosk_id, product_id);


--
-- Name: kiosk kiosk_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.kiosk
    ADD CONSTRAINT kiosk_pkey PRIMARY KEY (id);


--
-- Name: kiosk_service_version kiosk_service_version_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.kiosk_service_version
    ADD CONSTRAINT kiosk_service_version_pkey PRIMARY KEY (kiosk_id, service);


--
-- Name: kiosk_status kiosk_status_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.kiosk_status
    ADD CONSTRAINT kiosk_status_pkey PRIMARY KEY (id);


--
-- Name: kiosks_date_non_new kiosks_date_non_new_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.kiosks_date_non_new
    ADD CONSTRAINT kiosks_date_non_new_pkey PRIMARY KEY (id);


--
-- Name: label_order label_order_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.label_order
    ADD CONSTRAINT label_order_pkey PRIMARY KEY (id);


--
-- Name: label label_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.label
    ADD CONSTRAINT label_pkey PRIMARY KEY (id);


--
-- Name: last_kiosk_status last_kiosk_status_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.last_kiosk_status
    ADD CONSTRAINT last_kiosk_status_pkey PRIMARY KEY (id);


--
-- Name: manual_adjustment manual_adjustment_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.manual_adjustment
    ADD CONSTRAINT manual_adjustment_pkey PRIMARY KEY (id);


--
-- Name: nutrition_filter nutrition_filter_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.nutrition_filter
    ADD CONSTRAINT nutrition_filter_pkey PRIMARY KEY (id);


--
-- Name: order_meta order_meta_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.order_meta
    ADD CONSTRAINT order_meta_pkey PRIMARY KEY (id);


--
-- Name: order order_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry."order"
    ADD CONSTRAINT order_pkey PRIMARY KEY (order_id);


--
-- Name: par_history par_history_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.par_history
    ADD CONSTRAINT par_history_pkey PRIMARY KEY (id);


--
-- Name: payment_order payment_order_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.payment_order
    ADD CONSTRAINT payment_order_pkey PRIMARY KEY (id);


--
-- Name: permission_mapping permission_mapping_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.permission_mapping
    ADD CONSTRAINT permission_mapping_pkey PRIMARY KEY (role_id, permission_id);


--
-- Name: permission permission_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.permission
    ADD CONSTRAINT permission_pkey PRIMARY KEY (id);


--
-- Name: pick_list_row pick_list_row_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.pick_list_row
    ADD CONSTRAINT pick_list_row_pkey PRIMARY KEY (id);


--
-- Name: product_20190507 product_20190507_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.product_20190507
    ADD CONSTRAINT product_20190507_pkey PRIMARY KEY (id);


--
-- Name: product_categories product_categories_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.product_categories
    ADD CONSTRAINT product_categories_pkey PRIMARY KEY (id);


--
-- Name: product_history product_history_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.product_history
    ADD CONSTRAINT product_history_pkey PRIMARY KEY (id);


--
-- Name: product_kiosk_price_offset product_kiosk_price_offset_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.product_kiosk_price_offset
    ADD CONSTRAINT product_kiosk_price_offset_pkey PRIMARY KEY (id);


--
-- Name: product product_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.product
    ADD CONSTRAINT product_pkey PRIMARY KEY (id);


--
-- Name: product_request product_request_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.product_request
    ADD CONSTRAINT product_request_pkey PRIMARY KEY (id);


--
-- Name: recent_transactions recent_transactions_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.recent_transactions
    ADD CONSTRAINT recent_transactions_pkey PRIMARY KEY (kiosk_id);


--
-- Name: restock_item restock_item_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.restock_item
    ADD CONSTRAINT restock_item_pkey PRIMARY KEY (id);


--
-- Name: ro_order ro_order_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.ro_order
    ADD CONSTRAINT ro_order_pkey PRIMARY KEY (order_id);


--
-- Name: role_mapping role_mapping_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.role_mapping
    ADD CONSTRAINT role_mapping_pkey PRIMARY KEY (role_id, parent_id);


--
-- Name: role role_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.role
    ADD CONSTRAINT role_pkey PRIMARY KEY (id);


--
-- Name: running_service running_service_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.running_service
    ADD CONSTRAINT running_service_pkey PRIMARY KEY (app_name);


--
-- Name: spoilage spoilage_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.spoilage
    ADD CONSTRAINT spoilage_pkey PRIMARY KEY (id);


--
-- Name: stockout stockout_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.stockout
    ADD CONSTRAINT stockout_pkey PRIMARY KEY (id);


--
-- Name: tag tag_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.tag
    ADD CONSTRAINT tag_pkey PRIMARY KEY (id);


--
-- Name: temperature_tag_history temperature_tag_history_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.temperature_tag_history
    ADD CONSTRAINT temperature_tag_history_pkey PRIMARY KEY (id);


--
-- Name: tmp_april23_error_order_fixes tmp_april23_error_order_fixes_pk; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.tmp_april23_error_order_fixes
    ADD CONSTRAINT tmp_april23_error_order_fixes_pk PRIMARY KEY (order_id);


--
-- Name: tmp_eng_3692 tmp_eng_3692_pk; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.tmp_eng_3692
    ADD CONSTRAINT tmp_eng_3692_pk PRIMARY KEY (order_id);


--
-- Name: tmp_may4_error_order_fixes tmp_may4_error_order_fixes_pk; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.tmp_may4_error_order_fixes
    ADD CONSTRAINT tmp_may4_error_order_fixes_pk PRIMARY KEY (order_id);


--
-- Name: tmp_may4_pricefinalize_order_fixes tmp_may4_error_pricefinalize_fixes_pk; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.tmp_may4_pricefinalize_order_fixes
    ADD CONSTRAINT tmp_may4_error_pricefinalize_fixes_pk PRIMARY KEY (order_id);


--
-- Name: tmp_order_transaction_id_map tmp_order_transaction_id_map_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.tmp_order_transaction_id_map
    ADD CONSTRAINT tmp_order_transaction_id_map_pkey PRIMARY KEY (transaction_id);


--
-- Name: tmp_payment_order tmp_payment_order_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.tmp_payment_order
    ADD CONSTRAINT tmp_payment_order_pkey PRIMARY KEY (order_id);


--
-- Name: tmp_payment_order_with_id tmp_payment_order_with_id_order_id_key; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.tmp_payment_order_with_id
    ADD CONSTRAINT tmp_payment_order_with_id_order_id_key UNIQUE (order_id);


--
-- Name: tmp_payment_order_with_id tmp_payment_order_with_id_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.tmp_payment_order_with_id
    ADD CONSTRAINT tmp_payment_order_with_id_pkey PRIMARY KEY (id);


--
-- Name: tmp_price_finalized_order_ids tmp_price_finalized_order_ids_pk; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.tmp_price_finalized_order_ids
    ADD CONSTRAINT tmp_price_finalized_order_ids_pk PRIMARY KEY (order_id);


--
-- Name: tmp_process_order_txt tmp_process_order_txt_order_id_key; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.tmp_process_order_txt
    ADD CONSTRAINT tmp_process_order_txt_order_id_key UNIQUE (order_id);


--
-- Name: tmp_process_order_txt tmp_process_order_txt_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.tmp_process_order_txt
    ADD CONSTRAINT tmp_process_order_txt_pkey PRIMARY KEY (id);


--
-- Name: tmp_process_order_vantiv tmp_process_order_vantiv_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.tmp_process_order_vantiv
    ADD CONSTRAINT tmp_process_order_vantiv_pkey PRIMARY KEY (id);


--
-- Name: tmp_revert_order_status tmp_re_auth_orders_pk; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.tmp_revert_order_status
    ADD CONSTRAINT tmp_re_auth_orders_pk PRIMARY KEY (order_id);


--
-- Name: transact_comp transact_comp_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.transact_comp
    ADD CONSTRAINT transact_comp_pkey PRIMARY KEY (id);


--
-- Name: transact_express transact_express_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.transact_express
    ADD CONSTRAINT transact_express_pkey PRIMARY KEY (id);


--
-- Name: transact_fp transact_fp_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.transact_fp
    ADD CONSTRAINT transact_fp_pkey PRIMARY KEY (id);


--
-- Name: transact_ipc transact_ipc_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.transact_ipc
    ADD CONSTRAINT transact_ipc_pkey PRIMARY KEY (id);


--
-- Name: user user_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry."user"
    ADD CONSTRAINT user_pkey PRIMARY KEY (id);


--
-- Name: awsdms_ddl_audit awsdms_ddl_audit_pkey; Type: CONSTRAINT; Schema: public; Owner: dbservice
--

ALTER TABLE ONLY public.awsdms_ddl_audit
    ADD CONSTRAINT awsdms_ddl_audit_pkey PRIMARY KEY (c_key);


--
-- Name: awsdms_heartbeat awsdms_heartbeat_pkey; Type: CONSTRAINT; Schema: public; Owner: dbservice
--

ALTER TABLE ONLY public.awsdms_heartbeat
    ADD CONSTRAINT awsdms_heartbeat_pkey PRIMARY KEY (hb_key);


--
-- Name: bytecodelog bytecodelog_pkey; Type: CONSTRAINT; Schema: public; Owner: dbservice
--

ALTER TABLE ONLY public.bytecodelog
    ADD CONSTRAINT bytecodelog_pkey PRIMARY KEY (email, bytecode);


--
-- Name: campaigns campaigns_description_key; Type: CONSTRAINT; Schema: public; Owner: dbservice
--

ALTER TABLE ONLY public.campaigns
    ADD CONSTRAINT campaigns_description_key UNIQUE (description);


--
-- Name: campaigns campaigns_owner_key; Type: CONSTRAINT; Schema: public; Owner: dbservice
--

ALTER TABLE ONLY public.campaigns
    ADD CONSTRAINT campaigns_owner_key UNIQUE (owner);


--
-- Name: campaigns campaigns_pkey; Type: CONSTRAINT; Schema: public; Owner: dbservice
--

ALTER TABLE ONLY public.campaigns
    ADD CONSTRAINT campaigns_pkey PRIMARY KEY (campaign_id);


--
-- Name: campaigns campaigns_title_key; Type: CONSTRAINT; Schema: public; Owner: dbservice
--

ALTER TABLE ONLY public.campaigns
    ADD CONSTRAINT campaigns_title_key UNIQUE (title);


--
-- Name: customer_campaigns customer_campaigns_coupon_id_key; Type: CONSTRAINT; Schema: public; Owner: dbservice
--

ALTER TABLE ONLY public.customer_campaigns
    ADD CONSTRAINT customer_campaigns_coupon_id_key UNIQUE (coupon_id);


--
-- Name: customer_campaigns customer_campaigns_pkey; Type: CONSTRAINT; Schema: public; Owner: dbservice
--

ALTER TABLE ONLY public.customer_campaigns
    ADD CONSTRAINT customer_campaigns_pkey PRIMARY KEY (customer_id, campaign_id);


--
-- Name: customer_campaigns customer_campaigns_status_key; Type: CONSTRAINT; Schema: public; Owner: dbservice
--

ALTER TABLE ONLY public.customer_campaigns
    ADD CONSTRAINT customer_campaigns_status_key UNIQUE (status);


--
-- Name: customers customers_email_address_key; Type: CONSTRAINT; Schema: public; Owner: dbservice
--

ALTER TABLE ONLY public.customers
    ADD CONSTRAINT customers_email_address_key UNIQUE (email_address);


--
-- Name: customers customers_full_name_key; Type: CONSTRAINT; Schema: public; Owner: dbservice
--

ALTER TABLE ONLY public.customers
    ADD CONSTRAINT customers_full_name_key UNIQUE (full_name);


--
-- Name: customers customers_pkey; Type: CONSTRAINT; Schema: public; Owner: dbservice
--

ALTER TABLE ONLY public.customers
    ADD CONSTRAINT customers_pkey PRIMARY KEY (customer_id);


--
-- Name: inm_kiosk_weekly_sale inm_kiosk_weekly_sale_pkey; Type: CONSTRAINT; Schema: public; Owner: dbservice
--

ALTER TABLE ONLY public.inm_kiosk_weekly_sale
    ADD CONSTRAINT inm_kiosk_weekly_sale_pkey PRIMARY KEY (key);


--
-- Name: int_kiosk_weekly_sale int_kiosk_weekly_sale_pkey; Type: CONSTRAINT; Schema: public; Owner: dbservice
--

ALTER TABLE ONLY public.int_kiosk_weekly_sale
    ADD CONSTRAINT int_kiosk_weekly_sale_pkey PRIMARY KEY (key);


--
-- Name: kiosk kiosk_pkey; Type: CONSTRAINT; Schema: public; Owner: dbservice
--

ALTER TABLE ONLY public.kiosk
    ADD CONSTRAINT kiosk_pkey PRIMARY KEY (id);


--
-- Name: pantry.kiosk pantry.kiosk_pkey; Type: CONSTRAINT; Schema: public; Owner: dbservice
--

ALTER TABLE ONLY public."pantry.kiosk"
    ADD CONSTRAINT "pantry.kiosk_pkey" PRIMARY KEY (id);


--
-- Name: track_dashboard track_dashboard_pkey; Type: CONSTRAINT; Schema: public; Owner: dbservice
--

ALTER TABLE ONLY public.track_dashboard
    ADD CONSTRAINT track_dashboard_pkey PRIMARY KEY (id);


--
-- Name: track_inventory track_inventory_pkey; Type: CONSTRAINT; Schema: public; Owner: dbservice
--

ALTER TABLE ONLY public.track_inventory
    ADD CONSTRAINT track_inventory_pkey PRIMARY KEY (id);


--
-- Name: eng2903 eng2903_pk; Type: CONSTRAINT; Schema: test; Owner: dbservice
--

ALTER TABLE ONLY test.eng2903
    ADD CONSTRAINT eng2903_pk PRIMARY KEY (order_id);


--
-- Name: kiosk_payment_start kiosk_payment_start_pkey; Type: CONSTRAINT; Schema: test; Owner: dbservice
--

ALTER TABLE ONLY test.kiosk_payment_start
    ADD CONSTRAINT kiosk_payment_start_pkey PRIMARY KEY (id);


--
-- Name: kiosk_serial_20190916 kiosk_serial_20190916_pkey; Type: CONSTRAINT; Schema: test; Owner: dbservice
--

ALTER TABLE ONLY test.kiosk_serial_20190916
    ADD CONSTRAINT kiosk_serial_20190916_pkey PRIMARY KEY (id);


--
-- Name: order_complimentary_eng_2292 order_complimentary_eng_2292_pkey; Type: CONSTRAINT; Schema: test; Owner: dbservice
--

ALTER TABLE ONLY test.order_complimentary_eng_2292
    ADD CONSTRAINT order_complimentary_eng_2292_pkey PRIMARY KEY (order_id);


--
-- Name: reauth_2019_07_priced_finalized_orders reauth_2019_07_priced_finalized_orders_pk; Type: CONSTRAINT; Schema: test; Owner: dbservice
--

ALTER TABLE ONLY test.reauth_2019_07_priced_finalized_orders
    ADD CONSTRAINT reauth_2019_07_priced_finalized_orders_pk PRIMARY KEY (order_id);


--
-- Name: request_log_order request_log_order_pkey; Type: CONSTRAINT; Schema: test; Owner: dbservice
--

ALTER TABLE ONLY test.request_log_order
    ADD CONSTRAINT request_log_order_pkey PRIMARY KEY (order_id);


--
-- Name: deps_saved_ddl deps_saved_ddl_pkey; Type: CONSTRAINT; Schema: util; Owner: dbservice
--

ALTER TABLE ONLY util.deps_saved_ddl
    ADD CONSTRAINT deps_saved_ddl_pkey PRIMARY KEY (deps_id);


--
-- Name: awsdms_history_task_history_index; Type: INDEX; Schema: aws_dms; Owner: dbservice
--

CREATE UNIQUE INDEX awsdms_history_task_history_index ON aws_dms.awsdms_history USING btree (server_name, task_name, timeslot_type, timeslot);


--
-- Name: awsdms_status_task_status_index; Type: INDEX; Schema: aws_dms; Owner: dbservice
--

CREATE UNIQUE INDEX awsdms_status_task_status_index ON aws_dms.awsdms_status USING btree (server_name, task_name);


--
-- Name: awsdms_suspended_tables_task_suspended_tables_index; Type: INDEX; Schema: aws_dms; Owner: dbservice
--

CREATE UNIQUE INDEX awsdms_suspended_tables_task_suspended_tables_index ON aws_dms.awsdms_suspended_tables USING btree (server_name, task_name, table_owner, table_name);


--
-- Name: awsdms_history_task_history_index; Type: INDEX; Schema: dms7; Owner: dbservice
--

CREATE UNIQUE INDEX awsdms_history_task_history_index ON dms7.awsdms_history USING btree (server_name, task_name, timeslot_type, timeslot);


--
-- Name: awsdms_status_task_status_index; Type: INDEX; Schema: dms7; Owner: dbservice
--

CREATE UNIQUE INDEX awsdms_status_task_status_index ON dms7.awsdms_status USING btree (server_name, task_name);


--
-- Name: awsdms_suspended_tables_task_suspended_tables_index; Type: INDEX; Schema: dms7; Owner: dbservice
--

CREATE UNIQUE INDEX awsdms_suspended_tables_task_suspended_tables_index ON dms7.awsdms_suspended_tables USING btree (server_name, task_name, table_owner, table_name);


--
-- Name: sku_property_property_id_idx; Type: INDEX; Schema: inm; Owner: dbservice
--

CREATE INDEX sku_property_property_id_idx ON inm.sku_property USING btree (property_id);


--
-- Name: kiosk_restriction_by_property_property_id_idx; Type: INDEX; Schema: mixalot; Owner: dbservice
--

CREATE INDEX kiosk_restriction_by_property_property_id_idx ON mixalot.kiosk_restriction_by_property USING btree (property_id);


--
-- Name: kiosk_restriction_by_sku_sku_id_idx; Type: INDEX; Schema: mixalot; Owner: dbservice
--

CREATE INDEX kiosk_restriction_by_sku_sku_id_idx ON mixalot.kiosk_restriction_by_sku USING btree (sku_id);


--
-- Name: request_log_endpoint; Type: INDEX; Schema: mixalot; Owner: dbservice
--

CREATE INDEX request_log_endpoint ON mixalot.request_log USING btree (endpoint);


--
-- Name: request_log_kid; Type: INDEX; Schema: mixalot; Owner: dbservice
--

CREATE INDEX request_log_kid ON mixalot.request_log USING btree (kid);


--
-- Name: request_log_kiosk_id; Type: INDEX; Schema: mixalot; Owner: dbservice
--

CREATE INDEX request_log_kiosk_id ON mixalot.request_log USING btree (kiosk_id);


--
-- Name: request_log_kiosk_id_kid_rec_version; Type: INDEX; Schema: mixalot; Owner: dbservice
--

CREATE INDEX request_log_kiosk_id_kid_rec_version ON mixalot.request_log USING btree (kiosk_id, kid, rec_version);


--
-- Name: request_log_order_id; Type: INDEX; Schema: mixalot; Owner: dbservice
--

CREATE INDEX request_log_order_id ON mixalot.request_log USING btree (order_id);


--
-- Name: request_log_rec_version; Type: INDEX; Schema: mixalot; Owner: dbservice
--

CREATE INDEX request_log_rec_version ON mixalot.request_log USING btree (rec_version);


--
-- Name: request_log_source; Type: INDEX; Schema: mixalot; Owner: dbservice
--

CREATE INDEX request_log_source ON mixalot.request_log USING btree (source);


--
-- Name: request_log_stamp; Type: INDEX; Schema: mixalot; Owner: dbservice
--

CREATE INDEX request_log_stamp ON mixalot.request_log USING btree (stamp);


--
-- Name: request_log_start_ts; Type: INDEX; Schema: mixalot; Owner: dbservice
--

CREATE INDEX request_log_start_ts ON mixalot.request_log USING btree (start_ts);


--
-- Name: request_log_status_code; Type: INDEX; Schema: mixalot; Owner: dbservice
--

CREATE INDEX request_log_status_code ON mixalot.request_log USING btree (status_code);


--
-- Name: request_log_time; Type: INDEX; Schema: mixalot; Owner: dbservice
--

CREATE INDEX request_log_time ON mixalot.request_log USING btree ("time");


--
-- Name: request_log_version; Type: INDEX; Schema: mixalot; Owner: dbservice
--

CREATE INDEX request_log_version ON mixalot.request_log USING btree (version);


--
-- Name: sku_property_property_id_idx; Type: INDEX; Schema: mixalot; Owner: dbservice
--

CREATE INDEX sku_property_property_id_idx ON mixalot.sku_property USING btree (property_id);


--
-- Name: byte_created_idx; Type: INDEX; Schema: pantry; Owner: dbservice
--

CREATE INDEX byte_created_idx ON pantry."order" USING btree (created);


--
-- Name: byte_label_added_idx; Type: INDEX; Schema: pantry; Owner: dbservice
--

CREATE INDEX byte_label_added_idx ON pantry.label USING btree (to_timestamp((time_added)::double precision), product_id);


--
-- Name: byte_label_epc_idx; Type: INDEX; Schema: pantry; Owner: dbservice
--

CREATE INDEX byte_label_epc_idx ON pantry.label USING btree (epc);


--
-- Name: byte_label_kiosk_id_idx; Type: INDEX; Schema: pantry; Owner: dbservice
--

CREATE INDEX byte_label_kiosk_id_idx ON pantry.label USING btree (kiosk_id);


--
-- Name: byte_label_order_id_idx; Type: INDEX; Schema: pantry; Owner: dbservice
--

CREATE INDEX byte_label_order_id_idx ON pantry.label USING btree (order_id);


--
-- Name: byte_label_order_status_idx; Type: INDEX; Schema: pantry; Owner: dbservice
--

CREATE INDEX byte_label_order_status_idx ON pantry.label USING btree (order_id, status);


--
-- Name: byte_label_ts_idx; Type: INDEX; Schema: pantry; Owner: dbservice
--

CREATE INDEX byte_label_ts_idx ON pantry.label USING btree (to_timestamp((COALESCE(time_updated, time_created, time_added))::double precision));


--
-- Name: byte_product_stats_by_kiosk_idx; Type: INDEX; Schema: pantry; Owner: dbservice
--

CREATE INDEX byte_product_stats_by_kiosk_idx ON pantry.product_stats_by_kiosk USING btree (to_timestamp(("timestamp")::double precision));


--
-- Name: byte_raw_orders_ts_idx; Type: INDEX; Schema: pantry; Owner: dbservice
--

CREATE INDEX byte_raw_orders_ts_idx ON pantry."order" USING btree (to_timestamp((created)::double precision)) WHERE (campus_id = 87);


--
-- Name: byte_spoilage_ts_idx; Type: INDEX; Schema: pantry; Owner: dbservice
--

CREATE INDEX byte_spoilage_ts_idx ON pantry.spoilage USING btree (to_timestamp((time_removed)::double precision));


--
-- Name: byte_stockouts_restock_ts_idx; Type: INDEX; Schema: pantry; Owner: dbservice
--

CREATE INDEX byte_stockouts_restock_ts_idx ON pantry.stockout USING btree (to_timestamp((restock_timestamp)::double precision));


--
-- Name: byte_stockouts_ts_idx; Type: INDEX; Schema: pantry; Owner: dbservice
--

CREATE INDEX byte_stockouts_ts_idx ON pantry.stockout USING btree (to_timestamp(("timestamp")::double precision));


--
-- Name: byte_tickets_idx; Type: INDEX; Schema: pantry; Owner: dbservice
--

CREATE INDEX byte_tickets_idx ON pantry."order" USING btree (to_timestamp((created)::double precision)) WHERE ((campus_id = 87) AND ((state)::text = ANY (ARRAY[('Processed'::character varying)::text, ('Refunded'::character varying)::text])));


--
-- Name: byte_time_created_idx; Type: INDEX; Schema: pantry; Owner: dbservice
--

CREATE INDEX byte_time_created_idx ON pantry.label USING btree (time_created);


--
-- Name: history_epc; Type: INDEX; Schema: pantry; Owner: dbservice
--

CREATE INDEX history_epc ON pantry.history USING btree (epc);


--
-- Name: history_epc_order_epc; Type: INDEX; Schema: pantry; Owner: dbservice
--

CREATE INDEX history_epc_order_epc ON pantry.history_epc_order USING btree (epc);


--
-- Name: history_epc_order_kiosk_id; Type: INDEX; Schema: pantry; Owner: dbservice
--

CREATE INDEX history_epc_order_kiosk_id ON pantry.history_epc_order USING btree (kiosk_id);


--
-- Name: history_epc_order_order_id; Type: INDEX; Schema: pantry; Owner: dbservice
--

CREATE INDEX history_epc_order_order_id ON pantry.history_epc_order USING btree (order_id);


--
-- Name: history_epc_order_time; Type: INDEX; Schema: pantry; Owner: dbservice
--

CREATE INDEX history_epc_order_time ON pantry.history_epc_order USING btree ("time");


--
-- Name: history_idx; Type: INDEX; Schema: pantry; Owner: dbservice
--

CREATE INDEX history_idx ON pantry.history USING btree (to_timestamp(("time")::double precision));


--
-- Name: history_kiosk_id; Type: INDEX; Schema: pantry; Owner: dbservice
--

CREATE INDEX history_kiosk_id ON pantry.history USING btree (kiosk_id);


--
-- Name: history_order_id; Type: INDEX; Schema: pantry; Owner: dbservice
--

CREATE INDEX history_order_id ON pantry.history USING btree (order_id);


--
-- Name: history_time; Type: INDEX; Schema: pantry; Owner: dbservice
--

CREATE INDEX history_time ON pantry.history USING btree ("time");


--
-- Name: inventory_history_campus_id_time_idx; Type: INDEX; Schema: pantry; Owner: dbservice
--

CREATE INDEX inventory_history_campus_id_time_idx ON pantry.inventory_history USING btree (to_timestamp(("time")::double precision)) WHERE (campus_id = 87);


--
-- Name: inventory_history_idx; Type: INDEX; Schema: pantry; Owner: dbservice
--

CREATE INDEX inventory_history_idx ON pantry.inventory_history USING btree (to_timestamp(("time")::double precision));


--
-- Name: inventory_history_kiosk_id_idx; Type: INDEX; Schema: pantry; Owner: dbservice
--

CREATE INDEX inventory_history_kiosk_id_idx ON pantry.inventory_history USING btree (kiosk_id);


--
-- Name: inventory_history_product_id_idx; Type: INDEX; Schema: pantry; Owner: dbservice
--

CREATE INDEX inventory_history_product_id_idx ON pantry.inventory_history USING btree (product_id);


--
-- Name: inventory_history_time_idx; Type: INDEX; Schema: pantry; Owner: dbservice
--

CREATE INDEX inventory_history_time_idx ON pantry.inventory_history USING btree ("time");


--
-- Name: inventory_history_to_timestamp_product_id_idx; Type: INDEX; Schema: pantry; Owner: dbservice
--

CREATE INDEX inventory_history_to_timestamp_product_id_idx ON pantry.inventory_history USING btree (to_timestamp(("time")::double precision), product_id);


--
-- Name: inventory_request_epc; Type: INDEX; Schema: pantry; Owner: dbservice
--

CREATE INDEX inventory_request_epc ON pantry.inventory_request USING btree (epc);


--
-- Name: inventory_request_kiosk_id; Type: INDEX; Schema: pantry; Owner: dbservice
--

CREATE INDEX inventory_request_kiosk_id ON pantry.inventory_request USING btree (kiosk_id);


--
-- Name: inventory_request_time; Type: INDEX; Schema: pantry; Owner: dbservice
--

CREATE INDEX inventory_request_time ON pantry.inventory_request USING btree ("time");


--
-- Name: inventory_request_ts; Type: INDEX; Schema: pantry; Owner: dbservice
--

CREATE INDEX inventory_request_ts ON pantry.inventory_request USING btree (to_timestamp(("time")::double precision));


--
-- Name: last_kiosk_status_id; Type: INDEX; Schema: pantry; Owner: dbservice
--

CREATE UNIQUE INDEX last_kiosk_status_id ON pantry.last_kiosk_status USING btree (kiosk_id);


--
-- Name: order_id_unique; Type: INDEX; Schema: pantry; Owner: dbservice
--

CREATE UNIQUE INDEX order_id_unique ON pantry.feedback USING btree (order_id);


--
-- Name: pantry_coupon_code_idx; Type: INDEX; Schema: pantry; Owner: dbservice
--

CREATE INDEX pantry_coupon_code_idx ON pantry.coupon USING btree (code);


--
-- Name: pantry_order_coupon_idx; Type: INDEX; Schema: pantry; Owner: dbservice
--

CREATE INDEX pantry_order_coupon_idx ON pantry."order" USING btree (coupon);


--
-- Name: pantry_order_kiosk_id; Type: INDEX; Schema: pantry; Owner: dbservice
--

CREATE INDEX pantry_order_kiosk_id ON pantry."order" USING btree (kiosk_id);


--
-- Name: pantry_order_kiosk_id_ts; Type: INDEX; Schema: pantry; Owner: dbservice
--

CREATE INDEX pantry_order_kiosk_id_ts ON pantry."order" USING btree (kiosk_id, created) WHERE ((campus_id = 87) AND ((order_id)::text !~~ 'RE%'::text));


--
-- Name: tag_name_id; Type: INDEX; Schema: pantry; Owner: dbservice
--

CREATE UNIQUE INDEX tag_name_id ON pantry.tag USING btree (tag);


--
-- Name: tag_unique_constraint_index; Type: INDEX; Schema: pantry; Owner: dbservice
--

CREATE UNIQUE INDEX tag_unique_constraint_index ON pantry.tag USING btree (lower((tag)::text));


--
-- Name: tmp_payment_order_with_id_payload_idx; Type: INDEX; Schema: pantry; Owner: dbservice
--

CREATE INDEX tmp_payment_order_with_id_payload_idx ON pantry.tmp_payment_order_with_id USING btree (payload);


--
-- Name: awsdms_history_task_history_index; Type: INDEX; Schema: public; Owner: dbservice
--

CREATE UNIQUE INDEX awsdms_history_task_history_index ON public.awsdms_history USING btree (server_name, task_name, timeslot_type, timeslot);


--
-- Name: awsdms_status_task_status_index; Type: INDEX; Schema: public; Owner: dbservice
--

CREATE UNIQUE INDEX awsdms_status_task_status_index ON public.awsdms_status USING btree (server_name, task_name);


--
-- Name: awsdms_suspended_tables_task_suspended_tables_index; Type: INDEX; Schema: public; Owner: dbservice
--

CREATE UNIQUE INDEX awsdms_suspended_tables_task_suspended_tables_index ON public.awsdms_suspended_tables USING btree (server_name, task_name, table_owner, table_name);


--
-- Name: bytecodelog_bytecode_expires_at; Type: INDEX; Schema: public; Owner: dbservice
--

CREATE INDEX bytecodelog_bytecode_expires_at ON public.bytecodelog USING btree (bytecode, expires_at);


--
-- Name: idx_bkg_hkp; Type: INDEX; Schema: public; Owner: dbservice
--

CREATE INDEX idx_bkg_hkp ON public.byte_kp_grid USING btree (kiosk_id, product_id, hour_start);


--
-- Name: idx_bko_hkp; Type: INDEX; Schema: public; Owner: dbservice
--

CREATE INDEX idx_bko_hkp ON public.byte_kp_sales USING btree (kiosk_id, product_id, sales_hour);


--
-- Name: idx_bkp_oavg; Type: INDEX; Schema: public; Owner: dbservice
--

CREATE INDEX idx_bkp_oavg ON public.byte_kp_oos_avgdowhour USING btree (kiosk_id, product_id, dowhour);


--
-- Name: idx_bkp_savg; Type: INDEX; Schema: public; Owner: dbservice
--

CREATE INDEX idx_bkp_savg ON public.byte_kp_sales_avgdowhour USING btree (kiosk_id, product_id, dowhour);


--
-- Name: vantiv_20190801_referencenumber_idx; Type: INDEX; Schema: test; Owner: dbservice
--

CREATE UNIQUE INDEX vantiv_20190801_referencenumber_idx ON test.vantiv_20190801 USING btree (referencenumber);


--
-- Name: pick_inventory set_default_pick_date; Type: TRIGGER; Schema: inm_test; Owner: dbservice
--

CREATE TRIGGER set_default_pick_date BEFORE INSERT ON inm_test.pick_inventory FOR EACH ROW EXECUTE PROCEDURE inm_test.pick_inventory_insert();


--
-- Name: product_stats_by_kiosk before_insert_product_stats_by_kiosk; Type: TRIGGER; Schema: pantry; Owner: dbservice
--

CREATE TRIGGER before_insert_product_stats_by_kiosk BEFORE INSERT ON pantry.product_stats_by_kiosk FOR EACH ROW EXECUTE PROCEDURE pantry.fn_product_stats_by_kiosk();


--
-- Name: spoilage before_insert_spoilage; Type: TRIGGER; Schema: pantry; Owner: dbservice
--

CREATE TRIGGER before_insert_spoilage BEFORE INSERT ON pantry.spoilage FOR EACH ROW EXECUTE PROCEDURE pantry.fn_spoilage_insert();


--
-- Name: campus campus_insert; Type: TRIGGER; Schema: pantry; Owner: dbservice
--

CREATE TRIGGER campus_insert AFTER INSERT ON pantry.campus FOR EACH ROW EXECUTE PROCEDURE pantry.fn_campus_insert();


--
-- Name: card card_insert; Type: TRIGGER; Schema: pantry; Owner: dbservice
--

CREATE TRIGGER card_insert BEFORE INSERT ON pantry.card FOR EACH ROW EXECUTE PROCEDURE pantry.fn_card_insert();


--
-- Name: discount discount_delete; Type: TRIGGER; Schema: pantry; Owner: dbservice
--

CREATE TRIGGER discount_delete AFTER DELETE ON pantry.discount FOR EACH ROW EXECUTE PROCEDURE pantry.fn_discount_delete();


--
-- Name: discount discount_insert; Type: TRIGGER; Schema: pantry; Owner: dbservice
--

CREATE TRIGGER discount_insert AFTER INSERT ON pantry.discount FOR EACH ROW EXECUTE PROCEDURE pantry.fn_discount_insert();


--
-- Name: discount discount_update; Type: TRIGGER; Schema: pantry; Owner: dbservice
--

CREATE TRIGGER discount_update AFTER UPDATE ON pantry.discount FOR EACH ROW EXECUTE PROCEDURE pantry.fn_discount_update();


--
-- Name: kiosk guardrails_ssl_cert_bytetech_co; Type: TRIGGER; Schema: pantry; Owner: dbservice
--

CREATE TRIGGER guardrails_ssl_cert_bytetech_co BEFORE INSERT OR UPDATE ON pantry.kiosk FOR EACH ROW EXECUTE PROCEDURE pantry.kiosk_guardrails_ssl_cert_bytetech_co();


--
-- Name: kiosk kiosk_audit_log_insert; Type: TRIGGER; Schema: pantry; Owner: dbservice
--

CREATE TRIGGER kiosk_audit_log_insert AFTER INSERT ON pantry.kiosk FOR EACH ROW EXECUTE PROCEDURE pantry.fn_kiosk_audit_log_insert();


--
-- Name: kiosk kiosk_audit_log_update; Type: TRIGGER; Schema: pantry; Owner: dbservice
--

CREATE TRIGGER kiosk_audit_log_update BEFORE UPDATE ON pantry.kiosk FOR EACH ROW EXECUTE PROCEDURE pantry.fn_kiosk_audit_log_update();


--
-- Name: kiosk_status kiosk_status_insert; Type: TRIGGER; Schema: pantry; Owner: dbservice
--

CREATE TRIGGER kiosk_status_insert BEFORE INSERT ON pantry.kiosk_status FOR EACH ROW EXECUTE PROCEDURE pantry.fn_kiosk_status_insert();


--
-- Name: kiosk kiosk_update; Type: TRIGGER; Schema: pantry; Owner: dbservice
--

CREATE TRIGGER kiosk_update AFTER UPDATE ON pantry.kiosk FOR EACH ROW EXECUTE PROCEDURE pantry.fn_kiosk_update();


--
-- Name: label label_delete; Type: TRIGGER; Schema: pantry; Owner: dbservice
--

CREATE TRIGGER label_delete AFTER DELETE ON pantry.label FOR EACH ROW EXECUTE PROCEDURE pantry.fn_label_delete();


--
-- Name: label label_insert; Type: TRIGGER; Schema: pantry; Owner: dbservice
--

CREATE TRIGGER label_insert BEFORE INSERT ON pantry.label FOR EACH ROW EXECUTE PROCEDURE pantry.fn_label_insert();


--
-- Name: label label_update; Type: TRIGGER; Schema: pantry; Owner: dbservice
--

CREATE TRIGGER label_update AFTER UPDATE ON pantry.label FOR EACH ROW EXECUTE PROCEDURE pantry.fn_label_update();


--
-- Name: order order_insert; Type: TRIGGER; Schema: pantry; Owner: dbservice
--

CREATE TRIGGER order_insert AFTER INSERT ON pantry."order" FOR EACH ROW EXECUTE PROCEDURE pantry.fn_order_insert();


--
-- Name: order order_update; Type: TRIGGER; Schema: pantry; Owner: dbservice
--

CREATE TRIGGER order_update AFTER UPDATE ON pantry."order" FOR EACH ROW EXECUTE PROCEDURE pantry.fn_order_update();


--
-- Name: product product_delete; Type: TRIGGER; Schema: pantry; Owner: dbservice
--

CREATE TRIGGER product_delete AFTER DELETE ON pantry.product FOR EACH ROW EXECUTE PROCEDURE pantry.fn_product_delete();


--
-- Name: product product_insert; Type: TRIGGER; Schema: pantry; Owner: dbservice
--

CREATE TRIGGER product_insert AFTER INSERT ON pantry.product FOR EACH ROW EXECUTE PROCEDURE pantry.fn_product_insert();


--
-- Name: product product_update; Type: TRIGGER; Schema: pantry; Owner: dbservice
--

CREATE TRIGGER product_update AFTER UPDATE ON pantry.product FOR EACH ROW EXECUTE PROCEDURE pantry.fn_product_update();


--
-- Name: campus_attribute trg_campus_attribute; Type: TRIGGER; Schema: pantry; Owner: dbservice
--

CREATE TRIGGER trg_campus_attribute AFTER INSERT OR DELETE OR UPDATE ON pantry.campus_attribute FOR EACH ROW EXECUTE PROCEDURE pantry.fn_audit_campus_attribute();


--
-- Name: global_attribute_def trg_global_attribute_def; Type: TRIGGER; Schema: pantry; Owner: dbservice
--

CREATE TRIGGER trg_global_attribute_def AFTER INSERT OR DELETE OR UPDATE ON pantry.global_attribute_def FOR EACH ROW EXECUTE PROCEDURE pantry.fn_audit_global_attribute_def();


--
-- Name: kiosk_attribute trg_kiosk_attribute; Type: TRIGGER; Schema: pantry; Owner: dbservice
--

CREATE TRIGGER trg_kiosk_attribute AFTER INSERT OR DELETE OR UPDATE ON pantry.kiosk_attribute FOR EACH ROW EXECUTE PROCEDURE pantry.fn_audit_kiosk_attribute();


--
-- Name: kiosk_device trg_kiosk_device; Type: TRIGGER; Schema: pantry; Owner: dbservice
--

CREATE TRIGGER trg_kiosk_device AFTER INSERT OR DELETE OR UPDATE ON pantry.kiosk_device FOR EACH ROW EXECUTE PROCEDURE pantry.fn_audit_kiosk_device();


--
-- Name: kiosk_service_version trg_kiosk_service_version; Type: TRIGGER; Schema: pantry; Owner: dbservice
--

CREATE TRIGGER trg_kiosk_service_version AFTER INSERT OR DELETE OR UPDATE ON pantry.kiosk_service_version FOR EACH ROW EXECUTE PROCEDURE pantry.fn_audit_kiosk_service_version();


--
-- Name: tmp_unit lineitem_order_id_fkey; Type: FK CONSTRAINT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.tmp_unit
    ADD CONSTRAINT lineitem_order_id_fkey FOREIGN KEY (order_id) REFERENCES mixalot.tmp_transact(order_id);


--
-- Name: log log_order_id_fkey; Type: FK CONSTRAINT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.log
    ADD CONSTRAINT log_order_id_fkey FOREIGN KEY (order_id) REFERENCES mixalot.tmp_transact(order_id);


--
-- Name: awsdms_intercept_ddl; Type: EVENT TRIGGER; Schema: -; Owner: rdsadmin
--

CREATE EVENT TRIGGER awsdms_intercept_ddl ON ddl_command_end
   EXECUTE PROCEDURE public.awsdms_intercept_ddl();


ALTER EVENT TRIGGER awsdms_intercept_ddl OWNER TO rdsadmin;

--
-- Name: SCHEMA inm; Type: ACL; Schema: -; Owner: dbservice
--

GRANT ALL ON SCHEMA inm TO bytedevs;


--
-- Name: SCHEMA mixalot; Type: ACL; Schema: -; Owner: dbservice
--

GRANT USAGE ON SCHEMA mixalot TO requestlogs;
GRANT ALL ON SCHEMA mixalot TO bytedevs;


--
-- Name: SCHEMA pantry; Type: ACL; Schema: -; Owner: dbservice
--

GRANT ALL ON SCHEMA pantry TO pantry_web_user;
GRANT ALL ON SCHEMA pantry TO bytedevs;


--
-- Name: SCHEMA public; Type: ACL; Schema: -; Owner: dbservice
--

REVOKE ALL ON SCHEMA public FROM rdsadmin;
REVOKE ALL ON SCHEMA public FROM PUBLIC;
GRANT ALL ON SCHEMA public TO dbservice;
GRANT ALL ON SCHEMA public TO PUBLIC;
GRANT ALL ON SCHEMA public TO pantry_web_user;


--
-- Name: SCHEMA report; Type: ACL; Schema: -; Owner: dbservice
--

GRANT ALL ON SCHEMA report TO bytedevs;


--
-- Name: SCHEMA rptg; Type: ACL; Schema: -; Owner: dbservice
--

GRANT ALL ON SCHEMA rptg TO bytedevs;


--
-- Name: SCHEMA test; Type: ACL; Schema: -; Owner: dbservice
--

GRANT ALL ON SCHEMA test TO bytedevs;


--
-- Name: FUNCTION allocation_ratio_by_sku_group(target_date date); Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON FUNCTION inm.allocation_ratio_by_sku_group(target_date date) TO bytedevs;


--
-- Name: FUNCTION allocation_ratio_by_sku_group_test(target_date date); Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON FUNCTION inm.allocation_ratio_by_sku_group_test(target_date date) TO bytedevs;


--
-- Name: FUNCTION f_kiosk_sku_group_sku_pick_stats(pick_time timestamp with time zone); Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON FUNCTION inm.f_kiosk_sku_group_sku_pick_stats(pick_time timestamp with time zone) TO bytedevs;


--
-- Name: FUNCTION get_all_pull_list(given_kiosk_id integer); Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON FUNCTION inm.get_all_pull_list(given_kiosk_id integer) TO bytedevs;


--
-- Name: FUNCTION get_performance_pull_list(given_kiosk_id integer); Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON FUNCTION inm.get_performance_pull_list(given_kiosk_id integer) TO bytedevs;


--
-- Name: FUNCTION get_pull_date(plan_window_start timestamp with time zone, plan_window_stop timestamp with time zone); Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON FUNCTION inm.get_pull_date(plan_window_start timestamp with time zone, plan_window_stop timestamp with time zone) TO bytedevs;


--
-- Name: FUNCTION get_spoilage_pull_list(); Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON FUNCTION inm.get_spoilage_pull_list() TO bytedevs;


--
-- Name: FUNCTION get_spoilage_pull_list(given_kiosk_id integer); Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON FUNCTION inm.get_spoilage_pull_list(given_kiosk_id integer) TO bytedevs;


--
-- Name: FUNCTION pick_check_restriction(_pick_date date); Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON FUNCTION inm.pick_check_restriction(_pick_date date) TO bytedevs;


--
-- Name: FUNCTION pick_get_delivery_schedule(pick_date date); Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON FUNCTION inm.pick_get_delivery_schedule(pick_date date) TO bytedevs;


--
-- Name: FUNCTION pick_get_delivery_schedule_optimo(target_date date); Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON FUNCTION inm.pick_get_delivery_schedule_optimo(target_date date) TO bytedevs;


--
-- Name: FUNCTION pick_get_demand_weekly_by_velocity(); Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON FUNCTION inm.pick_get_demand_weekly_by_velocity() TO bytedevs;


--
-- Name: FUNCTION pick_get_demand_weekly_wo_min(); Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON FUNCTION inm.pick_get_demand_weekly_wo_min() TO bytedevs;


--
-- Name: FUNCTION pick_get_order(start_ts timestamp with time zone, end_ts timestamp with time zone); Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON FUNCTION inm.pick_get_order(start_ts timestamp with time zone, end_ts timestamp with time zone) TO bytedevs;


--
-- Name: FUNCTION pick_get_order_with_velocity(start_ts timestamp with time zone, end_ts timestamp with time zone); Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON FUNCTION inm.pick_get_order_with_velocity(start_ts timestamp with time zone, end_ts timestamp with time zone) TO bytedevs;


--
-- Name: FUNCTION pick_get_plan_kiosk(pick_date date); Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON FUNCTION inm.pick_get_plan_kiosk(pick_date date) TO bytedevs;


--
-- Name: FUNCTION pick_get_plan_kiosk(plan_window_start timestamp with time zone, plan_window_stop timestamp with time zone); Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON FUNCTION inm.pick_get_plan_kiosk(plan_window_start timestamp with time zone, plan_window_stop timestamp with time zone) TO bytedevs;


--
-- Name: FUNCTION pick_get_plan_kiosk_bringg(plan_window_start timestamp with time zone, plan_window_stop timestamp with time zone); Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON FUNCTION inm.pick_get_plan_kiosk_bringg(plan_window_start timestamp with time zone, plan_window_stop timestamp with time zone) TO bytedevs;


--
-- Name: FUNCTION pick_get_plan_kiosk_disabled_product(pick_date date); Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON FUNCTION inm.pick_get_plan_kiosk_disabled_product(pick_date date) TO bytedevs;


--
-- Name: FUNCTION pick_get_plan_kiosk_optimo(plan_window_start timestamp with time zone, plan_window_stop timestamp with time zone); Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON FUNCTION inm.pick_get_plan_kiosk_optimo(plan_window_start timestamp with time zone, plan_window_stop timestamp with time zone) TO bytedevs;


--
-- Name: FUNCTION pick_get_plan_kiosk_projected_stock(plan_window_start timestamp with time zone, plan_window_stop timestamp with time zone); Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON FUNCTION inm.pick_get_plan_kiosk_projected_stock(plan_window_start timestamp with time zone, plan_window_stop timestamp with time zone) TO bytedevs;


--
-- Name: FUNCTION pick_get_sales_period_ratio(start_ts timestamp with time zone, end_ts timestamp with time zone); Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON FUNCTION inm.pick_get_sales_period_ratio(start_ts timestamp with time zone, end_ts timestamp with time zone) TO bytedevs;


--
-- Name: FUNCTION pick_get_summary(target_date date); Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON FUNCTION inm.pick_get_summary(target_date date) TO bytedevs;


--
-- Name: FUNCTION pick_get_ticket(target_date date); Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON FUNCTION inm.pick_get_ticket(target_date date) TO bytedevs;


--
-- Name: FUNCTION pick_submit(target_date date, overwrite integer, wait_time_seconds integer, OUT submit_status text); Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON FUNCTION inm.pick_submit(target_date date, overwrite integer, wait_time_seconds integer, OUT submit_status text) TO bytedevs;


--
-- Name: FUNCTION sync_restriction_by_property(kiosk_id integer, restriction character varying); Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON FUNCTION inm.sync_restriction_by_property(kiosk_id integer, restriction character varying) TO bytedevs;


--
-- Name: FUNCTION backup_pick_allocation(target_pick_date date); Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON FUNCTION mixalot.backup_pick_allocation(target_pick_date date) TO bytedevs;


--
-- Name: FUNCTION pick_allocation_insert(); Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON FUNCTION mixalot.pick_allocation_insert() TO bytedevs;


--
-- Name: FUNCTION pick_demand_insert(); Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON FUNCTION mixalot.pick_demand_insert() TO bytedevs;


--
-- Name: FUNCTION pick_get_delivery_schedule(start_ts timestamp with time zone, end_ts timestamp with time zone); Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON FUNCTION mixalot.pick_get_delivery_schedule(start_ts timestamp with time zone, end_ts timestamp with time zone) TO bytedevs;


--
-- Name: FUNCTION pick_get_gsheets_plan_demand(start_ts timestamp with time zone, end_ts timestamp with time zone); Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON FUNCTION mixalot.pick_get_gsheets_plan_demand(start_ts timestamp with time zone, end_ts timestamp with time zone) TO bytedevs;


--
-- Name: FUNCTION pick_get_plan_demand(start_ts timestamp with time zone, end_ts timestamp with time zone); Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON FUNCTION mixalot.pick_get_plan_demand(start_ts timestamp with time zone, end_ts timestamp with time zone) TO bytedevs;


--
-- Name: FUNCTION pick_get_summary(target_date date); Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON FUNCTION mixalot.pick_get_summary(target_date date) TO bytedevs;


--
-- Name: FUNCTION pick_inventory_insert(); Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON FUNCTION mixalot.pick_inventory_insert() TO bytedevs;


--
-- Name: FUNCTION pick_summary(target_date date); Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON FUNCTION mixalot.pick_summary(target_date date) TO bytedevs;


--
-- Name: FUNCTION pick_ticket(target_date date); Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON FUNCTION mixalot.pick_ticket(target_date date) TO bytedevs;


--
-- Name: FUNCTION plan_kiosk(plan_window_start timestamp with time zone, plan_window_stop timestamp with time zone); Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON FUNCTION mixalot.plan_kiosk(plan_window_start timestamp with time zone, plan_window_stop timestamp with time zone) TO bytedevs;


--
-- Name: FUNCTION set_sequence_val_max(schema_name name, table_name name, raise_notice boolean); Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON FUNCTION mixalot.set_sequence_val_max(schema_name name, table_name name, raise_notice boolean) TO bytedevs;


--
-- Name: FUNCTION sku_pick_order(target_ts timestamp with time zone); Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON FUNCTION mixalot.sku_pick_order(target_ts timestamp with time zone) TO bytedevs;


--
-- Name: FUNCTION fn_add_to_watch(label_id bigint, order_id character varying); Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON FUNCTION pantry.fn_add_to_watch(label_id bigint, order_id character varying) TO pantry_web_user;
GRANT ALL ON FUNCTION pantry.fn_add_to_watch(label_id bigint, order_id character varying) TO bytedevs;


--
-- Name: FUNCTION fn_audit_campus_attribute(); Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON FUNCTION pantry.fn_audit_campus_attribute() TO pantry_web_user;
GRANT ALL ON FUNCTION pantry.fn_audit_campus_attribute() TO bytedevs;


--
-- Name: FUNCTION fn_audit_global_attribute_def(); Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON FUNCTION pantry.fn_audit_global_attribute_def() TO pantry_web_user;
GRANT ALL ON FUNCTION pantry.fn_audit_global_attribute_def() TO bytedevs;


--
-- Name: FUNCTION fn_audit_kiosk_attribute(); Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON FUNCTION pantry.fn_audit_kiosk_attribute() TO pantry_web_user;
GRANT ALL ON FUNCTION pantry.fn_audit_kiosk_attribute() TO bytedevs;


--
-- Name: FUNCTION fn_audit_kiosk_device(); Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON FUNCTION pantry.fn_audit_kiosk_device() TO pantry_web_user;
GRANT ALL ON FUNCTION pantry.fn_audit_kiosk_device() TO bytedevs;


--
-- Name: FUNCTION fn_audit_kiosk_service_version(); Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON FUNCTION pantry.fn_audit_kiosk_service_version() TO pantry_web_user;
GRANT ALL ON FUNCTION pantry.fn_audit_kiosk_service_version() TO bytedevs;


--
-- Name: FUNCTION fn_campus_insert(); Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON FUNCTION pantry.fn_campus_insert() TO pantry_web_user;
GRANT ALL ON FUNCTION pantry.fn_campus_insert() TO bytedevs;


--
-- Name: FUNCTION fn_card_insert(); Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON FUNCTION pantry.fn_card_insert() TO pantry_web_user;
GRANT ALL ON FUNCTION pantry.fn_card_insert() TO bytedevs;


--
-- Name: FUNCTION fn_discount_delete(); Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON FUNCTION pantry.fn_discount_delete() TO pantry_web_user;
GRANT ALL ON FUNCTION pantry.fn_discount_delete() TO bytedevs;


--
-- Name: FUNCTION fn_discount_insert(); Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON FUNCTION pantry.fn_discount_insert() TO pantry_web_user;
GRANT ALL ON FUNCTION pantry.fn_discount_insert() TO bytedevs;


--
-- Name: FUNCTION fn_discount_update(); Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON FUNCTION pantry.fn_discount_update() TO pantry_web_user;
GRANT ALL ON FUNCTION pantry.fn_discount_update() TO bytedevs;


--
-- Name: FUNCTION fn_kiosk_audit_log_insert(); Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON FUNCTION pantry.fn_kiosk_audit_log_insert() TO pantry_web_user;
GRANT ALL ON FUNCTION pantry.fn_kiosk_audit_log_insert() TO bytedevs;


--
-- Name: FUNCTION fn_kiosk_audit_log_update(); Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON FUNCTION pantry.fn_kiosk_audit_log_update() TO pantry_web_user;
GRANT ALL ON FUNCTION pantry.fn_kiosk_audit_log_update() TO bytedevs;


--
-- Name: FUNCTION fn_kiosk_status_insert(); Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON FUNCTION pantry.fn_kiosk_status_insert() TO pantry_web_user;
GRANT ALL ON FUNCTION pantry.fn_kiosk_status_insert() TO bytedevs;


--
-- Name: FUNCTION fn_kiosk_update(); Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON FUNCTION pantry.fn_kiosk_update() TO pantry_web_user;
GRANT ALL ON FUNCTION pantry.fn_kiosk_update() TO bytedevs;


--
-- Name: FUNCTION fn_label_delete(); Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON FUNCTION pantry.fn_label_delete() TO pantry_web_user;
GRANT ALL ON FUNCTION pantry.fn_label_delete() TO bytedevs;


--
-- Name: FUNCTION fn_label_insert(); Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON FUNCTION pantry.fn_label_insert() TO pantry_web_user;
GRANT ALL ON FUNCTION pantry.fn_label_insert() TO bytedevs;


--
-- Name: FUNCTION fn_label_update(); Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON FUNCTION pantry.fn_label_update() TO pantry_web_user;
GRANT ALL ON FUNCTION pantry.fn_label_update() TO bytedevs;


--
-- Name: FUNCTION fn_order_insert(); Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON FUNCTION pantry.fn_order_insert() TO pantry_web_user;
GRANT ALL ON FUNCTION pantry.fn_order_insert() TO bytedevs;


--
-- Name: FUNCTION fn_order_update(); Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON FUNCTION pantry.fn_order_update() TO pantry_web_user;
GRANT ALL ON FUNCTION pantry.fn_order_update() TO bytedevs;


--
-- Name: FUNCTION fn_product_delete(); Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON FUNCTION pantry.fn_product_delete() TO pantry_web_user;
GRANT ALL ON FUNCTION pantry.fn_product_delete() TO bytedevs;


--
-- Name: FUNCTION fn_product_insert(); Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON FUNCTION pantry.fn_product_insert() TO pantry_web_user;
GRANT ALL ON FUNCTION pantry.fn_product_insert() TO bytedevs;


--
-- Name: FUNCTION fn_product_stats_by_kiosk(); Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON FUNCTION pantry.fn_product_stats_by_kiosk() TO pantry_web_user;
GRANT ALL ON FUNCTION pantry.fn_product_stats_by_kiosk() TO bytedevs;


--
-- Name: FUNCTION fn_product_update(); Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON FUNCTION pantry.fn_product_update() TO pantry_web_user;
GRANT ALL ON FUNCTION pantry.fn_product_update() TO bytedevs;


--
-- Name: FUNCTION fn_ro_order_set_order(orderid character varying); Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON FUNCTION pantry.fn_ro_order_set_order(orderid character varying) TO pantry_web_user;
GRANT ALL ON FUNCTION pantry.fn_ro_order_set_order(orderid character varying) TO bytedevs;


--
-- Name: FUNCTION fn_ro_order_update_full_price(orderid character varying); Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON FUNCTION pantry.fn_ro_order_update_full_price(orderid character varying) TO pantry_web_user;
GRANT ALL ON FUNCTION pantry.fn_ro_order_update_full_price(orderid character varying) TO bytedevs;


--
-- Name: FUNCTION fn_spoilage_insert(); Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON FUNCTION pantry.fn_spoilage_insert() TO pantry_web_user;
GRANT ALL ON FUNCTION pantry.fn_spoilage_insert() TO bytedevs;


--
-- Name: FUNCTION get_permissions(a integer); Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON FUNCTION pantry.get_permissions(a integer) TO pantry_web_user;
GRANT ALL ON FUNCTION pantry.get_permissions(a integer) TO bytedevs;


--
-- Name: FUNCTION hierarchy(givenid integer, initial integer); Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON FUNCTION pantry.hierarchy(givenid integer, initial integer) TO pantry_web_user;
GRANT ALL ON FUNCTION pantry.hierarchy(givenid integer, initial integer) TO bytedevs;


--
-- Name: FUNCTION key_loc_lookup(param_kiosk_id bigint, key_name character varying); Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON FUNCTION pantry.key_loc_lookup(param_kiosk_id bigint, key_name character varying) TO pantry_web_user;
GRANT ALL ON FUNCTION pantry.key_loc_lookup(param_kiosk_id bigint, key_name character varying) TO bytedevs;


--
-- Name: FUNCTION kiosk_guardrails_ssl_cert_bytetech_co(); Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON FUNCTION pantry.kiosk_guardrails_ssl_cert_bytetech_co() TO pantry_web_user;
GRANT ALL ON FUNCTION pantry.kiosk_guardrails_ssl_cert_bytetech_co() TO bytedevs;


--
-- Name: FUNCTION awsdms_intercept_ddl(); Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON FUNCTION public.awsdms_intercept_ddl() TO pantry_web_user;


--
-- Name: FUNCTION checkpoint(receiving_start timestamp without time zone, receiving_stop timestamp without time zone, location_id bigint); Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON FUNCTION public.checkpoint(receiving_start timestamp without time zone, receiving_stop timestamp without time zone, location_id bigint) TO pantry_web_user;


--
-- Name: FUNCTION date_round(base_date timestamp with time zone, round_interval interval); Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON FUNCTION public.date_round(base_date timestamp with time zone, round_interval interval) TO pantry_web_user;


--
-- Name: FUNCTION div(numeric, numeric); Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON FUNCTION public.div(numeric, numeric) TO pantry_web_user;


--
-- Name: FUNCTION dowhour(timestamp with time zone); Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON FUNCTION public.dowhour(timestamp with time zone) TO pantry_web_user;


--
-- Name: FUNCTION epoch_round(bigint, round_interval interval); Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON FUNCTION public.epoch_round(bigint, round_interval interval) TO pantry_web_user;


--
-- Name: FUNCTION f_nr_stockout_minutes(ts timestamp with time zone, kiosk_restock_ts timestamp with time zone, hour_start timestamp with time zone, hour_end timestamp with time zone); Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON FUNCTION public.f_nr_stockout_minutes(ts timestamp with time zone, kiosk_restock_ts timestamp with time zone, hour_start timestamp with time zone, hour_end timestamp with time zone) TO pantry_web_user;


--
-- Name: FUNCTION fmt_ts(timestamp with time zone); Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON FUNCTION public.fmt_ts(timestamp with time zone) TO pantry_web_user;


--
-- Name: FUNCTION fmt_ts_mmdd(timestamp with time zone); Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON FUNCTION public.fmt_ts_mmdd(timestamp with time zone) TO pantry_web_user;


--
-- Name: FUNCTION frac(numeric, numeric); Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON FUNCTION public.frac(numeric, numeric) TO pantry_web_user;


--
-- Name: FUNCTION get_sum(a numeric, b numeric); Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON FUNCTION public.get_sum(a numeric, b numeric) TO pantry_web_user;


--
-- Name: FUNCTION hash_to_bigint(hexval character varying); Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON FUNCTION public.hash_to_bigint(hexval character varying) TO pantry_web_user;


--
-- Name: FUNCTION hex_to_int(hexval character varying); Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON FUNCTION public.hex_to_int(hexval character varying) TO pantry_web_user;


--
-- Name: FUNCTION if(boolean, anyelement, anyelement); Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON FUNCTION public.if(boolean, anyelement, anyelement) TO pantry_web_user;


--
-- Name: FUNCTION int_hash(text); Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON FUNCTION public.int_hash(text) TO pantry_web_user;


--
-- Name: FUNCTION interval_hours(interval); Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON FUNCTION public.interval_hours(interval) TO pantry_web_user;


--
-- Name: FUNCTION monthly_infographic_data(yyyy_mm text); Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON FUNCTION public.monthly_infographic_data(yyyy_mm text) TO pantry_web_user;


--
-- Name: FUNCTION path_check(VARIADIC kiosk_path text[]); Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON FUNCTION public.path_check(VARIADIC kiosk_path text[]) TO pantry_web_user;


--
-- Name: FUNCTION path_check_1_2_3(receiving_start timestamp without time zone, receiving_stop timestamp without time zone); Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON FUNCTION public.path_check_1_2_3(receiving_start timestamp without time zone, receiving_stop timestamp without time zone) TO pantry_web_user;


--
-- Name: FUNCTION pct(numeric, numeric); Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON FUNCTION public.pct(numeric, numeric) TO pantry_web_user;


--
-- Name: FUNCTION pick_get_next_delivery(target_date date); Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON FUNCTION public.pick_get_next_delivery(target_date date) TO pantry_web_user;


--
-- Name: FUNCTION pickpack(receiving_start timestamp without time zone, receiving_stop timestamp without time zone, location_id bigint); Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON FUNCTION public.pickpack(receiving_start timestamp without time zone, receiving_stop timestamp without time zone, location_id bigint) TO pantry_web_user;


--
-- Name: FUNCTION receiving(receiving_start timestamp without time zone, receiving_stop timestamp without time zone); Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON FUNCTION public.receiving(receiving_start timestamp without time zone, receiving_stop timestamp without time zone) TO pantry_web_user;


--
-- Name: FUNCTION set_sequence_val_max(schema_name name, table_name name, raise_notice boolean); Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON FUNCTION public.set_sequence_val_max(schema_name name, table_name name, raise_notice boolean) TO pantry_web_user;


--
-- Name: FUNCTION shelf_life_bucket(integer); Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON FUNCTION public.shelf_life_bucket(integer) TO pantry_web_user;


--
-- Name: FUNCTION stockout_hours(text, text); Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON FUNCTION public.stockout_hours(text, text) TO pantry_web_user;


--
-- Name: FUNCTION user_retention_by_month(n integer); Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON FUNCTION public.user_retention_by_month(n integer) TO pantry_web_user;


--
-- Name: FUNCTION user_retention_by_week(n integer); Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON FUNCTION public.user_retention_by_week(n integer) TO pantry_web_user;


--
-- Name: FUNCTION dependency_tree(object_ids oid[]); Type: ACL; Schema: report; Owner: dbservice
--

GRANT ALL ON FUNCTION report.dependency_tree(object_ids oid[]) TO bytedevs;


--
-- Name: FUNCTION dependency_tree(object_names text[]); Type: ACL; Schema: report; Owner: dbservice
--

GRANT ALL ON FUNCTION report.dependency_tree(object_names text[]) TO bytedevs;


--
-- Name: FUNCTION dependency_tree(search_pattern text); Type: ACL; Schema: report; Owner: dbservice
--

GRANT ALL ON FUNCTION report.dependency_tree(search_pattern text) TO bytedevs;


--
-- Name: FUNCTION byte_losses(beginning_date date, ending_date date); Type: ACL; Schema: rptg; Owner: dbservice
--

GRANT ALL ON FUNCTION rptg.byte_losses(beginning_date date, ending_date date) TO bytedevs;


--
-- Name: FUNCTION byte_sales(beginning_date date, ending_date date); Type: ACL; Schema: rptg; Owner: dbservice
--

GRANT ALL ON FUNCTION rptg.byte_sales(beginning_date date, ending_date date) TO bytedevs;


--
-- Name: FUNCTION losses(beginning_date date, ending_date date); Type: ACL; Schema: rptg; Owner: dbservice
--

GRANT ALL ON FUNCTION rptg.losses(beginning_date date, ending_date date) TO bytedevs;


--
-- Name: FUNCTION non_byte_losses(beginning_date date, ending_date date); Type: ACL; Schema: rptg; Owner: dbservice
--

GRANT ALL ON FUNCTION rptg.non_byte_losses(beginning_date date, ending_date date) TO bytedevs;


--
-- Name: FUNCTION non_byte_sales(beginning_date date, ending_date date); Type: ACL; Schema: rptg; Owner: dbservice
--

GRANT ALL ON FUNCTION rptg.non_byte_sales(beginning_date date, ending_date date) TO bytedevs;


--
-- Name: FUNCTION pick_audit(start_date date, end_date date); Type: ACL; Schema: rptg; Owner: dbservice
--

GRANT ALL ON FUNCTION rptg.pick_audit(start_date date, end_date date) TO bytedevs;


--
-- Name: FUNCTION restocks(beginning_date date, ending_date date); Type: ACL; Schema: rptg; Owner: dbservice
--

GRANT ALL ON FUNCTION rptg.restocks(beginning_date date, ending_date date) TO bytedevs;


--
-- Name: FUNCTION sales(beginning_date date, ending_date date); Type: ACL; Schema: rptg; Owner: dbservice
--

GRANT ALL ON FUNCTION rptg.sales(beginning_date date, ending_date date) TO bytedevs;


--
-- Name: FUNCTION spoils(beginning_date date, ending_date date); Type: ACL; Schema: rptg; Owner: dbservice
--

GRANT ALL ON FUNCTION rptg.spoils(beginning_date date, ending_date date) TO bytedevs;


--
-- Name: TABLE warehouse_inventory; Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON TABLE inm.warehouse_inventory TO bytedevs;


--
-- Name: TABLE product; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.product TO pantry_web_user;
GRANT ALL ON TABLE pantry.product TO bytedevs;


--
-- Name: TABLE allocable_inventory; Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON TABLE inm.allocable_inventory TO bytedevs;


--
-- Name: TABLE bringg_delivery; Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON TABLE inm.bringg_delivery TO bytedevs;


--
-- Name: TABLE configuration; Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON TABLE inm.configuration TO bytedevs;


--
-- Name: TABLE kiosk_attribute; Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON TABLE inm.kiosk_attribute TO bytedevs;


--
-- Name: TABLE kiosk_control; Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON TABLE inm.kiosk_control TO bytedevs;


--
-- Name: TABLE kiosk_product_disabled; Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON TABLE inm.kiosk_product_disabled TO bytedevs;


--
-- Name: TABLE pick_allocation; Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON TABLE inm.pick_allocation TO bytedevs;


--
-- Name: TABLE sku_group_attribute; Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON TABLE inm.sku_group_attribute TO bytedevs;


--
-- Name: TABLE kiosk; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.kiosk TO pantry_web_user;
GRANT ALL ON TABLE pantry.kiosk TO bytedevs;


--
-- Name: TABLE label; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.label TO pantry_web_user;
GRANT ALL ON TABLE pantry.label TO bytedevs;


--
-- Name: TABLE "order"; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry."order" TO pantry_web_user;
GRANT ALL ON TABLE pantry."order" TO bytedevs;


--
-- Name: TABLE kiosk_projected_minimum; Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON TABLE inm.kiosk_projected_minimum TO bytedevs;


--
-- Name: TABLE kiosk_projected_stock; Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON TABLE inm.kiosk_projected_stock TO bytedevs;


--
-- Name: TABLE kiosk_projected_stock_sku_level; Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON TABLE inm.kiosk_projected_stock_sku_level TO bytedevs;


--
-- Name: TABLE kiosk_restriction_by_product; Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON TABLE inm.kiosk_restriction_by_product TO bytedevs;


--
-- Name: TABLE kiosk_restriction_by_property; Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON TABLE inm.kiosk_restriction_by_property TO bytedevs;


--
-- Name: TABLE kiosk_restriction_by_sku; Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON TABLE inm.kiosk_restriction_by_sku TO bytedevs;


--
-- Name: TABLE product_property_def; Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON TABLE inm.product_property_def TO bytedevs;


--
-- Name: TABLE kiosk_restriction_list; Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON TABLE inm.kiosk_restriction_list TO bytedevs;


--
-- Name: TABLE kiosk_sku_group_manual_scale; Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON TABLE inm.kiosk_sku_group_manual_scale TO bytedevs;


--
-- Name: TABLE pick_demand; Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON TABLE inm.pick_demand TO bytedevs;


--
-- Name: TABLE pick_inventory; Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON TABLE inm.pick_inventory TO bytedevs;


--
-- Name: TABLE pick_list; Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON TABLE inm.pick_list TO bytedevs;


--
-- Name: TABLE pick_preference_kiosk_sku; Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON TABLE inm.pick_preference_kiosk_sku TO bytedevs;


--
-- Name: TABLE pick_priority_kiosk; Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON TABLE inm.pick_priority_kiosk TO bytedevs;


--
-- Name: TABLE pick_priority_sku; Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON TABLE inm.pick_priority_sku TO bytedevs;


--
-- Name: TABLE pick_rejection; Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON TABLE inm.pick_rejection TO bytedevs;


--
-- Name: TABLE pick_route; Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON TABLE inm.pick_route TO bytedevs;


--
-- Name: TABLE pick_substitution; Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON TABLE inm.pick_substitution TO bytedevs;


--
-- Name: TABLE product_property; Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON TABLE inm.product_property TO bytedevs;


--
-- Name: SEQUENCE product_property_def_id_seq; Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON SEQUENCE inm.product_property_def_id_seq TO bytedevs;


--
-- Name: TABLE sku_def; Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON TABLE inm.sku_def TO bytedevs;


--
-- Name: TABLE sku_group; Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON TABLE inm.sku_group TO bytedevs;


--
-- Name: TABLE sku_group_control; Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON TABLE inm.sku_group_control TO bytedevs;


--
-- Name: TABLE sku_property; Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON TABLE inm.sku_property TO bytedevs;


--
-- Name: TABLE sku_property_def; Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON TABLE inm.sku_property_def TO bytedevs;


--
-- Name: TABLE temp_pick_order; Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON TABLE inm.temp_pick_order TO bytedevs;


--
-- Name: TABLE temp_velocity; Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON TABLE inm.temp_velocity TO bytedevs;


--
-- Name: TABLE all_raw_orders; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.all_raw_orders TO bytedevs;
GRANT ALL ON TABLE public.all_raw_orders TO pantry_web_user;


--
-- Name: TABLE _all_orders; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public._all_orders TO bytedevs;
GRANT ALL ON TABLE public._all_orders TO pantry_web_user;


--
-- Name: TABLE all_orders; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.all_orders TO bytedevs;
GRANT ALL ON TABLE public.all_orders TO pantry_web_user;


--
-- Name: TABLE byte_products_fast; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_products_fast TO pantry_web_user;


--
-- Name: TABLE byte_products; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_products TO pantry_web_user;


--
-- Name: TABLE byte_label_product; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_label_product TO pantry_web_user;


--
-- Name: TABLE byte_orders; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_orders TO bytedevs;
GRANT ALL ON TABLE public.byte_orders TO pantry_web_user;


--
-- Name: TABLE byte_tickets; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_tickets TO bytedevs;
GRANT ALL ON TABLE public.byte_tickets TO pantry_web_user;


--
-- Name: TABLE byte_tickets_12weeks; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_tickets_12weeks TO bytedevs;
GRANT ALL ON TABLE public.byte_tickets_12weeks TO pantry_web_user;


--
-- Name: TABLE byte_epcssold_12weeks; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_epcssold_12weeks TO bytedevs;
GRANT ALL ON TABLE public.byte_epcssold_12weeks TO pantry_web_user;


--
-- Name: TABLE v_kiosk_sale_hourly; Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON TABLE inm.v_kiosk_sale_hourly TO bytedevs;


--
-- Name: TABLE route_stop; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.route_stop TO bytedevs;


--
-- Name: TABLE v_kiosk_demand_plan_ratio; Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON TABLE inm.v_kiosk_demand_plan_ratio TO bytedevs;


--
-- Name: TABLE v_kiosk_sku_enabled; Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON TABLE inm.v_kiosk_sku_enabled TO bytedevs;


--
-- Name: TABLE v_kiosk_sku_group_stock_sale_spoil_history; Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON TABLE inm.v_kiosk_sku_group_stock_sale_spoil_history TO bytedevs;


--
-- Name: TABLE byte_tickets_3months; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_tickets_3months TO bytedevs;
GRANT ALL ON TABLE public.byte_tickets_3months TO pantry_web_user;


--
-- Name: TABLE byte_epcssold_3months; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_epcssold_3months TO bytedevs;
GRANT ALL ON TABLE public.byte_epcssold_3months TO pantry_web_user;


--
-- Name: TABLE v_kiosk_sku_group_velocity_demand_week; Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON TABLE inm.v_kiosk_sku_group_velocity_demand_week TO bytedevs;


--
-- Name: TABLE v_kiosk_sku_velocity; Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON TABLE inm.v_kiosk_sku_velocity TO bytedevs;


--
-- Name: TABLE v_kiosk_sku_group_sku_stats; Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON TABLE inm.v_kiosk_sku_group_sku_stats TO bytedevs;


--
-- Name: TABLE v_warehouse_ordering_rec; Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON TABLE inm.v_warehouse_ordering_rec TO bytedevs;


--
-- Name: TABLE view_sku_sku_group; Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON TABLE inm.view_sku_sku_group TO bytedevs;


--
-- Name: TABLE inm_sku_velocity; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.inm_sku_velocity TO bytedevs;


--
-- Name: TABLE inm_warehouse_sku_enabled; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.inm_warehouse_sku_enabled TO bytedevs;


--
-- Name: TABLE warehouse_ordering; Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON TABLE inm.warehouse_ordering TO bytedevs;


--
-- Name: TABLE allocable_inventory; Type: ACL; Schema: inm_beta; Owner: dbservice
--

GRANT ALL ON TABLE inm_beta.allocable_inventory TO jung;


--
-- Name: TABLE kiosk_control; Type: ACL; Schema: inm_beta; Owner: dbservice
--

GRANT ALL ON TABLE inm_beta.kiosk_control TO jung;


--
-- Name: TABLE kiosk_product_disabled; Type: ACL; Schema: inm_beta; Owner: dbservice
--

GRANT ALL ON TABLE inm_beta.kiosk_product_disabled TO jung;


--
-- Name: TABLE kiosk_restriction_by_product; Type: ACL; Schema: inm_beta; Owner: dbservice
--

GRANT ALL ON TABLE inm_beta.kiosk_restriction_by_product TO jung;


--
-- Name: TABLE kiosk_restriction_by_property; Type: ACL; Schema: inm_beta; Owner: dbservice
--

GRANT ALL ON TABLE inm_beta.kiosk_restriction_by_property TO jung;


--
-- Name: TABLE kiosk_sku_group_manual_scale; Type: ACL; Schema: inm_beta; Owner: dbservice
--

GRANT ALL ON TABLE inm_beta.kiosk_sku_group_manual_scale TO jung;


--
-- Name: TABLE pick_allocation; Type: ACL; Schema: inm_beta; Owner: dbservice
--

GRANT ALL ON TABLE inm_beta.pick_allocation TO jung;


--
-- Name: TABLE pick_demand; Type: ACL; Schema: inm_beta; Owner: dbservice
--

GRANT ALL ON TABLE inm_beta.pick_demand TO jung;


--
-- Name: TABLE pick_inventory; Type: ACL; Schema: inm_beta; Owner: dbservice
--

GRANT ALL ON TABLE inm_beta.pick_inventory TO jung;


--
-- Name: TABLE pick_list; Type: ACL; Schema: inm_beta; Owner: dbservice
--

GRANT ALL ON TABLE inm_beta.pick_list TO jung;


--
-- Name: TABLE pick_preference_kiosk_sku; Type: ACL; Schema: inm_beta; Owner: dbservice
--

GRANT ALL ON TABLE inm_beta.pick_preference_kiosk_sku TO jung;


--
-- Name: TABLE pick_priority_kiosk; Type: ACL; Schema: inm_beta; Owner: dbservice
--

GRANT ALL ON TABLE inm_beta.pick_priority_kiosk TO jung;


--
-- Name: TABLE pick_priority_sku; Type: ACL; Schema: inm_beta; Owner: dbservice
--

GRANT ALL ON TABLE inm_beta.pick_priority_sku TO jung;


--
-- Name: TABLE pick_rejection; Type: ACL; Schema: inm_beta; Owner: dbservice
--

GRANT ALL ON TABLE inm_beta.pick_rejection TO jung;


--
-- Name: TABLE pick_route; Type: ACL; Schema: inm_beta; Owner: dbservice
--

GRANT ALL ON TABLE inm_beta.pick_route TO jung;


--
-- Name: TABLE pick_substitution; Type: ACL; Schema: inm_beta; Owner: dbservice
--

GRANT ALL ON TABLE inm_beta.pick_substitution TO jung;


--
-- Name: TABLE product_property; Type: ACL; Schema: inm_beta; Owner: dbservice
--

GRANT ALL ON TABLE inm_beta.product_property TO jung;


--
-- Name: TABLE sku_group; Type: ACL; Schema: inm_beta; Owner: dbservice
--

GRANT ALL ON TABLE inm_beta.sku_group TO jung;


--
-- Name: TABLE sku_group_control; Type: ACL; Schema: inm_beta; Owner: dbservice
--

GRANT ALL ON TABLE inm_beta.sku_group_control TO jung;


--
-- Name: TABLE warehouse_inventory; Type: ACL; Schema: inm_beta; Owner: dbservice
--

GRANT ALL ON TABLE inm_beta.warehouse_inventory TO jung;


--
-- Name: TABLE facing_category; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.facing_category TO pantry_web_user;
GRANT ALL ON TABLE pantry.facing_category TO bytedevs;


--
-- Name: TABLE card_fact; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.card_fact TO bytedevs;


--
-- Name: SEQUENCE card_fact_id_seq; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON SEQUENCE mixalot.card_fact_id_seq TO bytedevs;


--
-- Name: TABLE card_product_fact; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.card_product_fact TO bytedevs;


--
-- Name: SEQUENCE card_product_fact_id_seq; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON SEQUENCE mixalot.card_product_fact_id_seq TO bytedevs;


--
-- Name: TABLE discount_rule; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.discount_rule TO bytedevs;


--
-- Name: TABLE gsheet_cache; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.gsheet_cache TO bytedevs;


--
-- Name: TABLE gsheets_kiosk_restriction; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.gsheets_kiosk_restriction TO bytedevs;


--
-- Name: TABLE history_order_pipeline; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.history_order_pipeline TO bytedevs;


--
-- Name: SEQUENCE history_order_id_seq; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON SEQUENCE mixalot.history_order_id_seq TO bytedevs;


--
-- Name: TABLE inm_byte_kiosk; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.inm_byte_kiosk TO bytedevs;


--
-- Name: TABLE inm_data; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.inm_data TO bytedevs;


--
-- Name: SEQUENCE inm_data_id_seq; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON SEQUENCE mixalot.inm_data_id_seq TO bytedevs;


--
-- Name: TABLE merchandising_slot_sku_group; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.merchandising_slot_sku_group TO bytedevs;


--
-- Name: TABLE sku_group_def; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.sku_group_def TO bytedevs;


--
-- Name: TABLE sku_group_sku; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.sku_group_sku TO bytedevs;


--
-- Name: TABLE inm_dc_inventory; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.inm_dc_inventory TO bytedevs;


--
-- Name: TABLE inm_demand; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.inm_demand TO bytedevs;


--
-- Name: TABLE inm_gsheets_kiosk_restriction; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.inm_gsheets_kiosk_restriction TO bytedevs;


--
-- Name: TABLE inm_kiosk_restriction_list; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.inm_kiosk_restriction_list TO bytedevs;


--
-- Name: TABLE kiosk_restriction_by_property; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.kiosk_restriction_by_property TO bytedevs;


--
-- Name: TABLE kiosk_restriction_by_sku; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.kiosk_restriction_by_sku TO bytedevs;


--
-- Name: TABLE sku_def; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.sku_def TO bytedevs;


--
-- Name: TABLE sku_property; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.sku_property TO bytedevs;


--
-- Name: TABLE sku_property_def; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.sku_property_def TO bytedevs;


--
-- Name: TABLE inm_kiosk_sku_disabled; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.inm_kiosk_sku_disabled TO bytedevs;


--
-- Name: TABLE inm_sku_enabled; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.inm_sku_enabled TO bytedevs;


--
-- Name: TABLE inm_sku_group_title_to_merchandising_slot; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.inm_sku_group_title_to_merchandising_slot TO bytedevs;


--
-- Name: TABLE kiosk; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.kiosk TO bytedevs;


--
-- Name: TABLE kiosk_contents; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.kiosk_contents TO bytedevs;


--
-- Name: SEQUENCE kiosk_contents_id_seq; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON SEQUENCE mixalot.kiosk_contents_id_seq TO bytedevs;


--
-- Name: TABLE kiosk_fact; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.kiosk_fact TO bytedevs;


--
-- Name: SEQUENCE kiosk_fact_id_seq; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON SEQUENCE mixalot.kiosk_fact_id_seq TO bytedevs;


--
-- Name: TABLE kiosk_restriction; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.kiosk_restriction TO bytedevs;


--
-- Name: TABLE request_log; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT SELECT ON TABLE mixalot.request_log TO requestlogs;
GRANT ALL ON TABLE mixalot.request_log TO bytedevs;


--
-- Name: TABLE kiosk_status; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.kiosk_status TO bytedevs;


--
-- Name: TABLE last_kiosk_status; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.last_kiosk_status TO bytedevs;


--
-- Name: TABLE tmp_unit; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.tmp_unit TO bytedevs;


--
-- Name: SEQUENCE lineitem_id_seq; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON SEQUENCE mixalot.lineitem_id_seq TO bytedevs;


--
-- Name: TABLE log; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.log TO bytedevs;


--
-- Name: SEQUENCE log_id_seq; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON SEQUENCE mixalot.log_id_seq TO bytedevs;


--
-- Name: TABLE merchandising_slot; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.merchandising_slot TO bytedevs;


--
-- Name: TABLE merchandising_slot_def; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.merchandising_slot_def TO bytedevs;


--
-- Name: SEQUENCE merchandising_slot_def_id_seq; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON SEQUENCE mixalot.merchandising_slot_def_id_seq TO bytedevs;


--
-- Name: SEQUENCE merchandising_slot_id_seq; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON SEQUENCE mixalot.merchandising_slot_id_seq TO bytedevs;


--
-- Name: TABLE order_fact; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.order_fact TO bytedevs;


--
-- Name: SEQUENCE order_fact_id_seq; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON SEQUENCE mixalot.order_fact_id_seq TO bytedevs;


--
-- Name: TABLE pgdu_bytes; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.pgdu_bytes TO bytedevs;


--
-- Name: TABLE pgdu; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.pgdu TO bytedevs;


--
-- Name: TABLE pick; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.pick TO bytedevs;


--
-- Name: TABLE pick_preference_kiosk_sku; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.pick_preference_kiosk_sku TO bytedevs;


--
-- Name: TABLE pick_priority_kiosk; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.pick_priority_kiosk TO bytedevs;


--
-- Name: TABLE pick_priority_sku; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.pick_priority_sku TO bytedevs;


--
-- Name: TABLE product_fact; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.product_fact TO bytedevs;


--
-- Name: SEQUENCE product_fact_id_seq; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON SEQUENCE mixalot.product_fact_id_seq TO bytedevs;


--
-- Name: TABLE product_kiosk_fact; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.product_kiosk_fact TO bytedevs;


--
-- Name: SEQUENCE product_kiosk_fact_id_seq; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON SEQUENCE mixalot.product_kiosk_fact_id_seq TO bytedevs;


--
-- Name: TABLE route; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.route TO bytedevs;


--
-- Name: TABLE server; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.server TO bytedevs;


--
-- Name: SEQUENCE server_id_seq; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON SEQUENCE mixalot.server_id_seq TO bytedevs;


--
-- Name: SEQUENCE sku_attribute_def_id_seq; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON SEQUENCE mixalot.sku_attribute_def_id_seq TO bytedevs;


--
-- Name: TABLE sku_group; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.sku_group TO bytedevs;


--
-- Name: SEQUENCE sku_group_def_id_seq; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON SEQUENCE mixalot.sku_group_def_id_seq TO bytedevs;


--
-- Name: SEQUENCE sku_group_id_seq; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON SEQUENCE mixalot.sku_group_id_seq TO bytedevs;


--
-- Name: TABLE sku_group_member; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.sku_group_member TO bytedevs;


--
-- Name: SEQUENCE sku_group_member_id_seq; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON SEQUENCE mixalot.sku_group_member_id_seq TO bytedevs;


--
-- Name: TABLE tally; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.tally TO bytedevs;


--
-- Name: TABLE temp_kiosk_restriction; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.temp_kiosk_restriction TO bytedevs;


--
-- Name: TABLE temp_ms_to_sg; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.temp_ms_to_sg TO bytedevs;


--
-- Name: TABLE temp_sku_group_volume; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.temp_sku_group_volume TO bytedevs;


--
-- Name: TABLE temp_sku_to_skugroup; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.temp_sku_to_skugroup TO bytedevs;


--
-- Name: TABLE temp_test; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.temp_test TO bytedevs;


--
-- Name: SEQUENCE temp_test_id_seq; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON SEQUENCE mixalot.temp_test_id_seq TO bytedevs;


--
-- Name: TABLE test_time; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.test_time TO bytedevs;


--
-- Name: SEQUENCE test_time_id_seq; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON SEQUENCE mixalot.test_time_id_seq TO bytedevs;


--
-- Name: TABLE tmp_discount_applied; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.tmp_discount_applied TO bytedevs;


--
-- Name: SEQUENCE tmp_discount_applied_id_seq; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON SEQUENCE mixalot.tmp_discount_applied_id_seq TO bytedevs;


--
-- Name: TABLE tmp_kiosk_status; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.tmp_kiosk_status TO bytedevs;


--
-- Name: SEQUENCE tmp_kiosk_status_id_seq; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON SEQUENCE mixalot.tmp_kiosk_status_id_seq TO bytedevs;


--
-- Name: TABLE tmp_transact; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.tmp_transact TO bytedevs;


--
-- Name: TABLE v_kiosk_request_log; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.v_kiosk_request_log TO bytedevs;


--
-- Name: TABLE v_kiosk_inventory_log; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.v_kiosk_inventory_log TO bytedevs;


--
-- Name: TABLE v_kiosk_item_log; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.v_kiosk_item_log TO bytedevs;


--
-- Name: TABLE v_kiosk_status_log; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.v_kiosk_status_log TO bytedevs;


--
-- Name: TABLE v_node_kiosk_request_log; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.v_node_kiosk_request_log TO bytedevs;


--
-- Name: TABLE v_node_kiosk_status_log; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.v_node_kiosk_status_log TO bytedevs;


--
-- Name: TABLE warehouse_order_history; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.warehouse_order_history TO bytedevs;


--
-- Name: TABLE kiosk_status; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.kiosk_status TO pantry_web_user;
GRANT ALL ON TABLE pantry.kiosk_status TO bytedevs;


--
-- Name: TABLE accounting; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.accounting TO pantry_web_user;
GRANT ALL ON TABLE pantry.accounting TO bytedevs;


--
-- Name: SEQUENCE accounting_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.accounting_id_seq TO pantry_web_user;
GRANT ALL ON SEQUENCE pantry.accounting_id_seq TO bytedevs;


--
-- Name: TABLE bad_timestamp; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.bad_timestamp TO pantry_web_user;
GRANT ALL ON TABLE pantry.bad_timestamp TO bytedevs;


--
-- Name: SEQUENCE bad_timestamp_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.bad_timestamp_id_seq TO pantry_web_user;
GRANT ALL ON SEQUENCE pantry.bad_timestamp_id_seq TO bytedevs;


--
-- Name: TABLE campus; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.campus TO pantry_web_user;
GRANT ALL ON TABLE pantry.campus TO bytedevs;


--
-- Name: TABLE campus_assets; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.campus_assets TO pantry_web_user;
GRANT ALL ON TABLE pantry.campus_assets TO bytedevs;


--
-- Name: TABLE campus_attribute; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.campus_attribute TO pantry_web_user;
GRANT ALL ON TABLE pantry.campus_attribute TO bytedevs;


--
-- Name: SEQUENCE campus_attribute_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.campus_attribute_id_seq TO pantry_web_user;


--
-- Name: SEQUENCE campus_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.campus_id_seq TO pantry_web_user;
GRANT ALL ON SEQUENCE pantry.campus_id_seq TO bytedevs;


--
-- Name: TABLE card; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.card TO pantry_web_user;
GRANT ALL ON TABLE pantry.card TO bytedevs;


--
-- Name: SEQUENCE card_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.card_id_seq TO pantry_web_user;
GRANT ALL ON SEQUENCE pantry.card_id_seq TO bytedevs;


--
-- Name: TABLE kiosk_components_history; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.kiosk_components_history TO pantry_web_user;
GRANT ALL ON TABLE pantry.kiosk_components_history TO bytedevs;


--
-- Name: SEQUENCE component_history_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.component_history_id_seq TO pantry_web_user;
GRANT ALL ON SEQUENCE pantry.component_history_id_seq TO bytedevs;


--
-- Name: TABLE contract; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.contract TO pantry_web_user;
GRANT ALL ON TABLE pantry.contract TO bytedevs;


--
-- Name: SEQUENCE contract_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.contract_id_seq TO pantry_web_user;
GRANT ALL ON SEQUENCE pantry.contract_id_seq TO bytedevs;


--
-- Name: TABLE coupon; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.coupon TO pantry_web_user;
GRANT ALL ON TABLE pantry.coupon TO bytedevs;


--
-- Name: SEQUENCE coupon_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.coupon_id_seq TO pantry_web_user;
GRANT ALL ON SEQUENCE pantry.coupon_id_seq TO bytedevs;


--
-- Name: TABLE cron; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.cron TO pantry_web_user;
GRANT ALL ON TABLE pantry.cron TO bytedevs;


--
-- Name: SEQUENCE cron_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.cron_id_seq TO pantry_web_user;
GRANT ALL ON SEQUENCE pantry.cron_id_seq TO bytedevs;


--
-- Name: TABLE currency_symbol; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.currency_symbol TO pantry_web_user;
GRANT ALL ON TABLE pantry.currency_symbol TO bytedevs;


--
-- Name: SEQUENCE currency_symbol_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.currency_symbol_id_seq TO pantry_web_user;


--
-- Name: TABLE current_label_status_365days; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.current_label_status_365days TO pantry_web_user;
GRANT ALL ON TABLE pantry.current_label_status_365days TO bytedevs;


--
-- Name: TABLE dc_inventory; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.dc_inventory TO pantry_web_user;
GRANT ALL ON TABLE pantry.dc_inventory TO bytedevs;


--
-- Name: TABLE delivery_schedule; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.delivery_schedule TO pantry_web_user;
GRANT ALL ON TABLE pantry.delivery_schedule TO bytedevs;


--
-- Name: SEQUENCE delivery_schedule_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.delivery_schedule_id_seq TO pantry_web_user;
GRANT ALL ON SEQUENCE pantry.delivery_schedule_id_seq TO bytedevs;


--
-- Name: TABLE discount; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.discount TO pantry_web_user;
GRANT ALL ON TABLE pantry.discount TO bytedevs;


--
-- Name: TABLE discount_applied; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.discount_applied TO pantry_web_user;
GRANT ALL ON TABLE pantry.discount_applied TO bytedevs;


--
-- Name: SEQUENCE discount_applied_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.discount_applied_id_seq TO pantry_web_user;
GRANT ALL ON SEQUENCE pantry.discount_applied_id_seq TO bytedevs;


--
-- Name: TABLE discount_history; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.discount_history TO pantry_web_user;
GRANT ALL ON TABLE pantry.discount_history TO bytedevs;


--
-- Name: SEQUENCE discount_history_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.discount_history_id_seq TO pantry_web_user;
GRANT ALL ON SEQUENCE pantry.discount_history_id_seq TO bytedevs;


--
-- Name: SEQUENCE discount_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.discount_id_seq TO pantry_web_user;
GRANT ALL ON SEQUENCE pantry.discount_id_seq TO bytedevs;


--
-- Name: TABLE email; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.email TO pantry_web_user;
GRANT ALL ON TABLE pantry.email TO bytedevs;


--
-- Name: SEQUENCE email_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.email_id_seq TO pantry_web_user;
GRANT ALL ON SEQUENCE pantry.email_id_seq TO bytedevs;


--
-- Name: TABLE empty_transaction; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.empty_transaction TO pantry_web_user;
GRANT ALL ON TABLE pantry.empty_transaction TO bytedevs;


--
-- Name: SEQUENCE empty_transaction_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.empty_transaction_id_seq TO pantry_web_user;
GRANT ALL ON SEQUENCE pantry.empty_transaction_id_seq TO bytedevs;


--
-- Name: TABLE event; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.event TO pantry_web_user;
GRANT ALL ON TABLE pantry.event TO bytedevs;


--
-- Name: SEQUENCE event_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.event_id_seq TO pantry_web_user;
GRANT ALL ON SEQUENCE pantry.event_id_seq TO bytedevs;


--
-- Name: SEQUENCE facing_category_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.facing_category_id_seq TO pantry_web_user;
GRANT ALL ON SEQUENCE pantry.facing_category_id_seq TO bytedevs;


--
-- Name: TABLE fee_rates; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.fee_rates TO pantry_web_user;
GRANT ALL ON TABLE pantry.fee_rates TO bytedevs;


--
-- Name: SEQUENCE fee_rates_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.fee_rates_id_seq TO pantry_web_user;
GRANT ALL ON SEQUENCE pantry.fee_rates_id_seq TO bytedevs;


--
-- Name: TABLE feedback; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.feedback TO pantry_web_user;
GRANT ALL ON TABLE pantry.feedback TO bytedevs;


--
-- Name: SEQUENCE feedback_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.feedback_id_seq TO pantry_web_user;
GRANT ALL ON SEQUENCE pantry.feedback_id_seq TO bytedevs;


--
-- Name: TABLE global_attribute_def; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.global_attribute_def TO pantry_web_user;
GRANT ALL ON TABLE pantry.global_attribute_def TO bytedevs;


--
-- Name: SEQUENCE global_attribute_def_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.global_attribute_def_id_seq TO pantry_web_user;


--
-- Name: TABLE "group"; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry."group" TO pantry_web_user;
GRANT ALL ON TABLE pantry."group" TO bytedevs;


--
-- Name: TABLE group_campus; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.group_campus TO pantry_web_user;
GRANT ALL ON TABLE pantry.group_campus TO bytedevs;


--
-- Name: SEQUENCE group_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.group_id_seq TO pantry_web_user;
GRANT ALL ON SEQUENCE pantry.group_id_seq TO bytedevs;


--
-- Name: TABLE history; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.history TO pantry_web_user;
GRANT ALL ON TABLE pantry.history TO bytedevs;


--
-- Name: TABLE history_campus_attribute; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.history_campus_attribute TO pantry_web_user;
GRANT ALL ON TABLE pantry.history_campus_attribute TO bytedevs;


--
-- Name: SEQUENCE history_campus_attribute_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.history_campus_attribute_id_seq TO pantry_web_user;


--
-- Name: TABLE history_epc_order; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.history_epc_order TO pantry_web_user;
GRANT ALL ON TABLE pantry.history_epc_order TO bytedevs;


--
-- Name: SEQUENCE history_epc_order_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.history_epc_order_id_seq TO pantry_web_user;
GRANT ALL ON SEQUENCE pantry.history_epc_order_id_seq TO bytedevs;


--
-- Name: TABLE history_global_attribute_def; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.history_global_attribute_def TO pantry_web_user;
GRANT ALL ON TABLE pantry.history_global_attribute_def TO bytedevs;


--
-- Name: SEQUENCE history_global_attribute_def_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.history_global_attribute_def_id_seq TO pantry_web_user;


--
-- Name: SEQUENCE history_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.history_id_seq TO pantry_web_user;
GRANT ALL ON SEQUENCE pantry.history_id_seq TO bytedevs;


--
-- Name: TABLE history_kiosk_attribute; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.history_kiosk_attribute TO pantry_web_user;
GRANT ALL ON TABLE pantry.history_kiosk_attribute TO bytedevs;


--
-- Name: SEQUENCE history_kiosk_attribute_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.history_kiosk_attribute_id_seq TO pantry_web_user;


--
-- Name: TABLE history_kiosk_device; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.history_kiosk_device TO pantry_web_user;
GRANT ALL ON TABLE pantry.history_kiosk_device TO bytedevs;


--
-- Name: SEQUENCE history_kiosk_device_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.history_kiosk_device_id_seq TO pantry_web_user;


--
-- Name: TABLE history_kiosk_service_version; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.history_kiosk_service_version TO pantry_web_user;
GRANT ALL ON TABLE pantry.history_kiosk_service_version TO bytedevs;


--
-- Name: SEQUENCE history_kiosk_service_version_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.history_kiosk_service_version_id_seq TO pantry_web_user;


--
-- Name: TABLE inventory_history; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.inventory_history TO pantry_web_user;
GRANT ALL ON TABLE pantry.inventory_history TO bytedevs;


--
-- Name: SEQUENCE inventory_history_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.inventory_history_id_seq TO pantry_web_user;
GRANT ALL ON SEQUENCE pantry.inventory_history_id_seq TO bytedevs;


--
-- Name: TABLE inventory_request; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.inventory_request TO pantry_web_user;
GRANT ALL ON TABLE pantry.inventory_request TO bytedevs;


--
-- Name: SEQUENCE inventory_request_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.inventory_request_id_seq TO pantry_web_user;
GRANT ALL ON SEQUENCE pantry.inventory_request_id_seq TO bytedevs;


--
-- Name: TABLE kiosk_attribute; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.kiosk_attribute TO pantry_web_user;
GRANT ALL ON TABLE pantry.kiosk_attribute TO bytedevs;


--
-- Name: SEQUENCE kiosk_attribute_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.kiosk_attribute_id_seq TO pantry_web_user;


--
-- Name: TABLE kiosk_audit_log; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.kiosk_audit_log TO pantry_web_user;
GRANT ALL ON TABLE pantry.kiosk_audit_log TO bytedevs;


--
-- Name: SEQUENCE kiosk_audit_log_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.kiosk_audit_log_id_seq TO pantry_web_user;
GRANT ALL ON SEQUENCE pantry.kiosk_audit_log_id_seq TO bytedevs;


--
-- Name: TABLE kiosk_catalog_downloads; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.kiosk_catalog_downloads TO pantry_web_user;
GRANT ALL ON TABLE pantry.kiosk_catalog_downloads TO bytedevs;


--
-- Name: SEQUENCE kiosk_catalog_downloads_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.kiosk_catalog_downloads_id_seq TO pantry_web_user;
GRANT ALL ON SEQUENCE pantry.kiosk_catalog_downloads_id_seq TO bytedevs;


--
-- Name: SEQUENCE kiosk_cd_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.kiosk_cd_id_seq TO pantry_web_user;
GRANT ALL ON SEQUENCE pantry.kiosk_cd_id_seq TO bytedevs;


--
-- Name: SEQUENCE kiosk_components_history_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.kiosk_components_history_id_seq TO pantry_web_user;
GRANT ALL ON SEQUENCE pantry.kiosk_components_history_id_seq TO bytedevs;


--
-- Name: TABLE kiosk_device; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.kiosk_device TO pantry_web_user;
GRANT ALL ON TABLE pantry.kiosk_device TO bytedevs;


--
-- Name: SEQUENCE kiosk_device_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.kiosk_device_id_seq TO pantry_web_user;


--
-- Name: SEQUENCE kiosk_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.kiosk_id_seq TO pantry_web_user;
GRANT ALL ON SEQUENCE pantry.kiosk_id_seq TO bytedevs;


--
-- Name: TABLE kiosk_par_level; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.kiosk_par_level TO pantry_web_user;
GRANT ALL ON TABLE pantry.kiosk_par_level TO bytedevs;


--
-- Name: TABLE kiosk_service_version; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.kiosk_service_version TO pantry_web_user;
GRANT ALL ON TABLE pantry.kiosk_service_version TO bytedevs;


--
-- Name: SEQUENCE kiosk_status_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.kiosk_status_id_seq TO pantry_web_user;
GRANT ALL ON SEQUENCE pantry.kiosk_status_id_seq TO bytedevs;


--
-- Name: TABLE kiosks_date_non_new; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.kiosks_date_non_new TO pantry_web_user;
GRANT ALL ON TABLE pantry.kiosks_date_non_new TO bytedevs;


--
-- Name: SEQUENCE kiosks_date_non_new_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.kiosks_date_non_new_id_seq TO pantry_web_user;
GRANT ALL ON SEQUENCE pantry.kiosks_date_non_new_id_seq TO bytedevs;


--
-- Name: SEQUENCE label_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.label_id_seq TO pantry_web_user;
GRANT ALL ON SEQUENCE pantry.label_id_seq TO bytedevs;


--
-- Name: TABLE label_order; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.label_order TO pantry_web_user;
GRANT ALL ON TABLE pantry.label_order TO bytedevs;


--
-- Name: SEQUENCE label_order_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.label_order_id_seq TO pantry_web_user;
GRANT ALL ON SEQUENCE pantry.label_order_id_seq TO bytedevs;


--
-- Name: TABLE label_stats; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.label_stats TO pantry_web_user;
GRANT ALL ON TABLE pantry.label_stats TO bytedevs;


--
-- Name: TABLE last_kiosk_status; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.last_kiosk_status TO pantry_web_user;
GRANT ALL ON TABLE pantry.last_kiosk_status TO bytedevs;


--
-- Name: SEQUENCE last_kiosk_status_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.last_kiosk_status_id_seq TO pantry_web_user;
GRANT ALL ON SEQUENCE pantry.last_kiosk_status_id_seq TO bytedevs;


--
-- Name: TABLE manual_adjustment; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.manual_adjustment TO pantry_web_user;
GRANT ALL ON TABLE pantry.manual_adjustment TO bytedevs;


--
-- Name: SEQUENCE manual_adjustment_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.manual_adjustment_id_seq TO pantry_web_user;
GRANT ALL ON SEQUENCE pantry.manual_adjustment_id_seq TO bytedevs;


--
-- Name: TABLE nutrition_filter; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.nutrition_filter TO pantry_web_user;
GRANT ALL ON TABLE pantry.nutrition_filter TO bytedevs;


--
-- Name: SEQUENCE nutrition_filter_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.nutrition_filter_id_seq TO pantry_web_user;
GRANT ALL ON SEQUENCE pantry.nutrition_filter_id_seq TO bytedevs;


--
-- Name: TABLE order_meta; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.order_meta TO pantry_web_user;
GRANT ALL ON TABLE pantry.order_meta TO bytedevs;


--
-- Name: SEQUENCE order_meta_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.order_meta_id_seq TO pantry_web_user;


--
-- Name: TABLE par_history; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.par_history TO pantry_web_user;
GRANT ALL ON TABLE pantry.par_history TO bytedevs;


--
-- Name: SEQUENCE par_history_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.par_history_id_seq TO pantry_web_user;
GRANT ALL ON SEQUENCE pantry.par_history_id_seq TO bytedevs;


--
-- Name: TABLE payment_order; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.payment_order TO pantry_web_user;
GRANT ALL ON TABLE pantry.payment_order TO bytedevs;


--
-- Name: SEQUENCE payment_order_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.payment_order_id_seq TO bytedevs;


--
-- Name: TABLE payment_order_nursing; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.payment_order_nursing TO pantry_web_user;
GRANT ALL ON TABLE pantry.payment_order_nursing TO bytedevs;


--
-- Name: TABLE permission; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.permission TO pantry_web_user;
GRANT ALL ON TABLE pantry.permission TO bytedevs;


--
-- Name: SEQUENCE permission_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.permission_id_seq TO pantry_web_user;
GRANT ALL ON SEQUENCE pantry.permission_id_seq TO bytedevs;


--
-- Name: TABLE permission_mapping; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.permission_mapping TO pantry_web_user;
GRANT ALL ON TABLE pantry.permission_mapping TO bytedevs;


--
-- Name: TABLE pick_list_row; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.pick_list_row TO pantry_web_user;
GRANT ALL ON TABLE pantry.pick_list_row TO bytedevs;


--
-- Name: SEQUENCE pick_list_row_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.pick_list_row_id_seq TO pantry_web_user;
GRANT ALL ON SEQUENCE pantry.pick_list_row_id_seq TO bytedevs;


--
-- Name: SEQUENCE product_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.product_id_seq TO pantry_web_user;
GRANT ALL ON SEQUENCE pantry.product_id_seq TO bytedevs;


--
-- Name: TABLE product_20190507; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.product_20190507 TO bytedevs;


--
-- Name: TABLE product_categories; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.product_categories TO pantry_web_user;
GRANT ALL ON TABLE pantry.product_categories TO bytedevs;


--
-- Name: SEQUENCE product_categories_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.product_categories_id_seq TO pantry_web_user;
GRANT ALL ON SEQUENCE pantry.product_categories_id_seq TO bytedevs;


--
-- Name: TABLE product_history; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.product_history TO pantry_web_user;
GRANT ALL ON TABLE pantry.product_history TO bytedevs;


--
-- Name: SEQUENCE product_history_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.product_history_id_seq TO pantry_web_user;
GRANT ALL ON SEQUENCE pantry.product_history_id_seq TO bytedevs;


--
-- Name: TABLE product_kiosk_price_offset; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.product_kiosk_price_offset TO pantry_web_user;
GRANT ALL ON TABLE pantry.product_kiosk_price_offset TO bytedevs;


--
-- Name: SEQUENCE product_kiosk_price_offset_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.product_kiosk_price_offset_id_seq TO pantry_web_user;
GRANT ALL ON SEQUENCE pantry.product_kiosk_price_offset_id_seq TO bytedevs;


--
-- Name: TABLE product_request; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.product_request TO pantry_web_user;
GRANT ALL ON TABLE pantry.product_request TO bytedevs;


--
-- Name: SEQUENCE product_request_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.product_request_id_seq TO pantry_web_user;
GRANT ALL ON SEQUENCE pantry.product_request_id_seq TO bytedevs;


--
-- Name: TABLE product_stats_by_kiosk; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.product_stats_by_kiosk TO pantry_web_user;
GRANT ALL ON TABLE pantry.product_stats_by_kiosk TO bytedevs;


--
-- Name: TABLE recent_transactions; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.recent_transactions TO pantry_web_user;
GRANT ALL ON TABLE pantry.recent_transactions TO bytedevs;


--
-- Name: TABLE refunds; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.refunds TO pantry_web_user;
GRANT ALL ON TABLE pantry.refunds TO bytedevs;


--
-- Name: TABLE restock_item; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.restock_item TO pantry_web_user;
GRANT ALL ON TABLE pantry.restock_item TO bytedevs;


--
-- Name: SEQUENCE restock_item_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.restock_item_id_seq TO pantry_web_user;
GRANT ALL ON SEQUENCE pantry.restock_item_id_seq TO bytedevs;


--
-- Name: TABLE ro_order; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.ro_order TO pantry_web_user;
GRANT ALL ON TABLE pantry.ro_order TO bytedevs;


--
-- Name: TABLE role; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.role TO pantry_web_user;
GRANT ALL ON TABLE pantry.role TO bytedevs;


--
-- Name: SEQUENCE role_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.role_id_seq TO pantry_web_user;
GRANT ALL ON SEQUENCE pantry.role_id_seq TO bytedevs;


--
-- Name: TABLE role_mapping; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.role_mapping TO pantry_web_user;
GRANT ALL ON TABLE pantry.role_mapping TO bytedevs;


--
-- Name: TABLE running_service; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.running_service TO pantry_web_user;
GRANT ALL ON TABLE pantry.running_service TO bytedevs;


--
-- Name: TABLE spoilage; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.spoilage TO pantry_web_user;
GRANT ALL ON TABLE pantry.spoilage TO bytedevs;


--
-- Name: SEQUENCE spoilage_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.spoilage_id_seq TO pantry_web_user;
GRANT ALL ON SEQUENCE pantry.spoilage_id_seq TO bytedevs;


--
-- Name: TABLE stockout; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.stockout TO pantry_web_user;
GRANT ALL ON TABLE pantry.stockout TO bytedevs;


--
-- Name: SEQUENCE stockout_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.stockout_id_seq TO pantry_web_user;
GRANT ALL ON SEQUENCE pantry.stockout_id_seq TO bytedevs;


--
-- Name: TABLE tag; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.tag TO pantry_web_user;
GRANT ALL ON TABLE pantry.tag TO bytedevs;


--
-- Name: SEQUENCE tag_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.tag_id_seq TO pantry_web_user;
GRANT ALL ON SEQUENCE pantry.tag_id_seq TO bytedevs;


--
-- Name: TABLE temp_kiosk_backup; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.temp_kiosk_backup TO pantry_web_user;
GRANT ALL ON TABLE pantry.temp_kiosk_backup TO bytedevs;


--
-- Name: TABLE temp_product_backup; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.temp_product_backup TO pantry_web_user;
GRANT ALL ON TABLE pantry.temp_product_backup TO bytedevs;


--
-- Name: TABLE temperature_tag_history; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.temperature_tag_history TO pantry_web_user;
GRANT ALL ON TABLE pantry.temperature_tag_history TO bytedevs;


--
-- Name: SEQUENCE temperature_tag_history_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.temperature_tag_history_id_seq TO pantry_web_user;
GRANT ALL ON SEQUENCE pantry.temperature_tag_history_id_seq TO bytedevs;


--
-- Name: TABLE tmp_april23_error_order_fixes; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.tmp_april23_error_order_fixes TO bytedevs;


--
-- Name: TABLE tmp_backup_order_before_05_03_process_will; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.tmp_backup_order_before_05_03_process_will TO bytedevs;


--
-- Name: TABLE tmp_cards_to_update; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.tmp_cards_to_update TO pantry_web_user;
GRANT ALL ON TABLE pantry.tmp_cards_to_update TO bytedevs;


--
-- Name: TABLE tmp_eng_3692; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.tmp_eng_3692 TO pantry_web_user;
GRANT ALL ON TABLE pantry.tmp_eng_3692 TO bytedevs;


--
-- Name: TABLE tmp_eng_495_cards_to_update; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.tmp_eng_495_cards_to_update TO pantry_web_user;
GRANT ALL ON TABLE pantry.tmp_eng_495_cards_to_update TO bytedevs;


--
-- Name: TABLE tmp_march1_rollingback_auths; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.tmp_march1_rollingback_auths TO pantry_web_user;
GRANT ALL ON TABLE pantry.tmp_march1_rollingback_auths TO bytedevs;


--
-- Name: TABLE tmp_may4_error_order_fixes; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.tmp_may4_error_order_fixes TO bytedevs;


--
-- Name: TABLE tmp_may4_pricefinalize_order_fixes; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.tmp_may4_pricefinalize_order_fixes TO bytedevs;


--
-- Name: TABLE tmp_order_eng_1915; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.tmp_order_eng_1915 TO bytedevs;


--
-- Name: TABLE tmp_order_may_6_preapr23; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.tmp_order_may_6_preapr23 TO bytedevs;


--
-- Name: TABLE tmp_order_transaction_id_map; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.tmp_order_transaction_id_map TO bytedevs;


--
-- Name: TABLE tmp_orderstoerror; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.tmp_orderstoerror TO pantry_web_user;
GRANT ALL ON TABLE pantry.tmp_orderstoerror TO bytedevs;


--
-- Name: TABLE tmp_payment_order; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.tmp_payment_order TO bytedevs;


--
-- Name: TABLE tmp_payment_order_with_id; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.tmp_payment_order_with_id TO bytedevs;


--
-- Name: SEQUENCE tmp_payment_order_with_id_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.tmp_payment_order_with_id_id_seq TO bytedevs;


--
-- Name: TABLE tmp_price_finalized_order_ids; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.tmp_price_finalized_order_ids TO bytedevs;


--
-- Name: TABLE tmp_process_order_txt; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.tmp_process_order_txt TO bytedevs;


--
-- Name: TABLE tmp_process_order; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.tmp_process_order TO bytedevs;


--
-- Name: SEQUENCE tmp_process_order_txt_d_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.tmp_process_order_txt_d_seq TO bytedevs;


--
-- Name: TABLE tmp_process_order_vantiv; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.tmp_process_order_vantiv TO bytedevs;


--
-- Name: SEQUENCE tmp_process_order_vantiv_d_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.tmp_process_order_vantiv_d_seq TO bytedevs;


--
-- Name: TABLE tmp_revert_order_status; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.tmp_revert_order_status TO bytedevs;


--
-- Name: TABLE tmp_watcher; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.tmp_watcher TO pantry_web_user;
GRANT ALL ON TABLE pantry.tmp_watcher TO bytedevs;


--
-- Name: TABLE transact_comp; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.transact_comp TO pantry_web_user;
GRANT ALL ON TABLE pantry.transact_comp TO bytedevs;


--
-- Name: SEQUENCE transact_comp_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.transact_comp_id_seq TO pantry_web_user;
GRANT ALL ON SEQUENCE pantry.transact_comp_id_seq TO bytedevs;


--
-- Name: TABLE transact_express; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.transact_express TO pantry_web_user;
GRANT ALL ON TABLE pantry.transact_express TO bytedevs;


--
-- Name: SEQUENCE transact_express_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.transact_express_id_seq TO pantry_web_user;
GRANT ALL ON SEQUENCE pantry.transact_express_id_seq TO bytedevs;


--
-- Name: TABLE transact_fp; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.transact_fp TO pantry_web_user;
GRANT ALL ON TABLE pantry.transact_fp TO bytedevs;


--
-- Name: SEQUENCE transact_fp_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.transact_fp_id_seq TO pantry_web_user;
GRANT ALL ON SEQUENCE pantry.transact_fp_id_seq TO bytedevs;


--
-- Name: TABLE transact_ipc; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.transact_ipc TO pantry_web_user;
GRANT ALL ON TABLE pantry.transact_ipc TO bytedevs;


--
-- Name: SEQUENCE transact_ipc_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.transact_ipc_id_seq TO pantry_web_user;
GRANT ALL ON SEQUENCE pantry.transact_ipc_id_seq TO bytedevs;


--
-- Name: TABLE "user"; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry."user" TO pantry_web_user;
GRANT ALL ON TABLE pantry."user" TO bytedevs;


--
-- Name: SEQUENCE user_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.user_id_seq TO pantry_web_user;
GRANT ALL ON SEQUENCE pantry.user_id_seq TO bytedevs;


--
-- Name: TABLE awsdms_apply_exceptions; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.awsdms_apply_exceptions TO pantry_web_user;


--
-- Name: TABLE awsdms_ddl_audit; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.awsdms_ddl_audit TO pantry_web_user;


--
-- Name: SEQUENCE awsdms_ddl_audit_c_key_seq; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON SEQUENCE public.awsdms_ddl_audit_c_key_seq TO pantry_web_user;


--
-- Name: TABLE awsdms_heartbeat; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.awsdms_heartbeat TO pantry_web_user;


--
-- Name: SEQUENCE awsdms_heartbeat_hb_key_seq; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON SEQUENCE public.awsdms_heartbeat_hb_key_seq TO pantry_web_user;


--
-- Name: TABLE awsdms_history; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.awsdms_history TO pantry_web_user;


--
-- Name: TABLE awsdms_status; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.awsdms_status TO pantry_web_user;


--
-- Name: TABLE awsdms_suspended_tables; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.awsdms_suspended_tables TO pantry_web_user;


--
-- Name: TABLE awsdms_validation_failures_v1; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.awsdms_validation_failures_v1 TO pantry_web_user;


--
-- Name: TABLE byte_tickets_120days; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_tickets_120days TO bytedevs;
GRANT ALL ON TABLE public.byte_tickets_120days TO pantry_web_user;


--
-- Name: TABLE byte_epcssold_120days; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_epcssold_120days TO bytedevs;
GRANT ALL ON TABLE public.byte_epcssold_120days TO pantry_web_user;


--
-- Name: TABLE byte_addicted_users_120days; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_addicted_users_120days TO bytedevs;
GRANT ALL ON TABLE public.byte_addicted_users_120days TO pantry_web_user;


--
-- Name: TABLE iplanner_inventory; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.iplanner_inventory TO pantry_web_user;


--
-- Name: TABLE byte_dc_inventory_history; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_dc_inventory_history TO pantry_web_user;


--
-- Name: TABLE byte_epcssold; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_epcssold TO bytedevs;
GRANT ALL ON TABLE public.byte_epcssold TO pantry_web_user;


--
-- Name: TABLE byte_tickets_10weeks; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_tickets_10weeks TO bytedevs;
GRANT ALL ON TABLE public.byte_tickets_10weeks TO pantry_web_user;


--
-- Name: TABLE byte_epcssold_10weeks; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_epcssold_10weeks TO bytedevs;
GRANT ALL ON TABLE public.byte_epcssold_10weeks TO pantry_web_user;


--
-- Name: TABLE byte_tickets_12months; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_tickets_12months TO bytedevs;
GRANT ALL ON TABLE public.byte_tickets_12months TO pantry_web_user;


--
-- Name: TABLE byte_epcssold_12months; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_epcssold_12months TO bytedevs;
GRANT ALL ON TABLE public.byte_epcssold_12months TO pantry_web_user;


--
-- Name: TABLE byte_tickets_180days; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_tickets_180days TO bytedevs;
GRANT ALL ON TABLE public.byte_tickets_180days TO pantry_web_user;


--
-- Name: TABLE byte_epcssold_180days; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_epcssold_180days TO bytedevs;
GRANT ALL ON TABLE public.byte_epcssold_180days TO pantry_web_user;


--
-- Name: TABLE byte_tickets_1day; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_tickets_1day TO bytedevs;
GRANT ALL ON TABLE public.byte_tickets_1day TO pantry_web_user;


--
-- Name: TABLE byte_epcssold_1day; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_epcssold_1day TO bytedevs;
GRANT ALL ON TABLE public.byte_epcssold_1day TO pantry_web_user;


--
-- Name: TABLE byte_tickets_1month; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_tickets_1month TO bytedevs;
GRANT ALL ON TABLE public.byte_tickets_1month TO pantry_web_user;


--
-- Name: TABLE byte_epcssold_1month; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_epcssold_1month TO bytedevs;
GRANT ALL ON TABLE public.byte_epcssold_1month TO pantry_web_user;


--
-- Name: TABLE byte_tickets_1week; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_tickets_1week TO bytedevs;
GRANT ALL ON TABLE public.byte_tickets_1week TO pantry_web_user;


--
-- Name: TABLE byte_epcssold_1week; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_epcssold_1week TO bytedevs;
GRANT ALL ON TABLE public.byte_epcssold_1week TO pantry_web_user;


--
-- Name: TABLE byte_tickets_1year; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_tickets_1year TO bytedevs;
GRANT ALL ON TABLE public.byte_tickets_1year TO pantry_web_user;


--
-- Name: TABLE byte_epcssold_1year; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_epcssold_1year TO bytedevs;
GRANT ALL ON TABLE public.byte_epcssold_1year TO pantry_web_user;


--
-- Name: TABLE byte_tickets_2015; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_tickets_2015 TO bytedevs;
GRANT ALL ON TABLE public.byte_tickets_2015 TO pantry_web_user;


--
-- Name: TABLE byte_epcssold_2015; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_epcssold_2015 TO bytedevs;
GRANT ALL ON TABLE public.byte_epcssold_2015 TO pantry_web_user;


--
-- Name: TABLE byte_tickets_2016; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_tickets_2016 TO bytedevs;
GRANT ALL ON TABLE public.byte_tickets_2016 TO pantry_web_user;


--
-- Name: TABLE byte_epcssold_2016; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_epcssold_2016 TO bytedevs;
GRANT ALL ON TABLE public.byte_epcssold_2016 TO pantry_web_user;


--
-- Name: TABLE byte_tickets_2017; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_tickets_2017 TO bytedevs;
GRANT ALL ON TABLE public.byte_tickets_2017 TO pantry_web_user;


--
-- Name: TABLE byte_epcssold_2017; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_epcssold_2017 TO bytedevs;
GRANT ALL ON TABLE public.byte_epcssold_2017 TO pantry_web_user;


--
-- Name: TABLE byte_tickets_2days; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_tickets_2days TO bytedevs;
GRANT ALL ON TABLE public.byte_tickets_2days TO pantry_web_user;


--
-- Name: TABLE byte_epcssold_2days; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_epcssold_2days TO bytedevs;
GRANT ALL ON TABLE public.byte_epcssold_2days TO pantry_web_user;


--
-- Name: TABLE byte_tickets_2months; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_tickets_2months TO bytedevs;
GRANT ALL ON TABLE public.byte_tickets_2months TO pantry_web_user;


--
-- Name: TABLE byte_epcssold_2months; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_epcssold_2months TO bytedevs;
GRANT ALL ON TABLE public.byte_epcssold_2months TO pantry_web_user;


--
-- Name: TABLE byte_tickets_2weeks; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_tickets_2weeks TO bytedevs;
GRANT ALL ON TABLE public.byte_tickets_2weeks TO pantry_web_user;


--
-- Name: TABLE byte_epcssold_2weeks; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_epcssold_2weeks TO bytedevs;
GRANT ALL ON TABLE public.byte_epcssold_2weeks TO pantry_web_user;


--
-- Name: TABLE byte_tickets_30days; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_tickets_30days TO bytedevs;
GRANT ALL ON TABLE public.byte_tickets_30days TO pantry_web_user;


--
-- Name: TABLE byte_epcssold_30days; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_epcssold_30days TO bytedevs;
GRANT ALL ON TABLE public.byte_epcssold_30days TO pantry_web_user;


--
-- Name: TABLE byte_tickets_360days; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_tickets_360days TO bytedevs;
GRANT ALL ON TABLE public.byte_tickets_360days TO pantry_web_user;


--
-- Name: TABLE byte_epcssold_360days; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_epcssold_360days TO bytedevs;
GRANT ALL ON TABLE public.byte_epcssold_360days TO pantry_web_user;


--
-- Name: TABLE byte_tickets_365days; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_tickets_365days TO bytedevs;
GRANT ALL ON TABLE public.byte_tickets_365days TO pantry_web_user;


--
-- Name: TABLE byte_epcssold_365days; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_epcssold_365days TO bytedevs;
GRANT ALL ON TABLE public.byte_epcssold_365days TO pantry_web_user;


--
-- Name: TABLE byte_tickets_3days; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_tickets_3days TO bytedevs;
GRANT ALL ON TABLE public.byte_tickets_3days TO pantry_web_user;


--
-- Name: TABLE byte_epcssold_3days; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_epcssold_3days TO bytedevs;
GRANT ALL ON TABLE public.byte_epcssold_3days TO pantry_web_user;


--
-- Name: TABLE byte_tickets_3weeks; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_tickets_3weeks TO bytedevs;
GRANT ALL ON TABLE public.byte_tickets_3weeks TO pantry_web_user;


--
-- Name: TABLE byte_epcssold_3weeks; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_epcssold_3weeks TO bytedevs;
GRANT ALL ON TABLE public.byte_epcssold_3weeks TO pantry_web_user;


--
-- Name: TABLE byte_tickets_45days; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_tickets_45days TO bytedevs;
GRANT ALL ON TABLE public.byte_tickets_45days TO pantry_web_user;


--
-- Name: TABLE byte_epcssold_45days; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_epcssold_45days TO bytedevs;
GRANT ALL ON TABLE public.byte_epcssold_45days TO pantry_web_user;


--
-- Name: TABLE byte_tickets_4days; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_tickets_4days TO bytedevs;
GRANT ALL ON TABLE public.byte_tickets_4days TO pantry_web_user;


--
-- Name: TABLE byte_epcssold_4days; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_epcssold_4days TO bytedevs;
GRANT ALL ON TABLE public.byte_epcssold_4days TO pantry_web_user;


--
-- Name: TABLE byte_tickets_4months; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_tickets_4months TO bytedevs;
GRANT ALL ON TABLE public.byte_tickets_4months TO pantry_web_user;


--
-- Name: TABLE byte_epcssold_4months; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_epcssold_4months TO bytedevs;
GRANT ALL ON TABLE public.byte_epcssold_4months TO pantry_web_user;


--
-- Name: TABLE byte_tickets_4weeks; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_tickets_4weeks TO bytedevs;
GRANT ALL ON TABLE public.byte_tickets_4weeks TO pantry_web_user;


--
-- Name: TABLE byte_epcssold_4weeks; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_epcssold_4weeks TO bytedevs;
GRANT ALL ON TABLE public.byte_epcssold_4weeks TO pantry_web_user;


--
-- Name: TABLE byte_tickets_5days; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_tickets_5days TO bytedevs;
GRANT ALL ON TABLE public.byte_tickets_5days TO pantry_web_user;


--
-- Name: TABLE byte_epcssold_5days; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_epcssold_5days TO bytedevs;
GRANT ALL ON TABLE public.byte_epcssold_5days TO pantry_web_user;


--
-- Name: TABLE byte_tickets_5weeks; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_tickets_5weeks TO bytedevs;
GRANT ALL ON TABLE public.byte_tickets_5weeks TO pantry_web_user;


--
-- Name: TABLE byte_epcssold_5weeks; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_epcssold_5weeks TO bytedevs;
GRANT ALL ON TABLE public.byte_epcssold_5weeks TO pantry_web_user;


--
-- Name: TABLE byte_tickets_60days; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_tickets_60days TO bytedevs;
GRANT ALL ON TABLE public.byte_tickets_60days TO pantry_web_user;


--
-- Name: TABLE byte_epcssold_60days; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_epcssold_60days TO bytedevs;
GRANT ALL ON TABLE public.byte_epcssold_60days TO pantry_web_user;


--
-- Name: TABLE byte_tickets_6days; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_tickets_6days TO bytedevs;
GRANT ALL ON TABLE public.byte_tickets_6days TO pantry_web_user;


--
-- Name: TABLE byte_epcssold_6days; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_epcssold_6days TO bytedevs;
GRANT ALL ON TABLE public.byte_epcssold_6days TO pantry_web_user;


--
-- Name: TABLE byte_tickets_6months; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_tickets_6months TO bytedevs;
GRANT ALL ON TABLE public.byte_tickets_6months TO pantry_web_user;


--
-- Name: TABLE byte_epcssold_6months; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_epcssold_6months TO bytedevs;
GRANT ALL ON TABLE public.byte_epcssold_6months TO pantry_web_user;


--
-- Name: TABLE byte_tickets_6weeks; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_tickets_6weeks TO bytedevs;
GRANT ALL ON TABLE public.byte_tickets_6weeks TO pantry_web_user;


--
-- Name: TABLE byte_epcssold_6weeks; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_epcssold_6weeks TO bytedevs;
GRANT ALL ON TABLE public.byte_epcssold_6weeks TO pantry_web_user;


--
-- Name: TABLE byte_tickets_7days; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_tickets_7days TO bytedevs;
GRANT ALL ON TABLE public.byte_tickets_7days TO pantry_web_user;


--
-- Name: TABLE byte_epcssold_7days; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_epcssold_7days TO bytedevs;
GRANT ALL ON TABLE public.byte_epcssold_7days TO pantry_web_user;


--
-- Name: TABLE byte_tickets_8weeks; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_tickets_8weeks TO bytedevs;
GRANT ALL ON TABLE public.byte_tickets_8weeks TO pantry_web_user;


--
-- Name: TABLE byte_epcssold_8weeks; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_epcssold_8weeks TO bytedevs;
GRANT ALL ON TABLE public.byte_epcssold_8weeks TO pantry_web_user;


--
-- Name: TABLE byte_tickets_90days; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_tickets_90days TO bytedevs;
GRANT ALL ON TABLE public.byte_tickets_90days TO pantry_web_user;


--
-- Name: TABLE byte_epcssold_90days; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_epcssold_90days TO bytedevs;
GRANT ALL ON TABLE public.byte_epcssold_90days TO pantry_web_user;


--
-- Name: TABLE byte_tickets_9months; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_tickets_9months TO bytedevs;
GRANT ALL ON TABLE public.byte_tickets_9months TO pantry_web_user;


--
-- Name: TABLE byte_epcssold_9months; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_epcssold_9months TO bytedevs;
GRANT ALL ON TABLE public.byte_epcssold_9months TO pantry_web_user;


--
-- Name: TABLE byte_epcssold_fast; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_epcssold_fast TO bytedevs;
GRANT ALL ON TABLE public.byte_epcssold_fast TO pantry_web_user;


--
-- Name: TABLE byte_feedback; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_feedback TO bytedevs;
GRANT ALL ON TABLE public.byte_feedback TO pantry_web_user;


--
-- Name: TABLE byte_feedback_monthly; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_feedback_monthly TO bytedevs;
GRANT ALL ON TABLE public.byte_feedback_monthly TO pantry_web_user;


--
-- Name: TABLE byte_feedback_weekly; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_feedback_weekly TO bytedevs;
GRANT ALL ON TABLE public.byte_feedback_weekly TO pantry_web_user;


--
-- Name: TABLE byte_kiosks; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_kiosks TO bytedevs;
GRANT ALL ON TABLE public.byte_kiosks TO pantry_web_user;


--
-- Name: TABLE inventory_current_lots; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.inventory_current_lots TO pantry_web_user;


--
-- Name: TABLE inventory_current; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.inventory_current TO pantry_web_user;


--
-- Name: TABLE byte_inventory_current; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_inventory_current TO bytedevs;
GRANT ALL ON TABLE public.byte_inventory_current TO pantry_web_user;


--
-- Name: TABLE byte_inventory_current_lots; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_inventory_current_lots TO bytedevs;
GRANT ALL ON TABLE public.byte_inventory_current_lots TO pantry_web_user;


--
-- Name: TABLE inventory_history; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.inventory_history TO bytedevs;
GRANT ALL ON TABLE public.inventory_history TO pantry_web_user;


--
-- Name: TABLE byte_inventory_history; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_inventory_history TO bytedevs;
GRANT ALL ON TABLE public.byte_inventory_history TO pantry_web_user;


--
-- Name: TABLE byte_inventory_history_eod; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_inventory_history_eod TO bytedevs;
GRANT ALL ON TABLE public.byte_inventory_history_eod TO pantry_web_user;


--
-- Name: TABLE byte_inventory_history_eod_2wks; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_inventory_history_eod_2wks TO bytedevs;
GRANT ALL ON TABLE public.byte_inventory_history_eod_2wks TO pantry_web_user;


--
-- Name: TABLE byte_kiosks_date_non_new; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_kiosks_date_non_new TO pantry_web_user;


--
-- Name: TABLE byte_restockings; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_restockings TO bytedevs;
GRANT ALL ON TABLE public.byte_restockings TO pantry_web_user;


--
-- Name: TABLE byte_kiosks_by_week; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_kiosks_by_week TO bytedevs;
GRANT ALL ON TABLE public.byte_kiosks_by_week TO pantry_web_user;


--
-- Name: TABLE byte_kiosks_with_perm_subsidy; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_kiosks_with_perm_subsidy TO bytedevs;
GRANT ALL ON TABLE public.byte_kiosks_with_perm_subsidy TO pantry_web_user;


--
-- Name: TABLE byte_kp_grid; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_kp_grid TO pantry_web_user;


--
-- Name: TABLE byte_kp_grid2; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_kp_grid2 TO pantry_web_user;


--
-- Name: TABLE byte_kp_oos; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_kp_oos TO pantry_web_user;


--
-- Name: TABLE byte_kp_oos_avgdowhour; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_kp_oos_avgdowhour TO pantry_web_user;


--
-- Name: TABLE byte_kp_oos_grid; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_kp_oos_grid TO pantry_web_user;


--
-- Name: TABLE byte_kp_sales; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_kp_sales TO pantry_web_user;


--
-- Name: TABLE byte_kp_sales_avgdowhour; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_kp_sales_avgdowhour TO pantry_web_user;


--
-- Name: TABLE byte_kp_sales_first; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_kp_sales_first TO pantry_web_user;


--
-- Name: TABLE byte_kp_sales_grid; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_kp_sales_grid TO pantry_web_user;


--
-- Name: TABLE byte_label_product_fast; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_label_product_fast TO pantry_web_user;


--
-- Name: TABLE byte_product_stats_by_kiosk; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_product_stats_by_kiosk TO bytedevs;
GRANT ALL ON TABLE public.byte_product_stats_by_kiosk TO pantry_web_user;


--
-- Name: TABLE byte_raw_orders; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_raw_orders TO bytedevs;
GRANT ALL ON TABLE public.byte_raw_orders TO pantry_web_user;


--
-- Name: TABLE byte_restockings_labels; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_restockings_labels TO bytedevs;
GRANT ALL ON TABLE public.byte_restockings_labels TO pantry_web_user;


--
-- Name: TABLE byte_sales_by_week; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_sales_by_week TO bytedevs;
GRANT ALL ON TABLE public.byte_sales_by_week TO pantry_web_user;


--
-- Name: TABLE byte_spoilage; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_spoilage TO bytedevs;
GRANT ALL ON TABLE public.byte_spoilage TO pantry_web_user;


--
-- Name: TABLE byte_spoilage_by_category_week_all; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_spoilage_by_category_week_all TO bytedevs;
GRANT ALL ON TABLE public.byte_spoilage_by_category_week_all TO pantry_web_user;


--
-- Name: TABLE byte_spoilage_by_category_week_newold; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_spoilage_by_category_week_newold TO bytedevs;
GRANT ALL ON TABLE public.byte_spoilage_by_category_week_newold TO pantry_web_user;


--
-- Name: TABLE byte_spoilage_by_category_week; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_spoilage_by_category_week TO bytedevs;
GRANT ALL ON TABLE public.byte_spoilage_by_category_week TO pantry_web_user;


--
-- Name: TABLE byte_spoilage_by_category_week_crosstab; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_spoilage_by_category_week_crosstab TO pantry_web_user;


--
-- Name: TABLE byte_spoilage_by_sku_2months; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_spoilage_by_sku_2months TO bytedevs;
GRANT ALL ON TABLE public.byte_spoilage_by_sku_2months TO pantry_web_user;


--
-- Name: TABLE byte_spoilage_by_week; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_spoilage_by_week TO bytedevs;
GRANT ALL ON TABLE public.byte_spoilage_by_week TO pantry_web_user;


--
-- Name: TABLE byte_stockouts; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_stockouts TO bytedevs;
GRANT ALL ON TABLE public.byte_stockouts TO pantry_web_user;


--
-- Name: TABLE byte_stockouts_by_week; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_stockouts_by_week TO bytedevs;
GRANT ALL ON TABLE public.byte_stockouts_by_week TO pantry_web_user;


--
-- Name: TABLE byte_spoilage_stockouts_by_week; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_spoilage_stockouts_by_week TO bytedevs;
GRANT ALL ON TABLE public.byte_spoilage_stockouts_by_week TO pantry_web_user;


--
-- Name: TABLE byte_stockouts_by_category_week_all; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_stockouts_by_category_week_all TO bytedevs;
GRANT ALL ON TABLE public.byte_stockouts_by_category_week_all TO pantry_web_user;


--
-- Name: TABLE byte_stockouts_by_category_week_newold; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_stockouts_by_category_week_newold TO bytedevs;
GRANT ALL ON TABLE public.byte_stockouts_by_category_week_newold TO pantry_web_user;


--
-- Name: TABLE byte_stockouts_by_category_week; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_stockouts_by_category_week TO bytedevs;
GRANT ALL ON TABLE public.byte_stockouts_by_category_week TO pantry_web_user;


--
-- Name: TABLE byte_stockouts_by_category_week_crosstab; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_stockouts_by_category_week_crosstab TO pantry_web_user;


--
-- Name: TABLE byte_tickets_labels; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_tickets_labels TO bytedevs;
GRANT ALL ON TABLE public.byte_tickets_labels TO pantry_web_user;


--
-- Name: TABLE byte_tickets_today; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_tickets_today TO bytedevs;
GRANT ALL ON TABLE public.byte_tickets_today TO pantry_web_user;


--
-- Name: TABLE byte_tickets_yesterday; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_tickets_yesterday TO bytedevs;
GRANT ALL ON TABLE public.byte_tickets_yesterday TO pantry_web_user;


--
-- Name: TABLE byte_users_multiple_fridges; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_users_multiple_fridges TO bytedevs;
GRANT ALL ON TABLE public.byte_users_multiple_fridges TO pantry_web_user;


--
-- Name: TABLE byte_users_products_4months; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_users_products_4months TO bytedevs;
GRANT ALL ON TABLE public.byte_users_products_4months TO pantry_web_user;


--
-- Name: TABLE bytecodelog; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.bytecodelog TO pantry_web_user;


--
-- Name: TABLE campaigns; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.campaigns TO pantry_web_user;


--
-- Name: SEQUENCE campaigns_campaign_id_seq; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON SEQUENCE public.campaigns_campaign_id_seq TO pantry_web_user;


--
-- Name: TABLE cogs_by_category_120d; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.cogs_by_category_120d TO bytedevs;
GRANT ALL ON TABLE public.cogs_by_category_120d TO pantry_web_user;


--
-- Name: TABLE sales_by_category_120d; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.sales_by_category_120d TO bytedevs;
GRANT ALL ON TABLE public.sales_by_category_120d TO pantry_web_user;


--
-- Name: TABLE spoilage_by_category_120d; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.spoilage_by_category_120d TO bytedevs;
GRANT ALL ON TABLE public.spoilage_by_category_120d TO pantry_web_user;


--
-- Name: TABLE category_stats_120d; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.category_stats_120d TO bytedevs;
GRANT ALL ON TABLE public.category_stats_120d TO pantry_web_user;


--
-- Name: TABLE customer_campaigns; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.customer_campaigns TO pantry_web_user;


--
-- Name: TABLE customers; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.customers TO pantry_web_user;


--
-- Name: SEQUENCE customers_customer_id_seq; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON SEQUENCE public.customers_customer_id_seq TO pantry_web_user;


--
-- Name: TABLE dashboard_monthly_stats; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.dashboard_monthly_stats TO bytedevs;
GRANT ALL ON TABLE public.dashboard_monthly_stats TO pantry_web_user;


--
-- Name: TABLE dashboard_weekly_stats; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.dashboard_weekly_stats TO bytedevs;
GRANT ALL ON TABLE public.dashboard_weekly_stats TO pantry_web_user;


--
-- Name: TABLE date_hours_2016; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.date_hours_2016 TO pantry_web_user;


--
-- Name: TABLE lastwk_hrs; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.lastwk_hrs TO pantry_web_user;


--
-- Name: TABLE dowhours; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.dowhours TO pantry_web_user;


--
-- Name: TABLE stockout_avg_kiosk_cat_sales_dowhour; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.stockout_avg_kiosk_cat_sales_dowhour TO bytedevs;
GRANT ALL ON TABLE public.stockout_avg_kiosk_cat_sales_dowhour TO pantry_web_user;


--
-- Name: TABLE stockout_dowhours; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.stockout_dowhours TO bytedevs;
GRANT ALL ON TABLE public.stockout_dowhours TO pantry_web_user;


--
-- Name: TABLE stockout_dowhours_weighted; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.stockout_dowhours_weighted TO bytedevs;
GRANT ALL ON TABLE public.stockout_dowhours_weighted TO pantry_web_user;


--
-- Name: TABLE dbg_stockout_dowhours_weighted; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.dbg_stockout_dowhours_weighted TO bytedevs;
GRANT ALL ON TABLE public.dbg_stockout_dowhours_weighted TO pantry_web_user;


--
-- Name: TABLE dbg_stockout_dowhours_weighted_stats; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.dbg_stockout_dowhours_weighted_stats TO bytedevs;
GRANT ALL ON TABLE public.dbg_stockout_dowhours_weighted_stats TO pantry_web_user;


--
-- Name: TABLE stockout_runs_weighted; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.stockout_runs_weighted TO bytedevs;
GRANT ALL ON TABLE public.stockout_runs_weighted TO pantry_web_user;


--
-- Name: TABLE dbg_stockout_runs_weighted; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.dbg_stockout_runs_weighted TO bytedevs;
GRANT ALL ON TABLE public.dbg_stockout_runs_weighted TO pantry_web_user;


--
-- Name: TABLE stockout_weighted; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.stockout_weighted TO bytedevs;
GRANT ALL ON TABLE public.stockout_weighted TO pantry_web_user;


--
-- Name: TABLE dbg_stockout_weighted; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.dbg_stockout_weighted TO bytedevs;
GRANT ALL ON TABLE public.dbg_stockout_weighted TO pantry_web_user;


--
-- Name: TABLE dbg_stockout_weighted_stats; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.dbg_stockout_weighted_stats TO bytedevs;
GRANT ALL ON TABLE public.dbg_stockout_weighted_stats TO pantry_web_user;


--
-- Name: TABLE dp_epcssold; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.dp_epcssold TO bytedevs;
GRANT ALL ON TABLE public.dp_epcssold TO pantry_web_user;


--
-- Name: TABLE dp_epcssold_2015; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.dp_epcssold_2015 TO bytedevs;
GRANT ALL ON TABLE public.dp_epcssold_2015 TO pantry_web_user;


--
-- Name: TABLE dp_epcssold_2016; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.dp_epcssold_2016 TO bytedevs;
GRANT ALL ON TABLE public.dp_epcssold_2016 TO pantry_web_user;


--
-- Name: TABLE dp_epcssold_2017; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.dp_epcssold_2017 TO bytedevs;
GRANT ALL ON TABLE public.dp_epcssold_2017 TO pantry_web_user;


--
-- Name: TABLE dp_epcssold_4weeks; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.dp_epcssold_4weeks TO bytedevs;
GRANT ALL ON TABLE public.dp_epcssold_4weeks TO pantry_web_user;


--
-- Name: TABLE dp_epcssold_8weeks; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.dp_epcssold_8weeks TO bytedevs;
GRANT ALL ON TABLE public.dp_epcssold_8weeks TO pantry_web_user;


--
-- Name: TABLE dp_inventory_current; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.dp_inventory_current TO bytedevs;
GRANT ALL ON TABLE public.dp_inventory_current TO pantry_web_user;


--
-- Name: TABLE dp_inventory_history; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.dp_inventory_history TO bytedevs;
GRANT ALL ON TABLE public.dp_inventory_history TO pantry_web_user;


--
-- Name: TABLE dp_kiosks; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.dp_kiosks TO bytedevs;
GRANT ALL ON TABLE public.dp_kiosks TO pantry_web_user;


--
-- Name: TABLE dp_products; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.dp_products TO pantry_web_user;


--
-- Name: TABLE dp_spoilage; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.dp_spoilage TO bytedevs;
GRANT ALL ON TABLE public.dp_spoilage TO pantry_web_user;


--
-- Name: TABLE dp_spoilage_2016; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.dp_spoilage_2016 TO bytedevs;
GRANT ALL ON TABLE public.dp_spoilage_2016 TO pantry_web_user;


--
-- Name: TABLE dp_spoilage_2017; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.dp_spoilage_2017 TO bytedevs;
GRANT ALL ON TABLE public.dp_spoilage_2017 TO pantry_web_user;


--
-- Name: TABLE dp_spoilage_4weeks; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.dp_spoilage_4weeks TO bytedevs;
GRANT ALL ON TABLE public.dp_spoilage_4weeks TO pantry_web_user;


--
-- Name: TABLE dp_spoilage_8weeks; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.dp_spoilage_8weeks TO bytedevs;
GRANT ALL ON TABLE public.dp_spoilage_8weeks TO pantry_web_user;


--
-- Name: TABLE dp_spoilage_daily_sold_join; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.dp_spoilage_daily_sold_join TO bytedevs;
GRANT ALL ON TABLE public.dp_spoilage_daily_sold_join TO pantry_web_user;


--
-- Name: TABLE dp_spoilage_daily_kiosk_product_pct; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.dp_spoilage_daily_kiosk_product_pct TO bytedevs;
GRANT ALL ON TABLE public.dp_spoilage_daily_kiosk_product_pct TO pantry_web_user;


--
-- Name: TABLE dp_spoilage_daily_kiosk_pct; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.dp_spoilage_daily_kiosk_pct TO bytedevs;
GRANT ALL ON TABLE public.dp_spoilage_daily_kiosk_pct TO pantry_web_user;


--
-- Name: TABLE dp_spoilage_daily_pct; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.dp_spoilage_daily_pct TO bytedevs;
GRANT ALL ON TABLE public.dp_spoilage_daily_pct TO pantry_web_user;


--
-- Name: TABLE dp_spoilage_daily_product_pct; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.dp_spoilage_daily_product_pct TO bytedevs;
GRANT ALL ON TABLE public.dp_spoilage_daily_product_pct TO pantry_web_user;


--
-- Name: TABLE dp_spoilage_monthly_sold_join; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.dp_spoilage_monthly_sold_join TO bytedevs;
GRANT ALL ON TABLE public.dp_spoilage_monthly_sold_join TO pantry_web_user;


--
-- Name: TABLE dp_spoilage_monthly_calc; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.dp_spoilage_monthly_calc TO bytedevs;
GRANT ALL ON TABLE public.dp_spoilage_monthly_calc TO pantry_web_user;


--
-- Name: TABLE dp_spoilage_monthly_kiosk_product_pct; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.dp_spoilage_monthly_kiosk_product_pct TO bytedevs;
GRANT ALL ON TABLE public.dp_spoilage_monthly_kiosk_product_pct TO pantry_web_user;


--
-- Name: TABLE dp_spoilage_monthly_kiosk_pct; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.dp_spoilage_monthly_kiosk_pct TO bytedevs;
GRANT ALL ON TABLE public.dp_spoilage_monthly_kiosk_pct TO pantry_web_user;


--
-- Name: TABLE dp_spoilage_monthly_pct; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.dp_spoilage_monthly_pct TO bytedevs;
GRANT ALL ON TABLE public.dp_spoilage_monthly_pct TO pantry_web_user;


--
-- Name: TABLE dp_spoilage_monthly_product_pct; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.dp_spoilage_monthly_product_pct TO bytedevs;
GRANT ALL ON TABLE public.dp_spoilage_monthly_product_pct TO pantry_web_user;


--
-- Name: TABLE dp_spoilage_weekly_sold_join; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.dp_spoilage_weekly_sold_join TO bytedevs;
GRANT ALL ON TABLE public.dp_spoilage_weekly_sold_join TO pantry_web_user;


--
-- Name: TABLE dp_spoilage_weekly_kiosk_product_pct; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.dp_spoilage_weekly_kiosk_product_pct TO bytedevs;
GRANT ALL ON TABLE public.dp_spoilage_weekly_kiosk_product_pct TO pantry_web_user;


--
-- Name: TABLE dp_spoilage_weekly_kiosk_pct; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.dp_spoilage_weekly_kiosk_pct TO bytedevs;
GRANT ALL ON TABLE public.dp_spoilage_weekly_kiosk_pct TO pantry_web_user;


--
-- Name: TABLE dp_spoilage_weekly_pct; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.dp_spoilage_weekly_pct TO bytedevs;
GRANT ALL ON TABLE public.dp_spoilage_weekly_pct TO pantry_web_user;


--
-- Name: TABLE dp_spoilage_weekly_product_pct; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.dp_spoilage_weekly_product_pct TO bytedevs;
GRANT ALL ON TABLE public.dp_spoilage_weekly_product_pct TO pantry_web_user;


--
-- Name: TABLE dp_stockouts; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.dp_stockouts TO bytedevs;
GRANT ALL ON TABLE public.dp_stockouts TO pantry_web_user;


--
-- Name: TABLE dp_stockouts_2016; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.dp_stockouts_2016 TO bytedevs;
GRANT ALL ON TABLE public.dp_stockouts_2016 TO pantry_web_user;


--
-- Name: TABLE dp_stockouts_2017; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.dp_stockouts_2017 TO bytedevs;
GRANT ALL ON TABLE public.dp_stockouts_2017 TO pantry_web_user;


--
-- Name: TABLE dp_stockouts_4weeks; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.dp_stockouts_4weeks TO bytedevs;
GRANT ALL ON TABLE public.dp_stockouts_4weeks TO pantry_web_user;


--
-- Name: TABLE dp_stockouts_8weeks; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.dp_stockouts_8weeks TO bytedevs;
GRANT ALL ON TABLE public.dp_stockouts_8weeks TO pantry_web_user;


--
-- Name: TABLE dp_stockouts_weekly_sold_join; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.dp_stockouts_weekly_sold_join TO bytedevs;
GRANT ALL ON TABLE public.dp_stockouts_weekly_sold_join TO pantry_web_user;


--
-- Name: TABLE dp_stockouts_weekly_calc; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.dp_stockouts_weekly_calc TO bytedevs;
GRANT ALL ON TABLE public.dp_stockouts_weekly_calc TO pantry_web_user;


--
-- Name: TABLE dp_stockouts_weekly_kiosk_product_pct; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.dp_stockouts_weekly_kiosk_product_pct TO bytedevs;
GRANT ALL ON TABLE public.dp_stockouts_weekly_kiosk_product_pct TO pantry_web_user;


--
-- Name: TABLE dp_stockouts_weekly_kiosk_pct; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.dp_stockouts_weekly_kiosk_pct TO bytedevs;
GRANT ALL ON TABLE public.dp_stockouts_weekly_kiosk_pct TO pantry_web_user;


--
-- Name: TABLE dp_stockouts_weekly_pct; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.dp_stockouts_weekly_pct TO bytedevs;
GRANT ALL ON TABLE public.dp_stockouts_weekly_pct TO pantry_web_user;


--
-- Name: TABLE dp_stockouts_weekly_product_pct; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.dp_stockouts_weekly_product_pct TO bytedevs;
GRANT ALL ON TABLE public.dp_stockouts_weekly_product_pct TO pantry_web_user;


--
-- Name: TABLE inm_kiosk_weekly_sale; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.inm_kiosk_weekly_sale TO pantry_web_user;


--
-- Name: TABLE int_kiosk_weekly_sale; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.int_kiosk_weekly_sale TO pantry_web_user;


--
-- Name: TABLE kiosk; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.kiosk TO pantry_web_user;


--
-- Name: TABLE kiosk_first_seen; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.kiosk_first_seen TO pantry_web_user;


--
-- Name: SEQUENCE kiosk_id_seq; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON SEQUENCE public.kiosk_id_seq TO pantry_web_user;


--
-- Name: TABLE kiosk_sales_by_dayofweek; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.kiosk_sales_by_dayofweek TO bytedevs;
GRANT ALL ON TABLE public.kiosk_sales_by_dayofweek TO pantry_web_user;


--
-- Name: TABLE kiosk_status; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.kiosk_status TO bytedevs;
GRANT ALL ON TABLE public.kiosk_status TO pantry_web_user;


--
-- Name: TABLE latest_label_records; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.latest_label_records TO pantry_web_user;


--
-- Name: TABLE mkt_camp_20170111_sku_revival_sonoma; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.mkt_camp_20170111_sku_revival_sonoma TO pantry_web_user;


--
-- Name: TABLE mkt_camp_20170123_whats_new_in_kiosk; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.mkt_camp_20170123_whats_new_in_kiosk TO pantry_web_user;


--
-- Name: TABLE "pantry.kiosk"; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public."pantry.kiosk" TO pantry_web_user;


--
-- Name: SEQUENCE "pantry.kiosk_id_seq"; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON SEQUENCE public."pantry.kiosk_id_seq" TO pantry_web_user;


--
-- Name: TABLE sales_by_shelflife_120d; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.sales_by_shelflife_120d TO bytedevs;
GRANT ALL ON TABLE public.sales_by_shelflife_120d TO pantry_web_user;


--
-- Name: TABLE sales_by_shelflife_30d; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.sales_by_shelflife_30d TO bytedevs;
GRANT ALL ON TABLE public.sales_by_shelflife_30d TO pantry_web_user;


--
-- Name: TABLE sales_by_shelflife_45d; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.sales_by_shelflife_45d TO bytedevs;
GRANT ALL ON TABLE public.sales_by_shelflife_45d TO pantry_web_user;


--
-- Name: TABLE spoilage_by_shelflife_120d; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.spoilage_by_shelflife_120d TO bytedevs;
GRANT ALL ON TABLE public.spoilage_by_shelflife_120d TO pantry_web_user;


--
-- Name: TABLE spoilage_by_shelflife_30d; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.spoilage_by_shelflife_30d TO bytedevs;
GRANT ALL ON TABLE public.spoilage_by_shelflife_30d TO pantry_web_user;


--
-- Name: TABLE spoilage_by_shelflife_45d; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.spoilage_by_shelflife_45d TO bytedevs;
GRANT ALL ON TABLE public.spoilage_by_shelflife_45d TO pantry_web_user;


--
-- Name: TABLE spoilagepct_by_shelflife_120d; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.spoilagepct_by_shelflife_120d TO bytedevs;
GRANT ALL ON TABLE public.spoilagepct_by_shelflife_120d TO pantry_web_user;


--
-- Name: TABLE spoilagepct_by_shelflife_30d; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.spoilagepct_by_shelflife_30d TO bytedevs;
GRANT ALL ON TABLE public.spoilagepct_by_shelflife_30d TO pantry_web_user;


--
-- Name: TABLE spoilagepct_by_shelflife_45d; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.spoilagepct_by_shelflife_45d TO bytedevs;
GRANT ALL ON TABLE public.spoilagepct_by_shelflife_45d TO pantry_web_user;


--
-- Name: TABLE sys_activity; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.sys_activity TO pantry_web_user;


--
-- Name: TABLE sys_conninfo; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.sys_conninfo TO pantry_web_user;


--
-- Name: TABLE sys_slow_queries; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.sys_slow_queries TO pantry_web_user;


--
-- Name: TABLE sys_table_sizes; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.sys_table_sizes TO pantry_web_user;


--
-- Name: TABLE sys_uptime; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.sys_uptime TO pantry_web_user;


--
-- Name: TABLE tmp_dormant; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.tmp_dormant TO pantry_web_user;


--
-- Name: TABLE tmp_dormant2; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.tmp_dormant2 TO pantry_web_user;


--
-- Name: TABLE tmp_reboots_log; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.tmp_reboots_log TO pantry_web_user;


--
-- Name: TABLE track_dashboard; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.track_dashboard TO pantry_web_user;


--
-- Name: SEQUENCE track_dashboard_id_seq; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON SEQUENCE public.track_dashboard_id_seq TO pantry_web_user;


--
-- Name: TABLE track_inventory; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.track_inventory TO pantry_web_user;


--
-- Name: SEQUENCE track_inventory_id_seq; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON SEQUENCE public.track_inventory_id_seq TO pantry_web_user;


--
-- Name: TABLE user_retention_10weeks; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.user_retention_10weeks TO pantry_web_user;


--
-- Name: TABLE user_retention_12months; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.user_retention_12months TO pantry_web_user;


--
-- Name: TABLE user_retention_12weeks; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.user_retention_12weeks TO pantry_web_user;


--
-- Name: TABLE user_retention_1month; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.user_retention_1month TO pantry_web_user;


--
-- Name: TABLE user_retention_1week; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.user_retention_1week TO pantry_web_user;


--
-- Name: TABLE user_retention_26weeks; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.user_retention_26weeks TO pantry_web_user;


--
-- Name: TABLE user_retention_2months; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.user_retention_2months TO pantry_web_user;


--
-- Name: TABLE user_retention_2weeks; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.user_retention_2weeks TO pantry_web_user;


--
-- Name: TABLE user_retention_3months; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.user_retention_3months TO pantry_web_user;


--
-- Name: TABLE user_retention_3weeks; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.user_retention_3weeks TO pantry_web_user;


--
-- Name: TABLE user_retention_4months; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.user_retention_4months TO pantry_web_user;


--
-- Name: TABLE user_retention_4weeks; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.user_retention_4weeks TO pantry_web_user;


--
-- Name: TABLE user_retention_52weeks; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.user_retention_52weeks TO pantry_web_user;


--
-- Name: TABLE user_retention_6months; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.user_retention_6months TO pantry_web_user;


--
-- Name: TABLE user_retention_6weeks; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.user_retention_6weeks TO pantry_web_user;


--
-- Name: TABLE user_retention_8weeks; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.user_retention_8weeks TO pantry_web_user;


--
-- Name: TABLE user_retention_9months; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.user_retention_9months TO pantry_web_user;


--
-- Name: TABLE user_retention_tickets; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.user_retention_tickets TO bytedevs;
GRANT ALL ON TABLE public.user_retention_tickets TO pantry_web_user;


--
-- Name: TABLE valid_bytecodes; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.valid_bytecodes TO pantry_web_user;


--
-- Name: TABLE dependency; Type: ACL; Schema: report; Owner: dbservice
--

GRANT ALL ON TABLE report.dependency TO bytedevs;


--
-- Name: TABLE current_inventory; Type: ACL; Schema: rptg; Owner: dbservice
--

GRANT ALL ON TABLE rptg.current_inventory TO bytedevs;


--
-- Name: TABLE temp_yann_boardq3; Type: ACL; Schema: rptg; Owner: dbservice
--

GRANT ALL ON TABLE rptg.temp_yann_boardq3 TO bytedevs;


--
-- Name: TABLE temp_yann_q1; Type: ACL; Schema: rptg; Owner: dbservice
--

GRANT ALL ON TABLE rptg.temp_yann_q1 TO bytedevs;


--
-- Name: TABLE accounting_bkup_20200204_partial; Type: ACL; Schema: test; Owner: dbservice
--

GRANT ALL ON TABLE test.accounting_bkup_20200204_partial TO bytedevs;


--
-- Name: TABLE accounting_partial_backup_20191101; Type: ACL; Schema: test; Owner: dbservice
--

GRANT ALL ON TABLE test.accounting_partial_backup_20191101 TO bytedevs;


--
-- Name: TABLE accounting_partial_bkup_20200131; Type: ACL; Schema: test; Owner: dbservice
--

GRANT ALL ON TABLE test.accounting_partial_bkup_20200131 TO bytedevs;


--
-- Name: TABLE backup_eng_2669_order; Type: ACL; Schema: test; Owner: dbservice
--

GRANT ALL ON TABLE test.backup_eng_2669_order TO bytedevs;


--
-- Name: TABLE campus_20190605; Type: ACL; Schema: test; Owner: dbservice
--

GRANT ALL ON TABLE test.campus_20190605 TO bytedevs;


--
-- Name: TABLE campus_20190620; Type: ACL; Schema: test; Owner: dbservice
--

GRANT ALL ON TABLE test.campus_20190620 TO bytedevs;


--
-- Name: TABLE cron_broken; Type: ACL; Schema: test; Owner: dbservice
--

GRANT ALL ON TABLE test.cron_broken TO bytedevs;


--
-- Name: TABLE discount_20190614; Type: ACL; Schema: test; Owner: dbservice
--

GRANT ALL ON TABLE test.discount_20190614 TO bytedevs;


--
-- Name: TABLE eng2903; Type: ACL; Schema: test; Owner: dbservice
--

GRANT ALL ON TABLE test.eng2903 TO bytedevs;


--
-- Name: TABLE fee_rate_bkup_20200131; Type: ACL; Schema: test; Owner: dbservice
--

GRANT ALL ON TABLE test.fee_rate_bkup_20200131 TO bytedevs;


--
-- Name: TABLE kiosk; Type: ACL; Schema: test; Owner: dbservice
--

GRANT ALL ON TABLE test.kiosk TO bytedevs;


--
-- Name: TABLE kiosk_20190605; Type: ACL; Schema: test; Owner: dbservice
--

GRANT ALL ON TABLE test.kiosk_20190605 TO bytedevs;


--
-- Name: TABLE kiosk_20190606; Type: ACL; Schema: test; Owner: dbservice
--

GRANT ALL ON TABLE test.kiosk_20190606 TO bytedevs;


--
-- Name: TABLE kiosk_20190611; Type: ACL; Schema: test; Owner: dbservice
--

GRANT ALL ON TABLE test.kiosk_20190611 TO bytedevs;


--
-- Name: TABLE kiosk_20190612; Type: ACL; Schema: test; Owner: dbservice
--

GRANT ALL ON TABLE test.kiosk_20190612 TO bytedevs;


--
-- Name: TABLE kiosk_20190918; Type: ACL; Schema: test; Owner: dbservice
--

GRANT ALL ON TABLE test.kiosk_20190918 TO bytedevs;


--
-- Name: TABLE kiosk_20200304; Type: ACL; Schema: test; Owner: dbservice
--

GRANT ALL ON TABLE test.kiosk_20200304 TO bytedevs;


--
-- Name: TABLE kiosk_bkup_20200204; Type: ACL; Schema: test; Owner: dbservice
--

GRANT ALL ON TABLE test.kiosk_bkup_20200204 TO bytedevs;


--
-- Name: TABLE kiosk_payment_start; Type: ACL; Schema: test; Owner: dbservice
--

GRANT ALL ON TABLE test.kiosk_payment_start TO bytedevs;


--
-- Name: TABLE kiosk_serial_20190916; Type: ACL; Schema: test; Owner: dbservice
--

GRANT ALL ON TABLE test.kiosk_serial_20190916 TO bytedevs;


--
-- Name: TABLE locked_kiosk_by_command; Type: ACL; Schema: test; Owner: dbservice
--

GRANT ALL ON TABLE test.locked_kiosk_by_command TO bytedevs;


--
-- Name: TABLE locked_kiosk_via_pw; Type: ACL; Schema: test; Owner: dbservice
--

GRANT ALL ON TABLE test.locked_kiosk_via_pw TO bytedevs;


--
-- Name: TABLE lost_wall_clock_orders; Type: ACL; Schema: test; Owner: dbservice
--

GRANT ALL ON TABLE test.lost_wall_clock_orders TO bytedevs;


--
-- Name: TABLE november_order; Type: ACL; Schema: test; Owner: dbservice
--

GRANT ALL ON TABLE test.november_order TO bytedevs;


--
-- Name: TABLE order_complimentary_eng_2292; Type: ACL; Schema: test; Owner: dbservice
--

GRANT ALL ON TABLE test.order_complimentary_eng_2292 TO bytedevs;


--
-- Name: TABLE order_epc_pending_sync; Type: ACL; Schema: test; Owner: dbservice
--

GRANT ALL ON TABLE test.order_epc_pending_sync TO bytedevs;


--
-- Name: TABLE order_with_1970_and_2000_dates; Type: ACL; Schema: test; Owner: dbservice
--

GRANT ALL ON TABLE test.order_with_1970_and_2000_dates TO bytedevs;


--
-- Name: TABLE reauth_2019_07_priced_finalized_orders; Type: ACL; Schema: test; Owner: dbservice
--

GRANT ALL ON TABLE test.reauth_2019_07_priced_finalized_orders TO bytedevs;


--
-- Name: TABLE request_log_epc_order; Type: ACL; Schema: test; Owner: dbservice
--

GRANT ALL ON TABLE test.request_log_epc_order TO bytedevs;


--
-- Name: TABLE request_log_order; Type: ACL; Schema: test; Owner: dbservice
--

GRANT ALL ON TABLE test.request_log_order TO bytedevs;


--
-- Name: TABLE request_log_sold_epc; Type: ACL; Schema: test; Owner: dbservice
--

GRANT ALL ON TABLE test.request_log_sold_epc TO bytedevs;


--
-- Name: TABLE temp_pending; Type: ACL; Schema: test; Owner: dbservice
--

GRANT ALL ON TABLE test.temp_pending TO bytedevs;


--
-- Name: TABLE transactions_pending_sync; Type: ACL; Schema: test; Owner: dbservice
--

GRANT ALL ON TABLE test.transactions_pending_sync TO bytedevs;


--
-- Name: SEQUENCE transactions_pending_sync_id_seq; Type: ACL; Schema: test; Owner: dbservice
--

GRANT ALL ON SEQUENCE test.transactions_pending_sync_id_seq TO bytedevs;


--
-- Name: TABLE vantiv_20190801; Type: ACL; Schema: test; Owner: dbservice
--

GRANT ALL ON TABLE test.vantiv_20190801 TO bytedevs;


--
-- Name: TABLE vantiv_20190801b; Type: ACL; Schema: test; Owner: dbservice
--

GRANT ALL ON TABLE test.vantiv_20190801b TO bytedevs;


--
-- Name: DEFAULT PRIVILEGES FOR FUNCTIONS; Type: DEFAULT ACL; Schema: inm; Owner: dbservice
--

ALTER DEFAULT PRIVILEGES FOR ROLE dbservice IN SCHEMA inm REVOKE ALL ON FUNCTIONS  FROM PUBLIC;
ALTER DEFAULT PRIVILEGES FOR ROLE dbservice IN SCHEMA inm REVOKE ALL ON FUNCTIONS  FROM dbservice;
ALTER DEFAULT PRIVILEGES FOR ROLE dbservice IN SCHEMA inm GRANT ALL ON FUNCTIONS  TO bytedevs;


--
-- Name: DEFAULT PRIVILEGES FOR TABLES; Type: DEFAULT ACL; Schema: inm; Owner: dbservice
--

ALTER DEFAULT PRIVILEGES FOR ROLE dbservice IN SCHEMA inm REVOKE ALL ON TABLES  FROM dbservice;
ALTER DEFAULT PRIVILEGES FOR ROLE dbservice IN SCHEMA inm GRANT ALL ON TABLES  TO bytedevs;


--
-- Name: DEFAULT PRIVILEGES FOR TABLES; Type: DEFAULT ACL; Schema: inm_beta; Owner: dbservice
--

ALTER DEFAULT PRIVILEGES FOR ROLE dbservice IN SCHEMA inm_beta REVOKE ALL ON TABLES  FROM dbservice;
ALTER DEFAULT PRIVILEGES FOR ROLE dbservice IN SCHEMA inm_beta GRANT ALL ON TABLES  TO jung;


--
-- Name: DEFAULT PRIVILEGES FOR FUNCTIONS; Type: DEFAULT ACL; Schema: mixalot; Owner: dbservice
--

ALTER DEFAULT PRIVILEGES FOR ROLE dbservice IN SCHEMA mixalot REVOKE ALL ON FUNCTIONS  FROM PUBLIC;
ALTER DEFAULT PRIVILEGES FOR ROLE dbservice IN SCHEMA mixalot REVOKE ALL ON FUNCTIONS  FROM dbservice;
ALTER DEFAULT PRIVILEGES FOR ROLE dbservice IN SCHEMA mixalot GRANT ALL ON FUNCTIONS  TO bytedevs;


--
-- Name: DEFAULT PRIVILEGES FOR TABLES; Type: DEFAULT ACL; Schema: mixalot; Owner: dbservice
--

ALTER DEFAULT PRIVILEGES FOR ROLE dbservice IN SCHEMA mixalot REVOKE ALL ON TABLES  FROM dbservice;
ALTER DEFAULT PRIVILEGES FOR ROLE dbservice IN SCHEMA mixalot GRANT ALL ON TABLES  TO bytedevs;


--
-- Name: DEFAULT PRIVILEGES FOR SEQUENCES; Type: DEFAULT ACL; Schema: pantry; Owner: dbservice
--

ALTER DEFAULT PRIVILEGES FOR ROLE dbservice IN SCHEMA pantry REVOKE ALL ON SEQUENCES  FROM dbservice;
ALTER DEFAULT PRIVILEGES FOR ROLE dbservice IN SCHEMA pantry GRANT ALL ON SEQUENCES  TO pantry_web_user;


--
-- Name: DEFAULT PRIVILEGES FOR FUNCTIONS; Type: DEFAULT ACL; Schema: pantry; Owner: dbservice
--

ALTER DEFAULT PRIVILEGES FOR ROLE dbservice IN SCHEMA pantry REVOKE ALL ON FUNCTIONS  FROM PUBLIC;
ALTER DEFAULT PRIVILEGES FOR ROLE dbservice IN SCHEMA pantry REVOKE ALL ON FUNCTIONS  FROM dbservice;
ALTER DEFAULT PRIVILEGES FOR ROLE dbservice IN SCHEMA pantry GRANT ALL ON FUNCTIONS  TO pantry_web_user;
ALTER DEFAULT PRIVILEGES FOR ROLE dbservice IN SCHEMA pantry GRANT ALL ON FUNCTIONS  TO bytedevs;


--
-- Name: DEFAULT PRIVILEGES FOR TABLES; Type: DEFAULT ACL; Schema: pantry; Owner: dbservice
--

ALTER DEFAULT PRIVILEGES FOR ROLE dbservice IN SCHEMA pantry REVOKE ALL ON TABLES  FROM dbservice;
ALTER DEFAULT PRIVILEGES FOR ROLE dbservice IN SCHEMA pantry GRANT ALL ON TABLES  TO pantry_web_user;
ALTER DEFAULT PRIVILEGES FOR ROLE dbservice IN SCHEMA pantry GRANT ALL ON TABLES  TO bytedevs;


--
-- Name: DEFAULT PRIVILEGES FOR FUNCTIONS; Type: DEFAULT ACL; Schema: public; Owner: dbservice
--

ALTER DEFAULT PRIVILEGES FOR ROLE dbservice IN SCHEMA public REVOKE ALL ON FUNCTIONS  FROM PUBLIC;
ALTER DEFAULT PRIVILEGES FOR ROLE dbservice IN SCHEMA public REVOKE ALL ON FUNCTIONS  FROM dbservice;
ALTER DEFAULT PRIVILEGES FOR ROLE dbservice IN SCHEMA public GRANT ALL ON FUNCTIONS  TO bytedevs;


--
-- Name: DEFAULT PRIVILEGES FOR TABLES; Type: DEFAULT ACL; Schema: public; Owner: dbservice
--

ALTER DEFAULT PRIVILEGES FOR ROLE dbservice IN SCHEMA public REVOKE ALL ON TABLES  FROM dbservice;
ALTER DEFAULT PRIVILEGES FOR ROLE dbservice IN SCHEMA public GRANT ALL ON TABLES  TO bytedevs;


--
-- Name: DEFAULT PRIVILEGES FOR FUNCTIONS; Type: DEFAULT ACL; Schema: report; Owner: dbservice
--

ALTER DEFAULT PRIVILEGES FOR ROLE dbservice IN SCHEMA report REVOKE ALL ON FUNCTIONS  FROM PUBLIC;
ALTER DEFAULT PRIVILEGES FOR ROLE dbservice IN SCHEMA report REVOKE ALL ON FUNCTIONS  FROM dbservice;
ALTER DEFAULT PRIVILEGES FOR ROLE dbservice IN SCHEMA report GRANT ALL ON FUNCTIONS  TO bytedevs;


--
-- Name: DEFAULT PRIVILEGES FOR TABLES; Type: DEFAULT ACL; Schema: report; Owner: dbservice
--

ALTER DEFAULT PRIVILEGES FOR ROLE dbservice IN SCHEMA report REVOKE ALL ON TABLES  FROM dbservice;
ALTER DEFAULT PRIVILEGES FOR ROLE dbservice IN SCHEMA report GRANT ALL ON TABLES  TO bytedevs;


--
-- Name: DEFAULT PRIVILEGES FOR FUNCTIONS; Type: DEFAULT ACL; Schema: rptg; Owner: dbservice
--

ALTER DEFAULT PRIVILEGES FOR ROLE dbservice IN SCHEMA rptg REVOKE ALL ON FUNCTIONS  FROM PUBLIC;
ALTER DEFAULT PRIVILEGES FOR ROLE dbservice IN SCHEMA rptg REVOKE ALL ON FUNCTIONS  FROM dbservice;
ALTER DEFAULT PRIVILEGES FOR ROLE dbservice IN SCHEMA rptg GRANT ALL ON FUNCTIONS  TO bytedevs;


--
-- Name: DEFAULT PRIVILEGES FOR TABLES; Type: DEFAULT ACL; Schema: rptg; Owner: dbservice
--

ALTER DEFAULT PRIVILEGES FOR ROLE dbservice IN SCHEMA rptg REVOKE ALL ON TABLES  FROM dbservice;
ALTER DEFAULT PRIVILEGES FOR ROLE dbservice IN SCHEMA rptg GRANT ALL ON TABLES  TO bytedevs;


--
-- Name: DEFAULT PRIVILEGES FOR FUNCTIONS; Type: DEFAULT ACL; Schema: test; Owner: dbservice
--

ALTER DEFAULT PRIVILEGES FOR ROLE dbservice IN SCHEMA test REVOKE ALL ON FUNCTIONS  FROM PUBLIC;
ALTER DEFAULT PRIVILEGES FOR ROLE dbservice IN SCHEMA test REVOKE ALL ON FUNCTIONS  FROM dbservice;
ALTER DEFAULT PRIVILEGES FOR ROLE dbservice IN SCHEMA test GRANT ALL ON FUNCTIONS  TO bytedevs;


--
-- Name: DEFAULT PRIVILEGES FOR TABLES; Type: DEFAULT ACL; Schema: test; Owner: dbservice
--

ALTER DEFAULT PRIVILEGES FOR ROLE dbservice IN SCHEMA test REVOKE ALL ON TABLES  FROM dbservice;
ALTER DEFAULT PRIVILEGES FOR ROLE dbservice IN SCHEMA test GRANT ALL ON TABLES  TO bytedevs;


--
-- PostgreSQL database dump complete
--

