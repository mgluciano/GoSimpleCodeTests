
CREATE VIEW public.byte_tickets_4days AS
 SELECT byte_tickets.order_id,
    byte_tickets.first_name,
    byte_tickets.last_name,
    byte_tickets.kiosk_id,
    byte_tickets.kiosk_title,
    byte_tickets.email,
    byte_tickets.amount_paid,
    byte_tickets.payment_system,
    byte_tickets.transaction_id,
    byte_tickets.approval_code,
    byte_tickets.status_code,
    byte_tickets.status_message,
    byte_tickets.status,
    byte_tickets.batch_id,
    byte_tickets.created,
    byte_tickets.auth_amount,
    byte_tickets.data_token,
    byte_tickets.time_opened,
    byte_tickets.time_closed,
    byte_tickets.card_hash,
    byte_tickets.state,
    byte_tickets.archived,
    byte_tickets.stamp,
    byte_tickets.last_update,
    byte_tickets.balance,
    byte_tickets.delta,
    byte_tickets.coupon_id,
    byte_tickets.coupon,
    byte_tickets.refund,
    byte_tickets.receipt,
    byte_tickets.campus_id,
    byte_tickets.amount_list_price,
    byte_tickets.notes,
    byte_tickets.time_door_opened,
    byte_tickets.time_door_closed,
    byte_tickets.client_name,
    byte_tickets.estd_num_users,
    byte_tickets.ts,
    byte_tickets.full_name,
    byte_tickets.door_opened_secs,
    byte_tickets.month,
    byte_tickets.week,
    byte_tickets.date,
    byte_tickets.dayofweek,
    byte_tickets.hour,
    byte_tickets.dowhour,
    byte_tickets.uniq_user
   FROM public.byte_tickets
  WHERE (byte_tickets.ts > (now() - '4 days'::interval day));
CREATE VIEW public.byte_spoilage_by_sku_2months AS
 SELECT to_char(t2.first_sale, 'MM-DD'::text) AS first_sale,
    p.shelf_life_days AS shelf_days,
    t.spoiled,
    t2.sold,
    to_char(((1.0 * (t.spoiled)::numeric) / ((t2.sold + t.spoiled))::numeric), '0.000'::text) AS frac_spoiled,
    ((t2.sold)::numeric * p.price) AS revenue,
    ((t.spoiled)::numeric * p.cost) AS spoil_cost,
    to_char((((t.spoiled)::numeric * p.cost) / (((t2.sold)::numeric * p.price) + 0.001)), '0.000'::text) AS spoil_dolr_frac,
    t.product_id,
    p.categories,
    p.title
   FROM ((( SELECT byte_spoilage.product_id,
            count(*) AS spoiled
           FROM public.byte_spoilage
          WHERE (byte_spoilage.ts_removed > (now() - '2 mons'::interval month))
          GROUP BY byte_spoilage.product_id) t
     JOIN ( SELECT byte_epcssold_2months.product_id,
            min(byte_epcssold_2months.ts) AS first_sale,
            count(*) AS sold
           FROM public.byte_epcssold_2months
          GROUP BY byte_epcssold_2months.product_id) t2 ON ((t.product_id = t2.product_id)))
     JOIN public.byte_products p ON ((t2.product_id = p.id)))
  ORDER BY (to_char(((1.0 * (t.spoiled)::numeric) / ((t2.sold + t.spoiled))::numeric), '0.000'::text)) DESC;
CREATE VIEW public.dp_epcssold_2016 AS
 SELECT dp_epcssold.order_id,
    dp_epcssold.first_name,
    dp_epcssold.last_name,
    dp_epcssold.kiosk_id,
    dp_epcssold.kiosk_title,
    dp_epcssold.email,
    dp_epcssold.amount_paid,
    dp_epcssold.payment_system,
    dp_epcssold.transaction_id,
    dp_epcssold.approval_code,
    dp_epcssold.status_code,
    dp_epcssold.status_message,
    dp_epcssold.status,
    dp_epcssold.batch_id,
    dp_epcssold.created,
    dp_epcssold.auth_amount,
    dp_epcssold.data_token,
    dp_epcssold.time_opened,
    dp_epcssold.time_closed,
    dp_epcssold.card_hash,
    dp_epcssold.state,
    dp_epcssold.archived,
    dp_epcssold.stamp,
    dp_epcssold.last_update,
    dp_epcssold.balance,
    dp_epcssold.delta,
    dp_epcssold.coupon_id,
    dp_epcssold.coupon,
    dp_epcssold.refund,
    dp_epcssold.receipt,
    dp_epcssold.campus_id,
    dp_epcssold.amount_list_price,
    dp_epcssold.notes,
    dp_epcssold.time_door_opened,
    dp_epcssold.time_door_closed,
    dp_epcssold.client_name,
    dp_epcssold.estd_num_users,
    dp_epcssold.ts,
    dp_epcssold.full_name,
    dp_epcssold.door_opened_secs,
    dp_epcssold.month,
    dp_epcssold.week,
    dp_epcssold.date,
    dp_epcssold.dayofweek,
    dp_epcssold.hour,
    dp_epcssold.dowhour,
    dp_epcssold.uniq_user,
    dp_epcssold.epc,
    dp_epcssold.label_order_id,
    dp_epcssold.label_status,
    dp_epcssold.label_price,
    dp_epcssold.time_created,
    dp_epcssold.time_added,
    dp_epcssold.time_updated,
    dp_epcssold.ts_created,
    dp_epcssold.ts_added,
    dp_epcssold.ts_updated,
    dp_epcssold.label_kiosk_id,
    dp_epcssold.product_id,
    dp_epcssold.product_title,
    dp_epcssold.product_archived,
    dp_epcssold.product_vendor,
    dp_epcssold.product_price,
    dp_epcssold.product_cost,
    dp_epcssold.product_shelf_life_days,
    dp_epcssold.product_attributes,
    dp_epcssold.product_categories,
    dp_epcssold.consumer_category,
    dp_epcssold.product_source
   FROM public.dp_epcssold
  WHERE ((dp_epcssold.ts >= '2016-01-01 08:00:00+00'::timestamp with time zone) AND (dp_epcssold.ts <= '2017-01-01 08:00:00+00'::timestamp with time zone));
CREATE VIEW public.dp_spoilage_monthly_calc AS
 SELECT dpssj.month,
    dpssj.kiosk_id,
    dpssj.product_id,
    dpssj.spoiled,
    dpssj.sold,
    p.title AS product_title,
    k.title AS kiosk_title,
    p.price AS unit_price,
    p.cost AS unit_cost,
    public.frac((dpssj.spoiled)::numeric, (dpssj.sold)::numeric) AS spoiled_frac_units,
    ((dpssj.sold)::numeric * p.price) AS revenue,
    (((dpssj.spoiled + dpssj.sold))::numeric * p.cost) AS cost,
    public.if((dpssj.sold = 0), 9999.0, (((1.0 * (dpssj.spoiled)::numeric) * p.cost) / ((dpssj.sold)::numeric * p.price))) AS spoilage_frac,
    (dpssj.month < knn.new_ts) AS new_kiosk
   FROM (((public.dp_spoilage_monthly_sold_join dpssj
     JOIN pantry.product p ON ((dpssj.product_id = p.id)))
     JOIN public.byte_kiosks k ON ((dpssj.kiosk_id = k.id)))
     JOIN public.byte_kiosks_date_non_new knn ON ((k.id = knn.kiosk_id)))
  WHERE (dpssj.month >= '2016-01-01 08:00:00+00'::timestamp with time zone)
  ORDER BY dpssj.month DESC;
CREATE VIEW byt_devops.pgdu AS
 SELECT pgdu_union.table_name,
    pgdu_union.table_size,
    pgdu_union.percent_table,
    pgdu_union.indexes_size,
    pgdu_union.percent_index,
    pgdu_union.total_size
   FROM byt_devops.pgdu_union;
CREATE VIEW inm.warehouse_ordering AS
 SELECT t9.sku_group,
    t9.sku,
    t9.name,
    sum(t9.su_plan_demand_qty) AS su,
    sum(t9.mo_plan_demand_qty) AS mo,
    sum(t9.tu_plan_demand_qty) AS tu,
    sum(t9.we_plan_demand_qty) AS we,
    sum(t9.th_plan_demand_qty) AS th
   FROM ( SELECT t8.kiosk_id,
            t8.sku_group,
            t8.sku,
            t8.name,
            COALESCE(round(
                CASE
                    WHEN (t8.preference_sum > (0)::numeric) THEN ((t8.preference_scale / t8.preference_sum) * t8.d1_plan_demand_qty)
                    ELSE 0.00
                END, 2), 0.00) AS su_plan_demand_qty,
            COALESCE(round(
                CASE
                    WHEN (t8.preference_sum > (0)::numeric) THEN ((t8.preference_scale / t8.preference_sum) * t8.d2_plan_demand_qty)
                    ELSE 0.00
                END, 2), 0.00) AS mo_plan_demand_qty,
            COALESCE(round(
                CASE
                    WHEN (t8.preference_sum > (0)::numeric) THEN ((t8.preference_scale / t8.preference_sum) * t8.d3_plan_demand_qty)
                    ELSE 0.00
                END, 2), 0.00) AS tu_plan_demand_qty,
            COALESCE(round(
                CASE
                    WHEN (t8.preference_sum > (0)::numeric) THEN ((t8.preference_scale / t8.preference_sum) * t8.d4_plan_demand_qty)
                    ELSE 0.00
                END, 2), 0.00) AS we_plan_demand_qty,
            COALESCE(round(
                CASE
                    WHEN (t8.preference_sum > (0)::numeric) THEN ((t8.preference_scale / t8.preference_sum) * t8.d5_plan_demand_qty)
                    ELSE 0.00
                END, 2), 0.00) AS th_plan_demand_qty
           FROM ( SELECT t7.kiosk_id,
                    t7.sku_group,
                    t7.sku,
                    t7.name,
                    t7.sample_size,
                    t7.dt_avg,
                    t7.dt_std,
                    t7.w_departure_time,
                    t7.preference,
                    t7.scale,
                    t7.week_demand_qty,
                    t7.d1_plan_demand_qty,
                    t7.d2_plan_demand_qty,
                    t7.d3_plan_demand_qty,
                    t7.d4_plan_demand_qty,
                    t7.d5_plan_demand_qty,
                    round((t7.preference * (t7.scale)::numeric), 2) AS preference_scale,
                    sum((t7.preference * (t7.scale)::numeric)) OVER (PARTITION BY t7.kiosk_id, t7.sku_group) AS preference_sum
                   FROM ( SELECT t4.kiosk_id,
                            t4.sku_group,
                            t4.sku,
                            t4.name,
                            t4.sample_size,
                            t4.dt_avg,
                            t4.dt_std,
                            t4.w_departure_time,
                            t4.preference,
                            t5.scale,
                            t6.week_demand_qty,
                            t6.d1_plan_demand_qty,
                            t6.d2_plan_demand_qty,
                            t6.d3_plan_demand_qty,
                            t6.d4_plan_demand_qty,
                            t6.d5_plan_demand_qty
                           FROM ((mixalot.inm_sku_velocity t4
                             LEFT JOIN mixalot.inm_warehouse_sku_enabled t5 ON ((t4.sku = t5.sku)))
                             LEFT JOIN ( SELECT t1.kiosk_id,
                                    t1.sku_group,
                                    t1.week_demand_qty,
                                    round(((t1.week_demand_qty * t1.d1_plan_demand_qty) / ((((t1.d1_plan_demand_qty + t1.d2_plan_demand_qty) + t1.d3_plan_demand_qty) + t1.d4_plan_demand_qty) + t1.d5_plan_demand_qty)), 2) AS d1_plan_demand_qty,
                                    round(((t1.week_demand_qty * t1.d2_plan_demand_qty) / ((((t1.d1_plan_demand_qty + t1.d2_plan_demand_qty) + t1.d3_plan_demand_qty) + t1.d4_plan_demand_qty) + t1.d5_plan_demand_qty)), 2) AS d2_plan_demand_qty,
                                    round(((t1.week_demand_qty * t1.d3_plan_demand_qty) / ((((t1.d1_plan_demand_qty + t1.d2_plan_demand_qty) + t1.d3_plan_demand_qty) + t1.d4_plan_demand_qty) + t1.d5_plan_demand_qty)), 2) AS d3_plan_demand_qty,
                                    round(((t1.week_demand_qty * t1.d4_plan_demand_qty) / ((((t1.d1_plan_demand_qty + t1.d2_plan_demand_qty) + t1.d3_plan_demand_qty) + t1.d4_plan_demand_qty) + t1.d5_plan_demand_qty)), 2) AS d4_plan_demand_qty,
                                    round(((t1.week_demand_qty * t1.d5_plan_demand_qty) / ((((t1.d1_plan_demand_qty + t1.d2_plan_demand_qty) + t1.d3_plan_demand_qty) + t1.d4_plan_demand_qty) + t1.d5_plan_demand_qty)), 2) AS d5_plan_demand_qty
                                   FROM ( SELECT k.kiosk_id,
    p.sku_group,
    COALESCE(d1.week_demand_qty, d2.week_demand_qty, d3.week_demand_qty, d4.week_demand_qty, d5.week_demand_qty) AS week_demand_qty,
    COALESCE(d1.plan_demand_qty, (0)::numeric) AS d1_plan_demand_qty,
    COALESCE(d2.plan_demand_qty, (0)::numeric) AS d2_plan_demand_qty,
    COALESCE(d3.plan_demand_qty, (0)::numeric) AS d3_plan_demand_qty,
    COALESCE(d4.plan_demand_qty, (0)::numeric) AS d4_plan_demand_qty,
    COALESCE(d5.plan_demand_qty, (0)::numeric) AS d5_plan_demand_qty
   FROM ((((((( SELECT k_1.id AS kiosk_id
     FROM pantry.kiosk k_1
    WHERE ((k_1.campus_id = 87) AND (k_1.archived = 0) AND (k_1.enable_reporting = 1))) k
     CROSS JOIN ( SELECT DISTINCT p_1.fc_title AS sku_group
     FROM pantry.product p_1
    WHERE ((p_1.campus_id = 87) AND (p_1.archived = 0) AND (p_1.fc_title IS NOT NULL) AND ((p_1.fc_title)::text <> 'N/A'::text))
    ORDER BY p_1.fc_title) p)
     FULL JOIN inm.pick_get_order_with_velocity('2018-12-16 20:00:00+00'::timestamp with time zone, '2018-12-17 18:00:00+00'::timestamp with time zone) d1(kiosk_id, route_date_time, sku_group_id, fc_title, week_demand_qty, plan_demand_qty, plan_order_qty) ON (((k.kiosk_id = d1.kiosk_id) AND ((p.sku_group)::text = d1.fc_title))))
     FULL JOIN inm.pick_get_order_with_velocity('2018-12-17 20:00:00+00'::timestamp with time zone, '2018-12-18 18:00:00+00'::timestamp with time zone) d2(kiosk_id, route_date_time, sku_group_id, fc_title, week_demand_qty, plan_demand_qty, plan_order_qty) ON (((k.kiosk_id = d2.kiosk_id) AND ((p.sku_group)::text = d2.fc_title))))
     FULL JOIN inm.pick_get_order_with_velocity('2018-12-18 20:00:00+00'::timestamp with time zone, '2018-12-19 18:00:00+00'::timestamp with time zone) d3(kiosk_id, route_date_time, sku_group_id, fc_title, week_demand_qty, plan_demand_qty, plan_order_qty) ON (((k.kiosk_id = d3.kiosk_id) AND ((p.sku_group)::text = d3.fc_title))))
     FULL JOIN inm.pick_get_order_with_velocity('2018-12-19 20:00:00+00'::timestamp with time zone, '2018-12-20 18:00:00+00'::timestamp with time zone) d4(kiosk_id, route_date_time, sku_group_id, fc_title, week_demand_qty, plan_demand_qty, plan_order_qty) ON (((k.kiosk_id = d4.kiosk_id) AND ((p.sku_group)::text = d4.fc_title))))
     FULL JOIN inm.pick_get_order_with_velocity('2018-12-20 20:00:00+00'::timestamp with time zone, '2018-12-21 18:00:00+00'::timestamp with time zone) d5(kiosk_id, route_date_time, sku_group_id, fc_title, week_demand_qty, plan_demand_qty, plan_order_qty) ON (((k.kiosk_id = d5.kiosk_id) AND ((p.sku_group)::text = d5.fc_title))))
  ORDER BY k.kiosk_id, p.sku_group) t1
                                  WHERE (((((t1.d1_plan_demand_qty + t1.d2_plan_demand_qty) + t1.d3_plan_demand_qty) + t1.d4_plan_demand_qty) + t1.d5_plan_demand_qty) > (0)::numeric)) t6 ON (((t4.kiosk_id = t6.kiosk_id) AND ((t4.sku_group)::text = (t6.sku_group)::text))))) t7) t8) t9
  GROUP BY t9.sku_group, t9.sku, t9.name
  ORDER BY t9.sku_group, t9.sku, t9.name;
CREATE VIEW public.byte_epcssold_10weeks AS
 SELECT o.order_id,
    o.first_name,
    o.last_name,
    o.kiosk_id,
    o.kiosk_title,
    o.email,
    o.amount_paid,
    o.payment_system,
    o.transaction_id,
    o.approval_code,
    o.status_code,
    o.status_message,
    o.status,
    o.batch_id,
    o.created,
    o.auth_amount,
    o.data_token,
    o.time_opened,
    o.time_closed,
    o.card_hash,
    o.state,
    o.archived,
    o.stamp,
    o.last_update,
    o.balance,
    o.delta,
    o.coupon_id,
    o.coupon,
    o.refund,
    o.receipt,
    o.campus_id,
    o.amount_list_price,
    o.notes,
    o.time_door_opened,
    o.time_door_closed,
    o.client_name,
    o.estd_num_users,
    o.ts,
    o.full_name,
    o.door_opened_secs,
    o.month,
    o.week,
    o.date,
    o.dayofweek,
    o.hour,
    o.dowhour,
    o.uniq_user,
    lp.epc,
    lp.label_order_id,
    lp.label_status,
    lp.label_price,
    lp.time_created,
    lp.time_added,
    lp.time_updated,
    lp.ts_created,
    lp.ts_added,
    lp.ts_updated,
    lp.label_kiosk_id,
    lp.product_id,
    lp.product_title,
    lp.product_archived,
    lp.product_vendor,
    lp.product_price,
    lp.product_cost,
    lp.product_shelf_life_days,
    lp.product_attributes,
    lp.product_categories,
    lp.consumer_category,
    lp.product_source
   FROM (public.byte_tickets_10weeks o
     JOIN public.byte_label_product lp ON (((lp.label_order_id)::text = (o.order_id)::text)))
  WHERE ((lp.label_status)::text = 'sold'::text);
CREATE VIEW public.byte_epcssold_5days AS
 SELECT o.order_id,
    o.first_name,
    o.last_name,
    o.kiosk_id,
    o.kiosk_title,
    o.email,
    o.amount_paid,
    o.payment_system,
    o.transaction_id,
    o.approval_code,
    o.status_code,
    o.status_message,
    o.status,
    o.batch_id,
    o.created,
    o.auth_amount,
    o.data_token,
    o.time_opened,
    o.time_closed,
    o.card_hash,
    o.state,
    o.archived,
    o.stamp,
    o.last_update,
    o.balance,
    o.delta,
    o.coupon_id,
    o.coupon,
    o.refund,
    o.receipt,
    o.campus_id,
    o.amount_list_price,
    o.notes,
    o.time_door_opened,
    o.time_door_closed,
    o.client_name,
    o.estd_num_users,
    o.ts,
    o.full_name,
    o.door_opened_secs,
    o.month,
    o.week,
    o.date,
    o.dayofweek,
    o.hour,
    o.dowhour,
    o.uniq_user,
    lp.epc,
    lp.label_order_id,
    lp.label_status,
    lp.label_price,
    lp.time_created,
    lp.time_added,
    lp.time_updated,
    lp.ts_created,
    lp.ts_added,
    lp.ts_updated,
    lp.label_kiosk_id,
    lp.product_id,
    lp.product_title,
    lp.product_archived,
    lp.product_vendor,
    lp.product_price,
    lp.product_cost,
    lp.product_shelf_life_days,
    lp.product_attributes,
    lp.product_categories,
    lp.consumer_category,
    lp.product_source
   FROM (public.byte_tickets_5days o
     JOIN public.byte_label_product lp ON (((lp.label_order_id)::text = (o.order_id)::text)))
  WHERE ((lp.label_status)::text = 'sold'::text);
CREATE VIEW public.byte_stockouts_by_category_week_newold AS
 SELECT s.week,
    ((regexp_replace((s.consumer_category)::text, '[^a-zA-Z]+'::text, '_'::text, 'g'::text) || '_'::text) ||
        CASE
            WHEN (s.ts >= k.new_ts) THEN 'hrs_old'::text
            ELSE 'hrs_new'::text
        END) AS cat_and_new,
    sum((date_part('minute'::text, (s.restock_ts - s.ts)) / (60.0)::double precision)) AS stockout_hrs
   FROM (public.byte_stockouts s
     JOIN public.byte_kiosks_date_non_new k ON ((s.kiosk_id = k.kiosk_id)))
  WHERE ((s.ts >= '2016-01-01 08:00:00+00'::timestamp with time zone) AND (s.consumer_category IS NOT NULL))
  GROUP BY s.week, ((regexp_replace((s.consumer_category)::text, '[^a-zA-Z]+'::text, '_'::text, 'g'::text) || '_'::text) ||
        CASE
            WHEN (s.ts >= k.new_ts) THEN 'hrs_old'::text
            ELSE 'hrs_new'::text
        END)
  ORDER BY s.week DESC, ((regexp_replace((s.consumer_category)::text, '[^a-zA-Z]+'::text, '_'::text, 'g'::text) || '_'::text) ||
        CASE
            WHEN (s.ts >= k.new_ts) THEN 'hrs_old'::text
            ELSE 'hrs_new'::text
        END);
CREATE VIEW public.user_retention_12months AS
 SELECT user_retention_by_month.month,
    user_retention_by_month.num_consumers,
    user_retention_by_month.repeat_consumers,
    user_retention_by_month.num_tickets,
    user_retention_by_month.sum_amount_list_price,
    user_retention_by_month.sum_amount_paid,
    user_retention_by_month.num_repeat_tickets,
    user_retention_by_month.sum_repeat_amount_list_price,
    user_retention_by_month.sum_repeat_amount_paid,
    user_retention_by_month.frac_users_retained,
    user_retention_by_month.frac_tickets_retained,
    user_retention_by_month.frac_listprice_retained,
    user_retention_by_month.frac_amountpaid_retained,
    user_retention_by_month.old_month,
    user_retention_by_month.old_num_consumers,
    user_retention_by_month.old_repeat_consumers,
    user_retention_by_month.old_num_tickets,
    user_retention_by_month.old_sum_amount_list_price,
    user_retention_by_month.old_sum_amount_paid
   FROM public.user_retention_by_month(12) user_retention_by_month(month, num_consumers, repeat_consumers, num_tickets, sum_amount_list_price, sum_amount_paid, num_repeat_tickets, sum_repeat_amount_list_price, sum_repeat_amount_paid, frac_users_retained, frac_tickets_retained, frac_listprice_retained, frac_amountpaid_retained, old_month, old_num_consumers, old_repeat_consumers, old_num_tickets, old_sum_amount_list_price, old_sum_amount_paid);
CREATE VIEW public.byte_epcssold_9months AS
 SELECT o.order_id,
    o.first_name,
    o.last_name,
    o.kiosk_id,
    o.kiosk_title,
    o.email,
    o.amount_paid,
    o.payment_system,
    o.transaction_id,
    o.approval_code,
    o.status_code,
    o.status_message,
    o.status,
    o.batch_id,
    o.created,
    o.auth_amount,
    o.data_token,
    o.time_opened,
    o.time_closed,
    o.card_hash,
    o.state,
    o.archived,
    o.stamp,
    o.last_update,
    o.balance,
    o.delta,
    o.coupon_id,
    o.coupon,
    o.refund,
    o.receipt,
    o.campus_id,
    o.amount_list_price,
    o.notes,
    o.time_door_opened,
    o.time_door_closed,
    o.client_name,
    o.estd_num_users,
    o.ts,
    o.full_name,
    o.door_opened_secs,
    o.month,
    o.week,
    o.date,
    o.dayofweek,
    o.hour,
    o.dowhour,
    o.uniq_user,
    lp.epc,
    lp.label_order_id,
    lp.label_status,
    lp.label_price,
    lp.time_created,
    lp.time_added,
    lp.time_updated,
    lp.ts_created,
    lp.ts_added,
    lp.ts_updated,
    lp.label_kiosk_id,
    lp.product_id,
    lp.product_title,
    lp.product_archived,
    lp.product_vendor,
    lp.product_price,
    lp.product_cost,
    lp.product_shelf_life_days,
    lp.product_attributes,
    lp.product_categories,
    lp.consumer_category,
    lp.product_source
   FROM (public.byte_tickets_9months o
     JOIN public.byte_label_product lp ON (((lp.label_order_id)::text = (o.order_id)::text)))
  WHERE ((lp.label_status)::text = 'sold'::text);
CREATE VIEW mixalot.v_kiosk_inventory_log AS
 SELECT l.ts,
    l."time",
    l.request_uuid,
    l.endpoint,
    l.client_ip,
    l.version,
    l.cookie,
    l.message,
    l.request_body,
    l.request_headers,
    l.start_ts,
    l.response_body,
    l.response_headers,
    l.status_code,
    l.end_ts,
    l.traceback,
    l.request_body_json,
    l.request_headers_json,
    l.response_headers_json,
    l.kiosk_id,
    l.source,
    (((l.request_body_json)::json ->> 'epc'::text))::character varying AS epc,
    (((l.request_body_json)::json ->> 'retry_count'::text))::integer AS retry_count
   FROM mixalot.v_kiosk_request_log l
  WHERE ((l.endpoint = '/inventory'::text) AND (l.source = 'mixalot'::text));
CREATE VIEW public.byte_addicted_users_120days AS
 SELECT t.kiosk_id,
    t.kiosk_title,
    t.product_id,
    t.product_title,
    count(*) AS count
   FROM ( SELECT items.kiosk_id,
            items.kiosk_title,
            ((btrim((items.first_name)::text) || ' '::text) || btrim((items.last_name)::text)) AS username,
            items.product_id,
            items.product_title,
            count(*) AS last_120d_purchases,
            sum(public.if((items.ts > (now() - '14 days'::interval day)), 1, 0)) AS last_14d_purchases
           FROM public.byte_epcssold_120days items
          GROUP BY items.kiosk_id, items.kiosk_title, ((btrim((items.first_name)::text) || ' '::text) || btrim((items.last_name)::text)), items.product_id, items.product_title) t
  WHERE ((t.last_14d_purchases >= 1) AND (t.last_120d_purchases >= 6) AND (t.username <> ALL (ARRAY[''::text, 'Free Complimentary'::text])))
  GROUP BY t.kiosk_id, t.kiosk_title, t.product_id, t.product_title;
CREATE VIEW public.byte_epcssold_1month AS
 SELECT o.order_id,
    o.first_name,
    o.last_name,
    o.kiosk_id,
    o.kiosk_title,
    o.email,
    o.amount_paid,
    o.payment_system,
    o.transaction_id,
    o.approval_code,
    o.status_code,
    o.status_message,
    o.status,
    o.batch_id,
    o.created,
    o.auth_amount,
    o.data_token,
    o.time_opened,
    o.time_closed,
    o.card_hash,
    o.state,
    o.archived,
    o.stamp,
    o.last_update,
    o.balance,
    o.delta,
    o.coupon_id,
    o.coupon,
    o.refund,
    o.receipt,
    o.campus_id,
    o.amount_list_price,
    o.notes,
    o.time_door_opened,
    o.time_door_closed,
    o.client_name,
    o.estd_num_users,
    o.ts,
    o.full_name,
    o.door_opened_secs,
    o.month,
    o.week,
    o.date,
    o.dayofweek,
    o.hour,
    o.dowhour,
    o.uniq_user,
    lp.epc,
    lp.label_order_id,
    lp.label_status,
    lp.label_price,
    lp.time_created,
    lp.time_added,
    lp.time_updated,
    lp.ts_created,
    lp.ts_added,
    lp.ts_updated,
    lp.label_kiosk_id,
    lp.product_id,
    lp.product_title,
    lp.product_archived,
    lp.product_vendor,
    lp.product_price,
    lp.product_cost,
    lp.product_shelf_life_days,
    lp.product_attributes,
    lp.product_categories,
    lp.consumer_category,
    lp.product_source
   FROM (public.byte_tickets_1month o
     JOIN public.byte_label_product lp ON (((lp.label_order_id)::text = (o.order_id)::text)))
  WHERE ((lp.label_status)::text = 'sold'::text);
CREATE VIEW public.byte_epcssold_3days AS
 SELECT o.order_id,
    o.first_name,
    o.last_name,
    o.kiosk_id,
    o.kiosk_title,
    o.email,
    o.amount_paid,
    o.payment_system,
    o.transaction_id,
    o.approval_code,
    o.status_code,
    o.status_message,
    o.status,
    o.batch_id,
    o.created,
    o.auth_amount,
    o.data_token,
    o.time_opened,
    o.time_closed,
    o.card_hash,
    o.state,
    o.archived,
    o.stamp,
    o.last_update,
    o.balance,
    o.delta,
    o.coupon_id,
    o.coupon,
    o.refund,
    o.receipt,
    o.campus_id,
    o.amount_list_price,
    o.notes,
    o.time_door_opened,
    o.time_door_closed,
    o.client_name,
    o.estd_num_users,
    o.ts,
    o.full_name,
    o.door_opened_secs,
    o.month,
    o.week,
    o.date,
    o.dayofweek,
    o.hour,
    o.dowhour,
    o.uniq_user,
    lp.epc,
    lp.label_order_id,
    lp.label_status,
    lp.label_price,
    lp.time_created,
    lp.time_added,
    lp.time_updated,
    lp.ts_created,
    lp.ts_added,
    lp.ts_updated,
    lp.label_kiosk_id,
    lp.product_id,
    lp.product_title,
    lp.product_archived,
    lp.product_vendor,
    lp.product_price,
    lp.product_cost,
    lp.product_shelf_life_days,
    lp.product_attributes,
    lp.product_categories,
    lp.consumer_category,
    lp.product_source
   FROM (public.byte_tickets_3days o
     JOIN public.byte_label_product lp ON (((lp.label_order_id)::text = (o.order_id)::text)))
  WHERE ((lp.label_status)::text = 'sold'::text);
CREATE VIEW public.dp_spoilage_weekly_sold_join AS
 SELECT date_trunc('week'::text, dp_spoilage_daily_sold_join.date) AS week,
    dp_spoilage_daily_sold_join.kiosk_id,
    dp_spoilage_daily_sold_join.product_id,
    sum(dp_spoilage_daily_sold_join.spoiled) AS spoiled,
    sum(dp_spoilage_daily_sold_join.sold) AS sold,
    count(DISTINCT dp_spoilage_daily_sold_join.date) AS days_in_week
   FROM public.dp_spoilage_daily_sold_join
  GROUP BY (date_trunc('week'::text, dp_spoilage_daily_sold_join.date)), dp_spoilage_daily_sold_join.kiosk_id, dp_spoilage_daily_sold_join.product_id;
CREATE VIEW public.dp_spoilage_weekly_product_pct AS
 SELECT dp_spoilage_weekly_kiosk_product_pct.week,
    dp_spoilage_weekly_kiosk_product_pct.product_id,
    dp_spoilage_weekly_kiosk_product_pct.new_kiosk,
    sum(dp_spoilage_weekly_kiosk_product_pct.spoiled) AS spoiled_units,
    sum(dp_spoilage_weekly_kiosk_product_pct.sold) AS sold_units,
    public.frac(sum(dp_spoilage_weekly_kiosk_product_pct.spoiled), sum(dp_spoilage_weekly_kiosk_product_pct.sold)) AS spoiled_frac_units,
    sum(dp_spoilage_weekly_kiosk_product_pct.revenue) AS revenue,
    sum(dp_spoilage_weekly_kiosk_product_pct.cost) AS cost,
    sum((dp_spoilage_weekly_kiosk_product_pct.spoiled * dp_spoilage_weekly_kiosk_product_pct.unit_cost)) AS spoilage_dolr,
    sum(dp_spoilage_weekly_kiosk_product_pct.net_profit) AS net_profit,
    public.if((sum(dp_spoilage_weekly_kiosk_product_pct.sold) = (0)::numeric), 9999.0, (sum((dp_spoilage_weekly_kiosk_product_pct.spoiled * dp_spoilage_weekly_kiosk_product_pct.unit_cost)) / sum(dp_spoilage_weekly_kiosk_product_pct.revenue))) AS spoilage_frac_dolr
   FROM public.dp_spoilage_weekly_kiosk_product_pct
  GROUP BY dp_spoilage_weekly_kiosk_product_pct.week, dp_spoilage_weekly_kiosk_product_pct.product_id, dp_spoilage_weekly_kiosk_product_pct.new_kiosk
  ORDER BY dp_spoilage_weekly_kiosk_product_pct.product_id, dp_spoilage_weekly_kiosk_product_pct.week DESC, dp_spoilage_weekly_kiosk_product_pct.new_kiosk;
CREATE VIEW public.user_retention_3weeks AS
 SELECT user_retention_by_week.week,
    user_retention_by_week.num_consumers,
    user_retention_by_week.repeat_consumers,
    user_retention_by_week.num_tickets,
    user_retention_by_week.sum_amount_list_price,
    user_retention_by_week.sum_amount_paid,
    user_retention_by_week.num_repeat_tickets,
    user_retention_by_week.sum_repeat_amount_list_price,
    user_retention_by_week.sum_repeat_amount_paid,
    user_retention_by_week.frac_users_retained,
    user_retention_by_week.frac_tickets_retained,
    user_retention_by_week.frac_listprice_retained,
    user_retention_by_week.frac_amountpaid_retained,
    user_retention_by_week.old_week,
    user_retention_by_week.old_num_consumers,
    user_retention_by_week.old_repeat_consumers,
    user_retention_by_week.old_num_tickets,
    user_retention_by_week.old_sum_amount_list_price,
    user_retention_by_week.old_sum_amount_paid
   FROM public.user_retention_by_week(3) user_retention_by_week(week, num_consumers, repeat_consumers, num_tickets, sum_amount_list_price, sum_amount_paid, num_repeat_tickets, sum_repeat_amount_list_price, sum_repeat_amount_paid, frac_users_retained, frac_tickets_retained, frac_listprice_retained, frac_amountpaid_retained, old_week, old_num_consumers, old_repeat_consumers, old_num_tickets, old_sum_amount_list_price, old_sum_amount_paid);
CREATE VIEW byt_devops.pgdutotal AS
 SELECT 1 AS union_sort_order,
    'All db objects'::text AS table_name,
    sum(pgdudetail.table_size) AS table_size,
    to_char(((sum(pgdudetail.table_size) / sum(pgdudetail.total_size)) * (100)::numeric), '999D9%'::text) AS percent_table,
    sum(pgdudetail.indexes_size) AS indexes_size,
    to_char(((sum(pgdudetail.indexes_size) / sum(pgdudetail.total_size)) * (100)::numeric), '999D9%'::text) AS percent_index,
    sum(pgdudetail.total_size) AS total_size
   FROM byt_devops.pgdudetail;
CREATE VIEW mixalot.v_kiosk_item_log AS
 SELECT l.ts,
    l."time",
    l.request_uuid,
    l.endpoint,
    l.client_ip,
    l.version,
    l.cookie,
    l.message,
    l.request_body,
    l.request_headers,
    l.start_ts,
    l.response_body,
    l.response_headers,
    l.status_code,
    l.end_ts,
    l.traceback,
    l.request_body_json,
    l.request_headers_json,
    l.response_headers_json,
    l.kiosk_id,
    l.source,
    (((l.request_body_json)::json ->> 'epc'::text))::character varying AS epc,
    (((l.request_body_json)::json ->> 'direction'::text))::character varying AS direction,
    (((l.request_body_json)::json ->> 'rssi'::text))::integer AS rssi,
    (((l.request_body_json)::json ->> 'read_count'::text))::integer AS read_count
   FROM mixalot.v_kiosk_request_log l
  WHERE ((l.endpoint = '/item'::text) AND (l.source = 'mixalot'::text));
CREATE VIEW public.dp_spoilage_daily_sold_join AS
 SELECT COALESCE(t1.date, t2.date) AS date,
    COALESCE((t1.kiosk_id)::bigint, t2.kiosk_id) AS kiosk_id,
    COALESCE((t1.product_id)::bigint, t2.product_id) AS product_id,
    COALESCE(t1.spoiled, (0)::bigint) AS spoiled,
    COALESCE(t2.sold, (0)::bigint) AS sold
   FROM (( SELECT s.date,
            s.kiosk_id,
            s.product_id,
            count(*) AS spoiled
           FROM public.dp_spoilage s
          GROUP BY s.date, s.kiosk_id, s.product_id) t1
     FULL JOIN ( SELECT dp_epcssold.date,
            dp_epcssold.kiosk_id,
            dp_epcssold.product_id,
            count(*) AS sold
           FROM public.dp_epcssold
          GROUP BY dp_epcssold.date, dp_epcssold.kiosk_id, dp_epcssold.product_id) t2 ON (((t1.product_id = t2.product_id) AND (t1.date = t2.date) AND (t1.kiosk_id = t2.kiosk_id))));
CREATE VIEW public.byte_spoilage_by_week AS
 SELECT s.week,
    sum(public.if((s.ts_removed > k.new_ts), 1, 0)) AS spoilage_units_in_old_kiosks,
    sum(public.if((s.ts_removed <= k.new_ts), 1, 0)) AS spoilage_units_in_new_kiosks,
    count(*) AS spoilage_units_in_all_kiosks,
    sum(public.if((s.ts_removed > k.new_ts), s.cost, 0.0)) AS spoilage_dolr_in_old_kiosks,
    sum(public.if((s.ts_removed <= k.new_ts), s.cost, 0.0)) AS spoilage_dolr_in_new_kiosks,
    sum(s.cost) AS spoilage_dolr_in_all_kiosks
   FROM (public.byte_spoilage s
     JOIN public.byte_kiosks_date_non_new k ON ((s.kiosk_id = k.kiosk_id)))
  WHERE (s.ts_removed >= '2016-01-01 08:00:00+00'::timestamp with time zone)
  GROUP BY s.week
  ORDER BY s.week DESC;
CREATE VIEW public.byte_stockouts_by_category_week AS
 SELECT t1.week,
    (regexp_replace(regexp_replace(t1.cat_and_new, '_hrs_'::text, '_per_'::text), '_all'::text, ''::text) || '_kiosk'::text) AS cat_and_new,
    (t1.stockout_hrs / (
        CASE
            WHEN (t1.cat_and_new ~~ '%new%'::text) THEN t2.num_new_kiosks
            WHEN (t1.cat_and_new ~~ '%old%'::text) THEN t2.num_old_kiosks
            ELSE t2.num_all_kiosks
        END)::double precision) AS stockout_hrs
   FROM (( SELECT byte_stockouts_by_category_week_newold.week,
            byte_stockouts_by_category_week_newold.cat_and_new,
            byte_stockouts_by_category_week_newold.stockout_hrs
           FROM public.byte_stockouts_by_category_week_newold
        UNION
         SELECT byte_stockouts_by_category_week_all.week,
            byte_stockouts_by_category_week_all.cat_and_new,
            byte_stockouts_by_category_week_all.stockout_hrs
           FROM public.byte_stockouts_by_category_week_all) t1
     LEFT JOIN public.byte_kiosks_by_week t2 ON ((t1.week = t2.week)));
CREATE VIEW public.dp_spoilage_daily_kiosk_product_pct AS
 SELECT t.date,
    t.kiosk_id,
    t.product_id,
    t.spoiled,
    t.sold,
    t.product_title,
    t.kiosk_title,
    t.unit_price,
    t.unit_cost,
    t.spoiled_frac_units,
    t.revenue,
    t.cost,
    t.spoilage_frac,
    t.new_kiosk,
    (t.revenue - t.cost) AS net_profit
   FROM ( SELECT dpssj.date,
            dpssj.kiosk_id,
            dpssj.product_id,
            dpssj.spoiled,
            dpssj.sold,
            p.title AS product_title,
            k.title AS kiosk_title,
            p.price AS unit_price,
            p.cost AS unit_cost,
            public.frac((dpssj.spoiled)::numeric, (dpssj.sold)::numeric) AS spoiled_frac_units,
            ((dpssj.sold)::numeric * p.price) AS revenue,
            (((dpssj.spoiled + dpssj.sold))::numeric * p.cost) AS cost,
            public.if((dpssj.sold = 0), (9999.0)::double precision, (div(((dpssj.spoiled)::numeric * p.cost), ((dpssj.sold)::numeric * p.price)))::double precision) AS spoilage_frac,
            (dpssj.date < COALESCE(knn.new_ts, now())) AS new_kiosk
           FROM (((public.dp_spoilage_daily_sold_join dpssj
             LEFT JOIN pantry.product p ON ((dpssj.product_id = p.id)))
             LEFT JOIN public.byte_kiosks k ON ((dpssj.kiosk_id = k.id)))
             LEFT JOIN public.byte_kiosks_date_non_new knn ON ((k.id = knn.kiosk_id)))
          WHERE (dpssj.date >= '2016-01-01 08:00:00+00'::timestamp with time zone)) t
  ORDER BY t.date DESC;
CREATE VIEW public.dp_stockouts_weekly_pct AS
 SELECT dp_stockouts_weekly_kiosk_product_pct.week,
    dp_stockouts_weekly_kiosk_product_pct.new_kiosk,
    max(dp_stockouts_weekly_kiosk_product_pct.days_in_week) AS days_in_week,
    sum(dp_stockouts_weekly_kiosk_product_pct.spoiled) AS spoiled_units,
    sum(dp_stockouts_weekly_kiosk_product_pct.sold) AS sold_units,
    public.frac(sum(dp_stockouts_weekly_kiosk_product_pct.spoiled), sum(dp_stockouts_weekly_kiosk_product_pct.sold)) AS spoiled_frac_units,
    sum(dp_stockouts_weekly_kiosk_product_pct.revenue) AS revenue,
    sum(dp_stockouts_weekly_kiosk_product_pct.cost) AS cost,
    sum(((dp_stockouts_weekly_kiosk_product_pct.spoiled)::numeric * dp_stockouts_weekly_kiosk_product_pct.unit_cost)) AS stockouts_dolr,
    sum(dp_stockouts_weekly_kiosk_product_pct.net_profit) AS net_profit,
    (sum(((dp_stockouts_weekly_kiosk_product_pct.spoiled)::numeric * dp_stockouts_weekly_kiosk_product_pct.unit_cost)) / (0.0001 + sum(((dp_stockouts_weekly_kiosk_product_pct.sold)::numeric * dp_stockouts_weekly_kiosk_product_pct.unit_price)))) AS stockouts_frac_dolr
   FROM public.dp_stockouts_weekly_kiosk_product_pct
  GROUP BY dp_stockouts_weekly_kiosk_product_pct.week, dp_stockouts_weekly_kiosk_product_pct.new_kiosk
  ORDER BY dp_stockouts_weekly_kiosk_product_pct.week, dp_stockouts_weekly_kiosk_product_pct.new_kiosk DESC;
CREATE VIEW mixalot.inm_warehouse_sku_enabled AS
 SELECT p.sku,
    p.name,
    p.sku_group,
    1 AS scale
   FROM (( SELECT p_1.fc_title AS sku_group,
            p_1.id AS sku,
            p_1.title AS name
           FROM pantry.product p_1
          WHERE ((p_1.campus_id = 87) AND (p_1.archived = 0) AND ((p_1.fc_title)::text <> 'N/A'::text) AND (p_1.fc_title IS NOT NULL))
          ORDER BY p_1.fc_title, p_1.id) p
     LEFT JOIN ( SELECT p_1.id AS sku,
            count(*) AS units_sold
           FROM (pantry.label l_1
             JOIN pantry.product p_1 ON ((l_1.product_id = p_1.id)))
          WHERE ((l_1.kiosk_id IS NOT NULL) AND ((l_1.status)::text = 'sold'::text) AND (timezone('US/Pacific'::text, to_timestamp((l_1.time_updated)::double precision)) > (date_trunc('week'::text, CURRENT_TIMESTAMP) - '28 days'::interval)) AND (p_1.campus_id = 87) AND (p_1.archived = 0) AND ((p_1.fc_title)::text <> 'N/A'::text) AND (p_1.fc_title IS NOT NULL))
          GROUP BY p_1.id) l ON ((p.sku = l.sku)));
CREATE VIEW mixalot.kiosk_status AS
 SELECT l.kiosk_id AS auth_token_kiosk_id,
    l.start_ts AS server_time,
    to_timestamp(((((l.request_body_json)::json ->> 'time'::text))::integer)::double precision) AS "time",
    ((l.request_body_json)::json ->> 'kiosk_id'::text) AS kiosk_id,
    ((l.request_body_json)::json ->> 'retry_queue_length'::text) AS retry_queue_length,
    ((l.request_body_json)::json ->> 'retry_count'::text) AS retry_count,
    ((l.request_body_json)::json ->> 'happy_hour'::text) AS happy_hour,
    ((l.request_body_json)::json ->> 'app_uptime'::text) AS app_uptime,
    ((l.request_body_json)::json ->> 'system_uptime'::text) AS system_uptime,
    ((l.request_body_json)::json ->> 'kiosk_temperature'::text) AS kiosk_temperature,
    ((l.request_body_json)::json ->> 'kit_temperature'::text) AS kit_temperature,
    ((l.request_body_json)::json ->> 'power'::text) AS power,
    ((l.request_body_json)::json ->> 'battery_level'::text) AS battery_level,
    ((l.request_body_json)::json ->> 'rfid_0'::text) AS rfid_0,
    ((l.request_body_json)::json ->> 'rfid_1'::text) AS rfid_1,
    ((l.request_body_json)::json ->> 'rfid_2'::text) AS rfid_2,
    ((l.request_body_json)::json ->> 'rfid_3'::text) AS rfid_3,
    ((l.request_body_json)::json ->> 'rfid_4'::text) AS rfid_4,
    ((l.request_body_json)::json ->> 'rfid_5'::text) AS rfid_5,
    ((l.request_body_json)::json ->> 'rfid_6'::text) AS rfid_6,
    ((l.request_body_json)::json ->> 'rfid_7'::text) AS rfid_7
   FROM mixalot.request_log l
  WHERE ((((l.request_headers_json)::json ->> 'User-Agent'::text) !~~ '%monitis%'::text) AND (l.endpoint = '/status'::text))
  ORDER BY l.start_ts;
CREATE VIEW public.byte_epcssold_1day AS
 SELECT o.order_id,
    o.first_name,
    o.last_name,
    o.kiosk_id,
    o.kiosk_title,
    o.email,
    o.amount_paid,
    o.payment_system,
    o.transaction_id,
    o.approval_code,
    o.status_code,
    o.status_message,
    o.status,
    o.batch_id,
    o.created,
    o.auth_amount,
    o.data_token,
    o.time_opened,
    o.time_closed,
    o.card_hash,
    o.state,
    o.archived,
    o.stamp,
    o.last_update,
    o.balance,
    o.delta,
    o.coupon_id,
    o.coupon,
    o.refund,
    o.receipt,
    o.campus_id,
    o.amount_list_price,
    o.notes,
    o.time_door_opened,
    o.time_door_closed,
    o.client_name,
    o.estd_num_users,
    o.ts,
    o.full_name,
    o.door_opened_secs,
    o.month,
    o.week,
    o.date,
    o.dayofweek,
    o.hour,
    o.dowhour,
    o.uniq_user,
    lp.epc,
    lp.label_order_id,
    lp.label_status,
    lp.label_price,
    lp.time_created,
    lp.time_added,
    lp.time_updated,
    lp.ts_created,
    lp.ts_added,
    lp.ts_updated,
    lp.label_kiosk_id,
    lp.product_id,
    lp.product_title,
    lp.product_archived,
    lp.product_vendor,
    lp.product_price,
    lp.product_cost,
    lp.product_shelf_life_days,
    lp.product_attributes,
    lp.product_categories,
    lp.consumer_category,
    lp.product_source
   FROM (public.byte_tickets_1day o
     JOIN public.byte_label_product lp ON (((lp.label_order_id)::text = (o.order_id)::text)))
  WHERE ((lp.label_status)::text = 'sold'::text);
CREATE VIEW public.byte_tickets_365days AS
 SELECT byte_tickets.order_id,
    byte_tickets.first_name,
    byte_tickets.last_name,
    byte_tickets.kiosk_id,
    byte_tickets.kiosk_title,
    byte_tickets.email,
    byte_tickets.amount_paid,
    byte_tickets.payment_system,
    byte_tickets.transaction_id,
    byte_tickets.approval_code,
    byte_tickets.status_code,
    byte_tickets.status_message,
    byte_tickets.status,
    byte_tickets.batch_id,
    byte_tickets.created,
    byte_tickets.auth_amount,
    byte_tickets.data_token,
    byte_tickets.time_opened,
    byte_tickets.time_closed,
    byte_tickets.card_hash,
    byte_tickets.state,
    byte_tickets.archived,
    byte_tickets.stamp,
    byte_tickets.last_update,
    byte_tickets.balance,
    byte_tickets.delta,
    byte_tickets.coupon_id,
    byte_tickets.coupon,
    byte_tickets.refund,
    byte_tickets.receipt,
    byte_tickets.campus_id,
    byte_tickets.amount_list_price,
    byte_tickets.notes,
    byte_tickets.time_door_opened,
    byte_tickets.time_door_closed,
    byte_tickets.client_name,
    byte_tickets.estd_num_users,
    byte_tickets.ts,
    byte_tickets.full_name,
    byte_tickets.door_opened_secs,
    byte_tickets.month,
    byte_tickets.week,
    byte_tickets.date,
    byte_tickets.dayofweek,
    byte_tickets.hour,
    byte_tickets.dowhour,
    byte_tickets.uniq_user
   FROM public.byte_tickets
  WHERE (byte_tickets.ts > (now() - '365 days'::interval day));
CREATE VIEW public.sales_by_shelflife_120d AS
 SELECT public.if((byte_epcssold_120days.product_shelf_life_days > 30), 999, byte_epcssold_120days.product_shelf_life_days) AS shelf_life,
    sum(byte_epcssold_120days.product_price) AS sales
   FROM public.byte_epcssold_120days
  GROUP BY (public.if((byte_epcssold_120days.product_shelf_life_days > 30), 999, byte_epcssold_120days.product_shelf_life_days))
  ORDER BY (public.if((byte_epcssold_120days.product_shelf_life_days > 30), 999, byte_epcssold_120days.product_shelf_life_days));
CREATE VIEW monitor.kiosk_not_heard AS
 SELECT kiosk_last_beat.id,
    kiosk_last_beat.geo,
    kiosk_last_beat.title,
    kiosk_last_beat.last_heard,
    kiosk_last_beat.last_heart_beat_minutes,
    kiosk_last_beat.campus_id
   FROM ( SELECT ks.kiosk_id AS id,
            k.geo,
            k.title,
            k.last_inventory AS last_heard,
            round((date_part('epoch'::text, (CURRENT_TIMESTAMP - max(to_timestamp((ks."time")::double precision)))) / (60.0)::double precision)) AS last_heart_beat_minutes,
            k.campus_id
           FROM (pantry.kiosk_status ks
             JOIN pantry.kiosk k ON ((k.id = ks.kiosk_id)))
          WHERE ((k.archived = 0) AND (k.last_inventory > 0))
          GROUP BY ks.kiosk_id, k.title, k.geo, k.last_inventory, k.campus_id) kiosk_last_beat
  WHERE (kiosk_last_beat.last_heart_beat_minutes > (40)::double precision);
CREATE VIEW public.byte_epcssold_1week AS
 SELECT o.order_id,
    o.first_name,
    o.last_name,
    o.kiosk_id,
    o.kiosk_title,
    o.email,
    o.amount_paid,
    o.payment_system,
    o.transaction_id,
    o.approval_code,
    o.status_code,
    o.status_message,
    o.status,
    o.batch_id,
    o.created,
    o.auth_amount,
    o.data_token,
    o.time_opened,
    o.time_closed,
    o.card_hash,
    o.state,
    o.archived,
    o.stamp,
    o.last_update,
    o.balance,
    o.delta,
    o.coupon_id,
    o.coupon,
    o.refund,
    o.receipt,
    o.campus_id,
    o.amount_list_price,
    o.notes,
    o.time_door_opened,
    o.time_door_closed,
    o.client_name,
    o.estd_num_users,
    o.ts,
    o.full_name,
    o.door_opened_secs,
    o.month,
    o.week,
    o.date,
    o.dayofweek,
    o.hour,
    o.dowhour,
    o.uniq_user,
    lp.epc,
    lp.label_order_id,
    lp.label_status,
    lp.label_price,
    lp.time_created,
    lp.time_added,
    lp.time_updated,
    lp.ts_created,
    lp.ts_added,
    lp.ts_updated,
    lp.label_kiosk_id,
    lp.product_id,
    lp.product_title,
    lp.product_archived,
    lp.product_vendor,
    lp.product_price,
    lp.product_cost,
    lp.product_shelf_life_days,
    lp.product_attributes,
    lp.product_categories,
    lp.consumer_category,
    lp.product_source
   FROM (public.byte_tickets_1week o
     JOIN public.byte_label_product lp ON (((lp.label_order_id)::text = (o.order_id)::text)))
  WHERE ((lp.label_status)::text = 'sold'::text);
CREATE VIEW public.byte_epcssold_6weeks AS
 SELECT o.order_id,
    o.first_name,
    o.last_name,
    o.kiosk_id,
    o.kiosk_title,
    o.email,
    o.amount_paid,
    o.payment_system,
    o.transaction_id,
    o.approval_code,
    o.status_code,
    o.status_message,
    o.status,
    o.batch_id,
    o.created,
    o.auth_amount,
    o.data_token,
    o.time_opened,
    o.time_closed,
    o.card_hash,
    o.state,
    o.archived,
    o.stamp,
    o.last_update,
    o.balance,
    o.delta,
    o.coupon_id,
    o.coupon,
    o.refund,
    o.receipt,
    o.campus_id,
    o.amount_list_price,
    o.notes,
    o.time_door_opened,
    o.time_door_closed,
    o.client_name,
    o.estd_num_users,
    o.ts,
    o.full_name,
    o.door_opened_secs,
    o.month,
    o.week,
    o.date,
    o.dayofweek,
    o.hour,
    o.dowhour,
    o.uniq_user,
    lp.epc,
    lp.label_order_id,
    lp.label_status,
    lp.label_price,
    lp.time_created,
    lp.time_added,
    lp.time_updated,
    lp.ts_created,
    lp.ts_added,
    lp.ts_updated,
    lp.label_kiosk_id,
    lp.product_id,
    lp.product_title,
    lp.product_archived,
    lp.product_vendor,
    lp.product_price,
    lp.product_cost,
    lp.product_shelf_life_days,
    lp.product_attributes,
    lp.product_categories,
    lp.consumer_category,
    lp.product_source
   FROM (public.byte_tickets_6weeks o
     JOIN public.byte_label_product lp ON (((lp.label_order_id)::text = (o.order_id)::text)))
  WHERE ((lp.label_status)::text = 'sold'::text);
CREATE VIEW public.dp_spoilage_monthly_sold_join AS
 SELECT COALESCE(t1.month, t2.month) AS month,
    COALESCE((t1.kiosk_id)::bigint, t2.kiosk_id) AS kiosk_id,
    COALESCE((t1.product_id)::bigint, t2.product_id) AS product_id,
    COALESCE(t1.spoiled, (0)::bigint) AS spoiled,
    COALESCE(t2.sold, (0)::bigint) AS sold
   FROM (( SELECT s.month,
            s.kiosk_id,
            s.product_id,
            count(*) AS spoiled
           FROM public.dp_spoilage s
          GROUP BY s.month, s.kiosk_id, s.product_id) t1
     FULL JOIN ( SELECT dp_epcssold.month,
            dp_epcssold.kiosk_id,
            dp_epcssold.product_id,
            count(*) AS sold
           FROM public.dp_epcssold
          GROUP BY dp_epcssold.month, dp_epcssold.kiosk_id, dp_epcssold.product_id) t2 ON (((t1.product_id = t2.product_id) AND (t1.month = t2.month) AND (t1.kiosk_id = t2.kiosk_id))));
CREATE VIEW public.byte_epcssold_4months AS
 SELECT o.order_id,
    o.first_name,
    o.last_name,
    o.kiosk_id,
    o.kiosk_title,
    o.email,
    o.amount_paid,
    o.payment_system,
    o.transaction_id,
    o.approval_code,
    o.status_code,
    o.status_message,
    o.status,
    o.batch_id,
    o.created,
    o.auth_amount,
    o.data_token,
    o.time_opened,
    o.time_closed,
    o.card_hash,
    o.state,
    o.archived,
    o.stamp,
    o.last_update,
    o.balance,
    o.delta,
    o.coupon_id,
    o.coupon,
    o.refund,
    o.receipt,
    o.campus_id,
    o.amount_list_price,
    o.notes,
    o.time_door_opened,
    o.time_door_closed,
    o.client_name,
    o.estd_num_users,
    o.ts,
    o.full_name,
    o.door_opened_secs,
    o.month,
    o.week,
    o.date,
    o.dayofweek,
    o.hour,
    o.dowhour,
    o.uniq_user,
    lp.epc,
    lp.label_order_id,
    lp.label_status,
    lp.label_price,
    lp.time_created,
    lp.time_added,
    lp.time_updated,
    lp.ts_created,
    lp.ts_added,
    lp.ts_updated,
    lp.label_kiosk_id,
    lp.product_id,
    lp.product_title,
    lp.product_archived,
    lp.product_vendor,
    lp.product_price,
    lp.product_cost,
    lp.product_shelf_life_days,
    lp.product_attributes,
    lp.product_categories,
    lp.consumer_category,
    lp.product_source
   FROM (public.byte_tickets_4months o
     JOIN public.byte_label_product lp ON (((lp.label_order_id)::text = (o.order_id)::text)))
  WHERE ((lp.label_status)::text = 'sold'::text);
CREATE VIEW byt_devops.pgdu_pretty AS
 SELECT pgdu_union_pretty.table_name,
    pgdu_union_pretty.table_size,
    pgdu_union_pretty.percent_table,
    pgdu_union_pretty.indexes_size,
    pgdu_union_pretty.percent_index,
    pgdu_union_pretty.total_size
   FROM byt_devops.pgdu_union_pretty;
CREATE VIEW public.byte_epcssold_180days AS
 SELECT o.order_id,
    o.first_name,
    o.last_name,
    o.kiosk_id,
    o.kiosk_title,
    o.email,
    o.amount_paid,
    o.payment_system,
    o.transaction_id,
    o.approval_code,
    o.status_code,
    o.status_message,
    o.status,
    o.batch_id,
    o.created,
    o.auth_amount,
    o.data_token,
    o.time_opened,
    o.time_closed,
    o.card_hash,
    o.state,
    o.archived,
    o.stamp,
    o.last_update,
    o.balance,
    o.delta,
    o.coupon_id,
    o.coupon,
    o.refund,
    o.receipt,
    o.campus_id,
    o.amount_list_price,
    o.notes,
    o.time_door_opened,
    o.time_door_closed,
    o.client_name,
    o.estd_num_users,
    o.ts,
    o.full_name,
    o.door_opened_secs,
    o.month,
    o.week,
    o.date,
    o.dayofweek,
    o.hour,
    o.dowhour,
    o.uniq_user,
    lp.epc,
    lp.label_order_id,
    lp.label_status,
    lp.label_price,
    lp.time_created,
    lp.time_added,
    lp.time_updated,
    lp.ts_created,
    lp.ts_added,
    lp.ts_updated,
    lp.label_kiosk_id,
    lp.product_id,
    lp.product_title,
    lp.product_archived,
    lp.product_vendor,
    lp.product_price,
    lp.product_cost,
    lp.product_shelf_life_days,
    lp.product_attributes,
    lp.product_categories,
    lp.consumer_category,
    lp.product_source
   FROM (public.byte_tickets_180days o
     JOIN public.byte_label_product lp ON (((lp.label_order_id)::text = (o.order_id)::text)))
  WHERE ((lp.label_status)::text = 'sold'::text);
CREATE VIEW public.byte_stockouts_by_week AS
 SELECT s.week,
    sum(public.if((s.ts >= k.new_ts), 1, 0)) AS stockout_units_in_old_kiosks,
    sum(public.if((s.ts < k.new_ts), 1, 0)) AS stockout_units_in_new_kiosks,
    count(*) AS stockout_units_in_all_kiosks,
    (sum(public.if((s.ts >= k.new_ts), (date_part('minute'::text, (s.restock_ts - s.ts)))::numeric, 0.0)) / 60.0) AS stockout_hrs_in_old_kiosks,
    (sum(public.if((s.ts < k.new_ts), (date_part('minute'::text, (s.restock_ts - s.ts)))::numeric, 0.0)) / 60.0) AS stockout_hrs_in_new_kiosks,
    sum((date_part('minute'::text, (s.restock_ts - s.ts)) / (60.0)::double precision)) AS stockout_hrs_in_all_kiosks
   FROM (public.byte_stockouts s
     JOIN public.byte_kiosks_date_non_new k ON ((s.kiosk_id = k.kiosk_id)))
  WHERE (s.ts >= '2016-01-01 08:00:00+00'::timestamp with time zone)
  GROUP BY s.week
  ORDER BY s.week DESC;
CREATE VIEW public.stockout_weighted AS
 WITH _unused AS (
         SELECT 1
        ), stockout_weighted AS (
         SELECT stockout_runs_weighted.kiosk_id,
            stockout_runs_weighted.product_id,
            min(stockout_runs_weighted.cat) AS cat,
            sum(stockout_runs_weighted.stockout_len) AS stockout_len,
            sum(stockout_runs_weighted.avg_cat_kiosk_sales) AS avg_cat_kiosk_sales,
            sum(stockout_runs_weighted.avg_cat_sales) AS avg_cat_sales,
            sum(stockout_runs_weighted.avg_kiosk_sales) AS avg_kiosk_sales
           FROM public.stockout_runs_weighted
          GROUP BY stockout_runs_weighted.kiosk_id, stockout_runs_weighted.product_id
        )
 SELECT stockout_weighted.kiosk_id,
    stockout_weighted.product_id,
    stockout_weighted.cat,
    stockout_weighted.stockout_len,
    stockout_weighted.avg_cat_kiosk_sales,
    stockout_weighted.avg_cat_sales,
    stockout_weighted.avg_kiosk_sales
   FROM stockout_weighted;
CREATE VIEW public.dp_spoilage_daily_product_pct AS
 SELECT dp_spoilage_daily_kiosk_product_pct.date,
    dp_spoilage_daily_kiosk_product_pct.product_id,
    dp_spoilage_daily_kiosk_product_pct.new_kiosk,
    sum(dp_spoilage_daily_kiosk_product_pct.spoiled) AS spoiled_units,
    sum(dp_spoilage_daily_kiosk_product_pct.sold) AS sold_units,
    public.frac(sum(dp_spoilage_daily_kiosk_product_pct.spoiled), sum(dp_spoilage_daily_kiosk_product_pct.sold)) AS spoiled_frac_units,
    sum(dp_spoilage_daily_kiosk_product_pct.revenue) AS revenue,
    sum(dp_spoilage_daily_kiosk_product_pct.cost) AS cost,
    sum(((dp_spoilage_daily_kiosk_product_pct.spoiled)::numeric * dp_spoilage_daily_kiosk_product_pct.unit_cost)) AS spoilage_dolr,
    sum(dp_spoilage_daily_kiosk_product_pct.net_profit) AS net_profit,
    public.if((sum(dp_spoilage_daily_kiosk_product_pct.sold) = (0)::numeric), 9999.0, (sum(((dp_spoilage_daily_kiosk_product_pct.spoiled)::numeric * dp_spoilage_daily_kiosk_product_pct.unit_cost)) / sum(dp_spoilage_daily_kiosk_product_pct.revenue))) AS spoilage_frac_dolr
   FROM public.dp_spoilage_daily_kiosk_product_pct
  GROUP BY dp_spoilage_daily_kiosk_product_pct.date, dp_spoilage_daily_kiosk_product_pct.product_id, dp_spoilage_daily_kiosk_product_pct.new_kiosk
  ORDER BY dp_spoilage_daily_kiosk_product_pct.product_id, dp_spoilage_daily_kiosk_product_pct.date DESC, dp_spoilage_daily_kiosk_product_pct.new_kiosk;
CREATE VIEW public.dp_stockouts_8weeks AS
 SELECT dp_stockouts.kiosk_id,
    dp_stockouts.order_id,
    dp_stockouts.product_id,
    dp_stockouts.ts,
    dp_stockouts.restock_ts,
    dp_stockouts.restock_order_id,
    dp_stockouts.id,
    dp_stockouts.title,
    dp_stockouts.description,
    dp_stockouts.tiny_description,
    dp_stockouts.short_description,
    dp_stockouts.medium_description,
    dp_stockouts.long_description,
    dp_stockouts.price,
    dp_stockouts.cost,
    dp_stockouts.shelf_time,
    dp_stockouts.campus_id,
    dp_stockouts.image,
    dp_stockouts.image_time,
    dp_stockouts.last_update,
    dp_stockouts.archived,
    dp_stockouts.taxable,
    dp_stockouts.allergens,
    dp_stockouts.attribute_names,
    dp_stockouts.categories,
    dp_stockouts.category_names,
    dp_stockouts.vendor,
    dp_stockouts.source,
    dp_stockouts.notes,
    dp_stockouts.total_cal,
    dp_stockouts.num_servings,
    dp_stockouts.ingredients,
    dp_stockouts.calories,
    dp_stockouts.proteins,
    dp_stockouts.sugar,
    dp_stockouts.carbohydrates,
    dp_stockouts.fat,
    dp_stockouts.consumer_category,
    dp_stockouts.ws_case_size,
    dp_stockouts.kiosk_ship_qty,
    dp_stockouts.ws_case_cost,
    dp_stockouts.pick_station,
    dp_stockouts.fc_title,
    dp_stockouts.pricing_tier,
    dp_stockouts.width_space,
    dp_stockouts.height_space,
    dp_stockouts.depth_space,
    dp_stockouts.slotted_width,
    dp_stockouts.tag_volume,
    dp_stockouts.delivery_option,
    dp_stockouts.kiosk_title,
    dp_stockouts.address,
    dp_stockouts.location_x,
    dp_stockouts.location_y,
    dp_stockouts.client_name,
    dp_stockouts.tags,
    dp_stockouts.estd_num_users,
    dp_stockouts.month,
    dp_stockouts.week,
    dp_stockouts.date
   FROM public.dp_stockouts
  WHERE (dp_stockouts.ts > (now() - '56 days'::interval day));
CREATE VIEW public.spoilagepct_by_shelflife_30d AS
 SELECT t1.shelf_life,
    sum(t1.sales) AS sales,
    sum(t2.spoilage_dolr) AS spoilage_dolr,
    public.if((sum(t2.spoilage_dolr) > 0.0), (sum(t2.spoilage_dolr) / sum(t1.sales)), 0.0) AS spoilage_frac
   FROM (public.sales_by_shelflife_30d t1
     JOIN public.spoilage_by_shelflife_30d t2 ON ((t1.shelf_life = t2.shelf_life)))
  GROUP BY t1.shelf_life
  ORDER BY t1.shelf_life;
CREATE VIEW public.byte_kiosks_date_non_new AS
 SELECT kiosks_date_non_new.kiosk_id,
    to_timestamp((kiosks_date_non_new.new_ts)::double precision) AS new_ts
   FROM pantry.kiosks_date_non_new;
CREATE VIEW public.byte_label_product_fast WITH (security_barrier='false') AS
 SELECT l.epc,
    l.order_id AS label_order_id,
    l.status AS label_status,
    l.price AS label_price,
    l.time_created,
    l.time_added,
    l.time_updated,
    to_timestamp((l.time_created)::double precision) AS ts_created,
    to_timestamp((l.time_added)::double precision) AS ts_added,
    to_timestamp((l.time_updated)::double precision) AS ts_updated,
    l.kiosk_id AS label_kiosk_id,
    p.id AS product_id,
    p.title AS product_title,
    p.archived AS product_archived,
    p.vendor AS product_vendor,
    p.price AS product_price,
    p.cost AS product_cost,
    p.shelf_life_days AS product_shelf_life_days,
    p.categories AS product_categories,
    p.consumer_category,
    p.source AS product_source,
    p.fc_title
   FROM (pantry.label l
     JOIN public.byte_products_fast p ON ((l.product_id = p.id)));
CREATE VIEW public.stockout_dowhours_weighted AS
 WITH _unused AS (
         SELECT 1
        ), stockout_dowhours_weighted AS (
         SELECT st.kiosk_id,
            st.product_id,
            st.cat,
            st.ts,
            st.restock_ts,
            st.dowhour,
            st.stockout_len,
            sa.avg_cat_kiosk_sales,
            sa.avg_cat_sales,
            sa.avg_kiosk_sales
           FROM (public.stockout_dowhours st
             JOIN public.stockout_avg_kiosk_cat_sales_dowhour sa ON (((st.dowhour = sa.dowhour) AND (st.kiosk_id = sa.kiosk_id) AND ((st.cat)::text = (sa.cat)::text))))
        )
 SELECT stockout_dowhours_weighted.kiosk_id,
    stockout_dowhours_weighted.product_id,
    stockout_dowhours_weighted.cat,
    stockout_dowhours_weighted.ts,
    stockout_dowhours_weighted.restock_ts,
    stockout_dowhours_weighted.dowhour,
    stockout_dowhours_weighted.stockout_len,
    stockout_dowhours_weighted.avg_cat_kiosk_sales,
    stockout_dowhours_weighted.avg_cat_sales,
    stockout_dowhours_weighted.avg_kiosk_sales
   FROM stockout_dowhours_weighted;
CREATE VIEW public.byte_tickets_1week AS
 SELECT byte_tickets.order_id,
    byte_tickets.first_name,
    byte_tickets.last_name,
    byte_tickets.kiosk_id,
    byte_tickets.kiosk_title,
    byte_tickets.email,
    byte_tickets.amount_paid,
    byte_tickets.payment_system,
    byte_tickets.transaction_id,
    byte_tickets.approval_code,
    byte_tickets.status_code,
    byte_tickets.status_message,
    byte_tickets.status,
    byte_tickets.batch_id,
    byte_tickets.created,
    byte_tickets.auth_amount,
    byte_tickets.data_token,
    byte_tickets.time_opened,
    byte_tickets.time_closed,
    byte_tickets.card_hash,
    byte_tickets.state,
    byte_tickets.archived,
    byte_tickets.stamp,
    byte_tickets.last_update,
    byte_tickets.balance,
    byte_tickets.delta,
    byte_tickets.coupon_id,
    byte_tickets.coupon,
    byte_tickets.refund,
    byte_tickets.receipt,
    byte_tickets.campus_id,
    byte_tickets.amount_list_price,
    byte_tickets.notes,
    byte_tickets.time_door_opened,
    byte_tickets.time_door_closed,
    byte_tickets.client_name,
    byte_tickets.estd_num_users,
    byte_tickets.ts,
    byte_tickets.full_name,
    byte_tickets.door_opened_secs,
    byte_tickets.month,
    byte_tickets.week,
    byte_tickets.date,
    byte_tickets.dayofweek,
    byte_tickets.hour,
    byte_tickets.dowhour,
    byte_tickets.uniq_user
   FROM public.byte_tickets
  WHERE (byte_tickets.ts > (now() - '7 days'::interval day));
CREATE VIEW public.user_retention_8weeks AS
 SELECT user_retention_by_week.week,
    user_retention_by_week.num_consumers,
    user_retention_by_week.repeat_consumers,
    user_retention_by_week.num_tickets,
    user_retention_by_week.sum_amount_list_price,
    user_retention_by_week.sum_amount_paid,
    user_retention_by_week.num_repeat_tickets,
    user_retention_by_week.sum_repeat_amount_list_price,
    user_retention_by_week.sum_repeat_amount_paid,
    user_retention_by_week.frac_users_retained,
    user_retention_by_week.frac_tickets_retained,
    user_retention_by_week.frac_listprice_retained,
    user_retention_by_week.frac_amountpaid_retained,
    user_retention_by_week.old_week,
    user_retention_by_week.old_num_consumers,
    user_retention_by_week.old_repeat_consumers,
    user_retention_by_week.old_num_tickets,
    user_retention_by_week.old_sum_amount_list_price,
    user_retention_by_week.old_sum_amount_paid
   FROM public.user_retention_by_week(8) user_retention_by_week(week, num_consumers, repeat_consumers, num_tickets, sum_amount_list_price, sum_amount_paid, num_repeat_tickets, sum_repeat_amount_list_price, sum_repeat_amount_paid, frac_users_retained, frac_tickets_retained, frac_listprice_retained, frac_amountpaid_retained, old_week, old_num_consumers, old_repeat_consumers, old_num_tickets, old_sum_amount_list_price, old_sum_amount_paid);
CREATE VIEW public.byte_dc_inventory_history AS
 SELECT iplanner_inventory.dccode AS dc,
    iplanner_inventory.bytesku AS product_id,
    iplanner_inventory.date,
    iplanner_inventory.inventory_count
   FROM public.iplanner_inventory;
CREATE VIEW public.spoilagepct_by_shelflife_45d AS
 SELECT t1.shelf_life,
    sum(t1.sales) AS sales,
    sum(t2.spoilage_dolr) AS spoilage_dolr,
    public.if((sum(t2.spoilage_dolr) > 0.0), (sum(t2.spoilage_dolr) / sum(t1.sales)), 0.0) AS spoilage_frac
   FROM (public.sales_by_shelflife_45d t1
     JOIN public.spoilage_by_shelflife_45d t2 ON ((t1.shelf_life = t2.shelf_life)))
  GROUP BY t1.shelf_life
  ORDER BY t1.shelf_life;
CREATE VIEW public.byte_tickets_60days AS
 SELECT byte_tickets.order_id,
    byte_tickets.first_name,
    byte_tickets.last_name,
    byte_tickets.kiosk_id,
    byte_tickets.kiosk_title,
    byte_tickets.email,
    byte_tickets.amount_paid,
    byte_tickets.payment_system,
    byte_tickets.transaction_id,
    byte_tickets.approval_code,
    byte_tickets.status_code,
    byte_tickets.status_message,
    byte_tickets.status,
    byte_tickets.batch_id,
    byte_tickets.created,
    byte_tickets.auth_amount,
    byte_tickets.data_token,
    byte_tickets.time_opened,
    byte_tickets.time_closed,
    byte_tickets.card_hash,
    byte_tickets.state,
    byte_tickets.archived,
    byte_tickets.stamp,
    byte_tickets.last_update,
    byte_tickets.balance,
    byte_tickets.delta,
    byte_tickets.coupon_id,
    byte_tickets.coupon,
    byte_tickets.refund,
    byte_tickets.receipt,
    byte_tickets.campus_id,
    byte_tickets.amount_list_price,
    byte_tickets.notes,
    byte_tickets.time_door_opened,
    byte_tickets.time_door_closed,
    byte_tickets.client_name,
    byte_tickets.estd_num_users,
    byte_tickets.ts,
    byte_tickets.full_name,
    byte_tickets.door_opened_secs,
    byte_tickets.month,
    byte_tickets.week,
    byte_tickets.date,
    byte_tickets.dayofweek,
    byte_tickets.hour,
    byte_tickets.dowhour,
    byte_tickets.uniq_user
   FROM public.byte_tickets
  WHERE (byte_tickets.ts > (now() - '60 days'::interval day));
CREATE VIEW public.byte_kiosks_with_perm_subsidy AS
 SELECT k.id,
    k.campus_id,
    k.serial,
    k.title,
    k.address,
    k.location_x,
    k.location_y,
    k.gcm_id,
    k.app_vname,
    k.app_vcode,
    k.archived,
    k.creation_time,
    k.deployment_time,
    k.last_update,
    k.client_name,
    k.last_status,
    k.last_inventory,
    k.kiosk_name,
    k.payment_start,
    k.payment_stop,
    k.features,
    k.sales_tax,
    k.default_fee_plan,
    k.timezone,
    k.estd_num_users,
    k.tags,
    k.publicly_accessible,
    k.cardkey_required,
    k.delivery_insns,
    k.fridge_loc_info,
    k.contact_first_name,
    k.contact_last_name,
    k.contact_email,
    k.contact_phone,
    k.accounting_email,
    k.byte_discount,
    k.subsidy_info,
    k.subsidy_notes,
    k.max_subscription,
    k.delivery_window_mon,
    k.delivery_window_tue,
    k.delivery_window_wed,
    k.delivery_window_thu,
    k.delivery_window_fri,
    k.delivery_window_sat,
    k.delivery_window_sun,
    k.notes,
    k.components,
    k.email_receipt_subject,
    k.ops_team_notes,
    k.geo,
    k.server_url,
    k.subscription_amount,
    k.enable_reporting,
    k.enable_monitoring,
    k.employees_num,
    k.kiosk_restrictions,
    k.first_restock,
    k.first_full_month
   FROM public.byte_kiosks k
  WHERE ((k.id IN ( SELECT discount.kiosk_id
           FROM pantry.discount)) OR ((k.id)::text IN ( SELECT regexp_split_to_table(string_agg((cron.kiosks)::text, ','::text), ','::text) AS regexp_split_to_table
           FROM pantry.cron
          WHERE ((cron.archived = 0) AND ((cron.command)::text = 'happy'::text) AND (cron.payload !~~ '%onetime":true%'::text) AND (cron.group_id = 80)))));
CREATE VIEW public.byte_users_products_4months AS
 SELECT t1.full_name,
    t1.products
   FROM ( SELECT btrim(byte_epcssold_4months.full_name) AS full_name,
            public.sort(array_agg(DISTINCT (byte_epcssold_4months.product_id)::integer)) AS products
           FROM public.byte_epcssold_4months
          WHERE ((btrim(byte_epcssold_4months.full_name) ~~ '% %'::text) AND (byte_epcssold_4months.full_name <> ''::text))
          GROUP BY byte_epcssold_4months.full_name) t1
  WHERE (array_length(t1.products, 1) > 1);
CREATE VIEW public.spoilage_by_category_120d AS
 SELECT byte_spoilage.consumer_category,
    sum(byte_spoilage.cost) AS spoilage_120d,
    sum(public.if(((byte_spoilage.ts_removed >= (now() - '30 days'::interval day)) AND (byte_spoilage.ts_removed <= (now() - '00:00:00'::interval day))), byte_spoilage.cost, 0.0)) AS spoilage_0d_30d,
    sum(public.if(((byte_spoilage.ts_removed >= (now() - '60 days'::interval day)) AND (byte_spoilage.ts_removed <= (now() - '30 days'::interval day))), byte_spoilage.cost, 0.0)) AS spoilage_30d_60d,
    sum(public.if(((byte_spoilage.ts_removed >= (now() - '90 days'::interval day)) AND (byte_spoilage.ts_removed <= (now() - '60 days'::interval day))), byte_spoilage.cost, 0.0)) AS spoilage_60d_90d,
    sum(public.if(((byte_spoilage.ts_removed >= (now() - '120 days'::interval day)) AND (byte_spoilage.ts_removed <= (now() - '90 days'::interval day))), byte_spoilage.cost, 0.0)) AS spoilage_90d_120d
   FROM public.byte_spoilage
  WHERE (byte_spoilage.ts_removed > (now() - '120 days'::interval day))
  GROUP BY byte_spoilage.consumer_category;
CREATE VIEW public.byte_epcssold_2016 AS
 SELECT o.order_id,
    o.first_name,
    o.last_name,
    o.kiosk_id,
    o.kiosk_title,
    o.email,
    o.amount_paid,
    o.payment_system,
    o.transaction_id,
    o.approval_code,
    o.status_code,
    o.status_message,
    o.status,
    o.batch_id,
    o.created,
    o.auth_amount,
    o.data_token,
    o.time_opened,
    o.time_closed,
    o.card_hash,
    o.state,
    o.archived,
    o.stamp,
    o.last_update,
    o.balance,
    o.delta,
    o.coupon_id,
    o.coupon,
    o.refund,
    o.receipt,
    o.campus_id,
    o.amount_list_price,
    o.notes,
    o.time_door_opened,
    o.time_door_closed,
    o.client_name,
    o.estd_num_users,
    o.ts,
    o.full_name,
    o.door_opened_secs,
    o.month,
    o.week,
    o.date,
    o.dayofweek,
    o.hour,
    o.dowhour,
    o.uniq_user,
    lp.epc,
    lp.label_order_id,
    lp.label_status,
    lp.label_price,
    lp.time_created,
    lp.time_added,
    lp.time_updated,
    lp.ts_created,
    lp.ts_added,
    lp.ts_updated,
    lp.label_kiosk_id,
    lp.product_id,
    lp.product_title,
    lp.product_archived,
    lp.product_vendor,
    lp.product_price,
    lp.product_cost,
    lp.product_shelf_life_days,
    lp.product_attributes,
    lp.product_categories,
    lp.consumer_category,
    lp.product_source
   FROM (public.byte_tickets_2016 o
     JOIN public.byte_label_product lp ON (((lp.label_order_id)::text = (o.order_id)::text)))
  WHERE ((lp.label_status)::text = 'sold'::text);
CREATE VIEW public.byte_spoilage_stockouts_by_week AS
 SELECT t1.week,
    ((t3.stockout_units_in_old_kiosks)::double precision / (t4.num_old_kiosks)::double precision) AS avg_stockout_units_per_old_kiosk,
    public.if((t4.num_new_kiosks > 0), ((t3.stockout_units_in_new_kiosks)::double precision / (t4.num_new_kiosks)::double precision), (0.0)::double precision) AS avg_stockout_units_per_new_kiosk,
    ((t3.stockout_units_in_all_kiosks)::double precision / (t4.num_all_kiosks)::double precision) AS avg_stockout_units_per_all_kiosk,
    (t3.stockout_hrs_in_old_kiosks / (t4.num_old_kiosks)::numeric) AS avg_stockout_hrs_per_old_kiosk,
    public.if((t4.num_new_kiosks > 0), ((t3.stockout_hrs_in_new_kiosks)::double precision / (t4.num_new_kiosks)::double precision), (0.0)::double precision) AS avg_stockout_hrs_per_new_kiosk,
    (t3.stockout_hrs_in_all_kiosks / (t4.num_all_kiosks)::double precision) AS avg_stockout_hrs_per_all_kiosk,
    (t2.spoilage_dolr_in_old_kiosks / t1.sales_listprc_in_old_kiosks) AS spoilage_frac_in_old_kiosks,
    public.if((t1.sales_listprc_in_new_kiosks > 0.0), ((t2.spoilage_dolr_in_new_kiosks)::double precision / (t1.sales_listprc_in_new_kiosks)::double precision), (0.0)::double precision) AS spoilage_frac_in_new_kiosks,
    (t2.spoilage_dolr_in_all_kiosks / t1.sales_listprc_in_all_kiosks) AS spoilage_frac_in_all_kiosks,
    t4.num_old_kiosks,
    t4.num_new_kiosks,
    t4.num_all_kiosks,
    t1.sales_units_in_old_kiosks,
    t1.sales_units_in_new_kiosks,
    t1.sales_units_in_all_kiosks,
    t1.sales_listprc_in_old_kiosks,
    t1.sales_listprc_in_new_kiosks,
    t1.sales_listprc_in_all_kiosks,
    t1.sales_actualprc_in_old_kiosks,
    t1.sales_actualprc_in_new_kiosks,
    t1.sales_actualprc_in_all_kiosks,
    t1.cost_list_in_old_kiosks,
    t1.cost_list_in_new_kiosks,
    t1.cost_list_in_all_kiosks,
    t3.stockout_units_in_old_kiosks,
    t3.stockout_units_in_new_kiosks,
    t3.stockout_units_in_all_kiosks,
    t3.stockout_hrs_in_old_kiosks,
    t3.stockout_hrs_in_new_kiosks,
    t3.stockout_hrs_in_all_kiosks,
    t2.spoilage_units_in_old_kiosks,
    t2.spoilage_units_in_new_kiosks,
    t2.spoilage_units_in_all_kiosks,
    t2.spoilage_dolr_in_old_kiosks,
    t2.spoilage_dolr_in_new_kiosks,
    t2.spoilage_dolr_in_all_kiosks
   FROM (((public.byte_sales_by_week t1
     JOIN public.byte_spoilage_by_week t2 ON ((t1.week = t2.week)))
     JOIN public.byte_stockouts_by_week t3 ON ((t1.week = t3.week)))
     JOIN public.byte_kiosks_by_week t4 ON ((t1.week = t4.week)))
  ORDER BY t1.week DESC;
CREATE VIEW iplanner.insync_kiosk_v1 AS
 SELECT kiosk.id,
    kiosk.campus_id,
    kiosk.title,
    kiosk.address,
    kiosk.location_x,
    kiosk.location_y,
    kiosk.archived,
    kiosk.creation_time,
    kiosk.deployment_time,
    kiosk.last_update,
    kiosk.client_name,
    kiosk.last_inventory,
    kiosk.kiosk_name,
    kiosk.payment_start,
    kiosk.payment_stop,
    kiosk.timezone,
    kiosk.estd_num_users,
    kiosk.delivery_window_mon,
    kiosk.delivery_window_tue,
    kiosk.delivery_window_wed,
    kiosk.delivery_window_thu,
    kiosk.delivery_window_fri,
    kiosk.delivery_window_sat,
    kiosk.delivery_window_sun,
    kiosk.geo,
    kiosk.kiosk_restrictions
   FROM pantry.kiosk
  WHERE ((kiosk.campus_id = 87) AND (kiosk.archived <> 1) AND ((kiosk.title)::text !~~* 'test%'::text) AND ((kiosk.title)::text !~~* 'burn%'::text));
CREATE VIEW mixalot.v_node_kiosk_request_log AS
 SELECT l.start_ts AS ts,
    (((l.request_body_json)::json ->> 'time'::text))::bigint AS "time",
    l.request_uuid,
    l.endpoint,
    l.client_ip,
    l.version,
    l.cookie,
    l.message,
    l.request_body,
    l.request_headers,
    l.start_ts,
    l.response_body,
    l.response_headers,
    l.status_code,
    l.end_ts,
    l.traceback,
    l.request_body_json,
    l.request_headers_json,
    l.response_headers_json,
    l.kiosk_id,
    l.source
   FROM mixalot.request_log l
  WHERE (l.source = 'node'::text);
CREATE VIEW public.byte_epcssold_2015 AS
 SELECT o.order_id,
    o.first_name,
    o.last_name,
    o.kiosk_id,
    o.kiosk_title,
    o.email,
    o.amount_paid,
    o.payment_system,
    o.transaction_id,
    o.approval_code,
    o.status_code,
    o.status_message,
    o.status,
    o.batch_id,
    o.created,
    o.auth_amount,
    o.data_token,
    o.time_opened,
    o.time_closed,
    o.card_hash,
    o.state,
    o.archived,
    o.stamp,
    o.last_update,
    o.balance,
    o.delta,
    o.coupon_id,
    o.coupon,
    o.refund,
    o.receipt,
    o.campus_id,
    o.amount_list_price,
    o.notes,
    o.time_door_opened,
    o.time_door_closed,
    o.client_name,
    o.estd_num_users,
    o.ts,
    o.full_name,
    o.door_opened_secs,
    o.month,
    o.week,
    o.date,
    o.dayofweek,
    o.hour,
    o.dowhour,
    o.uniq_user,
    lp.epc,
    lp.label_order_id,
    lp.label_status,
    lp.label_price,
    lp.time_created,
    lp.time_added,
    lp.time_updated,
    lp.ts_created,
    lp.ts_added,
    lp.ts_updated,
    lp.label_kiosk_id,
    lp.product_id,
    lp.product_title,
    lp.product_archived,
    lp.product_vendor,
    lp.product_price,
    lp.product_cost,
    lp.product_shelf_life_days,
    lp.product_attributes,
    lp.product_categories,
    lp.consumer_category,
    lp.product_source
   FROM (public.byte_tickets_2015 o
     JOIN public.byte_label_product lp ON (((lp.label_order_id)::text = (o.order_id)::text)))
  WHERE ((lp.label_status)::text = 'sold'::text);
CREATE VIEW public.byte_epcssold_7days AS
 SELECT o.order_id,
    o.first_name,
    o.last_name,
    o.kiosk_id,
    o.kiosk_title,
    o.email,
    o.amount_paid,
    o.payment_system,
    o.transaction_id,
    o.approval_code,
    o.status_code,
    o.status_message,
    o.status,
    o.batch_id,
    o.created,
    o.auth_amount,
    o.data_token,
    o.time_opened,
    o.time_closed,
    o.card_hash,
    o.state,
    o.archived,
    o.stamp,
    o.last_update,
    o.balance,
    o.delta,
    o.coupon_id,
    o.coupon,
    o.refund,
    o.receipt,
    o.campus_id,
    o.amount_list_price,
    o.notes,
    o.time_door_opened,
    o.time_door_closed,
    o.client_name,
    o.estd_num_users,
    o.ts,
    o.full_name,
    o.door_opened_secs,
    o.month,
    o.week,
    o.date,
    o.dayofweek,
    o.hour,
    o.dowhour,
    o.uniq_user,
    lp.epc,
    lp.label_order_id,
    lp.label_status,
    lp.label_price,
    lp.time_created,
    lp.time_added,
    lp.time_updated,
    lp.ts_created,
    lp.ts_added,
    lp.ts_updated,
    lp.label_kiosk_id,
    lp.product_id,
    lp.product_title,
    lp.product_archived,
    lp.product_vendor,
    lp.product_price,
    lp.product_cost,
    lp.product_shelf_life_days,
    lp.product_attributes,
    lp.product_categories,
    lp.consumer_category,
    lp.product_source
   FROM (public.byte_tickets_7days o
     JOIN public.byte_label_product lp ON (((lp.label_order_id)::text = (o.order_id)::text)))
  WHERE ((lp.label_status)::text = 'sold'::text);
CREATE VIEW public.byte_epcssold_90days AS
 SELECT o.order_id,
    o.first_name,
    o.last_name,
    o.kiosk_id,
    o.kiosk_title,
    o.email,
    o.amount_paid,
    o.payment_system,
    o.transaction_id,
    o.approval_code,
    o.status_code,
    o.status_message,
    o.status,
    o.batch_id,
    o.created,
    o.auth_amount,
    o.data_token,
    o.time_opened,
    o.time_closed,
    o.card_hash,
    o.state,
    o.archived,
    o.stamp,
    o.last_update,
    o.balance,
    o.delta,
    o.coupon_id,
    o.coupon,
    o.refund,
    o.receipt,
    o.campus_id,
    o.amount_list_price,
    o.notes,
    o.time_door_opened,
    o.time_door_closed,
    o.client_name,
    o.estd_num_users,
    o.ts,
    o.full_name,
    o.door_opened_secs,
    o.month,
    o.week,
    o.date,
    o.dayofweek,
    o.hour,
    o.dowhour,
    o.uniq_user,
    lp.epc,
    lp.label_order_id,
    lp.label_status,
    lp.label_price,
    lp.time_created,
    lp.time_added,
    lp.time_updated,
    lp.ts_created,
    lp.ts_added,
    lp.ts_updated,
    lp.label_kiosk_id,
    lp.product_id,
    lp.product_title,
    lp.product_archived,
    lp.product_vendor,
    lp.product_price,
    lp.product_cost,
    lp.product_shelf_life_days,
    lp.product_attributes,
    lp.product_categories,
    lp.consumer_category,
    lp.product_source
   FROM (public.byte_tickets_90days o
     JOIN public.byte_label_product lp ON (((lp.label_order_id)::text = (o.order_id)::text)))
  WHERE ((lp.label_status)::text = 'sold'::text);
CREATE VIEW public.byte_restockings AS
 SELECT byte_orders.order_id,
    byte_orders.first_name,
    byte_orders.last_name,
    byte_orders.kiosk_id,
    byte_orders.kiosk_title,
    byte_orders.email,
    byte_orders.amount_paid,
    byte_orders.payment_system,
    byte_orders.transaction_id,
    byte_orders.approval_code,
    byte_orders.status_code,
    byte_orders.status_message,
    byte_orders.status,
    byte_orders.batch_id,
    byte_orders.created,
    byte_orders.auth_amount,
    byte_orders.data_token,
    byte_orders.time_opened,
    byte_orders.time_closed,
    byte_orders.card_hash,
    byte_orders.state,
    byte_orders.archived,
    byte_orders.stamp,
    byte_orders.last_update,
    byte_orders.balance,
    byte_orders.delta,
    byte_orders.coupon_id,
    byte_orders.coupon,
    byte_orders.refund,
    byte_orders.receipt,
    byte_orders.campus_id,
    byte_orders.amount_list_price,
    byte_orders.notes,
    byte_orders.time_door_opened,
    byte_orders.time_door_closed,
    byte_orders.client_name,
    byte_orders.estd_num_users,
    byte_orders.ts,
    byte_orders.full_name,
    byte_orders.door_opened_secs,
    byte_orders.month,
    byte_orders.week,
    byte_orders.date,
    byte_orders.dayofweek,
    byte_orders.hour,
    byte_orders.dowhour
   FROM public.byte_orders
  WHERE ((byte_orders.payment_system)::text = 'Restocking'::text);
CREATE VIEW public.sys_table_sizes AS
 SELECT (((n.nspname)::text || '.'::text) || (c.relname)::text) AS relation,
    pg_size_pretty(pg_relation_size((c.oid)::regclass)) AS size
   FROM (pg_class c
     LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace)))
  WHERE (n.nspname <> ALL (ARRAY['pg_catalog'::name, 'information_schema'::name]))
  ORDER BY (pg_relation_size((c.oid)::regclass)) DESC;
CREATE VIEW public.byte_tickets_90days AS
 SELECT byte_tickets.order_id,
    byte_tickets.first_name,
    byte_tickets.last_name,
    byte_tickets.kiosk_id,
    byte_tickets.kiosk_title,
    byte_tickets.email,
    byte_tickets.amount_paid,
    byte_tickets.payment_system,
    byte_tickets.transaction_id,
    byte_tickets.approval_code,
    byte_tickets.status_code,
    byte_tickets.status_message,
    byte_tickets.status,
    byte_tickets.batch_id,
    byte_tickets.created,
    byte_tickets.auth_amount,
    byte_tickets.data_token,
    byte_tickets.time_opened,
    byte_tickets.time_closed,
    byte_tickets.card_hash,
    byte_tickets.state,
    byte_tickets.archived,
    byte_tickets.stamp,
    byte_tickets.last_update,
    byte_tickets.balance,
    byte_tickets.delta,
    byte_tickets.coupon_id,
    byte_tickets.coupon,
    byte_tickets.refund,
    byte_tickets.receipt,
    byte_tickets.campus_id,
    byte_tickets.amount_list_price,
    byte_tickets.notes,
    byte_tickets.time_door_opened,
    byte_tickets.time_door_closed,
    byte_tickets.client_name,
    byte_tickets.estd_num_users,
    byte_tickets.ts,
    byte_tickets.full_name,
    byte_tickets.door_opened_secs,
    byte_tickets.month,
    byte_tickets.week,
    byte_tickets.date,
    byte_tickets.dayofweek,
    byte_tickets.hour,
    byte_tickets.dowhour,
    byte_tickets.uniq_user
   FROM public.byte_tickets
  WHERE (byte_tickets.ts > (now() - '90 days'::interval day));
CREATE VIEW public.byte_inventory_current AS
 SELECT ic.kiosk_id,
    ic.product_id,
    ic.units
   FROM (public.inventory_current ic
     JOIN public.byte_kiosks bk ON ((ic.kiosk_id = bk.id)));
CREATE VIEW public.dashboard_monthly_stats AS
 SELECT byte_epcssold.month,
    count(DISTINCT byte_epcssold.epc) AS units,
    count(DISTINCT byte_epcssold.client_name) AS active_byte_customers,
    count(DISTINCT byte_epcssold.product_id) AS active_skus,
    count(DISTINCT byte_epcssold.product_vendor) AS active_brands,
    count(DISTINCT byte_epcssold.card_hash) AS cards,
    count(DISTINCT regexp_replace(byte_epcssold.full_name, '^(.).+? (.+)'::text, ' '::text)) AS estd_uniq_usernames,
    count(DISTINCT byte_epcssold.email) AS unique_emails,
    count(DISTINCT byte_epcssold.order_id) AS tickets,
    count(DISTINCT
        CASE
            WHEN ((byte_epcssold.email IS NULL) OR ((byte_epcssold.email)::text = ''::text)) THEN ''::character varying
            ELSE byte_epcssold.order_id
        END) AS tickets_w_email
   FROM public.byte_epcssold
  GROUP BY byte_epcssold.month
  ORDER BY byte_epcssold.month;
CREATE VIEW public.dbg_stockout_weighted AS
 SELECT stockout_weighted.kiosk_id,
    stockout_weighted.product_id,
    stockout_weighted.cat,
    public.interval_hours(stockout_weighted.stockout_len) AS stockout_hrs,
    (stockout_weighted.avg_cat_kiosk_sales)::numeric(8,2) AS avg_cat_kiosk_sales,
    (stockout_weighted.avg_cat_sales)::numeric(8,2) AS avg_cat_sales,
    (stockout_weighted.avg_kiosk_sales)::numeric(8,2) AS avg_kiosk_sales
   FROM public.stockout_weighted
  ORDER BY stockout_weighted.kiosk_id, stockout_weighted.product_id, stockout_weighted.cat;
CREATE VIEW mixalot.v_node_kiosk_status_log AS
 SELECT l.ts,
    l."time",
    l.request_uuid,
    l.endpoint,
    l.client_ip,
    l.version,
    l.cookie,
    l.message,
    l.request_body,
    l.request_headers,
    l.start_ts,
    l.response_body,
    l.response_headers,
    l.status_code,
    l.end_ts,
    l.traceback,
    l.request_body_json,
    l.request_headers_json,
    l.response_headers_json,
    l.kiosk_id,
    l.source,
    (((l.request_body_json)::json ->> 'kiosk_id'::text))::integer AS client_kiosk_id,
    (((l.request_body_json)::json ->> 'retry_queue_length'::text))::integer AS retry_queue_length,
    (((l.request_body_json)::json ->> 'retry_count'::text))::integer AS retry_count,
    (((l.request_body_json)::json ->> 'happy_hour'::text))::integer AS happy_hour,
    (((l.request_body_json)::json ->> 'app_uptime'::text))::bigint AS app_uptime,
    (((l.request_body_json)::json ->> 'system_uptime'::text))::bigint AS system_uptime,
    (((l.request_body_json)::json ->> 'kiosk_temperature'::text))::numeric AS kiosk_temperature,
    (((l.request_body_json)::json ->> 'kit_temperature'::text))::numeric AS kit_temperature,
    (((l.request_body_json)::json ->> 'power'::text))::integer AS power,
    (((l.request_body_json)::json ->> 'battery_level'::text))::integer AS battery_level,
    (((l.request_body_json)::json ->> 'rfid_0'::text))::integer AS rfid_0,
    (((l.request_body_json)::json ->> 'rfid_1'::text))::integer AS rfid_1,
    (((l.request_body_json)::json ->> 'rfid_2'::text))::integer AS rfid_2,
    (((l.request_body_json)::json ->> 'rfid_3'::text))::integer AS rfid_3,
    (((l.request_body_json)::json ->> 'rfid_4'::text))::integer AS rfid_4,
    (((l.request_body_json)::json ->> 'rfid_5'::text))::integer AS rfid_5,
    (((l.request_body_json)::json ->> 'rfid_6'::text))::integer AS rfid_6,
    (((l.request_body_json)::json ->> 'rfid_7'::text))::integer AS rfid_7
   FROM mixalot.v_node_kiosk_request_log l
  WHERE ((l.endpoint = '/status'::text) AND (l.source = 'node'::text));
CREATE VIEW public.byte_tickets_2months AS
 SELECT byte_tickets.order_id,
    byte_tickets.first_name,
    byte_tickets.last_name,
    byte_tickets.kiosk_id,
    byte_tickets.kiosk_title,
    byte_tickets.email,
    byte_tickets.amount_paid,
    byte_tickets.payment_system,
    byte_tickets.transaction_id,
    byte_tickets.approval_code,
    byte_tickets.status_code,
    byte_tickets.status_message,
    byte_tickets.status,
    byte_tickets.batch_id,
    byte_tickets.created,
    byte_tickets.auth_amount,
    byte_tickets.data_token,
    byte_tickets.time_opened,
    byte_tickets.time_closed,
    byte_tickets.card_hash,
    byte_tickets.state,
    byte_tickets.archived,
    byte_tickets.stamp,
    byte_tickets.last_update,
    byte_tickets.balance,
    byte_tickets.delta,
    byte_tickets.coupon_id,
    byte_tickets.coupon,
    byte_tickets.refund,
    byte_tickets.receipt,
    byte_tickets.campus_id,
    byte_tickets.amount_list_price,
    byte_tickets.notes,
    byte_tickets.time_door_opened,
    byte_tickets.time_door_closed,
    byte_tickets.client_name,
    byte_tickets.estd_num_users,
    byte_tickets.ts,
    byte_tickets.full_name,
    byte_tickets.door_opened_secs,
    byte_tickets.month,
    byte_tickets.week,
    byte_tickets.date,
    byte_tickets.dayofweek,
    byte_tickets.hour,
    byte_tickets.dowhour,
    byte_tickets.uniq_user
   FROM public.byte_tickets
  WHERE (byte_tickets.ts > (now() - '2 mons'::interval month));
CREATE VIEW public.dp_stockouts_2017 AS
 SELECT dp_stockouts.kiosk_id,
    dp_stockouts.order_id,
    dp_stockouts.product_id,
    dp_stockouts.ts,
    dp_stockouts.restock_ts,
    dp_stockouts.restock_order_id,
    dp_stockouts.id,
    dp_stockouts.title,
    dp_stockouts.description,
    dp_stockouts.tiny_description,
    dp_stockouts.short_description,
    dp_stockouts.medium_description,
    dp_stockouts.long_description,
    dp_stockouts.price,
    dp_stockouts.cost,
    dp_stockouts.shelf_time,
    dp_stockouts.campus_id,
    dp_stockouts.image,
    dp_stockouts.image_time,
    dp_stockouts.last_update,
    dp_stockouts.archived,
    dp_stockouts.taxable,
    dp_stockouts.allergens,
    dp_stockouts.attribute_names,
    dp_stockouts.categories,
    dp_stockouts.category_names,
    dp_stockouts.vendor,
    dp_stockouts.source,
    dp_stockouts.notes,
    dp_stockouts.total_cal,
    dp_stockouts.num_servings,
    dp_stockouts.ingredients,
    dp_stockouts.calories,
    dp_stockouts.proteins,
    dp_stockouts.sugar,
    dp_stockouts.carbohydrates,
    dp_stockouts.fat,
    dp_stockouts.consumer_category,
    dp_stockouts.ws_case_size,
    dp_stockouts.kiosk_ship_qty,
    dp_stockouts.ws_case_cost,
    dp_stockouts.pick_station,
    dp_stockouts.fc_title,
    dp_stockouts.pricing_tier,
    dp_stockouts.width_space,
    dp_stockouts.height_space,
    dp_stockouts.depth_space,
    dp_stockouts.slotted_width,
    dp_stockouts.tag_volume,
    dp_stockouts.delivery_option,
    dp_stockouts.kiosk_title,
    dp_stockouts.address,
    dp_stockouts.location_x,
    dp_stockouts.location_y,
    dp_stockouts.client_name,
    dp_stockouts.tags,
    dp_stockouts.estd_num_users,
    dp_stockouts.month,
    dp_stockouts.week,
    dp_stockouts.date
   FROM public.dp_stockouts
  WHERE ((dp_stockouts.ts >= '2017-01-01 08:00:00+00'::timestamp with time zone) AND (dp_stockouts.ts <= '2018-01-01 08:00:00+00'::timestamp with time zone));
CREATE VIEW public.user_retention_9months AS
 SELECT user_retention_by_month.month,
    user_retention_by_month.num_consumers,
    user_retention_by_month.repeat_consumers,
    user_retention_by_month.num_tickets,
    user_retention_by_month.sum_amount_list_price,
    user_retention_by_month.sum_amount_paid,
    user_retention_by_month.num_repeat_tickets,
    user_retention_by_month.sum_repeat_amount_list_price,
    user_retention_by_month.sum_repeat_amount_paid,
    user_retention_by_month.frac_users_retained,
    user_retention_by_month.frac_tickets_retained,
    user_retention_by_month.frac_listprice_retained,
    user_retention_by_month.frac_amountpaid_retained,
    user_retention_by_month.old_month,
    user_retention_by_month.old_num_consumers,
    user_retention_by_month.old_repeat_consumers,
    user_retention_by_month.old_num_tickets,
    user_retention_by_month.old_sum_amount_list_price,
    user_retention_by_month.old_sum_amount_paid
   FROM public.user_retention_by_month(9) user_retention_by_month(month, num_consumers, repeat_consumers, num_tickets, sum_amount_list_price, sum_amount_paid, num_repeat_tickets, sum_repeat_amount_list_price, sum_repeat_amount_paid, frac_users_retained, frac_tickets_retained, frac_listprice_retained, frac_amountpaid_retained, old_month, old_num_consumers, old_repeat_consumers, old_num_tickets, old_sum_amount_list_price, old_sum_amount_paid);
CREATE VIEW public.dowhours AS
 SELECT DISTINCT public.dowhour(lastwk_hrs.ts) AS dowhour
   FROM public.lastwk_hrs
  ORDER BY (public.dowhour(lastwk_hrs.ts));
CREATE VIEW public.dp_spoilage_daily_kiosk_pct AS
 SELECT dp_spoilage_daily_kiosk_product_pct.date,
    dp_spoilage_daily_kiosk_product_pct.kiosk_id,
    sum(dp_spoilage_daily_kiosk_product_pct.spoiled) AS spoiled_units,
    sum(dp_spoilage_daily_kiosk_product_pct.sold) AS sold_units,
    public.frac(sum(dp_spoilage_daily_kiosk_product_pct.spoiled), sum(dp_spoilage_daily_kiosk_product_pct.sold)) AS spoiled_frac_units,
    sum(dp_spoilage_daily_kiosk_product_pct.revenue) AS revenue,
    sum(dp_spoilage_daily_kiosk_product_pct.cost) AS cost,
    sum(((dp_spoilage_daily_kiosk_product_pct.spoiled)::numeric * dp_spoilage_daily_kiosk_product_pct.unit_cost)) AS spoilage_dolr,
    sum(dp_spoilage_daily_kiosk_product_pct.net_profit) AS net_profit,
    public.if((sum(dp_spoilage_daily_kiosk_product_pct.sold) = (0)::numeric), 9999.0, (sum(((dp_spoilage_daily_kiosk_product_pct.spoiled)::numeric * dp_spoilage_daily_kiosk_product_pct.unit_cost)) / sum(dp_spoilage_daily_kiosk_product_pct.revenue))) AS spoilage_frac,
    min((dp_spoilage_daily_kiosk_product_pct.kiosk_title)::text) AS kiosk_title,
    bool_and(dp_spoilage_daily_kiosk_product_pct.new_kiosk) AS new_kiosk
   FROM public.dp_spoilage_daily_kiosk_product_pct
  GROUP BY dp_spoilage_daily_kiosk_product_pct.date, dp_spoilage_daily_kiosk_product_pct.kiosk_id
  ORDER BY dp_spoilage_daily_kiosk_product_pct.kiosk_id, dp_spoilage_daily_kiosk_product_pct.date DESC;
CREATE VIEW mixalot.inm_kiosk_restriction_list AS
 SELECT gsheets_kiosk_restriction.kiosk_id,
    string_agg((gsheets_kiosk_restriction.restriction)::text, ','::text) AS restrictions
   FROM mixalot.gsheets_kiosk_restriction
  GROUP BY gsheets_kiosk_restriction.kiosk_id;
CREATE VIEW public.byte_tickets_4weeks AS
 SELECT byte_tickets.order_id,
    byte_tickets.first_name,
    byte_tickets.last_name,
    byte_tickets.kiosk_id,
    byte_tickets.kiosk_title,
    byte_tickets.email,
    byte_tickets.amount_paid,
    byte_tickets.payment_system,
    byte_tickets.transaction_id,
    byte_tickets.approval_code,
    byte_tickets.status_code,
    byte_tickets.status_message,
    byte_tickets.status,
    byte_tickets.batch_id,
    byte_tickets.created,
    byte_tickets.auth_amount,
    byte_tickets.data_token,
    byte_tickets.time_opened,
    byte_tickets.time_closed,
    byte_tickets.card_hash,
    byte_tickets.state,
    byte_tickets.archived,
    byte_tickets.stamp,
    byte_tickets.last_update,
    byte_tickets.balance,
    byte_tickets.delta,
    byte_tickets.coupon_id,
    byte_tickets.coupon,
    byte_tickets.refund,
    byte_tickets.receipt,
    byte_tickets.campus_id,
    byte_tickets.amount_list_price,
    byte_tickets.notes,
    byte_tickets.time_door_opened,
    byte_tickets.time_door_closed,
    byte_tickets.client_name,
    byte_tickets.estd_num_users,
    byte_tickets.ts,
    byte_tickets.full_name,
    byte_tickets.door_opened_secs,
    byte_tickets.month,
    byte_tickets.week,
    byte_tickets.date,
    byte_tickets.dayofweek,
    byte_tickets.hour,
    byte_tickets.dowhour,
    byte_tickets.uniq_user
   FROM public.byte_tickets
  WHERE (byte_tickets.ts > (now() - '28 days'::interval day));
CREATE VIEW public.byte_tickets_7days AS
 SELECT byte_tickets.order_id,
    byte_tickets.first_name,
    byte_tickets.last_name,
    byte_tickets.kiosk_id,
    byte_tickets.kiosk_title,
    byte_tickets.email,
    byte_tickets.amount_paid,
    byte_tickets.payment_system,
    byte_tickets.transaction_id,
    byte_tickets.approval_code,
    byte_tickets.status_code,
    byte_tickets.status_message,
    byte_tickets.status,
    byte_tickets.batch_id,
    byte_tickets.created,
    byte_tickets.auth_amount,
    byte_tickets.data_token,
    byte_tickets.time_opened,
    byte_tickets.time_closed,
    byte_tickets.card_hash,
    byte_tickets.state,
    byte_tickets.archived,
    byte_tickets.stamp,
    byte_tickets.last_update,
    byte_tickets.balance,
    byte_tickets.delta,
    byte_tickets.coupon_id,
    byte_tickets.coupon,
    byte_tickets.refund,
    byte_tickets.receipt,
    byte_tickets.campus_id,
    byte_tickets.amount_list_price,
    byte_tickets.notes,
    byte_tickets.time_door_opened,
    byte_tickets.time_door_closed,
    byte_tickets.client_name,
    byte_tickets.estd_num_users,
    byte_tickets.ts,
    byte_tickets.full_name,
    byte_tickets.door_opened_secs,
    byte_tickets.month,
    byte_tickets.week,
    byte_tickets.date,
    byte_tickets.dayofweek,
    byte_tickets.hour,
    byte_tickets.dowhour,
    byte_tickets.uniq_user
   FROM public.byte_tickets
  WHERE (byte_tickets.ts > (now() - '7 days'::interval day));
CREATE VIEW public.dp_spoilage_monthly_kiosk_product_pct AS
 SELECT dp_spoilage_monthly_calc.month,
    dp_spoilage_monthly_calc.kiosk_id,
    dp_spoilage_monthly_calc.product_id,
    dp_spoilage_monthly_calc.spoiled,
    dp_spoilage_monthly_calc.sold,
    dp_spoilage_monthly_calc.product_title,
    dp_spoilage_monthly_calc.kiosk_title,
    dp_spoilage_monthly_calc.unit_price,
    dp_spoilage_monthly_calc.unit_cost,
    dp_spoilage_monthly_calc.spoiled_frac_units,
    dp_spoilage_monthly_calc.revenue,
    dp_spoilage_monthly_calc.cost,
    dp_spoilage_monthly_calc.spoilage_frac,
    dp_spoilage_monthly_calc.new_kiosk,
    (dp_spoilage_monthly_calc.revenue - dp_spoilage_monthly_calc.cost) AS net_profit
   FROM public.dp_spoilage_monthly_calc;
CREATE VIEW public.user_retention_10weeks AS
 SELECT user_retention_by_week.week,
    user_retention_by_week.num_consumers,
    user_retention_by_week.repeat_consumers,
    user_retention_by_week.num_tickets,
    user_retention_by_week.sum_amount_list_price,
    user_retention_by_week.sum_amount_paid,
    user_retention_by_week.num_repeat_tickets,
    user_retention_by_week.sum_repeat_amount_list_price,
    user_retention_by_week.sum_repeat_amount_paid,
    user_retention_by_week.frac_users_retained,
    user_retention_by_week.frac_tickets_retained,
    user_retention_by_week.frac_listprice_retained,
    user_retention_by_week.frac_amountpaid_retained,
    user_retention_by_week.old_week,
    user_retention_by_week.old_num_consumers,
    user_retention_by_week.old_repeat_consumers,
    user_retention_by_week.old_num_tickets,
    user_retention_by_week.old_sum_amount_list_price,
    user_retention_by_week.old_sum_amount_paid
   FROM public.user_retention_by_week(10) user_retention_by_week(week, num_consumers, repeat_consumers, num_tickets, sum_amount_list_price, sum_amount_paid, num_repeat_tickets, sum_repeat_amount_list_price, sum_repeat_amount_paid, frac_users_retained, frac_tickets_retained, frac_listprice_retained, frac_amountpaid_retained, old_week, old_num_consumers, old_repeat_consumers, old_num_tickets, old_sum_amount_list_price, old_sum_amount_paid);
CREATE VIEW public.byte_tickets_2017 AS
 SELECT byte_tickets.order_id,
    byte_tickets.first_name,
    byte_tickets.last_name,
    byte_tickets.kiosk_id,
    byte_tickets.kiosk_title,
    byte_tickets.email,
    byte_tickets.amount_paid,
    byte_tickets.payment_system,
    byte_tickets.transaction_id,
    byte_tickets.approval_code,
    byte_tickets.status_code,
    byte_tickets.status_message,
    byte_tickets.status,
    byte_tickets.batch_id,
    byte_tickets.created,
    byte_tickets.auth_amount,
    byte_tickets.data_token,
    byte_tickets.time_opened,
    byte_tickets.time_closed,
    byte_tickets.card_hash,
    byte_tickets.state,
    byte_tickets.archived,
    byte_tickets.stamp,
    byte_tickets.last_update,
    byte_tickets.balance,
    byte_tickets.delta,
    byte_tickets.coupon_id,
    byte_tickets.coupon,
    byte_tickets.refund,
    byte_tickets.receipt,
    byte_tickets.campus_id,
    byte_tickets.amount_list_price,
    byte_tickets.notes,
    byte_tickets.time_door_opened,
    byte_tickets.time_door_closed,
    byte_tickets.client_name,
    byte_tickets.estd_num_users,
    byte_tickets.ts,
    byte_tickets.full_name,
    byte_tickets.door_opened_secs,
    byte_tickets.month,
    byte_tickets.week,
    byte_tickets.date,
    byte_tickets.dayofweek,
    byte_tickets.hour,
    byte_tickets.dowhour,
    byte_tickets.uniq_user
   FROM public.byte_tickets
  WHERE ((byte_tickets.ts >= '2017-01-01 08:00:00+00'::timestamp with time zone) AND (byte_tickets.ts < '2018-01-01 08:00:00+00'::timestamp with time zone));
CREATE VIEW public.byte_spoilage_by_category_week_all AS
 SELECT s.week,
    ((regexp_replace((s.consumer_category)::text, '[^a-zA-Z]+'::text, '_'::text, 'g'::text) || '_'::text) || 'cost_all'::text) AS cat_and_new,
    sum(s.cost) AS spoilage_cost
   FROM (public.byte_spoilage s
     JOIN public.byte_kiosks_date_non_new k ON ((s.kiosk_id = k.kiosk_id)))
  WHERE ((s.date >= '2016-01-01 08:00:00+00'::timestamp with time zone) AND (s.consumer_category IS NOT NULL))
  GROUP BY s.week, ((regexp_replace((s.consumer_category)::text, '[^a-zA-Z]+'::text, '_'::text, 'g'::text) || '_'::text) || 'cost_all'::text)
  ORDER BY s.week DESC, ((regexp_replace((s.consumer_category)::text, '[^a-zA-Z]+'::text, '_'::text, 'g'::text) || '_'::text) || 'cost_all'::text);
CREATE VIEW public.dashboard_weekly_stats AS
 SELECT t1.week,
    ((t2.stockout_units_in_old_kiosks)::double precision / (((t1.num_old_kiosks)::numeric + 0.01))::double precision) AS avg_stockouts_per_old_kiosk,
    ((t2.stockout_units_in_new_kiosks)::double precision / (((t1.num_new_kiosks)::numeric + 0.01))::double precision) AS avg_stockouts_per_new_kiosk,
    ((t2.stockout_units_in_all_kiosks)::double precision / (t1.num_all_kiosks)::double precision) AS avg_stockouts_per_kiosk,
    ((t2.stockout_hrs_in_old_kiosks)::double precision / (((t1.num_old_kiosks)::numeric + 0.01))::double precision) AS avg_stockout_hrs_per_old_kiosk,
    ((t2.stockout_hrs_in_new_kiosks)::double precision / (((t1.num_new_kiosks)::numeric + 0.01))::double precision) AS avg_stockout_hrs_per_new_kiosk,
    (t2.stockout_hrs_in_all_kiosks / (t1.num_all_kiosks)::double precision) AS avg_stockout_hrs_per_kiosk
   FROM (public.byte_kiosks_by_week t1
     JOIN public.byte_stockouts_by_week t2 ON ((t1.week = t2.week)))
  ORDER BY t1.week;
CREATE VIEW byt_devops.pgdu_union_pretty AS
 SELECT pgdudetail_pretty.union_sort_order,
    pgdudetail_pretty.total_size_sort_order,
    pgdudetail_pretty.table_name,
    pgdudetail_pretty.table_size,
    pgdudetail_pretty.percent_table,
    pgdudetail_pretty.indexes_size,
    pgdudetail_pretty.percent_index,
    pgdudetail_pretty.total_size
   FROM byt_devops.pgdudetail_pretty
UNION
 SELECT pgdutotal_pretty.union_sort_order,
    pgdutotal_pretty.total_size_sort_order,
    pgdutotal_pretty.table_name,
    pgdutotal_pretty.table_size,
    pgdutotal_pretty.percent_table,
    pgdutotal_pretty.indexes_size,
    pgdutotal_pretty.percent_index,
    pgdutotal_pretty.total_size
   FROM byt_devops.pgdutotal_pretty
  ORDER BY 1, 2 DESC;
CREATE VIEW public.byte_tickets_180days AS
 SELECT byte_tickets.order_id,
    byte_tickets.first_name,
    byte_tickets.last_name,
    byte_tickets.kiosk_id,
    byte_tickets.kiosk_title,
    byte_tickets.email,
    byte_tickets.amount_paid,
    byte_tickets.payment_system,
    byte_tickets.transaction_id,
    byte_tickets.approval_code,
    byte_tickets.status_code,
    byte_tickets.status_message,
    byte_tickets.status,
    byte_tickets.batch_id,
    byte_tickets.created,
    byte_tickets.auth_amount,
    byte_tickets.data_token,
    byte_tickets.time_opened,
    byte_tickets.time_closed,
    byte_tickets.card_hash,
    byte_tickets.state,
    byte_tickets.archived,
    byte_tickets.stamp,
    byte_tickets.last_update,
    byte_tickets.balance,
    byte_tickets.delta,
    byte_tickets.coupon_id,
    byte_tickets.coupon,
    byte_tickets.refund,
    byte_tickets.receipt,
    byte_tickets.campus_id,
    byte_tickets.amount_list_price,
    byte_tickets.notes,
    byte_tickets.time_door_opened,
    byte_tickets.time_door_closed,
    byte_tickets.client_name,
    byte_tickets.estd_num_users,
    byte_tickets.ts,
    byte_tickets.full_name,
    byte_tickets.door_opened_secs,
    byte_tickets.month,
    byte_tickets.week,
    byte_tickets.date,
    byte_tickets.dayofweek,
    byte_tickets.hour,
    byte_tickets.dowhour,
    byte_tickets.uniq_user
   FROM public.byte_tickets
  WHERE (byte_tickets.ts > (now() - '180 days'::interval day));
CREATE VIEW public.byte_inventory_current_lots AS
 SELECT ic.date,
    ic.product_id,
    ic.kiosk_id,
    ic.units,
    ic.expir_date,
    ic.shelf_life_days
   FROM (public.inventory_current_lots ic
     JOIN public.byte_kiosks bk ON ((ic.kiosk_id = bk.id)));
CREATE VIEW public.byte_epcssold_60days AS
 SELECT o.order_id,
    o.first_name,
    o.last_name,
    o.kiosk_id,
    o.kiosk_title,
    o.email,
    o.amount_paid,
    o.payment_system,
    o.transaction_id,
    o.approval_code,
    o.status_code,
    o.status_message,
    o.status,
    o.batch_id,
    o.created,
    o.auth_amount,
    o.data_token,
    o.time_opened,
    o.time_closed,
    o.card_hash,
    o.state,
    o.archived,
    o.stamp,
    o.last_update,
    o.balance,
    o.delta,
    o.coupon_id,
    o.coupon,
    o.refund,
    o.receipt,
    o.campus_id,
    o.amount_list_price,
    o.notes,
    o.time_door_opened,
    o.time_door_closed,
    o.client_name,
    o.estd_num_users,
    o.ts,
    o.full_name,
    o.door_opened_secs,
    o.month,
    o.week,
    o.date,
    o.dayofweek,
    o.hour,
    o.dowhour,
    o.uniq_user,
    lp.epc,
    lp.label_order_id,
    lp.label_status,
    lp.label_price,
    lp.time_created,
    lp.time_added,
    lp.time_updated,
    lp.ts_created,
    lp.ts_added,
    lp.ts_updated,
    lp.label_kiosk_id,
    lp.product_id,
    lp.product_title,
    lp.product_archived,
    lp.product_vendor,
    lp.product_price,
    lp.product_cost,
    lp.product_shelf_life_days,
    lp.product_attributes,
    lp.product_categories,
    lp.consumer_category,
    lp.product_source
   FROM (public.byte_tickets_60days o
     JOIN public.byte_label_product lp ON (((lp.label_order_id)::text = (o.order_id)::text)))
  WHERE ((lp.label_status)::text = 'sold'::text);
CREATE VIEW public.dp_inventory_current AS
 SELECT byte_inventory_current.kiosk_id,
    byte_inventory_current.product_id,
    byte_inventory_current.units
   FROM public.byte_inventory_current;
CREATE VIEW public.dp_spoilage_4weeks AS
 SELECT dp_spoilage.kiosk_id,
    dp_spoilage.order_id,
    dp_spoilage.epc,
    dp_spoilage.product_id,
    dp_spoilage.ts_added,
    dp_spoilage.ts_removed,
    dp_spoilage.id,
    dp_spoilage.title,
    dp_spoilage.description,
    dp_spoilage.tiny_description,
    dp_spoilage.short_description,
    dp_spoilage.medium_description,
    dp_spoilage.long_description,
    dp_spoilage.price,
    dp_spoilage.cost,
    dp_spoilage.shelf_time,
    dp_spoilage.campus_id,
    dp_spoilage.image,
    dp_spoilage.image_time,
    dp_spoilage.last_update,
    dp_spoilage.archived,
    dp_spoilage.taxable,
    dp_spoilage.allergens,
    dp_spoilage.attribute_names,
    dp_spoilage.categories,
    dp_spoilage.category_names,
    dp_spoilage.vendor,
    dp_spoilage.source,
    dp_spoilage.notes,
    dp_spoilage.total_cal,
    dp_spoilage.num_servings,
    dp_spoilage.ingredients,
    dp_spoilage.calories,
    dp_spoilage.proteins,
    dp_spoilage.sugar,
    dp_spoilage.carbohydrates,
    dp_spoilage.fat,
    dp_spoilage.consumer_category,
    dp_spoilage.ws_case_size,
    dp_spoilage.kiosk_ship_qty,
    dp_spoilage.ws_case_cost,
    dp_spoilage.pick_station,
    dp_spoilage.fc_title,
    dp_spoilage.pricing_tier,
    dp_spoilage.width_space,
    dp_spoilage.height_space,
    dp_spoilage.depth_space,
    dp_spoilage.slotted_width,
    dp_spoilage.tag_volume,
    dp_spoilage.delivery_option,
    dp_spoilage.kiosk_title,
    dp_spoilage.address,
    dp_spoilage.location_x,
    dp_spoilage.location_y,
    dp_spoilage.client_name,
    dp_spoilage.tags,
    dp_spoilage.estd_num_users,
    dp_spoilage.month,
    dp_spoilage.week,
    dp_spoilage.date
   FROM public.dp_spoilage
  WHERE (dp_spoilage.ts_removed > (now() - '28 days'::interval day));
CREATE VIEW public.byte_stockouts_by_category_week_all AS
 SELECT s.week,
    ((regexp_replace((s.consumer_category)::text, '[^a-zA-Z]+'::text, '_'::text, 'g'::text) || '_'::text) || 'hrs_all'::text) AS cat_and_new,
    sum((date_part('minute'::text, (s.restock_ts - s.ts)) / (60.0)::double precision)) AS stockout_hrs
   FROM (public.byte_stockouts s
     JOIN public.byte_kiosks_date_non_new k ON ((s.kiosk_id = k.kiosk_id)))
  WHERE ((s.ts >= '2016-01-01 08:00:00+00'::timestamp with time zone) AND (s.consumer_category IS NOT NULL))
  GROUP BY s.week, ((regexp_replace((s.consumer_category)::text, '[^a-zA-Z]+'::text, '_'::text, 'g'::text) || '_'::text) || 'hrs_all'::text)
  ORDER BY s.week DESC, ((regexp_replace((s.consumer_category)::text, '[^a-zA-Z]+'::text, '_'::text, 'g'::text) || '_'::text) || 'hrs_all'::text);
CREATE VIEW public.sales_by_shelflife_45d AS
 SELECT public.if((byte_epcssold_45days.product_shelf_life_days > 30), 999, byte_epcssold_45days.product_shelf_life_days) AS shelf_life,
    sum(byte_epcssold_45days.product_price) AS sales
   FROM public.byte_epcssold_45days
  GROUP BY (public.if((byte_epcssold_45days.product_shelf_life_days > 30), 999, byte_epcssold_45days.product_shelf_life_days))
  ORDER BY (public.if((byte_epcssold_45days.product_shelf_life_days > 30), 999, byte_epcssold_45days.product_shelf_life_days));
CREATE VIEW iplanner.facing_category_v1 AS
 SELECT facing_category.id,
    facing_category.title,
    facing_category.shelf_level,
    facing_category.sku_count,
    facing_category.min_slotted,
    facing_category.max_slotted,
    facing_category.mixed_slotted
   FROM pantry.facing_category;
CREATE VIEW public.byte_epcssold_12months AS
 SELECT o.order_id,
    o.first_name,
    o.last_name,
    o.kiosk_id,
    o.kiosk_title,
    o.email,
    o.amount_paid,
    o.payment_system,
    o.transaction_id,
    o.approval_code,
    o.status_code,
    o.status_message,
    o.status,
    o.batch_id,
    o.created,
    o.auth_amount,
    o.data_token,
    o.time_opened,
    o.time_closed,
    o.card_hash,
    o.state,
    o.archived,
    o.stamp,
    o.last_update,
    o.balance,
    o.delta,
    o.coupon_id,
    o.coupon,
    o.refund,
    o.receipt,
    o.campus_id,
    o.amount_list_price,
    o.notes,
    o.time_door_opened,
    o.time_door_closed,
    o.client_name,
    o.estd_num_users,
    o.ts,
    o.full_name,
    o.door_opened_secs,
    o.month,
    o.week,
    o.date,
    o.dayofweek,
    o.hour,
    o.dowhour,
    o.uniq_user,
    lp.epc,
    lp.label_order_id,
    lp.label_status,
    lp.label_price,
    lp.time_created,
    lp.time_added,
    lp.time_updated,
    lp.ts_created,
    lp.ts_added,
    lp.ts_updated,
    lp.label_kiosk_id,
    lp.product_id,
    lp.product_title,
    lp.product_archived,
    lp.product_vendor,
    lp.product_price,
    lp.product_cost,
    lp.product_shelf_life_days,
    lp.product_attributes,
    lp.product_categories,
    lp.consumer_category,
    lp.product_source,
    lp.fc_title
   FROM (public.byte_tickets_12months o
     JOIN public.byte_label_product lp ON (((lp.label_order_id)::text = (o.order_id)::text)))
  WHERE ((lp.label_status)::text = 'sold'::text);
CREATE VIEW public.stockout_dowhours AS
 WITH _unused AS (
         SELECT 1
        ), stockouts AS (
         SELECT byte_stockouts.kiosk_id,
            byte_stockouts.product_id,
            byte_stockouts.consumer_category AS cat,
            byte_stockouts.ts AS stockout_ts,
            COALESCE(byte_stockouts.restock_ts, now()) AS restock_ts
           FROM public.byte_stockouts
          WHERE (byte_stockouts.ts > (now() - '7 days'::interval day))
        ), stockout_dowhours AS (
         SELECT s.kiosk_id,
            s.product_id,
            s.cat,
            lw.ts,
            s.restock_ts,
            public.dowhour(lw.ts) AS dowhour,
            (s.restock_ts - s.stockout_ts) AS stockout_len
           FROM stockouts s,
            public.lastwk_hrs lw
          WHERE ((s.stockout_ts <= lw.ts) AND (lw.ts < s.restock_ts))
        )
 SELECT stockout_dowhours.kiosk_id,
    stockout_dowhours.product_id,
    stockout_dowhours.cat,
    stockout_dowhours.ts,
    stockout_dowhours.restock_ts,
    stockout_dowhours.dowhour,
    stockout_dowhours.stockout_len
   FROM stockout_dowhours;
CREATE VIEW public.dp_spoilage_daily_pct AS
 SELECT dp_spoilage_daily_kiosk_product_pct.date,
    dp_spoilage_daily_kiosk_product_pct.new_kiosk,
    sum(dp_spoilage_daily_kiosk_product_pct.spoiled) AS spoiled_units,
    sum(dp_spoilage_daily_kiosk_product_pct.sold) AS sold_units,
    public.frac(sum(dp_spoilage_daily_kiosk_product_pct.spoiled), sum(dp_spoilage_daily_kiosk_product_pct.sold)) AS spoiled_frac_units,
    sum(dp_spoilage_daily_kiosk_product_pct.revenue) AS revenue,
    sum(dp_spoilage_daily_kiosk_product_pct.cost) AS cost,
    sum(((dp_spoilage_daily_kiosk_product_pct.spoiled)::numeric * dp_spoilage_daily_kiosk_product_pct.unit_cost)) AS spoilage_dolr,
    sum((dp_spoilage_daily_kiosk_product_pct.revenue - dp_spoilage_daily_kiosk_product_pct.cost)) AS net_profit,
    public.if((sum(dp_spoilage_daily_kiosk_product_pct.sold) = (0)::numeric), 9999.0, (sum(((dp_spoilage_daily_kiosk_product_pct.spoiled)::numeric * dp_spoilage_daily_kiosk_product_pct.unit_cost)) / sum(dp_spoilage_daily_kiosk_product_pct.revenue))) AS spoilage_frac_dolr
   FROM public.dp_spoilage_daily_kiosk_product_pct
  GROUP BY dp_spoilage_daily_kiosk_product_pct.date, dp_spoilage_daily_kiosk_product_pct.new_kiosk
  ORDER BY dp_spoilage_daily_kiosk_product_pct.date DESC, dp_spoilage_daily_kiosk_product_pct.new_kiosk;
CREATE VIEW public.dp_spoilage_weekly_pct AS
 SELECT dp_spoilage_weekly_kiosk_product_pct.week,
    dp_spoilage_weekly_kiosk_product_pct.new_kiosk,
    sum(dp_spoilage_weekly_kiosk_product_pct.spoiled) AS spoiled_units,
    sum(dp_spoilage_weekly_kiosk_product_pct.sold) AS sold_units,
    public.frac(sum(dp_spoilage_weekly_kiosk_product_pct.spoiled), sum(dp_spoilage_weekly_kiosk_product_pct.sold)) AS spoiled_frac_units,
    sum(dp_spoilage_weekly_kiosk_product_pct.revenue) AS revenue,
    sum(dp_spoilage_weekly_kiosk_product_pct.cost) AS cost,
    sum((dp_spoilage_weekly_kiosk_product_pct.spoiled * dp_spoilage_weekly_kiosk_product_pct.unit_cost)) AS spoilage_dolr,
    sum(dp_spoilage_weekly_kiosk_product_pct.net_profit) AS net_profit,
    public.if((sum(dp_spoilage_weekly_kiosk_product_pct.sold) = (0)::numeric), 9999.0, (sum((dp_spoilage_weekly_kiosk_product_pct.spoiled * dp_spoilage_weekly_kiosk_product_pct.unit_cost)) / sum(dp_spoilage_weekly_kiosk_product_pct.revenue))) AS spoilage_frac_dolr
   FROM public.dp_spoilage_weekly_kiosk_product_pct
  GROUP BY dp_spoilage_weekly_kiosk_product_pct.week, dp_spoilage_weekly_kiosk_product_pct.new_kiosk
  ORDER BY dp_spoilage_weekly_kiosk_product_pct.week DESC, dp_spoilage_weekly_kiosk_product_pct.new_kiosk;
CREATE VIEW public.kiosk_sales_by_dayofweek AS
 SELECT t.kiosk_id,
    t.min_ts,
    t.sun_pct,
    t.mon_pct,
    t.tue_pct,
    t.wed_pct,
    t.thu_pct,
    t.fri_pct,
    t.sat_pct,
    t.weekend_pct,
    t.title
   FROM ( SELECT t_1.kiosk_id,
            min(t_1.ts) AS min_ts,
            ((sum(public.if((t_1.dayofweek = (0)::double precision), t_1.amount_list_price, 0.0)) / sum(t_1.amount_list_price)))::numeric(6,3) AS sun_pct,
            ((sum(public.if((t_1.dayofweek = (1)::double precision), t_1.amount_list_price, 0.0)) / sum(t_1.amount_list_price)))::numeric(6,3) AS mon_pct,
            ((sum(public.if((t_1.dayofweek = (2)::double precision), t_1.amount_list_price, 0.0)) / sum(t_1.amount_list_price)))::numeric(6,3) AS tue_pct,
            ((sum(public.if((t_1.dayofweek = (3)::double precision), t_1.amount_list_price, 0.0)) / sum(t_1.amount_list_price)))::numeric(6,3) AS wed_pct,
            ((sum(public.if((t_1.dayofweek = (4)::double precision), t_1.amount_list_price, 0.0)) / sum(t_1.amount_list_price)))::numeric(6,3) AS thu_pct,
            ((sum(public.if((t_1.dayofweek = (5)::double precision), t_1.amount_list_price, 0.0)) / sum(t_1.amount_list_price)))::numeric(6,3) AS fri_pct,
            ((sum(public.if((t_1.dayofweek = (6)::double precision), t_1.amount_list_price, 0.0)) / sum(t_1.amount_list_price)))::numeric(6,3) AS sat_pct,
            ((sum(public.if((t_1.dayofweek = ANY (ARRAY[(0)::double precision, (6)::double precision])), t_1.amount_list_price, 0.0)) / sum(t_1.amount_list_price)))::numeric(6,3) AS weekend_pct,
            min((t_1.kiosk_title)::text) AS title
           FROM ((public.byte_tickets_6months t_1
             JOIN public.byte_kiosks_date_non_new knn ON ((t_1.kiosk_id = knn.kiosk_id)))
             JOIN public.byte_kiosks k ON ((t_1.kiosk_id = k.id)))
          WHERE ((k.archived = 0) AND (t_1.ts >= knn.new_ts))
          GROUP BY t_1.kiosk_id) t
  WHERE (t.min_ts < (now() - '30 days'::interval day))
  ORDER BY t.weekend_pct DESC;
CREATE VIEW public.user_retention_52weeks AS
 SELECT user_retention_by_week.week,
    user_retention_by_week.num_consumers,
    user_retention_by_week.repeat_consumers,
    user_retention_by_week.num_tickets,
    user_retention_by_week.sum_amount_list_price,
    user_retention_by_week.sum_amount_paid,
    user_retention_by_week.num_repeat_tickets,
    user_retention_by_week.sum_repeat_amount_list_price,
    user_retention_by_week.sum_repeat_amount_paid,
    user_retention_by_week.frac_users_retained,
    user_retention_by_week.frac_tickets_retained,
    user_retention_by_week.frac_listprice_retained,
    user_retention_by_week.frac_amountpaid_retained,
    user_retention_by_week.old_week,
    user_retention_by_week.old_num_consumers,
    user_retention_by_week.old_repeat_consumers,
    user_retention_by_week.old_num_tickets,
    user_retention_by_week.old_sum_amount_list_price,
    user_retention_by_week.old_sum_amount_paid
   FROM public.user_retention_by_week(52) user_retention_by_week(week, num_consumers, repeat_consumers, num_tickets, sum_amount_list_price, sum_amount_paid, num_repeat_tickets, sum_repeat_amount_list_price, sum_repeat_amount_paid, frac_users_retained, frac_tickets_retained, frac_listprice_retained, frac_amountpaid_retained, old_week, old_num_consumers, old_repeat_consumers, old_num_tickets, old_sum_amount_list_price, old_sum_amount_paid);
CREATE VIEW public.user_retention_1month AS
 SELECT user_retention_by_month.month,
    user_retention_by_month.num_consumers,
    user_retention_by_month.repeat_consumers,
    user_retention_by_month.num_tickets,
    user_retention_by_month.sum_amount_list_price,
    user_retention_by_month.sum_amount_paid,
    user_retention_by_month.num_repeat_tickets,
    user_retention_by_month.sum_repeat_amount_list_price,
    user_retention_by_month.sum_repeat_amount_paid,
    user_retention_by_month.frac_users_retained,
    user_retention_by_month.frac_tickets_retained,
    user_retention_by_month.frac_listprice_retained,
    user_retention_by_month.frac_amountpaid_retained,
    user_retention_by_month.old_month,
    user_retention_by_month.old_num_consumers,
    user_retention_by_month.old_repeat_consumers,
    user_retention_by_month.old_num_tickets,
    user_retention_by_month.old_sum_amount_list_price,
    user_retention_by_month.old_sum_amount_paid
   FROM public.user_retention_by_month(1) user_retention_by_month(month, num_consumers, repeat_consumers, num_tickets, sum_amount_list_price, sum_amount_paid, num_repeat_tickets, sum_repeat_amount_list_price, sum_repeat_amount_paid, frac_users_retained, frac_tickets_retained, frac_listprice_retained, frac_amountpaid_retained, old_month, old_num_consumers, old_repeat_consumers, old_num_tickets, old_sum_amount_list_price, old_sum_amount_paid);
CREATE VIEW mixalot.inm_dc_inventory AS
 SELECT dc_sku.product_id AS sku_id,
    sku_group.sku_group_id,
    sgd.title AS sku_group_title,
    ms.merchandising_slot_id,
    dc_sku.qty,
    dc_sku.sort_order,
    dc_sku.import_ts
   FROM (((mixalot.inm_data dc_sku
     JOIN mixalot.sku_group_sku sku_group ON ((dc_sku.product_id = sku_group.sku_id)))
     JOIN mixalot.merchandising_slot_sku_group ms ON ((sku_group.sku_group_id = ms.sku_group_id)))
     JOIN mixalot.sku_group_def sgd ON ((sku_group.sku_group_id = sgd.id)))
  WHERE ((dc_sku.data_type = 'Warehouse SKU Inventory'::text) AND (dc_sku.import_ts = ( SELECT max(dc_sku_1.import_ts) AS max
           FROM mixalot.inm_data dc_sku_1
          WHERE (dc_sku_1.data_type = 'Warehouse SKU Inventory'::text))));
CREATE VIEW public.byte_restockings_labels AS
 SELECT history_epc_order.order_id,
    history_epc_order.product_id,
    to_timestamp((min(history_epc_order."time"))::double precision) AS to_timestamp,
    min(k.id) AS kiosk_id,
    min((k.title)::text) AS title,
    count(*) AS count
   FROM (pantry.history_epc_order
     JOIN public.byte_kiosks k ON ((history_epc_order.kiosk_id = k.id)))
  WHERE ((history_epc_order.order_id)::text ~~ 'RE%'::text)
  GROUP BY history_epc_order.order_id, history_epc_order.product_id;
CREATE VIEW public.sys_slow_queries AS
 SELECT ((pg_stat_statements.total_time / (1000)::double precision) / (60)::double precision) AS total_minutes,
    (pg_stat_statements.total_time / (pg_stat_statements.calls)::double precision) AS average_time,
    pg_stat_statements.query
   FROM public.pg_stat_statements
  ORDER BY ((pg_stat_statements.total_time / (1000)::double precision) / (60)::double precision);
CREATE VIEW public.date_hours_2016 AS
 SELECT generate_series(('2016-01-01'::date)::timestamp with time zone, ('2017-01-01'::date)::timestamp with time zone, '01:00:00'::interval) AS hour_start,
    (generate_series(('2016-01-01'::date)::timestamp with time zone, ('2017-01-01'::date)::timestamp with time zone, '01:00:00'::interval) + '01:00:00'::interval) AS hour_end;
CREATE VIEW public.dp_stockouts_weekly_product_pct AS
 SELECT dp_stockouts_weekly_kiosk_product_pct.week,
    dp_stockouts_weekly_kiosk_product_pct.product_id,
    dp_stockouts_weekly_kiosk_product_pct.new_kiosk,
    max(dp_stockouts_weekly_kiosk_product_pct.days_in_week) AS days_in_week,
    sum(dp_stockouts_weekly_kiosk_product_pct.spoiled) AS spoiled_units,
    sum(dp_stockouts_weekly_kiosk_product_pct.sold) AS sold_units,
    public.frac(sum(dp_stockouts_weekly_kiosk_product_pct.spoiled), sum(dp_stockouts_weekly_kiosk_product_pct.sold)) AS spoiled_frac_units,
    sum(dp_stockouts_weekly_kiosk_product_pct.revenue) AS revenue,
    sum(dp_stockouts_weekly_kiosk_product_pct.cost) AS cost,
    sum(((dp_stockouts_weekly_kiosk_product_pct.spoiled)::numeric * dp_stockouts_weekly_kiosk_product_pct.unit_cost)) AS stockouts_dolr,
    sum(dp_stockouts_weekly_kiosk_product_pct.net_profit) AS net_profit,
    (sum(((dp_stockouts_weekly_kiosk_product_pct.spoiled)::numeric * dp_stockouts_weekly_kiosk_product_pct.unit_cost)) / (0.0001 + sum(dp_stockouts_weekly_kiosk_product_pct.revenue))) AS stockouts_frac_dolr
   FROM public.dp_stockouts_weekly_kiosk_product_pct
  GROUP BY dp_stockouts_weekly_kiosk_product_pct.week, dp_stockouts_weekly_kiosk_product_pct.product_id, dp_stockouts_weekly_kiosk_product_pct.new_kiosk
  ORDER BY dp_stockouts_weekly_kiosk_product_pct.product_id, dp_stockouts_weekly_kiosk_product_pct.new_kiosk, dp_stockouts_weekly_kiosk_product_pct.week DESC;
CREATE VIEW mixalot.inm_byte_kiosk AS
 SELECT kiosk.id,
    kiosk.campus_id,
    kiosk.title,
    kiosk.address
   FROM pantry.kiosk
  WHERE ((kiosk.archived <> 0) AND (kiosk.campus_id = 87));
CREATE VIEW public.byte_tickets_4months AS
 SELECT byte_tickets.order_id,
    byte_tickets.first_name,
    byte_tickets.last_name,
    byte_tickets.kiosk_id,
    byte_tickets.kiosk_title,
    byte_tickets.email,
    byte_tickets.amount_paid,
    byte_tickets.payment_system,
    byte_tickets.transaction_id,
    byte_tickets.approval_code,
    byte_tickets.status_code,
    byte_tickets.status_message,
    byte_tickets.status,
    byte_tickets.batch_id,
    byte_tickets.created,
    byte_tickets.auth_amount,
    byte_tickets.data_token,
    byte_tickets.time_opened,
    byte_tickets.time_closed,
    byte_tickets.card_hash,
    byte_tickets.state,
    byte_tickets.archived,
    byte_tickets.stamp,
    byte_tickets.last_update,
    byte_tickets.balance,
    byte_tickets.delta,
    byte_tickets.coupon_id,
    byte_tickets.coupon,
    byte_tickets.refund,
    byte_tickets.receipt,
    byte_tickets.campus_id,
    byte_tickets.amount_list_price,
    byte_tickets.notes,
    byte_tickets.time_door_opened,
    byte_tickets.time_door_closed,
    byte_tickets.client_name,
    byte_tickets.estd_num_users,
    byte_tickets.ts,
    byte_tickets.full_name,
    byte_tickets.door_opened_secs,
    byte_tickets.month,
    byte_tickets.week,
    byte_tickets.date,
    byte_tickets.dayofweek,
    byte_tickets.hour,
    byte_tickets.dowhour,
    byte_tickets.uniq_user
   FROM public.byte_tickets
  WHERE (byte_tickets.ts > (now() - '4 mons'::interval month));
CREATE VIEW public.dp_spoilage_monthly_pct AS
 SELECT dp_spoilage_monthly_kiosk_product_pct.month,
    sum(dp_spoilage_monthly_kiosk_product_pct.spoiled) AS spoiled_units,
    sum(dp_spoilage_monthly_kiosk_product_pct.sold) AS sold_units,
    public.frac(sum(dp_spoilage_monthly_kiosk_product_pct.spoiled), sum(dp_spoilage_monthly_kiosk_product_pct.sold)) AS spoiled_frac_units,
    sum(dp_spoilage_monthly_kiosk_product_pct.revenue) AS revenue,
    sum(dp_spoilage_monthly_kiosk_product_pct.cost) AS cost,
    sum(((dp_spoilage_monthly_kiosk_product_pct.spoiled)::numeric * dp_spoilage_monthly_kiosk_product_pct.unit_cost)) AS spoilage_dolr,
    sum(dp_spoilage_monthly_kiosk_product_pct.net_profit) AS net_profit,
    (sum(((dp_spoilage_monthly_kiosk_product_pct.spoiled)::numeric * dp_spoilage_monthly_kiosk_product_pct.unit_cost)) / sum(((dp_spoilage_monthly_kiosk_product_pct.sold)::numeric * dp_spoilage_monthly_kiosk_product_pct.unit_price))) AS spoilage_frac_dolr
   FROM public.dp_spoilage_monthly_kiosk_product_pct
  GROUP BY dp_spoilage_monthly_kiosk_product_pct.month
  ORDER BY dp_spoilage_monthly_kiosk_product_pct.month DESC;
CREATE VIEW report.dependency AS
 WITH RECURSIVE preference AS (
         SELECT 10 AS max_depth,
            16384 AS min_oid,
            '^(londiste|pgq|pg_toast)'::text AS schema_exclusion,
            '^pg_(conversion|language|ts_(dict|template))'::text AS class_exclusion,
            '{"SCHEMA":"00", "TABLE":"01", "TABLE CONSTRAINT":"02", "DEFAULT VALUE":"03",
        "INDEX":"05", "SEQUENCE":"06", "TRIGGER":"07", "FUNCTION":"08",
        "VIEW":"10", "MATERIALIZED VIEW":"11", "FOREIGN TABLE":"12"}'::json AS type_sort_orders
        ), dependency_pair AS (
         SELECT dep.objid,
            array_agg(dep.objsubid ORDER BY dep.objsubid) AS objsubids,
            upper(obj.type) AS object_type,
            COALESCE(obj.schema, "substring"(obj.identity, '(\w+?)\.'::text), ''::text) AS object_schema,
            obj.name AS object_name,
            obj.identity AS object_identity,
            dep.refobjid,
            array_agg(dep.refobjsubid ORDER BY dep.refobjsubid) AS refobjsubids,
            upper(refobj.type) AS refobj_type,
            COALESCE(
                CASE
                    WHEN (refobj.type = 'schema'::text) THEN refobj.identity
                    ELSE refobj.schema
                END, "substring"(refobj.identity, '(\w+?)\.'::text), ''::text) AS refobj_schema,
            refobj.name AS refobj_name,
            refobj.identity AS refobj_identity,
                CASE dep.deptype
                    WHEN 'n'::"char" THEN 'normal'::text
                    WHEN 'a'::"char" THEN 'automatic'::text
                    WHEN 'i'::"char" THEN 'internal'::text
                    WHEN 'e'::"char" THEN 'extension'::text
                    WHEN 'p'::"char" THEN 'pinned'::text
                    ELSE NULL::text
                END AS dependency_type
           FROM pg_depend dep,
            LATERAL pg_identify_object(dep.classid, dep.objid, 0) obj(type, schema, name, identity),
            LATERAL pg_identify_object(dep.refclassid, dep.refobjid, 0) refobj(type, schema, name, identity),
            preference
          WHERE ((dep.deptype = ANY ('{n,a}'::"char"[])) AND (dep.objid >= (preference.min_oid)::oid) AND ((dep.refobjid >= (preference.min_oid)::oid) OR (dep.refobjid = (2200)::oid)) AND (COALESCE(obj.schema, "substring"(obj.identity, '(\w+?)\.'::text), ''::text) !~ preference.schema_exclusion) AND (COALESCE(
                CASE
                    WHEN (refobj.type = 'schema'::text) THEN refobj.identity
                    ELSE refobj.schema
                END, "substring"(refobj.identity, '(\w+?)\.'::text), ''::text) !~ preference.schema_exclusion))
          GROUP BY dep.objid, obj.type, obj.schema, obj.name, obj.identity, dep.refobjid, refobj.type, refobj.schema, refobj.name, refobj.identity, dep.deptype
        ), dependency_hierarchy AS (
         SELECT DISTINCT 0 AS level,
            root.refobjid AS objid,
            root.refobj_type AS object_type,
            root.refobj_identity AS object_identity,
            NULL::text AS dependency_type,
            ARRAY[root.refobjid] AS dependency_chain,
            ARRAY[concat((preference.type_sort_orders ->> root.refobj_type), root.refobj_type, ':', root.refobj_identity)] AS dependency_sort_chain
           FROM dependency_pair root,
            preference
          WHERE ((NOT (EXISTS ( SELECT 'x'::text
                   FROM dependency_pair branch
                  WHERE (branch.objid = root.refobjid)))) AND (root.refobj_schema !~ preference.schema_exclusion))
        UNION ALL
         SELECT (parent.level + 1) AS level,
            child.objid,
            child.object_type,
            child.object_identity,
            child.dependency_type,
            (parent.dependency_chain || child.objid),
            (parent.dependency_sort_chain || concat((preference.type_sort_orders ->> child.object_type), child.object_type, ':', child.object_identity))
           FROM (dependency_pair child
             JOIN dependency_hierarchy parent ON ((parent.objid = child.refobjid))),
            preference
          WHERE ((parent.level < preference.max_depth) AND (child.object_schema !~ preference.schema_exclusion) AND (child.refobj_schema !~ preference.schema_exclusion) AND (NOT (child.objid = ANY (parent.dependency_chain))))
        )
 SELECT dependency_hierarchy.level,
    dependency_hierarchy.objid,
    dependency_hierarchy.object_type,
    dependency_hierarchy.object_identity,
    dependency_hierarchy.dependency_type,
    dependency_hierarchy.dependency_chain,
    dependency_hierarchy.dependency_sort_chain
   FROM dependency_hierarchy
  ORDER BY dependency_hierarchy.dependency_chain;
CREATE VIEW rptg.current_inventory AS
 SELECT spoiled_data.epc,
    spoiled_data.kiosk_id,
    spoiled_data.product_id,
    spoiled_data.time_added,
    spoiled_data.cost,
    spoiled_data.price,
    spoiled_data.kiosk_campus_id,
    spoiled_data.product_campus_id,
    spoiled_data.enable_reporting
   FROM ( SELECT unique_epcs.epc,
            all_epc_data.kiosk_id,
            all_epc_data.product_id,
            to_timestamp((all_epc_data.time_added)::double precision) AS time_added,
            all_epc_data.cost,
            all_epc_data.price,
            all_epc_data.kiosk_campus_id,
            all_epc_data.product_campus_id,
            all_epc_data.enable_reporting
           FROM (( SELECT l.epc,
                    max(l.time_added) AS time_added
                   FROM ((pantry.label l
                     JOIN pantry.kiosk k ON ((k.id = l.kiosk_id)))
                     JOIN pantry.product p ON ((p.id = l.product_id)))
                  WHERE (((l.status)::text = 'ok'::text) AND (l.order_id IS NULL))
                  GROUP BY l.epc) unique_epcs
             LEFT JOIN ( SELECT l.epc,
                    l.product_id,
                    l.time_added,
                    p.cost,
                    p.price,
                    l.kiosk_id,
                    k.campus_id AS kiosk_campus_id,
                    p.campus_id AS product_campus_id,
                    k.enable_reporting
                   FROM ((pantry.label l
                     JOIN pantry.kiosk k ON ((k.id = l.kiosk_id)))
                     JOIN pantry.product p ON ((p.id = l.product_id)))
                  WHERE (((l.status)::text = 'ok'::text) AND (l.order_id IS NULL))) all_epc_data ON ((((unique_epcs.epc)::text = (all_epc_data.epc)::text) AND (unique_epcs.time_added = all_epc_data.time_added))))) spoiled_data
  WHERE ((NOT ((spoiled_data.epc)::text IN ( SELECT l.epc
           FROM (((pantry.label l
             JOIN pantry.kiosk k ON ((k.id = l.kiosk_id)))
             JOIN pantry.product p ON ((p.id = l.product_id)))
             JOIN pantry."order" o ON (((o.order_id)::text = (l.order_id)::text)))
          WHERE (((to_timestamp((o.created)::double precision))::date >= ( SELECT ((now() - '1 mon'::interval))::date AS date)) AND ((to_timestamp((o.created)::double precision))::date <= ( SELECT ((now() + '1 mon'::interval))::date AS date)) AND ((l.status)::text = 'sold'::text) AND ((l.order_id)::text !~~ 'RE%'::text) AND (l.order_id IS NOT NULL))))) AND (NOT ((spoiled_data.epc)::text IN ( SELECT l.epc
           FROM (((pantry.label l
             JOIN pantry.kiosk k ON ((k.id = l.kiosk_id)))
             JOIN pantry.product p ON ((p.id = l.product_id)))
             JOIN pantry."order" o ON (((o.order_id)::text = (l.order_id)::text)))
          WHERE (((to_timestamp((o.created)::double precision))::date >= ( SELECT ((now() - '1 mon'::interval))::date AS date)) AND ((to_timestamp((o.created)::double precision))::date <= ( SELECT ((now() + '1 mon'::interval))::date AS date)) AND ((l.status)::text = 'sold'::text) AND ((l.order_id)::text ~~ 'RE%'::text))))));
CREATE VIEW byt_devops.pgdudetail_pretty AS
 SELECT 0 AS union_sort_order,
    pgdudetail.total_size AS total_size_sort_order,
    pgdudetail.table_name,
    pg_size_pretty(pgdudetail.table_size) AS table_size,
    pgdudetail.percent_table,
    pg_size_pretty(pgdudetail.indexes_size) AS indexes_size,
    pgdudetail.percent_index,
    pg_size_pretty(pgdudetail.total_size) AS total_size
   FROM byt_devops.pgdudetail
  ORDER BY pgdudetail.total_size DESC
 LIMIT 15;
CREATE VIEW public.byte_tickets_6days AS
 SELECT byte_tickets.order_id,
    byte_tickets.first_name,
    byte_tickets.last_name,
    byte_tickets.kiosk_id,
    byte_tickets.kiosk_title,
    byte_tickets.email,
    byte_tickets.amount_paid,
    byte_tickets.payment_system,
    byte_tickets.transaction_id,
    byte_tickets.approval_code,
    byte_tickets.status_code,
    byte_tickets.status_message,
    byte_tickets.status,
    byte_tickets.batch_id,
    byte_tickets.created,
    byte_tickets.auth_amount,
    byte_tickets.data_token,
    byte_tickets.time_opened,
    byte_tickets.time_closed,
    byte_tickets.card_hash,
    byte_tickets.state,
    byte_tickets.archived,
    byte_tickets.stamp,
    byte_tickets.last_update,
    byte_tickets.balance,
    byte_tickets.delta,
    byte_tickets.coupon_id,
    byte_tickets.coupon,
    byte_tickets.refund,
    byte_tickets.receipt,
    byte_tickets.campus_id,
    byte_tickets.amount_list_price,
    byte_tickets.notes,
    byte_tickets.time_door_opened,
    byte_tickets.time_door_closed,
    byte_tickets.client_name,
    byte_tickets.estd_num_users,
    byte_tickets.ts,
    byte_tickets.full_name,
    byte_tickets.door_opened_secs,
    byte_tickets.month,
    byte_tickets.week,
    byte_tickets.date,
    byte_tickets.dayofweek,
    byte_tickets.hour,
    byte_tickets.dowhour,
    byte_tickets.uniq_user
   FROM public.byte_tickets
  WHERE (byte_tickets.ts > (now() - '6 days'::interval day));
CREATE VIEW public.byte_tickets_labels AS
 SELECT o.order_id,
    o.first_name,
    o.last_name,
    o.kiosk_id,
    o.kiosk_title,
    o.email,
    o.amount_paid,
    o.payment_system,
    o.transaction_id,
    o.approval_code,
    o.status_code,
    o.status_message,
    o.status,
    o.batch_id,
    o.created,
    o.auth_amount,
    o.data_token,
    o.time_opened,
    o.time_closed,
    o.card_hash,
    o.state,
    o.archived,
    o.stamp,
    o.last_update,
    o.balance,
    o.delta,
    o.coupon_id,
    o.coupon,
    o.refund,
    o.receipt,
    o.campus_id,
    o.amount_list_price,
    o.notes,
    o.time_door_opened,
    o.time_door_closed,
    o.client_name,
    o.estd_num_users,
    o.ts,
    o.full_name,
    o.door_opened_secs,
    o.month,
    o.week,
    o.date,
    o.dayofweek,
    o.hour,
    o.dowhour,
    o.uniq_user,
    l.epc AS label_epc,
    l.status AS label_status,
    l.time_created AS label_time_created
   FROM (pantry.label l
     JOIN public.byte_tickets o ON (((o.order_id)::text = (l.order_id)::text)));
CREATE VIEW public.dp_epcssold AS
 SELECT byte_epcssold.order_id,
    byte_epcssold.first_name,
    byte_epcssold.last_name,
    byte_epcssold.kiosk_id,
    byte_epcssold.kiosk_title,
    byte_epcssold.email,
    byte_epcssold.amount_paid,
    byte_epcssold.payment_system,
    byte_epcssold.transaction_id,
    byte_epcssold.approval_code,
    byte_epcssold.status_code,
    byte_epcssold.status_message,
    byte_epcssold.status,
    byte_epcssold.batch_id,
    byte_epcssold.created,
    byte_epcssold.auth_amount,
    byte_epcssold.data_token,
    byte_epcssold.time_opened,
    byte_epcssold.time_closed,
    byte_epcssold.card_hash,
    byte_epcssold.state,
    byte_epcssold.archived,
    byte_epcssold.stamp,
    byte_epcssold.last_update,
    byte_epcssold.balance,
    byte_epcssold.delta,
    byte_epcssold.coupon_id,
    byte_epcssold.coupon,
    byte_epcssold.refund,
    byte_epcssold.receipt,
    byte_epcssold.campus_id,
    byte_epcssold.amount_list_price,
    byte_epcssold.notes,
    byte_epcssold.time_door_opened,
    byte_epcssold.time_door_closed,
    byte_epcssold.client_name,
    byte_epcssold.estd_num_users,
    byte_epcssold.ts,
    byte_epcssold.full_name,
    byte_epcssold.door_opened_secs,
    byte_epcssold.month,
    byte_epcssold.week,
    byte_epcssold.date,
    byte_epcssold.dayofweek,
    byte_epcssold.hour,
    byte_epcssold.dowhour,
    byte_epcssold.uniq_user,
    byte_epcssold.epc,
    byte_epcssold.label_order_id,
    byte_epcssold.label_status,
    byte_epcssold.label_price,
    byte_epcssold.time_created,
    byte_epcssold.time_added,
    byte_epcssold.time_updated,
    byte_epcssold.ts_created,
    byte_epcssold.ts_added,
    byte_epcssold.ts_updated,
    byte_epcssold.label_kiosk_id,
    byte_epcssold.product_id,
    byte_epcssold.product_title,
    byte_epcssold.product_archived,
    byte_epcssold.product_vendor,
    byte_epcssold.product_price,
    byte_epcssold.product_cost,
    byte_epcssold.product_shelf_life_days,
    byte_epcssold.product_attributes,
    byte_epcssold.product_categories,
    byte_epcssold.consumer_category,
    byte_epcssold.product_source
   FROM public.byte_epcssold;
CREATE VIEW beta.temp_test3 AS
 SELECT t1.id,
    t1.name,
    t2.value
   FROM (beta.temp_test t1
     JOIN beta.temp_test2 t2 ON ((t1.id = t2.id)));
CREATE VIEW inm.kiosk_projected_minimum AS
 SELECT combined_stock.kiosk_id,
    combined_stock.kiosk_title,
    combined_stock.fc_title,
    sga.minimum_kiosk_qty AS min_qty,
    sum(combined_stock.qty) AS stock_qty,
    ((sga.minimum_kiosk_qty)::numeric - sum(combined_stock.qty)) AS min_need
   FROM (( SELECT l.kiosk_id,
            k.title AS kiosk_title,
            p.fc_title,
            count(l.epc) AS qty
           FROM ((pantry.label l
             JOIN pantry.product p ON ((l.product_id = p.id)))
             JOIN pantry.kiosk k ON ((l.kiosk_id = k.id)))
          WHERE (((l.status)::text ~~ 'ok'::text) AND (k.campus_id = 87) AND (k.enable_reporting = 1) AND (k.archived <> 1) AND (l.kiosk_id <> 737))
          GROUP BY l.kiosk_id, k.title, p.fc_title
        UNION ALL
         SELECT a.kiosk_id,
            k.title AS kiosk_title,
            p.fc_title,
            a.qty
           FROM (((inm.pick_allocation a
             LEFT JOIN pantry."order" o ON (((a.route_date = (to_timestamp((o.created)::double precision))::date) AND (a.kiosk_id = o.kiosk_id) AND ((o.payment_system)::text = 'Restocking'::text))))
             JOIN pantry.product p ON ((a.sku_id = p.id)))
             JOIN pantry.kiosk k ON ((a.kiosk_id = k.id)))
          WHERE ((a.route_date >= ('now'::text)::date) AND (a.pick_date > (('now'::text)::date - 1)) AND (o.kiosk_id IS NULL))) combined_stock
     JOIN inm.sku_group_attribute sga ON (((combined_stock.fc_title)::text = (sga.title)::text)))
  GROUP BY combined_stock.kiosk_id, combined_stock.kiosk_title, combined_stock.fc_title, sga.minimum_kiosk_qty;
CREATE VIEW public.dbg_stockout_dowhours_weighted AS
 SELECT stockout_dowhours_weighted.kiosk_id,
    stockout_dowhours_weighted.product_id,
    stockout_dowhours_weighted.cat,
    public.fmt_ts(stockout_dowhours_weighted.ts) AS ts,
    public.fmt_ts(stockout_dowhours_weighted.restock_ts) AS restock_ts,
    stockout_dowhours_weighted.dowhour,
    public.interval_hours(stockout_dowhours_weighted.stockout_len) AS stockout_hrs,
    (stockout_dowhours_weighted.avg_cat_kiosk_sales)::numeric(6,2) AS avg_cat_kiosk_sales,
    (stockout_dowhours_weighted.avg_cat_sales)::numeric(6,2) AS avg_cat_sales,
    (stockout_dowhours_weighted.avg_kiosk_sales)::numeric(6,2) AS avg_kiosk_sales
   FROM public.stockout_dowhours_weighted
  ORDER BY stockout_dowhours_weighted.kiosk_id, stockout_dowhours_weighted.product_id, (public.fmt_ts(stockout_dowhours_weighted.ts));
CREATE VIEW byt_devops.pgdutotal_pretty AS
 SELECT 1 AS union_sort_order,
    sum(pgdudetail.total_size) AS total_size_sort_order,
    'All db objects'::text AS table_name,
    pg_size_pretty(sum(pgdudetail.table_size)) AS table_size,
    to_char(((sum(pgdudetail.table_size) / sum(pgdudetail.total_size)) * (100)::numeric), '999D9%'::text) AS percent_table,
    pg_size_pretty(sum(pgdudetail.indexes_size)) AS indexes_size,
    to_char(((sum(pgdudetail.indexes_size) / sum(pgdudetail.total_size)) * (100)::numeric), '999D9%'::text) AS percent_index,
    pg_size_pretty(sum(pgdudetail.total_size)) AS total_size
   FROM byt_devops.pgdudetail;
CREATE VIEW public.byte_spoilage AS
 SELECT t.kiosk_id,
    t.order_id,
    t.epc,
    t.product_id,
    t.ts_added,
    t.ts_removed,
    t.id,
    t.title,
    t.description,
    t.tiny_description,
    t.short_description,
    t.medium_description,
    t.long_description,
    t.price,
    t.cost,
    t.shelf_time,
    t.campus_id,
    t.image,
    t.image_time,
    t.last_update,
    t.archived,
    t.taxable,
    t.allergens,
    t.attribute_names,
    t.categories,
    t.category_names,
    t.vendor,
    t.source,
    t.notes,
    t.total_cal,
    t.num_servings,
    t.ingredients,
    t.calories,
    t.proteins,
    t.sugar,
    t.carbohydrates,
    t.fat,
    t.consumer_category,
    t.ws_case_size,
    t.kiosk_ship_qty,
    t.ws_case_cost,
    t.pick_station,
    t.fc_title,
    t.pricing_tier,
    t.width_space,
    t.height_space,
    t.depth_space,
    t.slotted_width,
    t.tag_volume,
    t.delivery_option,
    t.kiosk_title,
    t.address,
    t.location_x,
    t.location_y,
    t.client_name,
    t.tags,
    t.estd_num_users,
    date_trunc('month'::text, t.ts_removed) AS month,
    date_trunc('week'::text, t.ts_removed) AS week,
    date_trunc('day'::text, t.ts_removed) AS date
   FROM ( SELECT s.kiosk_id,
            s.order_id,
            s.epc,
            s.product_id,
            to_timestamp((s.time_added)::double precision) AS ts_added,
            to_timestamp((s.time_removed)::double precision) AS ts_removed,
            p.id,
            p.title,
            p.description,
            p.tiny_description,
            p.short_description,
            p.medium_description,
            p.long_description,
            p.price,
            p.cost,
            p.shelf_time,
            p.campus_id,
            p.image,
            p.image_time,
            p.last_update,
            p.archived,
            p.taxable,
            p.allergens,
            p.attribute_names,
            p.categories,
            p.category_names,
            p.vendor,
            p.source,
            p.notes,
            p.total_cal,
            p.num_servings,
            p.ingredients,
            p.calories,
            p.proteins,
            p.sugar,
            p.carbohydrates,
            p.fat,
            p.consumer_category,
            p.ws_case_size,
            p.kiosk_ship_qty,
            p.ws_case_cost,
            p.pick_station,
            p.fc_title,
            p.pricing_tier,
            p.width_space,
            p.height_space,
            p.depth_space,
            p.slotted_width,
            p.tag_volume,
            p.delivery_option,
            k.title AS kiosk_title,
            k.address,
            k.location_x,
            k.location_y,
            k.client_name,
            k.tags,
            k.estd_num_users
           FROM ((pantry.spoilage s
             JOIN pantry.product p ON ((s.product_id = p.id)))
             JOIN pantry.kiosk k ON ((s.kiosk_id = k.id)))
          WHERE ((k.campus_id = 87) AND (s.order_id IS NOT NULL) AND (k.enable_reporting = 1))) t;
CREATE VIEW public.spoilagepct_by_shelflife_120d AS
 SELECT t1.shelf_life,
    sum(t1.sales) AS sales,
    sum(t2.spoilage_dolr) AS spoilage_dolr,
    public.if((sum(t2.spoilage_dolr) > 0.0), (sum(t2.spoilage_dolr) / sum(t1.sales)), 0.0) AS spoilage_frac
   FROM (public.sales_by_shelflife_120d t1
     JOIN public.spoilage_by_shelflife_120d t2 ON ((t1.shelf_life = t2.shelf_life)))
  GROUP BY t1.shelf_life
  ORDER BY t1.shelf_life;
CREATE VIEW public.byte_tickets_360days AS
 SELECT byte_tickets.order_id,
    byte_tickets.first_name,
    byte_tickets.last_name,
    byte_tickets.kiosk_id,
    byte_tickets.kiosk_title,
    byte_tickets.email,
    byte_tickets.amount_paid,
    byte_tickets.payment_system,
    byte_tickets.transaction_id,
    byte_tickets.approval_code,
    byte_tickets.status_code,
    byte_tickets.status_message,
    byte_tickets.status,
    byte_tickets.batch_id,
    byte_tickets.created,
    byte_tickets.auth_amount,
    byte_tickets.data_token,
    byte_tickets.time_opened,
    byte_tickets.time_closed,
    byte_tickets.card_hash,
    byte_tickets.state,
    byte_tickets.archived,
    byte_tickets.stamp,
    byte_tickets.last_update,
    byte_tickets.balance,
    byte_tickets.delta,
    byte_tickets.coupon_id,
    byte_tickets.coupon,
    byte_tickets.refund,
    byte_tickets.receipt,
    byte_tickets.campus_id,
    byte_tickets.amount_list_price,
    byte_tickets.notes,
    byte_tickets.time_door_opened,
    byte_tickets.time_door_closed,
    byte_tickets.client_name,
    byte_tickets.estd_num_users,
    byte_tickets.ts,
    byte_tickets.full_name,
    byte_tickets.door_opened_secs,
    byte_tickets.month,
    byte_tickets.week,
    byte_tickets.date,
    byte_tickets.dayofweek,
    byte_tickets.hour,
    byte_tickets.dowhour,
    byte_tickets.uniq_user
   FROM public.byte_tickets
  WHERE (byte_tickets.ts > (now() - '360 days'::interval day));
CREATE VIEW public.byte_tickets_yesterday AS
 SELECT byte_tickets.order_id,
    byte_tickets.first_name,
    byte_tickets.last_name,
    byte_tickets.kiosk_id,
    byte_tickets.kiosk_title,
    byte_tickets.email,
    byte_tickets.amount_paid,
    byte_tickets.payment_system,
    byte_tickets.transaction_id,
    byte_tickets.approval_code,
    byte_tickets.status_code,
    byte_tickets.status_message,
    byte_tickets.status,
    byte_tickets.batch_id,
    byte_tickets.created,
    byte_tickets.auth_amount,
    byte_tickets.data_token,
    byte_tickets.time_opened,
    byte_tickets.time_closed,
    byte_tickets.card_hash,
    byte_tickets.state,
    byte_tickets.archived,
    byte_tickets.stamp,
    byte_tickets.last_update,
    byte_tickets.balance,
    byte_tickets.delta,
    byte_tickets.coupon_id,
    byte_tickets.coupon,
    byte_tickets.refund,
    byte_tickets.receipt,
    byte_tickets.campus_id,
    byte_tickets.amount_list_price,
    byte_tickets.notes,
    byte_tickets.time_door_opened,
    byte_tickets.time_door_closed,
    byte_tickets.client_name,
    byte_tickets.estd_num_users,
    byte_tickets.ts,
    byte_tickets.full_name,
    byte_tickets.door_opened_secs,
    byte_tickets.month,
    byte_tickets.week,
    byte_tickets.date,
    byte_tickets.dayofweek,
    byte_tickets.hour,
    byte_tickets.dowhour,
    byte_tickets.uniq_user
   FROM public.byte_tickets
  WHERE ((byte_tickets.ts >= (date_trunc('day'::text, ('now'::text)::timestamp without time zone) - '1 day'::interval day)) AND (byte_tickets.ts <= date_trunc('day'::text, ('now'::text)::timestamp without time zone)));
CREATE VIEW public.dp_stockouts_weekly_sold_join AS
 SELECT COALESCE(t1.week, t2.week) AS week,
    COALESCE((t1.kiosk_id)::bigint, t2.kiosk_id) AS kiosk_id,
    COALESCE((t1.product_id)::bigint, t2.product_id) AS product_id,
    COALESCE(t1.spoiled, (0)::bigint) AS spoiled,
    COALESCE(t2.sold, (0)::bigint) AS sold,
    t2.days_in_week
   FROM (( SELECT s.week,
            s.kiosk_id,
            s.product_id,
            count(*) AS spoiled
           FROM public.dp_stockouts s
          GROUP BY s.week, s.kiosk_id, s.product_id) t1
     FULL JOIN ( SELECT dp_epcssold.week,
            dp_epcssold.kiosk_id,
            dp_epcssold.product_id,
            count(DISTINCT dp_epcssold.date) AS days_in_week,
            count(*) AS sold
           FROM public.dp_epcssold
          GROUP BY dp_epcssold.week, dp_epcssold.kiosk_id, dp_epcssold.product_id) t2 ON (((t1.product_id = t2.product_id) AND (t1.week = t2.week) AND (t1.kiosk_id = t2.kiosk_id))));
CREATE VIEW inm.view_sku_sku_group AS
 SELECT p.id AS product_id,
    p.title,
    sga.id AS sku_group_id,
    p.fc_title
   FROM (pantry.product p
     JOIN inm.sku_group_attribute sga ON (((p.fc_title)::text = (sga.title)::text)))
  WHERE ((p.campus_id = 87) AND (p.fc_title IS NOT NULL) AND (p.archived = 0));
CREATE VIEW public.byte_tickets_3weeks AS
 SELECT byte_tickets.order_id,
    byte_tickets.first_name,
    byte_tickets.last_name,
    byte_tickets.kiosk_id,
    byte_tickets.kiosk_title,
    byte_tickets.email,
    byte_tickets.amount_paid,
    byte_tickets.payment_system,
    byte_tickets.transaction_id,
    byte_tickets.approval_code,
    byte_tickets.status_code,
    byte_tickets.status_message,
    byte_tickets.status,
    byte_tickets.batch_id,
    byte_tickets.created,
    byte_tickets.auth_amount,
    byte_tickets.data_token,
    byte_tickets.time_opened,
    byte_tickets.time_closed,
    byte_tickets.card_hash,
    byte_tickets.state,
    byte_tickets.archived,
    byte_tickets.stamp,
    byte_tickets.last_update,
    byte_tickets.balance,
    byte_tickets.delta,
    byte_tickets.coupon_id,
    byte_tickets.coupon,
    byte_tickets.refund,
    byte_tickets.receipt,
    byte_tickets.campus_id,
    byte_tickets.amount_list_price,
    byte_tickets.notes,
    byte_tickets.time_door_opened,
    byte_tickets.time_door_closed,
    byte_tickets.client_name,
    byte_tickets.estd_num_users,
    byte_tickets.ts,
    byte_tickets.full_name,
    byte_tickets.door_opened_secs,
    byte_tickets.month,
    byte_tickets.week,
    byte_tickets.date,
    byte_tickets.dayofweek,
    byte_tickets.hour,
    byte_tickets.dowhour,
    byte_tickets.uniq_user
   FROM public.byte_tickets
  WHERE (byte_tickets.ts > (now() - '21 days'::interval day));
CREATE VIEW public.dp_stockouts_weekly_kiosk_product_pct AS
 SELECT dp_stockouts_weekly_calc.week,
    dp_stockouts_weekly_calc.kiosk_id,
    dp_stockouts_weekly_calc.product_id,
    dp_stockouts_weekly_calc.spoiled,
    dp_stockouts_weekly_calc.sold,
    dp_stockouts_weekly_calc.days_in_week,
    dp_stockouts_weekly_calc.product_title,
    dp_stockouts_weekly_calc.kiosk_title,
    dp_stockouts_weekly_calc.unit_price,
    dp_stockouts_weekly_calc.unit_cost,
    dp_stockouts_weekly_calc.spoiled_frac_units,
    dp_stockouts_weekly_calc.revenue,
    dp_stockouts_weekly_calc.cost,
    dp_stockouts_weekly_calc.stockouts_frac,
    dp_stockouts_weekly_calc.new_kiosk,
    (dp_stockouts_weekly_calc.revenue - dp_stockouts_weekly_calc.cost) AS net_profit
   FROM public.dp_stockouts_weekly_calc;
CREATE VIEW public.byte_tickets_2016 AS
 SELECT byte_tickets.order_id,
    byte_tickets.first_name,
    byte_tickets.last_name,
    byte_tickets.kiosk_id,
    byte_tickets.kiosk_title,
    byte_tickets.email,
    byte_tickets.amount_paid,
    byte_tickets.payment_system,
    byte_tickets.transaction_id,
    byte_tickets.approval_code,
    byte_tickets.status_code,
    byte_tickets.status_message,
    byte_tickets.status,
    byte_tickets.batch_id,
    byte_tickets.created,
    byte_tickets.auth_amount,
    byte_tickets.data_token,
    byte_tickets.time_opened,
    byte_tickets.time_closed,
    byte_tickets.card_hash,
    byte_tickets.state,
    byte_tickets.archived,
    byte_tickets.stamp,
    byte_tickets.last_update,
    byte_tickets.balance,
    byte_tickets.delta,
    byte_tickets.coupon_id,
    byte_tickets.coupon,
    byte_tickets.refund,
    byte_tickets.receipt,
    byte_tickets.campus_id,
    byte_tickets.amount_list_price,
    byte_tickets.notes,
    byte_tickets.time_door_opened,
    byte_tickets.time_door_closed,
    byte_tickets.client_name,
    byte_tickets.estd_num_users,
    byte_tickets.ts,
    byte_tickets.full_name,
    byte_tickets.door_opened_secs,
    byte_tickets.month,
    byte_tickets.week,
    byte_tickets.date,
    byte_tickets.dayofweek,
    byte_tickets.hour,
    byte_tickets.dowhour,
    byte_tickets.uniq_user
   FROM public.byte_tickets
  WHERE ((byte_tickets.ts >= '2016-01-01 08:00:00+00'::timestamp with time zone) AND (byte_tickets.ts < '2017-01-01 08:00:00+00'::timestamp with time zone));
CREATE VIEW public.byte_epcssold_3weeks AS
 SELECT o.order_id,
    o.first_name,
    o.last_name,
    o.kiosk_id,
    o.kiosk_title,
    o.email,
    o.amount_paid,
    o.payment_system,
    o.transaction_id,
    o.approval_code,
    o.status_code,
    o.status_message,
    o.status,
    o.batch_id,
    o.created,
    o.auth_amount,
    o.data_token,
    o.time_opened,
    o.time_closed,
    o.card_hash,
    o.state,
    o.archived,
    o.stamp,
    o.last_update,
    o.balance,
    o.delta,
    o.coupon_id,
    o.coupon,
    o.refund,
    o.receipt,
    o.campus_id,
    o.amount_list_price,
    o.notes,
    o.time_door_opened,
    o.time_door_closed,
    o.client_name,
    o.estd_num_users,
    o.ts,
    o.full_name,
    o.door_opened_secs,
    o.month,
    o.week,
    o.date,
    o.dayofweek,
    o.hour,
    o.dowhour,
    o.uniq_user,
    lp.epc,
    lp.label_order_id,
    lp.label_status,
    lp.label_price,
    lp.time_created,
    lp.time_added,
    lp.time_updated,
    lp.ts_created,
    lp.ts_added,
    lp.ts_updated,
    lp.label_kiosk_id,
    lp.product_id,
    lp.product_title,
    lp.product_archived,
    lp.product_vendor,
    lp.product_price,
    lp.product_cost,
    lp.product_shelf_life_days,
    lp.product_attributes,
    lp.product_categories,
    lp.consumer_category,
    lp.product_source
   FROM (public.byte_tickets_3weeks o
     JOIN public.byte_label_product lp ON (((lp.label_order_id)::text = (o.order_id)::text)))
  WHERE ((lp.label_status)::text = 'sold'::text);
CREATE VIEW public.stockout_avg_kiosk_cat_sales_dowhour AS
 WITH _unused AS (
         SELECT 1
        ), epcs_sold_recently AS (
         SELECT e.kiosk_id,
            e.product_id,
            e.label_price,
            e.consumer_category AS cat,
            e.dowhour
           FROM public.byte_epcssold_fast e
          WHERE (e.ts > (now() - '45 days'::interval))
        ), _avg_kiosk_sales_dowhour AS (
         SELECT epcs_sold_recently.kiosk_id,
            epcs_sold_recently.dowhour,
            sum(epcs_sold_recently.label_price) AS sales,
            count(*) AS cnt,
            (sum(epcs_sold_recently.label_price) / (count(*))::numeric) AS avg_kiosk_sales
           FROM epcs_sold_recently
          GROUP BY epcs_sold_recently.kiosk_id, epcs_sold_recently.dowhour
        ), _avg_sku_sales_dowhour AS (
         SELECT epcs_sold_recently.product_id,
            epcs_sold_recently.dowhour,
            sum(epcs_sold_recently.label_price) AS sales,
            count(*) AS cnt,
            (sum(epcs_sold_recently.label_price) / (count(*))::numeric) AS avg_sku_sales
           FROM epcs_sold_recently
          GROUP BY epcs_sold_recently.product_id, epcs_sold_recently.dowhour
        ), avg_kiosk_sales_dowhour AS (
         SELECT dh.dowhour,
            s.kiosk_id,
            s.avg_kiosk_sales
           FROM (public.dowhours dh
             JOIN _avg_kiosk_sales_dowhour s ON ((dh.dowhour = s.dowhour)))
        ), avg_sku_sales_dowhour AS (
         SELECT dh.dowhour,
            s.product_id,
            s.avg_sku_sales
           FROM (public.dowhours dh
             JOIN _avg_sku_sales_dowhour s ON ((dh.dowhour = s.dowhour)))
        ), _avg_cat_sales_dowhour AS (
         SELECT p.consumer_category AS cat,
            ss.dowhour,
            (sum(ss.sales) / sum(ss.cnt)) AS avg_cat_sales
           FROM (_avg_sku_sales_dowhour ss
             JOIN pantry.product p ON ((ss.product_id = p.id)))
          GROUP BY p.consumer_category, ss.dowhour
        ), avg_cat_sales_dowhour AS (
         SELECT dh.dowhour,
            s.cat,
            s.avg_cat_sales
           FROM (public.dowhours dh
             LEFT JOIN _avg_cat_sales_dowhour s ON ((dh.dowhour = s.dowhour)))
        ), stockout_avg_kiosk_cat_sales_dowhour AS (
         SELECT DISTINCT e.kiosk_id,
            e.cat,
            ss.dowhour,
            (COALESCE(ss.avg_cat_sales, 1.0) * COALESCE(ks.avg_kiosk_sales, 1.0)) AS avg_cat_kiosk_sales,
            ss.avg_cat_sales,
            ks.avg_kiosk_sales
           FROM ((epcs_sold_recently e
             LEFT JOIN avg_cat_sales_dowhour ss ON (((e.cat)::text = (ss.cat)::text)))
             FULL JOIN avg_kiosk_sales_dowhour ks ON (((e.kiosk_id = ks.kiosk_id) AND (ss.dowhour = ks.dowhour))))
        )
 SELECT stockout_avg_kiosk_cat_sales_dowhour.kiosk_id,
    stockout_avg_kiosk_cat_sales_dowhour.cat,
    stockout_avg_kiosk_cat_sales_dowhour.dowhour,
    stockout_avg_kiosk_cat_sales_dowhour.avg_cat_kiosk_sales,
    stockout_avg_kiosk_cat_sales_dowhour.avg_cat_sales,
    stockout_avg_kiosk_cat_sales_dowhour.avg_kiosk_sales
   FROM stockout_avg_kiosk_cat_sales_dowhour;
CREATE VIEW public.dbg_stockout_dowhours_weighted_stats AS
 SELECT count(*) AS count,
    count(DISTINCT stockout_dowhours_weighted.kiosk_id) AS kiosks,
    count(DISTINCT stockout_dowhours_weighted.product_id) AS products,
    count(DISTINCT stockout_dowhours_weighted.dowhour) AS dowhours,
    count(DISTINCT stockout_dowhours_weighted.cat) AS cats
   FROM public.stockout_dowhours_weighted;
CREATE VIEW inm_beta.allocable_inventory AS
 SELECT warehouse_inventory.inventory_date,
    warehouse_inventory.product_id,
    ((warehouse_inventory.stickered_units + (warehouse_inventory.stickered_cases * warehouse_inventory.units_per_case)) - warehouse_inventory.spoiled_units) AS qty
   FROM inm.warehouse_inventory;
CREATE VIEW public.byte_tickets_5weeks AS
 SELECT byte_tickets.order_id,
    byte_tickets.first_name,
    byte_tickets.last_name,
    byte_tickets.kiosk_id,
    byte_tickets.kiosk_title,
    byte_tickets.email,
    byte_tickets.amount_paid,
    byte_tickets.payment_system,
    byte_tickets.transaction_id,
    byte_tickets.approval_code,
    byte_tickets.status_code,
    byte_tickets.status_message,
    byte_tickets.status,
    byte_tickets.batch_id,
    byte_tickets.created,
    byte_tickets.auth_amount,
    byte_tickets.data_token,
    byte_tickets.time_opened,
    byte_tickets.time_closed,
    byte_tickets.card_hash,
    byte_tickets.state,
    byte_tickets.archived,
    byte_tickets.stamp,
    byte_tickets.last_update,
    byte_tickets.balance,
    byte_tickets.delta,
    byte_tickets.coupon_id,
    byte_tickets.coupon,
    byte_tickets.refund,
    byte_tickets.receipt,
    byte_tickets.campus_id,
    byte_tickets.amount_list_price,
    byte_tickets.notes,
    byte_tickets.time_door_opened,
    byte_tickets.time_door_closed,
    byte_tickets.client_name,
    byte_tickets.estd_num_users,
    byte_tickets.ts,
    byte_tickets.full_name,
    byte_tickets.door_opened_secs,
    byte_tickets.month,
    byte_tickets.week,
    byte_tickets.date,
    byte_tickets.dayofweek,
    byte_tickets.hour,
    byte_tickets.dowhour,
    byte_tickets.uniq_user
   FROM public.byte_tickets
  WHERE (byte_tickets.ts > (now() - '35 days'::interval day));
CREATE VIEW public.byte_epcssold_fast AS
 SELECT byte_epcssold.order_id,
    byte_epcssold.first_name,
    byte_epcssold.last_name,
    byte_epcssold.kiosk_id,
    byte_epcssold.kiosk_title,
    byte_epcssold.email,
    byte_epcssold.amount_paid,
    byte_epcssold.payment_system,
    byte_epcssold.transaction_id,
    byte_epcssold.approval_code,
    byte_epcssold.status_code,
    byte_epcssold.status_message,
    byte_epcssold.status,
    byte_epcssold.batch_id,
    byte_epcssold.created,
    byte_epcssold.auth_amount,
    byte_epcssold.data_token,
    byte_epcssold.time_opened,
    byte_epcssold.time_closed,
    byte_epcssold.card_hash,
    byte_epcssold.state,
    byte_epcssold.archived,
    byte_epcssold.stamp,
    byte_epcssold.last_update,
    byte_epcssold.balance,
    byte_epcssold.delta,
    byte_epcssold.coupon_id,
    byte_epcssold.coupon,
    byte_epcssold.refund,
    byte_epcssold.receipt,
    byte_epcssold.campus_id,
    byte_epcssold.amount_list_price,
    byte_epcssold.notes,
    byte_epcssold.time_door_opened,
    byte_epcssold.time_door_closed,
    byte_epcssold.client_name,
    byte_epcssold.estd_num_users,
    byte_epcssold.ts,
    byte_epcssold.full_name,
    byte_epcssold.door_opened_secs,
    byte_epcssold.month,
    byte_epcssold.week,
    byte_epcssold.date,
    byte_epcssold.dayofweek,
    byte_epcssold.hour,
    byte_epcssold.dowhour,
    byte_epcssold.uniq_user,
    byte_epcssold.epc,
    byte_epcssold.label_order_id,
    byte_epcssold.label_status,
    byte_epcssold.label_price,
    byte_epcssold.time_created,
    byte_epcssold.time_added,
    byte_epcssold.time_updated,
    byte_epcssold.ts_created,
    byte_epcssold.ts_added,
    byte_epcssold.ts_updated,
    byte_epcssold.label_kiosk_id,
    byte_epcssold.product_id,
    byte_epcssold.product_title,
    byte_epcssold.product_archived,
    byte_epcssold.product_vendor,
    byte_epcssold.product_price,
    byte_epcssold.product_cost,
    byte_epcssold.product_shelf_life_days,
    byte_epcssold.product_attributes,
    byte_epcssold.product_categories,
    byte_epcssold.consumer_category,
    byte_epcssold.product_source
   FROM public.byte_epcssold;
CREATE VIEW public.byte_stockouts_by_category_week_crosstab AS
 SELECT ct.week,
    ct.breakfast_hrs_per_old_kiosk,
    ct.breakfast_hrs_per_new_kiosk,
    ct.breakfast_hrs_per_kiosk,
    ct.burritos_hrs_per_old_kiosk,
    ct.burritos_hrs_per_new_kiosk,
    ct.burritos_hrs_per_kiosk,
    ct.desserts_hrs_per_old_kiosk,
    ct.desserts_hrs_per_new_kiosk,
    ct.desserts_hrs_per_kiosk,
    ct.drinks_hrs_per_old_kiosk,
    ct.drinks_hrs_per_new_kiosk,
    ct.drinks_hrs_per_kiosk,
    ct.entrees_hrs_per_old_kiosk,
    ct.entrees_hrs_per_new_kiosk,
    ct.entrees_hrs_per_kiosk,
    ct.sandwiches_wraps_hrs_per_old_kiosk,
    ct.sandwiches_wraps_hrs_per_new_kiosk,
    ct.sandwiches_wraps_hrs_per_kiosk,
    ct.snacks_hrs_per_old_kiosk,
    ct.snacks_hrs_per_new_kiosk,
    ct.snacks_hrs_per_kiosk,
    ct.soups_salads_hrs_per_old_kiosk,
    ct.soups_salads_hrs_per_new_kiosk,
    ct.soups_salads_hrs_per_kiosk
   FROM public.crosstab('select to_char(week,''YYYY-MM-DD'') as week,cat_and_new,stockout_hrs from byte_stockouts_by_category_week order by week desc,cat_and_new desc'::text) ct(week text, breakfast_hrs_per_old_kiosk double precision, breakfast_hrs_per_new_kiosk double precision, breakfast_hrs_per_kiosk double precision, burritos_hrs_per_old_kiosk double precision, burritos_hrs_per_new_kiosk double precision, burritos_hrs_per_kiosk double precision, desserts_hrs_per_old_kiosk double precision, desserts_hrs_per_new_kiosk double precision, desserts_hrs_per_kiosk double precision, drinks_hrs_per_old_kiosk double precision, drinks_hrs_per_new_kiosk double precision, drinks_hrs_per_kiosk double precision, entrees_hrs_per_old_kiosk double precision, entrees_hrs_per_new_kiosk double precision, entrees_hrs_per_kiosk double precision, sandwiches_wraps_hrs_per_old_kiosk double precision, sandwiches_wraps_hrs_per_new_kiosk double precision, sandwiches_wraps_hrs_per_kiosk double precision, snacks_hrs_per_old_kiosk double precision, snacks_hrs_per_new_kiosk double precision, snacks_hrs_per_kiosk double precision, soups_salads_hrs_per_old_kiosk double precision, soups_salads_hrs_per_new_kiosk double precision, soups_salads_hrs_per_kiosk double precision);
CREATE VIEW public.user_retention_4months AS
 SELECT user_retention_by_month.month,
    user_retention_by_month.num_consumers,
    user_retention_by_month.repeat_consumers,
    user_retention_by_month.num_tickets,
    user_retention_by_month.sum_amount_list_price,
    user_retention_by_month.sum_amount_paid,
    user_retention_by_month.num_repeat_tickets,
    user_retention_by_month.sum_repeat_amount_list_price,
    user_retention_by_month.sum_repeat_amount_paid,
    user_retention_by_month.frac_users_retained,
    user_retention_by_month.frac_tickets_retained,
    user_retention_by_month.frac_listprice_retained,
    user_retention_by_month.frac_amountpaid_retained,
    user_retention_by_month.old_month,
    user_retention_by_month.old_num_consumers,
    user_retention_by_month.old_repeat_consumers,
    user_retention_by_month.old_num_tickets,
    user_retention_by_month.old_sum_amount_list_price,
    user_retention_by_month.old_sum_amount_paid
   FROM public.user_retention_by_month(4) user_retention_by_month(month, num_consumers, repeat_consumers, num_tickets, sum_amount_list_price, sum_amount_paid, num_repeat_tickets, sum_repeat_amount_list_price, sum_repeat_amount_paid, frac_users_retained, frac_tickets_retained, frac_listprice_retained, frac_amountpaid_retained, old_month, old_num_consumers, old_repeat_consumers, old_num_tickets, old_sum_amount_list_price, old_sum_amount_paid);
CREATE VIEW public.byte_epcssold_2days AS
 SELECT o.order_id,
    o.first_name,
    o.last_name,
    o.kiosk_id,
    o.kiosk_title,
    o.email,
    o.amount_paid,
    o.payment_system,
    o.transaction_id,
    o.approval_code,
    o.status_code,
    o.status_message,
    o.status,
    o.batch_id,
    o.created,
    o.auth_amount,
    o.data_token,
    o.time_opened,
    o.time_closed,
    o.card_hash,
    o.state,
    o.archived,
    o.stamp,
    o.last_update,
    o.balance,
    o.delta,
    o.coupon_id,
    o.coupon,
    o.refund,
    o.receipt,
    o.campus_id,
    o.amount_list_price,
    o.notes,
    o.time_door_opened,
    o.time_door_closed,
    o.client_name,
    o.estd_num_users,
    o.ts,
    o.full_name,
    o.door_opened_secs,
    o.month,
    o.week,
    o.date,
    o.dayofweek,
    o.hour,
    o.dowhour,
    o.uniq_user,
    lp.epc,
    lp.label_order_id,
    lp.label_status,
    lp.label_price,
    lp.time_created,
    lp.time_added,
    lp.time_updated,
    lp.ts_created,
    lp.ts_added,
    lp.ts_updated,
    lp.label_kiosk_id,
    lp.product_id,
    lp.product_title,
    lp.product_archived,
    lp.product_vendor,
    lp.product_price,
    lp.product_cost,
    lp.product_shelf_life_days,
    lp.product_attributes,
    lp.product_categories,
    lp.consumer_category,
    lp.product_source
   FROM (public.byte_tickets_2days o
     JOIN public.byte_label_product lp ON (((lp.label_order_id)::text = (o.order_id)::text)))
  WHERE ((lp.label_status)::text = 'sold'::text);
CREATE VIEW public.byte_epcssold_30days AS
 SELECT o.order_id,
    o.first_name,
    o.last_name,
    o.kiosk_id,
    o.kiosk_title,
    o.email,
    o.amount_paid,
    o.payment_system,
    o.transaction_id,
    o.approval_code,
    o.status_code,
    o.status_message,
    o.status,
    o.batch_id,
    o.created,
    o.auth_amount,
    o.data_token,
    o.time_opened,
    o.time_closed,
    o.card_hash,
    o.state,
    o.archived,
    o.stamp,
    o.last_update,
    o.balance,
    o.delta,
    o.coupon_id,
    o.coupon,
    o.refund,
    o.receipt,
    o.campus_id,
    o.amount_list_price,
    o.notes,
    o.time_door_opened,
    o.time_door_closed,
    o.client_name,
    o.estd_num_users,
    o.ts,
    o.full_name,
    o.door_opened_secs,
    o.month,
    o.week,
    o.date,
    o.dayofweek,
    o.hour,
    o.dowhour,
    o.uniq_user,
    lp.epc,
    lp.label_order_id,
    lp.label_status,
    lp.label_price,
    lp.time_created,
    lp.time_added,
    lp.time_updated,
    lp.ts_created,
    lp.ts_added,
    lp.ts_updated,
    lp.label_kiosk_id,
    lp.product_id,
    lp.product_title,
    lp.product_archived,
    lp.product_vendor,
    lp.product_price,
    lp.product_cost,
    lp.product_shelf_life_days,
    lp.product_attributes,
    lp.product_categories,
    lp.consumer_category,
    lp.product_source
   FROM (public.byte_tickets_30days o
     JOIN public.byte_label_product lp ON (((lp.label_order_id)::text = (o.order_id)::text)))
  WHERE ((lp.label_status)::text = 'sold'::text);
CREATE VIEW public.byte_tickets_today AS
 SELECT byte_tickets.order_id,
    byte_tickets.first_name,
    byte_tickets.last_name,
    byte_tickets.kiosk_id,
    byte_tickets.kiosk_title,
    byte_tickets.email,
    byte_tickets.amount_paid,
    byte_tickets.payment_system,
    byte_tickets.transaction_id,
    byte_tickets.approval_code,
    byte_tickets.status_code,
    byte_tickets.status_message,
    byte_tickets.status,
    byte_tickets.batch_id,
    byte_tickets.created,
    byte_tickets.auth_amount,
    byte_tickets.data_token,
    byte_tickets.time_opened,
    byte_tickets.time_closed,
    byte_tickets.card_hash,
    byte_tickets.state,
    byte_tickets.archived,
    byte_tickets.stamp,
    byte_tickets.last_update,
    byte_tickets.balance,
    byte_tickets.delta,
    byte_tickets.coupon_id,
    byte_tickets.coupon,
    byte_tickets.refund,
    byte_tickets.receipt,
    byte_tickets.campus_id,
    byte_tickets.amount_list_price,
    byte_tickets.notes,
    byte_tickets.time_door_opened,
    byte_tickets.time_door_closed,
    byte_tickets.client_name,
    byte_tickets.estd_num_users,
    byte_tickets.ts,
    byte_tickets.full_name,
    byte_tickets.door_opened_secs,
    byte_tickets.month,
    byte_tickets.week,
    byte_tickets.date,
    byte_tickets.dayofweek,
    byte_tickets.hour,
    byte_tickets.dowhour,
    byte_tickets.uniq_user
   FROM public.byte_tickets
  WHERE (byte_tickets.ts > date_trunc('day'::text, ('now'::text)::timestamp without time zone));
CREATE VIEW public.user_retention_6weeks AS
 SELECT user_retention_by_week.week,
    user_retention_by_week.num_consumers,
    user_retention_by_week.repeat_consumers,
    user_retention_by_week.num_tickets,
    user_retention_by_week.sum_amount_list_price,
    user_retention_by_week.sum_amount_paid,
    user_retention_by_week.num_repeat_tickets,
    user_retention_by_week.sum_repeat_amount_list_price,
    user_retention_by_week.sum_repeat_amount_paid,
    user_retention_by_week.frac_users_retained,
    user_retention_by_week.frac_tickets_retained,
    user_retention_by_week.frac_listprice_retained,
    user_retention_by_week.frac_amountpaid_retained,
    user_retention_by_week.old_week,
    user_retention_by_week.old_num_consumers,
    user_retention_by_week.old_repeat_consumers,
    user_retention_by_week.old_num_tickets,
    user_retention_by_week.old_sum_amount_list_price,
    user_retention_by_week.old_sum_amount_paid
   FROM public.user_retention_by_week(6) user_retention_by_week(week, num_consumers, repeat_consumers, num_tickets, sum_amount_list_price, sum_amount_paid, num_repeat_tickets, sum_repeat_amount_list_price, sum_repeat_amount_paid, frac_users_retained, frac_tickets_retained, frac_listprice_retained, frac_amountpaid_retained, old_week, old_num_consumers, old_repeat_consumers, old_num_tickets, old_sum_amount_list_price, old_sum_amount_paid);
CREATE VIEW public.byte_sales_by_week AS
 SELECT s.week,
    sum(public.if((s.ts >= k.new_ts), 1, 0)) AS sales_units_in_old_kiosks,
    sum(public.if((s.ts < k.new_ts), 1, 0)) AS sales_units_in_new_kiosks,
    count(*) AS sales_units_in_all_kiosks,
    sum(public.if((s.ts >= k.new_ts), s.product_price, 0.0)) AS sales_listprc_in_old_kiosks,
    sum(public.if((s.ts < k.new_ts), s.product_price, 0.0)) AS sales_listprc_in_new_kiosks,
    sum(s.product_price) AS sales_listprc_in_all_kiosks,
    sum(public.if((s.ts >= k.new_ts), s.label_price, 0.0)) AS sales_actualprc_in_old_kiosks,
    sum(public.if((s.ts < k.new_ts), s.label_price, 0.0)) AS sales_actualprc_in_new_kiosks,
    sum(s.label_price) AS sales_actualprc_in_all_kiosks,
    sum(public.if((s.ts >= k.new_ts), s.product_cost, 0.0)) AS cost_list_in_old_kiosks,
    sum(public.if((s.ts < k.new_ts), s.product_cost, 0.0)) AS cost_list_in_new_kiosks,
    sum(s.product_cost) AS cost_list_in_all_kiosks
   FROM (public.byte_epcssold s
     JOIN public.byte_kiosks_date_non_new k ON ((s.kiosk_id = k.kiosk_id)))
  GROUP BY s.week
  ORDER BY s.week DESC;
CREATE VIEW public.byte_users_multiple_fridges AS
 SELECT t.email_50chars,
    t.last_trans,
    t.cnt,
    t.clients
   FROM ( SELECT "left"((o.email)::text, 50) AS email_50chars,
            max(o.ts) AS last_trans,
            count(DISTINCT o.client_name) AS cnt,
            string_agg(DISTINCT (o.client_name)::text, ';'::text) AS clients
           FROM public.byte_tickets_1year o
          WHERE (((o.client_name)::text <> ALL (ARRAY[('Byte'::character varying)::text, ('Byte Foods'::character varying)::text, ('Byte Foods Inc'::character varying)::text, ('unknown or test'::character varying)::text, ('Megan Mokri'::character varying)::text, (''::character varying)::text])) AND ((o.email)::text <> ALL (ARRAY[('no@no.com'::character varying)::text, ('a@a.com'::character varying)::text])) AND ((o.email)::text !~~ '%pantry%'::text) AND ((o.email)::text !~~ '%bytefoods%'::text) AND ((o.email)::text <> ''::text))
          GROUP BY o.email) t
  WHERE ((t.clients <> 'ARE;Veracyte'::text) AND (t.cnt > 1) AND (t.last_trans > (now() - '3 mons'::interval month)))
  ORDER BY t.clients, t.email_50chars;
CREATE VIEW public.dp_epcssold_8weeks AS
 SELECT dp_epcssold.order_id,
    dp_epcssold.first_name,
    dp_epcssold.last_name,
    dp_epcssold.kiosk_id,
    dp_epcssold.kiosk_title,
    dp_epcssold.email,
    dp_epcssold.amount_paid,
    dp_epcssold.payment_system,
    dp_epcssold.transaction_id,
    dp_epcssold.approval_code,
    dp_epcssold.status_code,
    dp_epcssold.status_message,
    dp_epcssold.status,
    dp_epcssold.batch_id,
    dp_epcssold.created,
    dp_epcssold.auth_amount,
    dp_epcssold.data_token,
    dp_epcssold.time_opened,
    dp_epcssold.time_closed,
    dp_epcssold.card_hash,
    dp_epcssold.state,
    dp_epcssold.archived,
    dp_epcssold.stamp,
    dp_epcssold.last_update,
    dp_epcssold.balance,
    dp_epcssold.delta,
    dp_epcssold.coupon_id,
    dp_epcssold.coupon,
    dp_epcssold.refund,
    dp_epcssold.receipt,
    dp_epcssold.campus_id,
    dp_epcssold.amount_list_price,
    dp_epcssold.notes,
    dp_epcssold.time_door_opened,
    dp_epcssold.time_door_closed,
    dp_epcssold.client_name,
    dp_epcssold.estd_num_users,
    dp_epcssold.ts,
    dp_epcssold.full_name,
    dp_epcssold.door_opened_secs,
    dp_epcssold.month,
    dp_epcssold.week,
    dp_epcssold.date,
    dp_epcssold.dayofweek,
    dp_epcssold.hour,
    dp_epcssold.dowhour,
    dp_epcssold.uniq_user,
    dp_epcssold.epc,
    dp_epcssold.label_order_id,
    dp_epcssold.label_status,
    dp_epcssold.label_price,
    dp_epcssold.time_created,
    dp_epcssold.time_added,
    dp_epcssold.time_updated,
    dp_epcssold.ts_created,
    dp_epcssold.ts_added,
    dp_epcssold.ts_updated,
    dp_epcssold.label_kiosk_id,
    dp_epcssold.product_id,
    dp_epcssold.product_title,
    dp_epcssold.product_archived,
    dp_epcssold.product_vendor,
    dp_epcssold.product_price,
    dp_epcssold.product_cost,
    dp_epcssold.product_shelf_life_days,
    dp_epcssold.product_attributes,
    dp_epcssold.product_categories,
    dp_epcssold.consumer_category,
    dp_epcssold.product_source
   FROM public.dp_epcssold
  WHERE (dp_epcssold.ts > (now() - '56 days'::interval day));
CREATE VIEW public.dp_inventory_history AS
 SELECT byte_inventory_history.month,
    byte_inventory_history.week,
    byte_inventory_history.date,
    byte_inventory_history.hour,
    byte_inventory_history.dayofweek,
    byte_inventory_history.ts,
    byte_inventory_history.product_id,
    byte_inventory_history.kiosk_id,
    byte_inventory_history.qty,
    byte_inventory_history.product_title,
    byte_inventory_history.kiosk_title
   FROM public.byte_inventory_history;
CREATE VIEW byte_pgdu.pgdudetail AS
 SELECT 0 AS union_sort_order,
    all_tables.table_schema,
    all_tables.table_name,
    pg_table_size((all_tables.full_table_name)::regclass) AS table_size,
    to_char((((pg_table_size((all_tables.full_table_name)::regclass))::double precision / (pg_total_relation_size((all_tables.full_table_name)::regclass))::double precision) * (100)::double precision), '999D9%'::text) AS percent_table,
    pg_indexes_size((all_tables.full_table_name)::regclass) AS indexes_size,
    to_char((((pg_indexes_size((all_tables.full_table_name)::regclass))::double precision / (pg_total_relation_size((all_tables.full_table_name)::regclass))::double precision) * (100)::double precision), '999D9%'::text) AS percent_index,
    pg_total_relation_size((all_tables.full_table_name)::regclass) AS total_size
   FROM ( SELECT tables.table_schema,
            tables.table_name,
            (((('"'::text || (tables.table_schema)::text) || '"."'::text) || (tables.table_name)::text) || '"'::text) AS full_table_name
           FROM information_schema.tables
          WHERE (((tables.table_schema)::text !~~ 'pg_%'::text) AND ((tables.table_schema)::text <> 'information_schema'::text))) all_tables
  WHERE (pg_total_relation_size((all_tables.full_table_name)::regclass) > 0)
  ORDER BY (pg_total_relation_size((all_tables.full_table_name)::regclass)) DESC;
CREATE VIEW public.sys_activity AS
 SELECT pg_stat_activity.datname,
    pg_stat_activity.pid,
    pg_stat_activity.usename,
    pg_stat_activity.application_name,
    pg_stat_activity.client_addr,
    pg_stat_activity.client_hostname,
    pg_stat_activity.client_port,
    pg_stat_activity.query,
    pg_stat_activity.state
   FROM pg_stat_activity;
CREATE VIEW public.byte_epcssold_2017 AS
 SELECT o.order_id,
    o.first_name,
    o.last_name,
    o.kiosk_id,
    o.kiosk_title,
    o.email,
    o.amount_paid,
    o.payment_system,
    o.transaction_id,
    o.approval_code,
    o.status_code,
    o.status_message,
    o.status,
    o.batch_id,
    o.created,
    o.auth_amount,
    o.data_token,
    o.time_opened,
    o.time_closed,
    o.card_hash,
    o.state,
    o.archived,
    o.stamp,
    o.last_update,
    o.balance,
    o.delta,
    o.coupon_id,
    o.coupon,
    o.refund,
    o.receipt,
    o.campus_id,
    o.amount_list_price,
    o.notes,
    o.time_door_opened,
    o.time_door_closed,
    o.client_name,
    o.estd_num_users,
    o.ts,
    o.full_name,
    o.door_opened_secs,
    o.month,
    o.week,
    o.date,
    o.dayofweek,
    o.hour,
    o.dowhour,
    o.uniq_user,
    lp.epc,
    lp.label_order_id,
    lp.label_status,
    lp.label_price,
    lp.time_created,
    lp.time_added,
    lp.time_updated,
    lp.ts_created,
    lp.ts_added,
    lp.ts_updated,
    lp.label_kiosk_id,
    lp.product_id,
    lp.product_title,
    lp.product_archived,
    lp.product_vendor,
    lp.product_price,
    lp.product_cost,
    lp.product_shelf_life_days,
    lp.product_attributes,
    lp.product_categories,
    lp.consumer_category,
    lp.product_source
   FROM (public.byte_tickets_2017 o
     JOIN public.byte_label_product lp ON (((lp.label_order_id)::text = (o.order_id)::text)))
  WHERE ((lp.label_status)::text = 'sold'::text);
CREATE VIEW public.spoilage_by_shelflife_45d AS
 SELECT public.if((byte_spoilage.shelf_time > 30), 999, byte_spoilage.shelf_time) AS shelf_life,
    sum(byte_spoilage.cost) AS spoilage_dolr
   FROM public.byte_spoilage
  WHERE (byte_spoilage.ts_removed > (now() - '45 days'::interval day))
  GROUP BY (public.if((byte_spoilage.shelf_time > 30), 999, byte_spoilage.shelf_time))
  ORDER BY (public.if((byte_spoilage.shelf_time > 30), 999, byte_spoilage.shelf_time));
CREATE VIEW public.valid_bytecodes AS
 SELECT bytecodelog.email,
    bytecodelog.bytecode,
    to_timestamp((bytecodelog.created_at)::double precision) AS created_at,
    bytecodelog.duration,
    to_timestamp((bytecodelog.expires_at)::double precision) AS expires_at
   FROM public.bytecodelog
  WHERE ((bytecodelog.expires_at)::double precision >= date_part('epoch'::text, now()))
  ORDER BY (to_timestamp((bytecodelog.expires_at)::double precision)) DESC;
CREATE VIEW public.byte_epcssold_8weeks AS
 SELECT o.order_id,
    o.first_name,
    o.last_name,
    o.kiosk_id,
    o.kiosk_title,
    o.email,
    o.amount_paid,
    o.payment_system,
    o.transaction_id,
    o.approval_code,
    o.status_code,
    o.status_message,
    o.status,
    o.batch_id,
    o.created,
    o.auth_amount,
    o.data_token,
    o.time_opened,
    o.time_closed,
    o.card_hash,
    o.state,
    o.archived,
    o.stamp,
    o.last_update,
    o.balance,
    o.delta,
    o.coupon_id,
    o.coupon,
    o.refund,
    o.receipt,
    o.campus_id,
    o.amount_list_price,
    o.notes,
    o.time_door_opened,
    o.time_door_closed,
    o.client_name,
    o.estd_num_users,
    o.ts,
    o.full_name,
    o.door_opened_secs,
    o.month,
    o.week,
    o.date,
    o.dayofweek,
    o.hour,
    o.dowhour,
    o.uniq_user,
    lp.epc,
    lp.label_order_id,
    lp.label_status,
    lp.label_price,
    lp.time_created,
    lp.time_added,
    lp.time_updated,
    lp.ts_created,
    lp.ts_added,
    lp.ts_updated,
    lp.label_kiosk_id,
    lp.product_id,
    lp.product_title,
    lp.product_archived,
    lp.product_vendor,
    lp.product_price,
    lp.product_cost,
    lp.product_shelf_life_days,
    lp.product_attributes,
    lp.product_categories,
    lp.consumer_category,
    lp.product_source
   FROM (public.byte_tickets_8weeks o
     JOIN public.byte_label_product lp ON (((lp.label_order_id)::text = (o.order_id)::text)))
  WHERE ((lp.label_status)::text = 'sold'::text);
CREATE VIEW public.category_stats_120d AS
 SELECT t1.consumer_category,
    t1.sales_0d_30d,
    t1.sales_30d_60d,
    t1.sales_60d_90d,
    t1.sales_90d_120d,
    t2.cogs_0d_30d,
    t2.cogs_30d_60d,
    t2.cogs_60d_90d,
    t2.cogs_90d_120d,
    t3.spoilage_0d_30d,
    t3.spoilage_30d_60d,
    t3.spoilage_60d_90d,
    t3.spoilage_90d_120d
   FROM ((public.sales_by_category_120d t1
     LEFT JOIN public.cogs_by_category_120d t2 ON (((t1.consumer_category)::text = (t2.consumer_category)::text)))
     LEFT JOIN public.spoilage_by_category_120d t3 ON (((t2.consumer_category)::text = (t3.consumer_category)::text)));
CREATE VIEW mixalot.pgdu_bytes AS
 SELECT all_tables.table_name,
    pg_table_size((all_tables.table_name)::regclass) AS table_size,
    pg_indexes_size((all_tables.table_name)::regclass) AS indexes_size,
    pg_total_relation_size((all_tables.table_name)::regclass) AS total_size
   FROM ( SELECT (((('"'::text || (tables.table_schema)::text) || '"."'::text) || (tables.table_name)::text) || '"'::text) AS table_name
           FROM information_schema.tables) all_tables
  ORDER BY (pg_total_relation_size((all_tables.table_name)::regclass)) DESC;
CREATE VIEW public.byte_tickets_1day AS
 SELECT byte_tickets.order_id,
    byte_tickets.first_name,
    byte_tickets.last_name,
    byte_tickets.kiosk_id,
    byte_tickets.kiosk_title,
    byte_tickets.email,
    byte_tickets.amount_paid,
    byte_tickets.payment_system,
    byte_tickets.transaction_id,
    byte_tickets.approval_code,
    byte_tickets.status_code,
    byte_tickets.status_message,
    byte_tickets.status,
    byte_tickets.batch_id,
    byte_tickets.created,
    byte_tickets.auth_amount,
    byte_tickets.data_token,
    byte_tickets.time_opened,
    byte_tickets.time_closed,
    byte_tickets.card_hash,
    byte_tickets.state,
    byte_tickets.archived,
    byte_tickets.stamp,
    byte_tickets.last_update,
    byte_tickets.balance,
    byte_tickets.delta,
    byte_tickets.coupon_id,
    byte_tickets.coupon,
    byte_tickets.refund,
    byte_tickets.receipt,
    byte_tickets.campus_id,
    byte_tickets.amount_list_price,
    byte_tickets.notes,
    byte_tickets.time_door_opened,
    byte_tickets.time_door_closed,
    byte_tickets.client_name,
    byte_tickets.estd_num_users,
    byte_tickets.ts,
    byte_tickets.full_name,
    byte_tickets.door_opened_secs,
    byte_tickets.month,
    byte_tickets.week,
    byte_tickets.date,
    byte_tickets.dayofweek,
    byte_tickets.hour,
    byte_tickets.dowhour,
    byte_tickets.uniq_user
   FROM public.byte_tickets
  WHERE (byte_tickets.ts > (now() - '1 day'::interval day));
CREATE VIEW public.byte_spoilage_by_category_week_crosstab AS
 SELECT ct.week,
    ct.breakfast_cost_per_old_kiosk,
    ct.breakfast_cost_per_new_kiosk,
    ct.breakfast_cost_per_kiosk,
    ct.burritos_cost_per_old_kiosk,
    ct.burritos_cost_per_new_kiosk,
    ct.burritos_cost_per_kiosk,
    ct.desserts_cost_per_old_kiosk,
    ct.desserts_cost_per_new_kiosk,
    ct.desserts_cost_per_kiosk,
    ct.drinks_cost_per_old_kiosk,
    ct.drinks_cost_per_new_kiosk,
    ct.drinks_cost_per_kiosk,
    ct.entrees_cost_per_old_kiosk,
    ct.entrees_cost_per_new_kiosk,
    ct.entrees_cost_per_kiosk,
    ct.sandwiches_wraps_cost_per_old_kiosk,
    ct.sandwiches_wraps_cost_per_new_kiosk,
    ct.sandwiches_wraps_cost_per_kiosk,
    ct.snacks_cost_per_old_kiosk,
    ct.snacks_cost_per_new_kiosk,
    ct.snacks_cost_per_kiosk,
    ct.soups_salads_cost_per_old_kiosk,
    ct.soups_salads_cost_per_new_kiosk,
    ct.soups_salads_cost_per_kiosk
   FROM public.crosstab('select to_char(week,''YYYY-MM-DD'') as week,cat_and_new,spoilage_cost from byte_spoilage_by_category_week order by week desc,cat_and_new desc'::text) ct(week text, breakfast_cost_per_old_kiosk numeric, breakfast_cost_per_new_kiosk numeric, breakfast_cost_per_kiosk numeric, burritos_cost_per_old_kiosk numeric, burritos_cost_per_new_kiosk numeric, burritos_cost_per_kiosk numeric, desserts_cost_per_old_kiosk numeric, desserts_cost_per_new_kiosk numeric, desserts_cost_per_kiosk numeric, drinks_cost_per_old_kiosk numeric, drinks_cost_per_new_kiosk numeric, drinks_cost_per_kiosk numeric, entrees_cost_per_old_kiosk numeric, entrees_cost_per_new_kiosk numeric, entrees_cost_per_kiosk numeric, sandwiches_wraps_cost_per_old_kiosk numeric, sandwiches_wraps_cost_per_new_kiosk numeric, sandwiches_wraps_cost_per_kiosk numeric, snacks_cost_per_old_kiosk numeric, snacks_cost_per_new_kiosk numeric, snacks_cost_per_kiosk numeric, soups_salads_cost_per_old_kiosk numeric, soups_salads_cost_per_new_kiosk numeric, soups_salads_cost_per_kiosk numeric);
CREATE VIEW public.latest_label_records AS
 SELECT l.id,
    l.product_id,
    l.epc,
    l.is_generic_sku,
    l.kiosk_id,
    l.order_id,
    l.status,
    l.price,
    l.cost,
    l.time_created,
    l.time_added,
    l.time_updated,
    l.notes
   FROM (pantry.label l
     JOIN ( SELECT max(label.id) AS id
           FROM pantry.label
          GROUP BY label.epc) t ON ((l.id = t.id)));
CREATE VIEW byt_devops.pgdu_union AS
 SELECT pgdudetail.union_sort_order,
    pgdudetail.table_name,
    pgdudetail.table_size,
    pgdudetail.percent_table,
    pgdudetail.indexes_size,
    pgdudetail.percent_index,
    pgdudetail.total_size
   FROM byt_devops.pgdudetail
UNION
 SELECT pgdutotal.union_sort_order,
    pgdutotal.table_name,
    pgdutotal.table_size,
    pgdutotal.percent_table,
    pgdutotal.indexes_size,
    pgdutotal.percent_index,
    pgdutotal.total_size
   FROM byt_devops.pgdutotal
  ORDER BY 1, 7 DESC;
CREATE VIEW public.byte_epcssold_4days AS
 SELECT o.order_id,
    o.first_name,
    o.last_name,
    o.kiosk_id,
    o.kiosk_title,
    o.email,
    o.amount_paid,
    o.payment_system,
    o.transaction_id,
    o.approval_code,
    o.status_code,
    o.status_message,
    o.status,
    o.batch_id,
    o.created,
    o.auth_amount,
    o.data_token,
    o.time_opened,
    o.time_closed,
    o.card_hash,
    o.state,
    o.archived,
    o.stamp,
    o.last_update,
    o.balance,
    o.delta,
    o.coupon_id,
    o.coupon,
    o.refund,
    o.receipt,
    o.campus_id,
    o.amount_list_price,
    o.notes,
    o.time_door_opened,
    o.time_door_closed,
    o.client_name,
    o.estd_num_users,
    o.ts,
    o.full_name,
    o.door_opened_secs,
    o.month,
    o.week,
    o.date,
    o.dayofweek,
    o.hour,
    o.dowhour,
    o.uniq_user,
    lp.epc,
    lp.label_order_id,
    lp.label_status,
    lp.label_price,
    lp.time_created,
    lp.time_added,
    lp.time_updated,
    lp.ts_created,
    lp.ts_added,
    lp.ts_updated,
    lp.label_kiosk_id,
    lp.product_id,
    lp.product_title,
    lp.product_archived,
    lp.product_vendor,
    lp.product_price,
    lp.product_cost,
    lp.product_shelf_life_days,
    lp.product_attributes,
    lp.product_categories,
    lp.consumer_category,
    lp.product_source
   FROM (public.byte_tickets_4days o
     JOIN public.byte_label_product lp ON (((lp.label_order_id)::text = (o.order_id)::text)))
  WHERE ((lp.label_status)::text = 'sold'::text);
CREATE VIEW public.byte_tickets_8weeks AS
 SELECT byte_tickets.order_id,
    byte_tickets.first_name,
    byte_tickets.last_name,
    byte_tickets.kiosk_id,
    byte_tickets.kiosk_title,
    byte_tickets.email,
    byte_tickets.amount_paid,
    byte_tickets.payment_system,
    byte_tickets.transaction_id,
    byte_tickets.approval_code,
    byte_tickets.status_code,
    byte_tickets.status_message,
    byte_tickets.status,
    byte_tickets.batch_id,
    byte_tickets.created,
    byte_tickets.auth_amount,
    byte_tickets.data_token,
    byte_tickets.time_opened,
    byte_tickets.time_closed,
    byte_tickets.card_hash,
    byte_tickets.state,
    byte_tickets.archived,
    byte_tickets.stamp,
    byte_tickets.last_update,
    byte_tickets.balance,
    byte_tickets.delta,
    byte_tickets.coupon_id,
    byte_tickets.coupon,
    byte_tickets.refund,
    byte_tickets.receipt,
    byte_tickets.campus_id,
    byte_tickets.amount_list_price,
    byte_tickets.notes,
    byte_tickets.time_door_opened,
    byte_tickets.time_door_closed,
    byte_tickets.client_name,
    byte_tickets.estd_num_users,
    byte_tickets.ts,
    byte_tickets.full_name,
    byte_tickets.door_opened_secs,
    byte_tickets.month,
    byte_tickets.week,
    byte_tickets.date,
    byte_tickets.dayofweek,
    byte_tickets.hour,
    byte_tickets.dowhour,
    byte_tickets.uniq_user
   FROM public.byte_tickets
  WHERE (byte_tickets.ts > (now() - '56 days'::interval day));
CREATE VIEW public.dp_spoilage_monthly_kiosk_pct AS
 SELECT dp_spoilage_monthly_kiosk_product_pct.month,
    dp_spoilage_monthly_kiosk_product_pct.kiosk_id,
    sum(dp_spoilage_monthly_kiosk_product_pct.spoiled) AS spoiled_units,
    sum(dp_spoilage_monthly_kiosk_product_pct.sold) AS sold_units,
    public.frac(sum(dp_spoilage_monthly_kiosk_product_pct.spoiled), sum(dp_spoilage_monthly_kiosk_product_pct.sold)) AS spoiled_frac_units,
    sum(dp_spoilage_monthly_kiosk_product_pct.revenue) AS revenue,
    sum(dp_spoilage_monthly_kiosk_product_pct.cost) AS cost,
    sum(((dp_spoilage_monthly_kiosk_product_pct.spoiled)::numeric * dp_spoilage_monthly_kiosk_product_pct.unit_cost)) AS spoilage_dolr,
    sum(dp_spoilage_monthly_kiosk_product_pct.net_profit) AS net_profit,
    public.if((sum(dp_spoilage_monthly_kiosk_product_pct.sold) = (0)::numeric), 9999.0, (sum(((dp_spoilage_monthly_kiosk_product_pct.spoiled)::numeric * dp_spoilage_monthly_kiosk_product_pct.unit_cost)) / sum(dp_spoilage_monthly_kiosk_product_pct.revenue))) AS spoilage_frac_dolr
   FROM public.dp_spoilage_monthly_kiosk_product_pct
  GROUP BY dp_spoilage_monthly_kiosk_product_pct.month, dp_spoilage_monthly_kiosk_product_pct.kiosk_id
  ORDER BY dp_spoilage_monthly_kiosk_product_pct.kiosk_id, dp_spoilage_monthly_kiosk_product_pct.month DESC;
CREATE VIEW public.byte_tickets_1year AS
 SELECT byte_tickets.order_id,
    byte_tickets.first_name,
    byte_tickets.last_name,
    byte_tickets.kiosk_id,
    byte_tickets.kiosk_title,
    byte_tickets.email,
    byte_tickets.amount_paid,
    byte_tickets.payment_system,
    byte_tickets.transaction_id,
    byte_tickets.approval_code,
    byte_tickets.status_code,
    byte_tickets.status_message,
    byte_tickets.status,
    byte_tickets.batch_id,
    byte_tickets.created,
    byte_tickets.auth_amount,
    byte_tickets.data_token,
    byte_tickets.time_opened,
    byte_tickets.time_closed,
    byte_tickets.card_hash,
    byte_tickets.state,
    byte_tickets.archived,
    byte_tickets.stamp,
    byte_tickets.last_update,
    byte_tickets.balance,
    byte_tickets.delta,
    byte_tickets.coupon_id,
    byte_tickets.coupon,
    byte_tickets.refund,
    byte_tickets.receipt,
    byte_tickets.campus_id,
    byte_tickets.amount_list_price,
    byte_tickets.notes,
    byte_tickets.time_door_opened,
    byte_tickets.time_door_closed,
    byte_tickets.client_name,
    byte_tickets.estd_num_users,
    byte_tickets.ts,
    byte_tickets.full_name,
    byte_tickets.door_opened_secs,
    byte_tickets.month,
    byte_tickets.week,
    byte_tickets.date,
    byte_tickets.dayofweek,
    byte_tickets.hour,
    byte_tickets.dowhour,
    byte_tickets.uniq_user
   FROM public.byte_tickets
  WHERE (byte_tickets.ts > (now() - '1 year'::interval year));
CREATE VIEW public.byte_epcssold_2weeks AS
 SELECT o.order_id,
    o.first_name,
    o.last_name,
    o.kiosk_id,
    o.kiosk_title,
    o.email,
    o.amount_paid,
    o.payment_system,
    o.transaction_id,
    o.approval_code,
    o.status_code,
    o.status_message,
    o.status,
    o.batch_id,
    o.created,
    o.auth_amount,
    o.data_token,
    o.time_opened,
    o.time_closed,
    o.card_hash,
    o.state,
    o.archived,
    o.stamp,
    o.last_update,
    o.balance,
    o.delta,
    o.coupon_id,
    o.coupon,
    o.refund,
    o.receipt,
    o.campus_id,
    o.amount_list_price,
    o.notes,
    o.time_door_opened,
    o.time_door_closed,
    o.client_name,
    o.estd_num_users,
    o.ts,
    o.full_name,
    o.door_opened_secs,
    o.month,
    o.week,
    o.date,
    o.dayofweek,
    o.hour,
    o.dowhour,
    o.uniq_user,
    lp.epc,
    lp.label_order_id,
    lp.label_status,
    lp.label_price,
    lp.time_created,
    lp.time_added,
    lp.time_updated,
    lp.ts_created,
    lp.ts_added,
    lp.ts_updated,
    lp.label_kiosk_id,
    lp.product_id,
    lp.product_title,
    lp.product_archived,
    lp.product_vendor,
    lp.product_price,
    lp.product_cost,
    lp.product_shelf_life_days,
    lp.product_attributes,
    lp.product_categories,
    lp.consumer_category,
    lp.product_source
   FROM (public.byte_tickets_2weeks o
     JOIN public.byte_label_product lp ON (((lp.label_order_id)::text = (o.order_id)::text)))
  WHERE ((lp.label_status)::text = 'sold'::text);
CREATE VIEW public.byte_product_stats_by_kiosk AS
 SELECT p.kiosk_id,
    p.product_id,
    p.is_new,
    p.is_popular
   FROM (pantry.product_stats_by_kiosk p
     JOIN public.byte_kiosks k ON ((p.kiosk_id = k.id)));
CREATE VIEW mixalot.v_kiosk_request_log AS
 SELECT l.start_ts AS ts,
    (((l.request_body_json)::json ->> 'time'::text))::bigint AS "time",
    l.request_uuid,
    l.endpoint,
    l.client_ip,
    l.version,
    l.cookie,
    l.message,
    l.request_body,
    l.request_headers,
    l.start_ts,
    l.response_body,
    l.response_headers,
    l.status_code,
    l.end_ts,
    l.traceback,
    l.request_body_json,
    l.request_headers_json,
    l.response_headers_json,
    l.kiosk_id,
    l.source
   FROM mixalot.request_log l
  WHERE ((((l.request_headers_json)::json ->> 'User-Agent'::text) !~~ '%monitis%'::text) AND (l.source = 'mixalot'::text));
CREATE VIEW public.byte_stockouts AS
 SELECT t.kiosk_id,
    t.order_id,
    t.product_id,
    t.ts,
    t.restock_ts,
    t.restock_order_id,
    t.id,
    t.title,
    t.description,
    t.tiny_description,
    t.short_description,
    t.medium_description,
    t.long_description,
    t.price,
    t.cost,
    t.shelf_time,
    t.campus_id,
    t.image,
    t.image_time,
    t.last_update,
    t.archived,
    t.taxable,
    t.allergens,
    t.attribute_names,
    t.categories,
    t.category_names,
    t.vendor,
    t.source,
    t.notes,
    t.total_cal,
    t.num_servings,
    t.ingredients,
    t.calories,
    t.proteins,
    t.sugar,
    t.carbohydrates,
    t.fat,
    t.consumer_category,
    t.ws_case_size,
    t.kiosk_ship_qty,
    t.ws_case_cost,
    t.pick_station,
    t.fc_title,
    t.pricing_tier,
    t.width_space,
    t.height_space,
    t.depth_space,
    t.slotted_width,
    t.tag_volume,
    t.delivery_option,
    t.kiosk_title,
    t.address,
    t.location_x,
    t.location_y,
    t.client_name,
    t.tags,
    t.estd_num_users,
    date_trunc('month'::text, t.ts) AS month,
    date_trunc('week'::text, t.ts) AS week,
    date_trunc('day'::text, t.ts) AS date
   FROM ( SELECT s.kiosk_id,
            s.order_id,
            s.product_id,
            to_timestamp((s."timestamp")::double precision) AS ts,
            to_timestamp((s.restock_timestamp)::double precision) AS restock_ts,
            s.restock_order_id,
            p.id,
            p.title,
            p.description,
            p.tiny_description,
            p.short_description,
            p.medium_description,
            p.long_description,
            p.price,
            p.cost,
            p.shelf_time,
            p.campus_id,
            p.image,
            p.image_time,
            p.last_update,
            p.archived,
            p.taxable,
            p.allergens,
            p.attribute_names,
            p.categories,
            p.category_names,
            p.vendor,
            p.source,
            p.notes,
            p.total_cal,
            p.num_servings,
            p.ingredients,
            p.calories,
            p.proteins,
            p.sugar,
            p.carbohydrates,
            p.fat,
            p.consumer_category,
            p.ws_case_size,
            p.kiosk_ship_qty,
            p.ws_case_cost,
            p.pick_station,
            p.fc_title,
            p.pricing_tier,
            p.width_space,
            p.height_space,
            p.depth_space,
            p.slotted_width,
            p.tag_volume,
            p.delivery_option,
            k.title AS kiosk_title,
            k.address,
            k.location_x,
            k.location_y,
            k.client_name,
            k.tags,
            k.estd_num_users
           FROM ((pantry.stockout s
             JOIN pantry.product p ON ((s.product_id = p.id)))
             JOIN public.byte_kiosks k ON ((s.kiosk_id = k.id)))
          WHERE (s.order_id IS NOT NULL)) t;
CREATE VIEW public.dp_stockouts_weekly_calc AS
 SELECT dpssj.week,
    dpssj.kiosk_id,
    dpssj.product_id,
    dpssj.spoiled,
    dpssj.sold,
    dpssj.days_in_week,
    p.title AS product_title,
    k.title AS kiosk_title,
    p.price AS unit_price,
    p.cost AS unit_cost,
    public.frac((dpssj.spoiled)::numeric, (dpssj.sold)::numeric) AS spoiled_frac_units,
    ((dpssj.sold)::numeric * p.price) AS revenue,
    (((dpssj.spoiled + dpssj.sold))::numeric * p.cost) AS cost,
    public.if((dpssj.sold = 0), 9999.0, div(((dpssj.spoiled)::numeric * p.cost), ((dpssj.sold)::numeric * p.price))) AS stockouts_frac,
    (dpssj.week < knn.new_ts) AS new_kiosk
   FROM (((public.dp_stockouts_weekly_sold_join dpssj
     JOIN pantry.product p ON ((dpssj.product_id = p.id)))
     JOIN public.byte_kiosks k ON ((dpssj.kiosk_id = k.id)))
     JOIN public.byte_kiosks_date_non_new knn ON ((k.id = knn.kiosk_id)))
  WHERE (dpssj.week >= '2016-01-01 08:00:00+00'::timestamp with time zone)
  ORDER BY dpssj.week DESC;
CREATE VIEW public.dp_spoilage_8weeks AS
 SELECT dp_spoilage.kiosk_id,
    dp_spoilage.order_id,
    dp_spoilage.epc,
    dp_spoilage.product_id,
    dp_spoilage.ts_added,
    dp_spoilage.ts_removed,
    dp_spoilage.id,
    dp_spoilage.title,
    dp_spoilage.description,
    dp_spoilage.tiny_description,
    dp_spoilage.short_description,
    dp_spoilage.medium_description,
    dp_spoilage.long_description,
    dp_spoilage.price,
    dp_spoilage.cost,
    dp_spoilage.shelf_time,
    dp_spoilage.campus_id,
    dp_spoilage.image,
    dp_spoilage.image_time,
    dp_spoilage.last_update,
    dp_spoilage.archived,
    dp_spoilage.taxable,
    dp_spoilage.allergens,
    dp_spoilage.attribute_names,
    dp_spoilage.categories,
    dp_spoilage.category_names,
    dp_spoilage.vendor,
    dp_spoilage.source,
    dp_spoilage.notes,
    dp_spoilage.total_cal,
    dp_spoilage.num_servings,
    dp_spoilage.ingredients,
    dp_spoilage.calories,
    dp_spoilage.proteins,
    dp_spoilage.sugar,
    dp_spoilage.carbohydrates,
    dp_spoilage.fat,
    dp_spoilage.consumer_category,
    dp_spoilage.ws_case_size,
    dp_spoilage.kiosk_ship_qty,
    dp_spoilage.ws_case_cost,
    dp_spoilage.pick_station,
    dp_spoilage.fc_title,
    dp_spoilage.pricing_tier,
    dp_spoilage.width_space,
    dp_spoilage.height_space,
    dp_spoilage.depth_space,
    dp_spoilage.slotted_width,
    dp_spoilage.tag_volume,
    dp_spoilage.delivery_option,
    dp_spoilage.kiosk_title,
    dp_spoilage.address,
    dp_spoilage.location_x,
    dp_spoilage.location_y,
    dp_spoilage.client_name,
    dp_spoilage.tags,
    dp_spoilage.estd_num_users,
    dp_spoilage.month,
    dp_spoilage.week,
    dp_spoilage.date
   FROM public.dp_spoilage
  WHERE (dp_spoilage.ts_removed > (now() - '56 days'::interval day));
CREATE VIEW public.dp_spoilage_weekly_kiosk_product_pct AS
 SELECT t.week,
    t.kiosk_id,
    t.product_id,
    t.spoiled,
    t.sold,
    t.days_in_week,
    t.product_title,
    t.kiosk_title,
    t.unit_price,
    t.unit_cost,
    t.spoiled_frac_units,
    t.revenue,
    t.cost,
    t.spoilage_frac,
    t.new_kiosk,
    (t.revenue - t.cost) AS net_profit
   FROM ( SELECT dpssj.week,
            dpssj.kiosk_id,
            dpssj.product_id,
            dpssj.spoiled,
            dpssj.sold,
            dpssj.days_in_week,
            p.title AS product_title,
            k.title AS kiosk_title,
            p.price AS unit_price,
            p.cost AS unit_cost,
            public.frac(dpssj.spoiled, dpssj.sold) AS spoiled_frac_units,
            (dpssj.sold * p.price) AS revenue,
            ((dpssj.spoiled + dpssj.sold) * p.cost) AS cost,
            public.if((dpssj.sold = (0)::numeric), (9999.0)::double precision, (div((dpssj.spoiled * p.cost), (dpssj.sold * p.price)))::double precision) AS spoilage_frac,
            (dpssj.week < knn.new_ts) AS new_kiosk
           FROM (((public.dp_spoilage_weekly_sold_join dpssj
             JOIN pantry.product p ON ((dpssj.product_id = p.id)))
             JOIN public.byte_kiosks k ON ((dpssj.kiosk_id = k.id)))
             JOIN public.byte_kiosks_date_non_new knn ON ((k.id = knn.kiosk_id)))
          WHERE (dpssj.week >= '2016-01-01 08:00:00+00'::timestamp with time zone)) t
  ORDER BY t.week DESC;
CREATE VIEW public.user_retention_12weeks AS
 SELECT user_retention_by_week.week,
    user_retention_by_week.num_consumers,
    user_retention_by_week.repeat_consumers,
    user_retention_by_week.num_tickets,
    user_retention_by_week.sum_amount_list_price,
    user_retention_by_week.sum_amount_paid,
    user_retention_by_week.num_repeat_tickets,
    user_retention_by_week.sum_repeat_amount_list_price,
    user_retention_by_week.sum_repeat_amount_paid,
    user_retention_by_week.frac_users_retained,
    user_retention_by_week.frac_tickets_retained,
    user_retention_by_week.frac_listprice_retained,
    user_retention_by_week.frac_amountpaid_retained,
    user_retention_by_week.old_week,
    user_retention_by_week.old_num_consumers,
    user_retention_by_week.old_repeat_consumers,
    user_retention_by_week.old_num_tickets,
    user_retention_by_week.old_sum_amount_list_price,
    user_retention_by_week.old_sum_amount_paid
   FROM public.user_retention_by_week(12) user_retention_by_week(week, num_consumers, repeat_consumers, num_tickets, sum_amount_list_price, sum_amount_paid, num_repeat_tickets, sum_repeat_amount_list_price, sum_repeat_amount_paid, frac_users_retained, frac_tickets_retained, frac_listprice_retained, frac_amountpaid_retained, old_week, old_num_consumers, old_repeat_consumers, old_num_tickets, old_sum_amount_list_price, old_sum_amount_paid);
CREATE VIEW public.dp_epcssold_4weeks AS
 SELECT dp_epcssold.order_id,
    dp_epcssold.first_name,
    dp_epcssold.last_name,
    dp_epcssold.kiosk_id,
    dp_epcssold.kiosk_title,
    dp_epcssold.email,
    dp_epcssold.amount_paid,
    dp_epcssold.payment_system,
    dp_epcssold.transaction_id,
    dp_epcssold.approval_code,
    dp_epcssold.status_code,
    dp_epcssold.status_message,
    dp_epcssold.status,
    dp_epcssold.batch_id,
    dp_epcssold.created,
    dp_epcssold.auth_amount,
    dp_epcssold.data_token,
    dp_epcssold.time_opened,
    dp_epcssold.time_closed,
    dp_epcssold.card_hash,
    dp_epcssold.state,
    dp_epcssold.archived,
    dp_epcssold.stamp,
    dp_epcssold.last_update,
    dp_epcssold.balance,
    dp_epcssold.delta,
    dp_epcssold.coupon_id,
    dp_epcssold.coupon,
    dp_epcssold.refund,
    dp_epcssold.receipt,
    dp_epcssold.campus_id,
    dp_epcssold.amount_list_price,
    dp_epcssold.notes,
    dp_epcssold.time_door_opened,
    dp_epcssold.time_door_closed,
    dp_epcssold.client_name,
    dp_epcssold.estd_num_users,
    dp_epcssold.ts,
    dp_epcssold.full_name,
    dp_epcssold.door_opened_secs,
    dp_epcssold.month,
    dp_epcssold.week,
    dp_epcssold.date,
    dp_epcssold.dayofweek,
    dp_epcssold.hour,
    dp_epcssold.dowhour,
    dp_epcssold.uniq_user,
    dp_epcssold.epc,
    dp_epcssold.label_order_id,
    dp_epcssold.label_status,
    dp_epcssold.label_price,
    dp_epcssold.time_created,
    dp_epcssold.time_added,
    dp_epcssold.time_updated,
    dp_epcssold.ts_created,
    dp_epcssold.ts_added,
    dp_epcssold.ts_updated,
    dp_epcssold.label_kiosk_id,
    dp_epcssold.product_id,
    dp_epcssold.product_title,
    dp_epcssold.product_archived,
    dp_epcssold.product_vendor,
    dp_epcssold.product_price,
    dp_epcssold.product_cost,
    dp_epcssold.product_shelf_life_days,
    dp_epcssold.product_attributes,
    dp_epcssold.product_categories,
    dp_epcssold.consumer_category,
    dp_epcssold.product_source
   FROM public.dp_epcssold
  WHERE (dp_epcssold.ts > (now() - '28 days'::interval day));
CREATE VIEW public.byte_epcssold_45days AS
 SELECT o.order_id,
    o.first_name,
    o.last_name,
    o.kiosk_id,
    o.kiosk_title,
    o.email,
    o.amount_paid,
    o.payment_system,
    o.transaction_id,
    o.approval_code,
    o.status_code,
    o.status_message,
    o.status,
    o.batch_id,
    o.created,
    o.auth_amount,
    o.data_token,
    o.time_opened,
    o.time_closed,
    o.card_hash,
    o.state,
    o.archived,
    o.stamp,
    o.last_update,
    o.balance,
    o.delta,
    o.coupon_id,
    o.coupon,
    o.refund,
    o.receipt,
    o.campus_id,
    o.amount_list_price,
    o.notes,
    o.time_door_opened,
    o.time_door_closed,
    o.client_name,
    o.estd_num_users,
    o.ts,
    o.full_name,
    o.door_opened_secs,
    o.month,
    o.week,
    o.date,
    o.dayofweek,
    o.hour,
    o.dowhour,
    o.uniq_user,
    lp.epc,
    lp.label_order_id,
    lp.label_status,
    lp.label_price,
    lp.time_created,
    lp.time_added,
    lp.time_updated,
    lp.ts_created,
    lp.ts_added,
    lp.ts_updated,
    lp.label_kiosk_id,
    lp.product_id,
    lp.product_title,
    lp.product_archived,
    lp.product_vendor,
    lp.product_price,
    lp.product_cost,
    lp.product_shelf_life_days,
    lp.product_attributes,
    lp.product_categories,
    lp.consumer_category,
    lp.product_source
   FROM (public.byte_tickets_45days o
     JOIN public.byte_label_product lp ON (((lp.label_order_id)::text = (o.order_id)::text)))
  WHERE ((lp.label_status)::text = 'sold'::text);
CREATE VIEW public.lastwk_hrs AS
 SELECT ts.ts
   FROM generate_series((now() - '7 days'::interval day), now(), '01:00:00'::interval) ts(ts);
CREATE VIEW public.byte_tickets_1month AS
 SELECT byte_tickets.order_id,
    byte_tickets.first_name,
    byte_tickets.last_name,
    byte_tickets.kiosk_id,
    byte_tickets.kiosk_title,
    byte_tickets.email,
    byte_tickets.amount_paid,
    byte_tickets.payment_system,
    byte_tickets.transaction_id,
    byte_tickets.approval_code,
    byte_tickets.status_code,
    byte_tickets.status_message,
    byte_tickets.status,
    byte_tickets.batch_id,
    byte_tickets.created,
    byte_tickets.auth_amount,
    byte_tickets.data_token,
    byte_tickets.time_opened,
    byte_tickets.time_closed,
    byte_tickets.card_hash,
    byte_tickets.state,
    byte_tickets.archived,
    byte_tickets.stamp,
    byte_tickets.last_update,
    byte_tickets.balance,
    byte_tickets.delta,
    byte_tickets.coupon_id,
    byte_tickets.coupon,
    byte_tickets.refund,
    byte_tickets.receipt,
    byte_tickets.campus_id,
    byte_tickets.amount_list_price,
    byte_tickets.notes,
    byte_tickets.time_door_opened,
    byte_tickets.time_door_closed,
    byte_tickets.client_name,
    byte_tickets.estd_num_users,
    byte_tickets.ts,
    byte_tickets.full_name,
    byte_tickets.door_opened_secs,
    byte_tickets.month,
    byte_tickets.week,
    byte_tickets.date,
    byte_tickets.dayofweek,
    byte_tickets.hour,
    byte_tickets.dowhour,
    byte_tickets.uniq_user
   FROM public.byte_tickets
  WHERE (byte_tickets.ts > (now() - '1 mon'::interval month));
CREATE VIEW public.byte_epcssold_2months AS
 SELECT o.order_id,
    o.first_name,
    o.last_name,
    o.kiosk_id,
    o.kiosk_title,
    o.email,
    o.amount_paid,
    o.payment_system,
    o.transaction_id,
    o.approval_code,
    o.status_code,
    o.status_message,
    o.status,
    o.batch_id,
    o.created,
    o.auth_amount,
    o.data_token,
    o.time_opened,
    o.time_closed,
    o.card_hash,
    o.state,
    o.archived,
    o.stamp,
    o.last_update,
    o.balance,
    o.delta,
    o.coupon_id,
    o.coupon,
    o.refund,
    o.receipt,
    o.campus_id,
    o.amount_list_price,
    o.notes,
    o.time_door_opened,
    o.time_door_closed,
    o.client_name,
    o.estd_num_users,
    o.ts,
    o.full_name,
    o.door_opened_secs,
    o.month,
    o.week,
    o.date,
    o.dayofweek,
    o.hour,
    o.dowhour,
    o.uniq_user,
    lp.epc,
    lp.label_order_id,
    lp.label_status,
    lp.label_price,
    lp.time_created,
    lp.time_added,
    lp.time_updated,
    lp.ts_created,
    lp.ts_added,
    lp.ts_updated,
    lp.label_kiosk_id,
    lp.product_id,
    lp.product_title,
    lp.product_archived,
    lp.product_vendor,
    lp.product_price,
    lp.product_cost,
    lp.product_shelf_life_days,
    lp.product_attributes,
    lp.product_categories,
    lp.consumer_category,
    lp.product_source
   FROM (public.byte_tickets_2months o
     JOIN public.byte_label_product lp ON (((lp.label_order_id)::text = (o.order_id)::text)))
  WHERE ((lp.label_status)::text = 'sold'::text);
CREATE VIEW public.byte_tickets_6weeks AS
 SELECT byte_tickets.order_id,
    byte_tickets.first_name,
    byte_tickets.last_name,
    byte_tickets.kiosk_id,
    byte_tickets.kiosk_title,
    byte_tickets.email,
    byte_tickets.amount_paid,
    byte_tickets.payment_system,
    byte_tickets.transaction_id,
    byte_tickets.approval_code,
    byte_tickets.status_code,
    byte_tickets.status_message,
    byte_tickets.status,
    byte_tickets.batch_id,
    byte_tickets.created,
    byte_tickets.auth_amount,
    byte_tickets.data_token,
    byte_tickets.time_opened,
    byte_tickets.time_closed,
    byte_tickets.card_hash,
    byte_tickets.state,
    byte_tickets.archived,
    byte_tickets.stamp,
    byte_tickets.last_update,
    byte_tickets.balance,
    byte_tickets.delta,
    byte_tickets.coupon_id,
    byte_tickets.coupon,
    byte_tickets.refund,
    byte_tickets.receipt,
    byte_tickets.campus_id,
    byte_tickets.amount_list_price,
    byte_tickets.notes,
    byte_tickets.time_door_opened,
    byte_tickets.time_door_closed,
    byte_tickets.client_name,
    byte_tickets.estd_num_users,
    byte_tickets.ts,
    byte_tickets.full_name,
    byte_tickets.door_opened_secs,
    byte_tickets.month,
    byte_tickets.week,
    byte_tickets.date,
    byte_tickets.dayofweek,
    byte_tickets.hour,
    byte_tickets.dowhour,
    byte_tickets.uniq_user
   FROM public.byte_tickets
  WHERE (byte_tickets.ts > (now() - '42 days'::interval day));
CREATE VIEW public.spoilage_by_shelflife_120d AS
 SELECT public.if((byte_spoilage.shelf_time > 30), 999, byte_spoilage.shelf_time) AS shelf_life,
    sum(byte_spoilage.cost) AS spoilage_dolr
   FROM public.byte_spoilage
  WHERE (byte_spoilage.ts_removed > (now() - '120 days'::interval day))
  GROUP BY (public.if((byte_spoilage.shelf_time > 30), 999, byte_spoilage.shelf_time))
  ORDER BY (public.if((byte_spoilage.shelf_time > 30), 999, byte_spoilage.shelf_time));
CREATE VIEW public.byte_epcssold_120days AS
 SELECT o.order_id,
    o.first_name,
    o.last_name,
    o.kiosk_id,
    o.kiosk_title,
    o.email,
    o.amount_paid,
    o.payment_system,
    o.transaction_id,
    o.approval_code,
    o.status_code,
    o.status_message,
    o.status,
    o.batch_id,
    o.created,
    o.auth_amount,
    o.data_token,
    o.time_opened,
    o.time_closed,
    o.card_hash,
    o.state,
    o.archived,
    o.stamp,
    o.last_update,
    o.balance,
    o.delta,
    o.coupon_id,
    o.coupon,
    o.refund,
    o.receipt,
    o.campus_id,
    o.amount_list_price,
    o.notes,
    o.time_door_opened,
    o.time_door_closed,
    o.client_name,
    o.estd_num_users,
    o.ts,
    o.full_name,
    o.door_opened_secs,
    o.month,
    o.week,
    o.date,
    o.dayofweek,
    o.hour,
    o.dowhour,
    o.uniq_user,
    lp.epc,
    lp.label_order_id,
    lp.label_status,
    lp.label_price,
    lp.time_created,
    lp.time_added,
    lp.time_updated,
    lp.ts_created,
    lp.ts_added,
    lp.ts_updated,
    lp.label_kiosk_id,
    lp.product_id,
    lp.product_title,
    lp.product_archived,
    lp.product_vendor,
    lp.product_price,
    lp.product_cost,
    lp.product_shelf_life_days,
    lp.product_attributes,
    lp.product_categories,
    lp.consumer_category,
    lp.product_source
   FROM (public.byte_tickets_120days o
     JOIN public.byte_label_product lp ON (((lp.label_order_id)::text = (o.order_id)::text)))
  WHERE ((lp.label_status)::text = 'sold'::text);
CREATE VIEW public.byte_tickets_45days AS
 SELECT byte_tickets.order_id,
    byte_tickets.first_name,
    byte_tickets.last_name,
    byte_tickets.kiosk_id,
    byte_tickets.kiosk_title,
    byte_tickets.email,
    byte_tickets.amount_paid,
    byte_tickets.payment_system,
    byte_tickets.transaction_id,
    byte_tickets.approval_code,
    byte_tickets.status_code,
    byte_tickets.status_message,
    byte_tickets.status,
    byte_tickets.batch_id,
    byte_tickets.created,
    byte_tickets.auth_amount,
    byte_tickets.data_token,
    byte_tickets.time_opened,
    byte_tickets.time_closed,
    byte_tickets.card_hash,
    byte_tickets.state,
    byte_tickets.archived,
    byte_tickets.stamp,
    byte_tickets.last_update,
    byte_tickets.balance,
    byte_tickets.delta,
    byte_tickets.coupon_id,
    byte_tickets.coupon,
    byte_tickets.refund,
    byte_tickets.receipt,
    byte_tickets.campus_id,
    byte_tickets.amount_list_price,
    byte_tickets.notes,
    byte_tickets.time_door_opened,
    byte_tickets.time_door_closed,
    byte_tickets.client_name,
    byte_tickets.estd_num_users,
    byte_tickets.ts,
    byte_tickets.full_name,
    byte_tickets.door_opened_secs,
    byte_tickets.month,
    byte_tickets.week,
    byte_tickets.date,
    byte_tickets.dayofweek,
    byte_tickets.hour,
    byte_tickets.dowhour,
    byte_tickets.uniq_user
   FROM public.byte_tickets
  WHERE (byte_tickets.ts > (now() - '45 days'::interval day));
CREATE VIEW public.cogs_by_category_120d AS
 SELECT byte_epcssold_120days.consumer_category,
    sum(byte_epcssold_120days.product_cost) AS cogs_120d,
    sum(public.if(((byte_epcssold_120days.ts >= (now() - '30 days'::interval day)) AND (byte_epcssold_120days.ts <= (now() - '00:00:00'::interval day))), byte_epcssold_120days.product_cost, 0.0)) AS cogs_0d_30d,
    sum(public.if(((byte_epcssold_120days.ts >= (now() - '60 days'::interval day)) AND (byte_epcssold_120days.ts <= (now() - '30 days'::interval day))), byte_epcssold_120days.product_cost, 0.0)) AS cogs_30d_60d,
    sum(public.if(((byte_epcssold_120days.ts >= (now() - '90 days'::interval day)) AND (byte_epcssold_120days.ts <= (now() - '60 days'::interval day))), byte_epcssold_120days.product_cost, 0.0)) AS cogs_60d_90d,
    sum(public.if(((byte_epcssold_120days.ts >= (now() - '120 days'::interval day)) AND (byte_epcssold_120days.ts <= (now() - '90 days'::interval day))), byte_epcssold_120days.product_cost, 0.0)) AS cogs_90d_120d
   FROM public.byte_epcssold_120days
  GROUP BY byte_epcssold_120days.consumer_category;
CREATE VIEW public.byte_tickets_2days AS
 SELECT byte_tickets.order_id,
    byte_tickets.first_name,
    byte_tickets.last_name,
    byte_tickets.kiosk_id,
    byte_tickets.kiosk_title,
    byte_tickets.email,
    byte_tickets.amount_paid,
    byte_tickets.payment_system,
    byte_tickets.transaction_id,
    byte_tickets.approval_code,
    byte_tickets.status_code,
    byte_tickets.status_message,
    byte_tickets.status,
    byte_tickets.batch_id,
    byte_tickets.created,
    byte_tickets.auth_amount,
    byte_tickets.data_token,
    byte_tickets.time_opened,
    byte_tickets.time_closed,
    byte_tickets.card_hash,
    byte_tickets.state,
    byte_tickets.archived,
    byte_tickets.stamp,
    byte_tickets.last_update,
    byte_tickets.balance,
    byte_tickets.delta,
    byte_tickets.coupon_id,
    byte_tickets.coupon,
    byte_tickets.refund,
    byte_tickets.receipt,
    byte_tickets.campus_id,
    byte_tickets.amount_list_price,
    byte_tickets.notes,
    byte_tickets.time_door_opened,
    byte_tickets.time_door_closed,
    byte_tickets.client_name,
    byte_tickets.estd_num_users,
    byte_tickets.ts,
    byte_tickets.full_name,
    byte_tickets.door_opened_secs,
    byte_tickets.month,
    byte_tickets.week,
    byte_tickets.date,
    byte_tickets.dayofweek,
    byte_tickets.hour,
    byte_tickets.dowhour,
    byte_tickets.uniq_user
   FROM public.byte_tickets
  WHERE (byte_tickets.ts > (now() - '2 days'::interval day));
CREATE VIEW public.dp_kiosks AS
 SELECT byte_kiosks.id,
    byte_kiosks.title,
    byte_kiosks.client_name,
    byte_kiosks.address,
    byte_kiosks.location_x,
    byte_kiosks.location_y,
    byte_kiosks.archived,
    to_timestamp((byte_kiosks.creation_time)::double precision) AS creation_ts,
    to_timestamp((byte_kiosks.deployment_time)::double precision) AS deployment_ts,
    byte_kiosks.timezone,
    byte_kiosks.estd_num_users
   FROM public.byte_kiosks;
CREATE VIEW public.dp_stockouts AS
 SELECT byte_stockouts.kiosk_id,
    byte_stockouts.order_id,
    byte_stockouts.product_id,
    byte_stockouts.ts,
    byte_stockouts.restock_ts,
    byte_stockouts.restock_order_id,
    byte_stockouts.id,
    byte_stockouts.title,
    byte_stockouts.description,
    byte_stockouts.tiny_description,
    byte_stockouts.short_description,
    byte_stockouts.medium_description,
    byte_stockouts.long_description,
    byte_stockouts.price,
    byte_stockouts.cost,
    byte_stockouts.shelf_time,
    byte_stockouts.campus_id,
    byte_stockouts.image,
    byte_stockouts.image_time,
    byte_stockouts.last_update,
    byte_stockouts.archived,
    byte_stockouts.taxable,
    byte_stockouts.allergens,
    byte_stockouts.attribute_names,
    byte_stockouts.categories,
    byte_stockouts.category_names,
    byte_stockouts.vendor,
    byte_stockouts.source,
    byte_stockouts.notes,
    byte_stockouts.total_cal,
    byte_stockouts.num_servings,
    byte_stockouts.ingredients,
    byte_stockouts.calories,
    byte_stockouts.proteins,
    byte_stockouts.sugar,
    byte_stockouts.carbohydrates,
    byte_stockouts.fat,
    byte_stockouts.consumer_category,
    byte_stockouts.ws_case_size,
    byte_stockouts.kiosk_ship_qty,
    byte_stockouts.ws_case_cost,
    byte_stockouts.pick_station,
    byte_stockouts.fc_title,
    byte_stockouts.pricing_tier,
    byte_stockouts.width_space,
    byte_stockouts.height_space,
    byte_stockouts.depth_space,
    byte_stockouts.slotted_width,
    byte_stockouts.tag_volume,
    byte_stockouts.delivery_option,
    byte_stockouts.kiosk_title,
    byte_stockouts.address,
    byte_stockouts.location_x,
    byte_stockouts.location_y,
    byte_stockouts.client_name,
    byte_stockouts.tags,
    byte_stockouts.estd_num_users,
    byte_stockouts.month,
    byte_stockouts.week,
    byte_stockouts.date
   FROM public.byte_stockouts;
CREATE VIEW public.dp_stockouts_weekly_kiosk_pct AS
 SELECT dp_stockouts_weekly_kiosk_product_pct.week,
    dp_stockouts_weekly_kiosk_product_pct.kiosk_id,
    bool_and(dp_stockouts_weekly_kiosk_product_pct.new_kiosk) AS new_kiosk,
    max(dp_stockouts_weekly_kiosk_product_pct.days_in_week) AS days_in_week,
    sum(dp_stockouts_weekly_kiosk_product_pct.spoiled) AS spoiled_units,
    sum(dp_stockouts_weekly_kiosk_product_pct.sold) AS sold_units,
    public.frac(sum(dp_stockouts_weekly_kiosk_product_pct.spoiled), sum(dp_stockouts_weekly_kiosk_product_pct.sold)) AS spoiled_frac_units,
    sum(dp_stockouts_weekly_kiosk_product_pct.revenue) AS revenue,
    sum(dp_stockouts_weekly_kiosk_product_pct.cost) AS cost,
    sum(((dp_stockouts_weekly_kiosk_product_pct.spoiled)::numeric * dp_stockouts_weekly_kiosk_product_pct.unit_cost)) AS stockouts_dolr,
    sum(dp_stockouts_weekly_kiosk_product_pct.net_profit) AS net_profit,
    (sum(((dp_stockouts_weekly_kiosk_product_pct.spoiled)::numeric * dp_stockouts_weekly_kiosk_product_pct.unit_cost)) / (0.0001 + sum(dp_stockouts_weekly_kiosk_product_pct.revenue))) AS stockouts_frac_dolr
   FROM public.dp_stockouts_weekly_kiosk_product_pct
  GROUP BY dp_stockouts_weekly_kiosk_product_pct.week, dp_stockouts_weekly_kiosk_product_pct.kiosk_id
  ORDER BY dp_stockouts_weekly_kiosk_product_pct.kiosk_id, dp_stockouts_weekly_kiosk_product_pct.week DESC;
CREATE VIEW public.user_retention_26weeks AS
 SELECT user_retention_by_week.week,
    user_retention_by_week.num_consumers,
    user_retention_by_week.repeat_consumers,
    user_retention_by_week.num_tickets,
    user_retention_by_week.sum_amount_list_price,
    user_retention_by_week.sum_amount_paid,
    user_retention_by_week.num_repeat_tickets,
    user_retention_by_week.sum_repeat_amount_list_price,
    user_retention_by_week.sum_repeat_amount_paid,
    user_retention_by_week.frac_users_retained,
    user_retention_by_week.frac_tickets_retained,
    user_retention_by_week.frac_listprice_retained,
    user_retention_by_week.frac_amountpaid_retained,
    user_retention_by_week.old_week,
    user_retention_by_week.old_num_consumers,
    user_retention_by_week.old_repeat_consumers,
    user_retention_by_week.old_num_tickets,
    user_retention_by_week.old_sum_amount_list_price,
    user_retention_by_week.old_sum_amount_paid
   FROM public.user_retention_by_week(26) user_retention_by_week(week, num_consumers, repeat_consumers, num_tickets, sum_amount_list_price, sum_amount_paid, num_repeat_tickets, sum_repeat_amount_list_price, sum_repeat_amount_paid, frac_users_retained, frac_tickets_retained, frac_listprice_retained, frac_amountpaid_retained, old_week, old_num_consumers, old_repeat_consumers, old_num_tickets, old_sum_amount_list_price, old_sum_amount_paid);
CREATE VIEW public.byte_tickets_12months AS
 SELECT byte_tickets.order_id,
    byte_tickets.first_name,
    byte_tickets.last_name,
    byte_tickets.kiosk_id,
    byte_tickets.kiosk_title,
    byte_tickets.email,
    byte_tickets.amount_paid,
    byte_tickets.payment_system,
    byte_tickets.transaction_id,
    byte_tickets.approval_code,
    byte_tickets.status_code,
    byte_tickets.status_message,
    byte_tickets.status,
    byte_tickets.batch_id,
    byte_tickets.created,
    byte_tickets.auth_amount,
    byte_tickets.data_token,
    byte_tickets.time_opened,
    byte_tickets.time_closed,
    byte_tickets.card_hash,
    byte_tickets.state,
    byte_tickets.archived,
    byte_tickets.stamp,
    byte_tickets.last_update,
    byte_tickets.balance,
    byte_tickets.delta,
    byte_tickets.coupon_id,
    byte_tickets.coupon,
    byte_tickets.refund,
    byte_tickets.receipt,
    byte_tickets.campus_id,
    byte_tickets.amount_list_price,
    byte_tickets.notes,
    byte_tickets.time_door_opened,
    byte_tickets.time_door_closed,
    byte_tickets.client_name,
    byte_tickets.estd_num_users,
    byte_tickets.ts,
    byte_tickets.full_name,
    byte_tickets.door_opened_secs,
    byte_tickets.month,
    byte_tickets.week,
    byte_tickets.date,
    byte_tickets.dayofweek,
    byte_tickets.hour,
    byte_tickets.dowhour,
    byte_tickets.uniq_user
   FROM public.byte_tickets
  WHERE (byte_tickets.ts > (now() - '1 year'::interval month));
CREATE VIEW public.byte_tickets_6months AS
 SELECT byte_tickets.order_id,
    byte_tickets.first_name,
    byte_tickets.last_name,
    byte_tickets.kiosk_id,
    byte_tickets.kiosk_title,
    byte_tickets.email,
    byte_tickets.amount_paid,
    byte_tickets.payment_system,
    byte_tickets.transaction_id,
    byte_tickets.approval_code,
    byte_tickets.status_code,
    byte_tickets.status_message,
    byte_tickets.status,
    byte_tickets.batch_id,
    byte_tickets.created,
    byte_tickets.auth_amount,
    byte_tickets.data_token,
    byte_tickets.time_opened,
    byte_tickets.time_closed,
    byte_tickets.card_hash,
    byte_tickets.state,
    byte_tickets.archived,
    byte_tickets.stamp,
    byte_tickets.last_update,
    byte_tickets.balance,
    byte_tickets.delta,
    byte_tickets.coupon_id,
    byte_tickets.coupon,
    byte_tickets.refund,
    byte_tickets.receipt,
    byte_tickets.campus_id,
    byte_tickets.amount_list_price,
    byte_tickets.notes,
    byte_tickets.time_door_opened,
    byte_tickets.time_door_closed,
    byte_tickets.client_name,
    byte_tickets.estd_num_users,
    byte_tickets.ts,
    byte_tickets.full_name,
    byte_tickets.door_opened_secs,
    byte_tickets.month,
    byte_tickets.week,
    byte_tickets.date,
    byte_tickets.dayofweek,
    byte_tickets.hour,
    byte_tickets.dowhour,
    byte_tickets.uniq_user
   FROM public.byte_tickets
  WHERE (byte_tickets.ts > (now() - '6 mons'::interval month));
CREATE VIEW public.byte_tickets_9months AS
 SELECT byte_tickets.order_id,
    byte_tickets.first_name,
    byte_tickets.last_name,
    byte_tickets.kiosk_id,
    byte_tickets.kiosk_title,
    byte_tickets.email,
    byte_tickets.amount_paid,
    byte_tickets.payment_system,
    byte_tickets.transaction_id,
    byte_tickets.approval_code,
    byte_tickets.status_code,
    byte_tickets.status_message,
    byte_tickets.status,
    byte_tickets.batch_id,
    byte_tickets.created,
    byte_tickets.auth_amount,
    byte_tickets.data_token,
    byte_tickets.time_opened,
    byte_tickets.time_closed,
    byte_tickets.card_hash,
    byte_tickets.state,
    byte_tickets.archived,
    byte_tickets.stamp,
    byte_tickets.last_update,
    byte_tickets.balance,
    byte_tickets.delta,
    byte_tickets.coupon_id,
    byte_tickets.coupon,
    byte_tickets.refund,
    byte_tickets.receipt,
    byte_tickets.campus_id,
    byte_tickets.amount_list_price,
    byte_tickets.notes,
    byte_tickets.time_door_opened,
    byte_tickets.time_door_closed,
    byte_tickets.client_name,
    byte_tickets.estd_num_users,
    byte_tickets.ts,
    byte_tickets.full_name,
    byte_tickets.door_opened_secs,
    byte_tickets.month,
    byte_tickets.week,
    byte_tickets.date,
    byte_tickets.dayofweek,
    byte_tickets.hour,
    byte_tickets.dowhour,
    byte_tickets.uniq_user
   FROM public.byte_tickets
  WHERE (byte_tickets.ts > (now() - '9 mons'::interval month));
CREATE VIEW public.dp_stockouts_4weeks AS
 SELECT dp_stockouts.kiosk_id,
    dp_stockouts.order_id,
    dp_stockouts.product_id,
    dp_stockouts.ts,
    dp_stockouts.restock_ts,
    dp_stockouts.restock_order_id,
    dp_stockouts.id,
    dp_stockouts.title,
    dp_stockouts.description,
    dp_stockouts.tiny_description,
    dp_stockouts.short_description,
    dp_stockouts.medium_description,
    dp_stockouts.long_description,
    dp_stockouts.price,
    dp_stockouts.cost,
    dp_stockouts.shelf_time,
    dp_stockouts.campus_id,
    dp_stockouts.image,
    dp_stockouts.image_time,
    dp_stockouts.last_update,
    dp_stockouts.archived,
    dp_stockouts.taxable,
    dp_stockouts.allergens,
    dp_stockouts.attribute_names,
    dp_stockouts.categories,
    dp_stockouts.category_names,
    dp_stockouts.vendor,
    dp_stockouts.source,
    dp_stockouts.notes,
    dp_stockouts.total_cal,
    dp_stockouts.num_servings,
    dp_stockouts.ingredients,
    dp_stockouts.calories,
    dp_stockouts.proteins,
    dp_stockouts.sugar,
    dp_stockouts.carbohydrates,
    dp_stockouts.fat,
    dp_stockouts.consumer_category,
    dp_stockouts.ws_case_size,
    dp_stockouts.kiosk_ship_qty,
    dp_stockouts.ws_case_cost,
    dp_stockouts.pick_station,
    dp_stockouts.fc_title,
    dp_stockouts.pricing_tier,
    dp_stockouts.width_space,
    dp_stockouts.height_space,
    dp_stockouts.depth_space,
    dp_stockouts.slotted_width,
    dp_stockouts.tag_volume,
    dp_stockouts.delivery_option,
    dp_stockouts.kiosk_title,
    dp_stockouts.address,
    dp_stockouts.location_x,
    dp_stockouts.location_y,
    dp_stockouts.client_name,
    dp_stockouts.tags,
    dp_stockouts.estd_num_users,
    dp_stockouts.month,
    dp_stockouts.week,
    dp_stockouts.date
   FROM public.dp_stockouts
  WHERE (dp_stockouts.ts > (now() - '28 days'::interval day));
CREATE VIEW public.sales_by_shelflife_30d AS
 SELECT public.if((byte_epcssold_30days.product_shelf_life_days > 30), 999, byte_epcssold_30days.product_shelf_life_days) AS shelf_life,
    sum(byte_epcssold_30days.product_price) AS sales
   FROM public.byte_epcssold_30days
  GROUP BY (public.if((byte_epcssold_30days.product_shelf_life_days > 30), 999, byte_epcssold_30days.product_shelf_life_days))
  ORDER BY (public.if((byte_epcssold_30days.product_shelf_life_days > 30), 999, byte_epcssold_30days.product_shelf_life_days));
CREATE VIEW public.user_retention_4weeks AS
 SELECT user_retention_by_week.week,
    user_retention_by_week.num_consumers,
    user_retention_by_week.repeat_consumers,
    user_retention_by_week.num_tickets,
    user_retention_by_week.sum_amount_list_price,
    user_retention_by_week.sum_amount_paid,
    user_retention_by_week.num_repeat_tickets,
    user_retention_by_week.sum_repeat_amount_list_price,
    user_retention_by_week.sum_repeat_amount_paid,
    user_retention_by_week.frac_users_retained,
    user_retention_by_week.frac_tickets_retained,
    user_retention_by_week.frac_listprice_retained,
    user_retention_by_week.frac_amountpaid_retained,
    user_retention_by_week.old_week,
    user_retention_by_week.old_num_consumers,
    user_retention_by_week.old_repeat_consumers,
    user_retention_by_week.old_num_tickets,
    user_retention_by_week.old_sum_amount_list_price,
    user_retention_by_week.old_sum_amount_paid
   FROM public.user_retention_by_week(4) user_retention_by_week(week, num_consumers, repeat_consumers, num_tickets, sum_amount_list_price, sum_amount_paid, num_repeat_tickets, sum_repeat_amount_list_price, sum_repeat_amount_paid, frac_users_retained, frac_tickets_retained, frac_listprice_retained, frac_amountpaid_retained, old_week, old_num_consumers, old_repeat_consumers, old_num_tickets, old_sum_amount_list_price, old_sum_amount_paid);
CREATE VIEW byt_devops.pgdudetail AS
 SELECT 0 AS union_sort_order,
    all_tables.table_name,
    pg_table_size((all_tables.table_name)::regclass) AS table_size,
    to_char((((pg_table_size((all_tables.table_name)::regclass))::double precision / (pg_total_relation_size((all_tables.table_name)::regclass))::double precision) * (100)::double precision), '999D9%'::text) AS percent_table,
    pg_indexes_size((all_tables.table_name)::regclass) AS indexes_size,
    to_char((((pg_indexes_size((all_tables.table_name)::regclass))::double precision / (pg_total_relation_size((all_tables.table_name)::regclass))::double precision) * (100)::double precision), '999D9%'::text) AS percent_index,
    pg_total_relation_size((all_tables.table_name)::regclass) AS total_size
   FROM ( SELECT (((('"'::text || (tables.table_schema)::text) || '"."'::text) || (tables.table_name)::text) || '"'::text) AS table_name
           FROM information_schema.tables) all_tables
  WHERE (pg_total_relation_size((all_tables.table_name)::regclass) > 0)
  ORDER BY (pg_total_relation_size((all_tables.table_name)::regclass)) DESC;
CREATE VIEW public.byte_tickets_2weeks AS
 SELECT byte_tickets.order_id,
    byte_tickets.first_name,
    byte_tickets.last_name,
    byte_tickets.kiosk_id,
    byte_tickets.kiosk_title,
    byte_tickets.email,
    byte_tickets.amount_paid,
    byte_tickets.payment_system,
    byte_tickets.transaction_id,
    byte_tickets.approval_code,
    byte_tickets.status_code,
    byte_tickets.status_message,
    byte_tickets.status,
    byte_tickets.batch_id,
    byte_tickets.created,
    byte_tickets.auth_amount,
    byte_tickets.data_token,
    byte_tickets.time_opened,
    byte_tickets.time_closed,
    byte_tickets.card_hash,
    byte_tickets.state,
    byte_tickets.archived,
    byte_tickets.stamp,
    byte_tickets.last_update,
    byte_tickets.balance,
    byte_tickets.delta,
    byte_tickets.coupon_id,
    byte_tickets.coupon,
    byte_tickets.refund,
    byte_tickets.receipt,
    byte_tickets.campus_id,
    byte_tickets.amount_list_price,
    byte_tickets.notes,
    byte_tickets.time_door_opened,
    byte_tickets.time_door_closed,
    byte_tickets.client_name,
    byte_tickets.estd_num_users,
    byte_tickets.ts,
    byte_tickets.full_name,
    byte_tickets.door_opened_secs,
    byte_tickets.month,
    byte_tickets.week,
    byte_tickets.date,
    byte_tickets.dayofweek,
    byte_tickets.hour,
    byte_tickets.dowhour,
    byte_tickets.uniq_user
   FROM public.byte_tickets
  WHERE (byte_tickets.ts > (now() - '14 days'::interval day));
CREATE VIEW public.byte_spoilage_by_category_week_newold AS
 SELECT s.week,
    ((regexp_replace((s.consumer_category)::text, '[^a-zA-Z]+'::text, '_'::text, 'g'::text) || '_'::text) ||
        CASE
            WHEN (s.date >= k.new_ts) THEN 'cost_old'::text
            ELSE 'cost_new'::text
        END) AS cat_and_new,
    sum(s.cost) AS spoilage_cost
   FROM (public.byte_spoilage s
     JOIN public.byte_kiosks_date_non_new k ON ((s.kiosk_id = k.kiosk_id)))
  WHERE ((s.date >= '2016-01-01 08:00:00+00'::timestamp with time zone) AND (s.consumer_category IS NOT NULL))
  GROUP BY s.week, ((regexp_replace((s.consumer_category)::text, '[^a-zA-Z]+'::text, '_'::text, 'g'::text) || '_'::text) ||
        CASE
            WHEN (s.date >= k.new_ts) THEN 'cost_old'::text
            ELSE 'cost_new'::text
        END)
  ORDER BY s.week DESC, ((regexp_replace((s.consumer_category)::text, '[^a-zA-Z]+'::text, '_'::text, 'g'::text) || '_'::text) ||
        CASE
            WHEN (s.date >= k.new_ts) THEN 'cost_old'::text
            ELSE 'cost_new'::text
        END);
CREATE VIEW public.dbg_stockout_runs_weighted AS
 SELECT stockout_runs_weighted.kiosk_id,
    stockout_runs_weighted.product_id,
    stockout_runs_weighted.cat,
    public.fmt_ts(stockout_runs_weighted.ts) AS stockout_ts,
    public.fmt_ts(stockout_runs_weighted.restock_ts) AS restock_ts,
    public.interval_hours(stockout_runs_weighted.stockout_len) AS stockout_hrs,
    (stockout_runs_weighted.avg_cat_kiosk_sales)::numeric(8,2) AS avg_cat_kiosk_sales,
    (stockout_runs_weighted.avg_cat_sales)::numeric(8,2) AS avg_cat_sales,
    (stockout_runs_weighted.avg_kiosk_sales)::numeric(8,2) AS avg_kiosk_sales
   FROM public.stockout_runs_weighted
  ORDER BY stockout_runs_weighted.kiosk_id, stockout_runs_weighted.product_id, stockout_runs_weighted.ts;
CREATE VIEW public.user_retention_2weeks AS
 SELECT user_retention_by_week.week,
    user_retention_by_week.num_consumers,
    user_retention_by_week.repeat_consumers,
    user_retention_by_week.num_tickets,
    user_retention_by_week.sum_amount_list_price,
    user_retention_by_week.sum_amount_paid,
    user_retention_by_week.num_repeat_tickets,
    user_retention_by_week.sum_repeat_amount_list_price,
    user_retention_by_week.sum_repeat_amount_paid,
    user_retention_by_week.frac_users_retained,
    user_retention_by_week.frac_tickets_retained,
    user_retention_by_week.frac_listprice_retained,
    user_retention_by_week.frac_amountpaid_retained,
    user_retention_by_week.old_week,
    user_retention_by_week.old_num_consumers,
    user_retention_by_week.old_repeat_consumers,
    user_retention_by_week.old_num_tickets,
    user_retention_by_week.old_sum_amount_list_price,
    user_retention_by_week.old_sum_amount_paid
   FROM public.user_retention_by_week(2) user_retention_by_week(week, num_consumers, repeat_consumers, num_tickets, sum_amount_list_price, sum_amount_paid, num_repeat_tickets, sum_repeat_amount_list_price, sum_repeat_amount_paid, frac_users_retained, frac_tickets_retained, frac_listprice_retained, frac_amountpaid_retained, old_week, old_num_consumers, old_repeat_consumers, old_num_tickets, old_sum_amount_list_price, old_sum_amount_paid);
CREATE VIEW public.inventory_current_lots AS
 SELECT t2.date,
    t2.product_id,
    t2.kiosk_id,
    t2.units,
    (t2.date + ('1 day'::interval day * ((p.shelf_time - 1))::double precision)) AS expir_date,
    p.shelf_time AS shelf_life_days
   FROM (( SELECT t1.date,
            t1.product_id,
            t1.kiosk_id,
            count(DISTINCT t1.epc) AS units
           FROM ( SELECT date_trunc('day'::text, to_timestamp((label.time_updated)::double precision)) AS date,
                    label.id,
                    label.product_id,
                    label.epc,
                    label.is_generic_sku,
                    label.kiosk_id,
                    label.order_id,
                    label.status,
                    label.price,
                    label.cost,
                    label.time_created,
                    label.time_added,
                    label.time_updated,
                    label.notes
                   FROM pantry.label
                  WHERE ((label.status)::text = 'ok'::text)) t1
          WHERE (t1.date > (now() - '2 days'::interval day))
          GROUP BY t1.date, t1.product_id, t1.kiosk_id) t2
     JOIN pantry.product p ON ((t2.product_id = p.id)))
  ORDER BY t2.product_id, t2.kiosk_id, (t2.date + ('1 day'::interval day * ((p.shelf_time - 1))::double precision));
CREATE VIEW public.byte_raw_orders AS
 SELECT all_raw_orders.order_id,
    all_raw_orders.first_name,
    all_raw_orders.last_name,
    all_raw_orders.kiosk_id,
    all_raw_orders.kiosk_title,
    all_raw_orders.email,
    all_raw_orders.amount_paid,
    all_raw_orders.payment_system,
    all_raw_orders.transaction_id,
    all_raw_orders.approval_code,
    all_raw_orders.status_code,
    all_raw_orders.status_message,
    all_raw_orders.status,
    all_raw_orders.batch_id,
    all_raw_orders.created,
    all_raw_orders.auth_amount,
    all_raw_orders.data_token,
    all_raw_orders.time_opened,
    all_raw_orders.time_closed,
    all_raw_orders.card_hash,
    all_raw_orders.state,
    all_raw_orders.archived,
    all_raw_orders.stamp,
    all_raw_orders.last_update,
    all_raw_orders.balance,
    all_raw_orders.delta,
    all_raw_orders.coupon_id,
    all_raw_orders.coupon,
    all_raw_orders.refund,
    all_raw_orders.receipt,
    all_raw_orders.campus_id,
    all_raw_orders.amount_list_price,
    all_raw_orders.notes,
    all_raw_orders.time_door_opened,
    all_raw_orders.time_door_closed,
    all_raw_orders.client_name,
    all_raw_orders.estd_num_users,
    all_raw_orders.ts,
    all_raw_orders.full_name,
    all_raw_orders.door_opened_secs
   FROM public.all_raw_orders
  WHERE (all_raw_orders.campus_id = 87);
CREATE VIEW public.spoilage_by_shelflife_30d AS
 SELECT public.if((byte_spoilage.shelf_time > 30), 999, byte_spoilage.shelf_time) AS shelf_life,
    sum(byte_spoilage.cost) AS spoilage_dolr
   FROM public.byte_spoilage
  WHERE (byte_spoilage.ts_removed > (now() - '30 days'::interval day))
  GROUP BY (public.if((byte_spoilage.shelf_time > 30), 999, byte_spoilage.shelf_time))
  ORDER BY (public.if((byte_spoilage.shelf_time > 30), 999, byte_spoilage.shelf_time));
CREATE VIEW public.byte_epcssold_365days AS
 SELECT o.order_id,
    o.first_name,
    o.last_name,
    o.kiosk_id,
    o.kiosk_title,
    o.email,
    o.amount_paid,
    o.payment_system,
    o.transaction_id,
    o.approval_code,
    o.status_code,
    o.status_message,
    o.status,
    o.batch_id,
    o.created,
    o.auth_amount,
    o.data_token,
    o.time_opened,
    o.time_closed,
    o.card_hash,
    o.state,
    o.archived,
    o.stamp,
    o.last_update,
    o.balance,
    o.delta,
    o.coupon_id,
    o.coupon,
    o.refund,
    o.receipt,
    o.campus_id,
    o.amount_list_price,
    o.notes,
    o.time_door_opened,
    o.time_door_closed,
    o.client_name,
    o.estd_num_users,
    o.ts,
    o.full_name,
    o.door_opened_secs,
    o.month,
    o.week,
    o.date,
    o.dayofweek,
    o.hour,
    o.dowhour,
    o.uniq_user,
    lp.epc,
    lp.label_order_id,
    lp.label_status,
    lp.label_price,
    lp.time_created,
    lp.time_added,
    lp.time_updated,
    lp.ts_created,
    lp.ts_added,
    lp.ts_updated,
    lp.label_kiosk_id,
    lp.product_id,
    lp.product_title,
    lp.product_archived,
    lp.product_vendor,
    lp.product_price,
    lp.product_cost,
    lp.product_shelf_life_days,
    lp.product_attributes,
    lp.product_categories,
    lp.consumer_category,
    lp.product_source
   FROM (public.byte_tickets_365days o
     JOIN public.byte_label_product lp ON (((lp.label_order_id)::text = (o.order_id)::text)))
  WHERE ((lp.label_status)::text = 'sold'::text);
CREATE VIEW public.byte_tickets_3days AS
 SELECT byte_tickets.order_id,
    byte_tickets.first_name,
    byte_tickets.last_name,
    byte_tickets.kiosk_id,
    byte_tickets.kiosk_title,
    byte_tickets.email,
    byte_tickets.amount_paid,
    byte_tickets.payment_system,
    byte_tickets.transaction_id,
    byte_tickets.approval_code,
    byte_tickets.status_code,
    byte_tickets.status_message,
    byte_tickets.status,
    byte_tickets.batch_id,
    byte_tickets.created,
    byte_tickets.auth_amount,
    byte_tickets.data_token,
    byte_tickets.time_opened,
    byte_tickets.time_closed,
    byte_tickets.card_hash,
    byte_tickets.state,
    byte_tickets.archived,
    byte_tickets.stamp,
    byte_tickets.last_update,
    byte_tickets.balance,
    byte_tickets.delta,
    byte_tickets.coupon_id,
    byte_tickets.coupon,
    byte_tickets.refund,
    byte_tickets.receipt,
    byte_tickets.campus_id,
    byte_tickets.amount_list_price,
    byte_tickets.notes,
    byte_tickets.time_door_opened,
    byte_tickets.time_door_closed,
    byte_tickets.client_name,
    byte_tickets.estd_num_users,
    byte_tickets.ts,
    byte_tickets.full_name,
    byte_tickets.door_opened_secs,
    byte_tickets.month,
    byte_tickets.week,
    byte_tickets.date,
    byte_tickets.dayofweek,
    byte_tickets.hour,
    byte_tickets.dowhour,
    byte_tickets.uniq_user
   FROM public.byte_tickets
  WHERE (byte_tickets.ts > (now() - '3 days'::interval day));
CREATE VIEW public.dp_spoilage AS
 SELECT byte_spoilage.kiosk_id,
    byte_spoilage.order_id,
    byte_spoilage.epc,
    byte_spoilage.product_id,
    byte_spoilage.ts_added,
    byte_spoilage.ts_removed,
    byte_spoilage.id,
    byte_spoilage.title,
    byte_spoilage.description,
    byte_spoilage.tiny_description,
    byte_spoilage.short_description,
    byte_spoilage.medium_description,
    byte_spoilage.long_description,
    byte_spoilage.price,
    byte_spoilage.cost,
    byte_spoilage.shelf_time,
    byte_spoilage.campus_id,
    byte_spoilage.image,
    byte_spoilage.image_time,
    byte_spoilage.last_update,
    byte_spoilage.archived,
    byte_spoilage.taxable,
    byte_spoilage.allergens,
    byte_spoilage.attribute_names,
    byte_spoilage.categories,
    byte_spoilage.category_names,
    byte_spoilage.vendor,
    byte_spoilage.source,
    byte_spoilage.notes,
    byte_spoilage.total_cal,
    byte_spoilage.num_servings,
    byte_spoilage.ingredients,
    byte_spoilage.calories,
    byte_spoilage.proteins,
    byte_spoilage.sugar,
    byte_spoilage.carbohydrates,
    byte_spoilage.fat,
    byte_spoilage.consumer_category,
    byte_spoilage.ws_case_size,
    byte_spoilage.kiosk_ship_qty,
    byte_spoilage.ws_case_cost,
    byte_spoilage.pick_station,
    byte_spoilage.fc_title,
    byte_spoilage.pricing_tier,
    byte_spoilage.width_space,
    byte_spoilage.height_space,
    byte_spoilage.depth_space,
    byte_spoilage.slotted_width,
    byte_spoilage.tag_volume,
    byte_spoilage.delivery_option,
    byte_spoilage.kiosk_title,
    byte_spoilage.address,
    byte_spoilage.location_x,
    byte_spoilage.location_y,
    byte_spoilage.client_name,
    byte_spoilage.tags,
    byte_spoilage.estd_num_users,
    byte_spoilage.month,
    byte_spoilage.week,
    byte_spoilage.date
   FROM public.byte_spoilage;
CREATE VIEW public.dp_spoilage_2017 AS
 SELECT dp_spoilage.kiosk_id,
    dp_spoilage.order_id,
    dp_spoilage.epc,
    dp_spoilage.product_id,
    dp_spoilage.ts_added,
    dp_spoilage.ts_removed,
    dp_spoilage.id,
    dp_spoilage.title,
    dp_spoilage.description,
    dp_spoilage.tiny_description,
    dp_spoilage.short_description,
    dp_spoilage.medium_description,
    dp_spoilage.long_description,
    dp_spoilage.price,
    dp_spoilage.cost,
    dp_spoilage.shelf_time,
    dp_spoilage.campus_id,
    dp_spoilage.image,
    dp_spoilage.image_time,
    dp_spoilage.last_update,
    dp_spoilage.archived,
    dp_spoilage.taxable,
    dp_spoilage.allergens,
    dp_spoilage.attribute_names,
    dp_spoilage.categories,
    dp_spoilage.category_names,
    dp_spoilage.vendor,
    dp_spoilage.source,
    dp_spoilage.notes,
    dp_spoilage.total_cal,
    dp_spoilage.num_servings,
    dp_spoilage.ingredients,
    dp_spoilage.calories,
    dp_spoilage.proteins,
    dp_spoilage.sugar,
    dp_spoilage.carbohydrates,
    dp_spoilage.fat,
    dp_spoilage.consumer_category,
    dp_spoilage.ws_case_size,
    dp_spoilage.kiosk_ship_qty,
    dp_spoilage.ws_case_cost,
    dp_spoilage.pick_station,
    dp_spoilage.fc_title,
    dp_spoilage.pricing_tier,
    dp_spoilage.width_space,
    dp_spoilage.height_space,
    dp_spoilage.depth_space,
    dp_spoilage.slotted_width,
    dp_spoilage.tag_volume,
    dp_spoilage.delivery_option,
    dp_spoilage.kiosk_title,
    dp_spoilage.address,
    dp_spoilage.location_x,
    dp_spoilage.location_y,
    dp_spoilage.client_name,
    dp_spoilage.tags,
    dp_spoilage.estd_num_users,
    dp_spoilage.month,
    dp_spoilage.week,
    dp_spoilage.date
   FROM public.dp_spoilage
  WHERE ((dp_spoilage.ts_removed >= '2017-01-01 08:00:00+00'::timestamp with time zone) AND (dp_spoilage.ts_removed <= '2018-01-01 08:00:00+00'::timestamp with time zone));
CREATE VIEW inm.kiosk_projected_stock_sku_level AS
 SELECT NULL::bigint AS kiosk_id,
    NULL::character varying(138) AS kiosk_title,
    NULL::character varying(255) AS fc_title,
    NULL::bigint AS id,
    NULL::character varying(127) AS title,
    NULL::numeric AS count;
CREATE VIEW mixalot.v_kiosk_status_log AS
 SELECT l.ts,
    l."time",
    l.request_uuid,
    l.endpoint,
    l.client_ip,
    l.version,
    l.cookie,
    l.message,
    l.request_body,
    l.request_headers,
    l.start_ts,
    l.response_body,
    l.response_headers,
    l.status_code,
    l.end_ts,
    l.traceback,
    l.request_body_json,
    l.request_headers_json,
    l.response_headers_json,
    l.kiosk_id,
    l.source,
    (((l.request_body_json)::json ->> 'kiosk_id'::text))::integer AS client_kiosk_id,
    (((l.request_body_json)::json ->> 'retry_queue_length'::text))::integer AS retry_queue_length,
    (((l.request_body_json)::json ->> 'retry_count'::text))::integer AS retry_count,
    (((l.request_body_json)::json ->> 'happy_hour'::text))::integer AS happy_hour,
    (((l.request_body_json)::json ->> 'app_uptime'::text))::integer AS app_uptime,
    (((l.request_body_json)::json ->> 'system_uptime'::text))::integer AS system_uptime,
    (((l.request_body_json)::json ->> 'kiosk_temperature'::text))::numeric AS kiosk_temperature,
    (((l.request_body_json)::json ->> 'kit_temperature'::text))::numeric AS kit_temperature,
    (((l.request_body_json)::json ->> 'power'::text))::integer AS power,
    (((l.request_body_json)::json ->> 'battery_level'::text))::integer AS battery_level,
    (((l.request_body_json)::json ->> 'rfid_0'::text))::integer AS rfid_0,
    (((l.request_body_json)::json ->> 'rfid_1'::text))::integer AS rfid_1,
    (((l.request_body_json)::json ->> 'rfid_2'::text))::integer AS rfid_2,
    (((l.request_body_json)::json ->> 'rfid_3'::text))::integer AS rfid_3,
    (((l.request_body_json)::json ->> 'rfid_4'::text))::integer AS rfid_4,
    (((l.request_body_json)::json ->> 'rfid_5'::text))::integer AS rfid_5,
    (((l.request_body_json)::json ->> 'rfid_6'::text))::integer AS rfid_6,
    (((l.request_body_json)::json ->> 'rfid_7'::text))::integer AS rfid_7
   FROM mixalot.v_kiosk_request_log l
  WHERE ((l.endpoint = '/status'::text) AND (l.source = 'mixalot'::text));
CREATE VIEW public.byte_epcssold_360days AS
 SELECT o.order_id,
    o.first_name,
    o.last_name,
    o.kiosk_id,
    o.kiosk_title,
    o.email,
    o.amount_paid,
    o.payment_system,
    o.transaction_id,
    o.approval_code,
    o.status_code,
    o.status_message,
    o.status,
    o.batch_id,
    o.created,
    o.auth_amount,
    o.data_token,
    o.time_opened,
    o.time_closed,
    o.card_hash,
    o.state,
    o.archived,
    o.stamp,
    o.last_update,
    o.balance,
    o.delta,
    o.coupon_id,
    o.coupon,
    o.refund,
    o.receipt,
    o.campus_id,
    o.amount_list_price,
    o.notes,
    o.time_door_opened,
    o.time_door_closed,
    o.client_name,
    o.estd_num_users,
    o.ts,
    o.full_name,
    o.door_opened_secs,
    o.month,
    o.week,
    o.date,
    o.dayofweek,
    o.hour,
    o.dowhour,
    o.uniq_user,
    lp.epc,
    lp.label_order_id,
    lp.label_status,
    lp.label_price,
    lp.time_created,
    lp.time_added,
    lp.time_updated,
    lp.ts_created,
    lp.ts_added,
    lp.ts_updated,
    lp.label_kiosk_id,
    lp.product_id,
    lp.product_title,
    lp.product_archived,
    lp.product_vendor,
    lp.product_price,
    lp.product_cost,
    lp.product_shelf_life_days,
    lp.product_attributes,
    lp.product_categories,
    lp.consumer_category,
    lp.product_source
   FROM (public.byte_tickets_360days o
     JOIN public.byte_label_product lp ON (((lp.label_order_id)::text = (o.order_id)::text)))
  WHERE ((lp.label_status)::text = 'sold'::text);
CREATE VIEW public.user_retention_6months AS
 SELECT user_retention_by_month.month,
    user_retention_by_month.num_consumers,
    user_retention_by_month.repeat_consumers,
    user_retention_by_month.num_tickets,
    user_retention_by_month.sum_amount_list_price,
    user_retention_by_month.sum_amount_paid,
    user_retention_by_month.num_repeat_tickets,
    user_retention_by_month.sum_repeat_amount_list_price,
    user_retention_by_month.sum_repeat_amount_paid,
    user_retention_by_month.frac_users_retained,
    user_retention_by_month.frac_tickets_retained,
    user_retention_by_month.frac_listprice_retained,
    user_retention_by_month.frac_amountpaid_retained,
    user_retention_by_month.old_month,
    user_retention_by_month.old_num_consumers,
    user_retention_by_month.old_repeat_consumers,
    user_retention_by_month.old_num_tickets,
    user_retention_by_month.old_sum_amount_list_price,
    user_retention_by_month.old_sum_amount_paid
   FROM public.user_retention_by_month(6) user_retention_by_month(month, num_consumers, repeat_consumers, num_tickets, sum_amount_list_price, sum_amount_paid, num_repeat_tickets, sum_repeat_amount_list_price, sum_repeat_amount_paid, frac_users_retained, frac_tickets_retained, frac_listprice_retained, frac_amountpaid_retained, old_month, old_num_consumers, old_repeat_consumers, old_num_tickets, old_sum_amount_list_price, old_sum_amount_paid);
CREATE VIEW public.dp_epcssold_2015 AS
 SELECT dp_epcssold.order_id,
    dp_epcssold.first_name,
    dp_epcssold.last_name,
    dp_epcssold.kiosk_id,
    dp_epcssold.kiosk_title,
    dp_epcssold.email,
    dp_epcssold.amount_paid,
    dp_epcssold.payment_system,
    dp_epcssold.transaction_id,
    dp_epcssold.approval_code,
    dp_epcssold.status_code,
    dp_epcssold.status_message,
    dp_epcssold.status,
    dp_epcssold.batch_id,
    dp_epcssold.created,
    dp_epcssold.auth_amount,
    dp_epcssold.data_token,
    dp_epcssold.time_opened,
    dp_epcssold.time_closed,
    dp_epcssold.card_hash,
    dp_epcssold.state,
    dp_epcssold.archived,
    dp_epcssold.stamp,
    dp_epcssold.last_update,
    dp_epcssold.balance,
    dp_epcssold.delta,
    dp_epcssold.coupon_id,
    dp_epcssold.coupon,
    dp_epcssold.refund,
    dp_epcssold.receipt,
    dp_epcssold.campus_id,
    dp_epcssold.amount_list_price,
    dp_epcssold.notes,
    dp_epcssold.time_door_opened,
    dp_epcssold.time_door_closed,
    dp_epcssold.client_name,
    dp_epcssold.estd_num_users,
    dp_epcssold.ts,
    dp_epcssold.full_name,
    dp_epcssold.door_opened_secs,
    dp_epcssold.month,
    dp_epcssold.week,
    dp_epcssold.date,
    dp_epcssold.dayofweek,
    dp_epcssold.hour,
    dp_epcssold.dowhour,
    dp_epcssold.uniq_user,
    dp_epcssold.epc,
    dp_epcssold.label_order_id,
    dp_epcssold.label_status,
    dp_epcssold.label_price,
    dp_epcssold.time_created,
    dp_epcssold.time_added,
    dp_epcssold.time_updated,
    dp_epcssold.ts_created,
    dp_epcssold.ts_added,
    dp_epcssold.ts_updated,
    dp_epcssold.label_kiosk_id,
    dp_epcssold.product_id,
    dp_epcssold.product_title,
    dp_epcssold.product_archived,
    dp_epcssold.product_vendor,
    dp_epcssold.product_price,
    dp_epcssold.product_cost,
    dp_epcssold.product_shelf_life_days,
    dp_epcssold.product_attributes,
    dp_epcssold.product_categories,
    dp_epcssold.consumer_category,
    dp_epcssold.product_source
   FROM public.dp_epcssold
  WHERE ((dp_epcssold.ts >= '2015-01-01 08:00:00+00'::timestamp with time zone) AND (dp_epcssold.ts <= '2016-01-01 08:00:00+00'::timestamp with time zone));
CREATE VIEW public.sys_conninfo AS
 SELECT pg_stat_activity.usename,
    count(*) AS count
   FROM pg_stat_activity
  GROUP BY pg_stat_activity.usename;
CREATE VIEW public.user_retention_2months AS
 SELECT user_retention_by_month.month,
    user_retention_by_month.num_consumers,
    user_retention_by_month.repeat_consumers,
    user_retention_by_month.num_tickets,
    user_retention_by_month.sum_amount_list_price,
    user_retention_by_month.sum_amount_paid,
    user_retention_by_month.num_repeat_tickets,
    user_retention_by_month.sum_repeat_amount_list_price,
    user_retention_by_month.sum_repeat_amount_paid,
    user_retention_by_month.frac_users_retained,
    user_retention_by_month.frac_tickets_retained,
    user_retention_by_month.frac_listprice_retained,
    user_retention_by_month.frac_amountpaid_retained,
    user_retention_by_month.old_month,
    user_retention_by_month.old_num_consumers,
    user_retention_by_month.old_repeat_consumers,
    user_retention_by_month.old_num_tickets,
    user_retention_by_month.old_sum_amount_list_price,
    user_retention_by_month.old_sum_amount_paid
   FROM public.user_retention_by_month(2) user_retention_by_month(month, num_consumers, repeat_consumers, num_tickets, sum_amount_list_price, sum_amount_paid, num_repeat_tickets, sum_repeat_amount_list_price, sum_repeat_amount_paid, frac_users_retained, frac_tickets_retained, frac_listprice_retained, frac_amountpaid_retained, old_month, old_num_consumers, old_repeat_consumers, old_num_tickets, old_sum_amount_list_price, old_sum_amount_paid);
CREATE VIEW public.byte_tickets_10weeks AS
 SELECT byte_tickets.order_id,
    byte_tickets.first_name,
    byte_tickets.last_name,
    byte_tickets.kiosk_id,
    byte_tickets.kiosk_title,
    byte_tickets.email,
    byte_tickets.amount_paid,
    byte_tickets.payment_system,
    byte_tickets.transaction_id,
    byte_tickets.approval_code,
    byte_tickets.status_code,
    byte_tickets.status_message,
    byte_tickets.status,
    byte_tickets.batch_id,
    byte_tickets.created,
    byte_tickets.auth_amount,
    byte_tickets.data_token,
    byte_tickets.time_opened,
    byte_tickets.time_closed,
    byte_tickets.card_hash,
    byte_tickets.state,
    byte_tickets.archived,
    byte_tickets.stamp,
    byte_tickets.last_update,
    byte_tickets.balance,
    byte_tickets.delta,
    byte_tickets.coupon_id,
    byte_tickets.coupon,
    byte_tickets.refund,
    byte_tickets.receipt,
    byte_tickets.campus_id,
    byte_tickets.amount_list_price,
    byte_tickets.notes,
    byte_tickets.time_door_opened,
    byte_tickets.time_door_closed,
    byte_tickets.client_name,
    byte_tickets.estd_num_users,
    byte_tickets.ts,
    byte_tickets.full_name,
    byte_tickets.door_opened_secs,
    byte_tickets.month,
    byte_tickets.week,
    byte_tickets.date,
    byte_tickets.dayofweek,
    byte_tickets.hour,
    byte_tickets.dowhour,
    byte_tickets.uniq_user
   FROM public.byte_tickets
  WHERE (byte_tickets.ts > (now() - '70 days'::interval day));
CREATE VIEW public.byte_epcssold_6months AS
 SELECT o.order_id,
    o.first_name,
    o.last_name,
    o.kiosk_id,
    o.kiosk_title,
    o.email,
    o.amount_paid,
    o.payment_system,
    o.transaction_id,
    o.approval_code,
    o.status_code,
    o.status_message,
    o.status,
    o.batch_id,
    o.created,
    o.auth_amount,
    o.data_token,
    o.time_opened,
    o.time_closed,
    o.card_hash,
    o.state,
    o.archived,
    o.stamp,
    o.last_update,
    o.balance,
    o.delta,
    o.coupon_id,
    o.coupon,
    o.refund,
    o.receipt,
    o.campus_id,
    o.amount_list_price,
    o.notes,
    o.time_door_opened,
    o.time_door_closed,
    o.client_name,
    o.estd_num_users,
    o.ts,
    o.full_name,
    o.door_opened_secs,
    o.month,
    o.week,
    o.date,
    o.dayofweek,
    o.hour,
    o.dowhour,
    o.uniq_user,
    lp.epc,
    lp.label_order_id,
    lp.label_status,
    lp.label_price,
    lp.time_created,
    lp.time_added,
    lp.time_updated,
    lp.ts_created,
    lp.ts_added,
    lp.ts_updated,
    lp.label_kiosk_id,
    lp.product_id,
    lp.product_title,
    lp.product_archived,
    lp.product_vendor,
    lp.product_price,
    lp.product_cost,
    lp.product_shelf_life_days,
    lp.product_attributes,
    lp.product_categories,
    lp.consumer_category,
    lp.product_source
   FROM (public.byte_tickets_6months o
     JOIN public.byte_label_product lp ON (((lp.label_order_id)::text = (o.order_id)::text)))
  WHERE ((lp.label_status)::text = 'sold'::text);
CREATE VIEW public.byte_kiosks_by_week AS
 SELECT s.week,
    (count(DISTINCT public.if((s.ts >= k.new_ts), k.kiosk_id, 0)) - 1) AS num_old_kiosks,
    (count(DISTINCT public.if((s.ts < k.new_ts), k.kiosk_id, 0)) - 1) AS num_new_kiosks,
    count(DISTINCT k.kiosk_id) AS num_all_kiosks
   FROM (public.byte_restockings s
     JOIN public.byte_kiosks_date_non_new k ON ((s.kiosk_id = k.kiosk_id)))
  GROUP BY s.week
  ORDER BY s.week;
CREATE VIEW public.byte_epcssold_6days AS
 SELECT o.order_id,
    o.first_name,
    o.last_name,
    o.kiosk_id,
    o.kiosk_title,
    o.email,
    o.amount_paid,
    o.payment_system,
    o.transaction_id,
    o.approval_code,
    o.status_code,
    o.status_message,
    o.status,
    o.batch_id,
    o.created,
    o.auth_amount,
    o.data_token,
    o.time_opened,
    o.time_closed,
    o.card_hash,
    o.state,
    o.archived,
    o.stamp,
    o.last_update,
    o.balance,
    o.delta,
    o.coupon_id,
    o.coupon,
    o.refund,
    o.receipt,
    o.campus_id,
    o.amount_list_price,
    o.notes,
    o.time_door_opened,
    o.time_door_closed,
    o.client_name,
    o.estd_num_users,
    o.ts,
    o.full_name,
    o.door_opened_secs,
    o.month,
    o.week,
    o.date,
    o.dayofweek,
    o.hour,
    o.dowhour,
    o.uniq_user,
    lp.epc,
    lp.label_order_id,
    lp.label_status,
    lp.label_price,
    lp.time_created,
    lp.time_added,
    lp.time_updated,
    lp.ts_created,
    lp.ts_added,
    lp.ts_updated,
    lp.label_kiosk_id,
    lp.product_id,
    lp.product_title,
    lp.product_archived,
    lp.product_vendor,
    lp.product_price,
    lp.product_cost,
    lp.product_shelf_life_days,
    lp.product_attributes,
    lp.product_categories,
    lp.consumer_category,
    lp.product_source
   FROM (public.byte_tickets_6days o
     JOIN public.byte_label_product lp ON (((lp.label_order_id)::text = (o.order_id)::text)))
  WHERE ((lp.label_status)::text = 'sold'::text);
CREATE VIEW public.inventory_current AS
 SELECT inventory_current_lots.kiosk_id,
    inventory_current_lots.product_id,
    sum(inventory_current_lots.units) AS units
   FROM public.inventory_current_lots
  GROUP BY inventory_current_lots.kiosk_id, inventory_current_lots.product_id;
CREATE VIEW public.byte_spoilage_by_category_week AS
 SELECT t1.week,
    (regexp_replace(regexp_replace(t1.cat_and_new, '_cost1_'::text, '_per_'::text), '_all'::text, ''::text) || '_kiosk'::text) AS cat_and_new,
    (t1.spoilage_cost / (
        CASE
            WHEN (t1.cat_and_new ~~ '%new%'::text) THEN t2.num_new_kiosks
            WHEN (t1.cat_and_new ~~ '%old%'::text) THEN t2.num_old_kiosks
            ELSE t2.num_all_kiosks
        END)::numeric) AS spoilage_cost
   FROM (( SELECT byte_spoilage_by_category_week_newold.week,
            byte_spoilage_by_category_week_newold.cat_and_new,
            byte_spoilage_by_category_week_newold.spoilage_cost
           FROM public.byte_spoilage_by_category_week_newold
        UNION
         SELECT byte_spoilage_by_category_week_all.week,
            byte_spoilage_by_category_week_all.cat_and_new,
            byte_spoilage_by_category_week_all.spoilage_cost
           FROM public.byte_spoilage_by_category_week_all) t1
     LEFT JOIN public.byte_kiosks_by_week t2 ON ((t1.week = t2.week)));
CREATE VIEW public.user_retention_3months AS
 SELECT user_retention_by_month.month,
    user_retention_by_month.num_consumers,
    user_retention_by_month.repeat_consumers,
    user_retention_by_month.num_tickets,
    user_retention_by_month.sum_amount_list_price,
    user_retention_by_month.sum_amount_paid,
    user_retention_by_month.num_repeat_tickets,
    user_retention_by_month.sum_repeat_amount_list_price,
    user_retention_by_month.sum_repeat_amount_paid,
    user_retention_by_month.frac_users_retained,
    user_retention_by_month.frac_tickets_retained,
    user_retention_by_month.frac_listprice_retained,
    user_retention_by_month.frac_amountpaid_retained,
    user_retention_by_month.old_month,
    user_retention_by_month.old_num_consumers,
    user_retention_by_month.old_repeat_consumers,
    user_retention_by_month.old_num_tickets,
    user_retention_by_month.old_sum_amount_list_price,
    user_retention_by_month.old_sum_amount_paid
   FROM public.user_retention_by_month(3) user_retention_by_month(month, num_consumers, repeat_consumers, num_tickets, sum_amount_list_price, sum_amount_paid, num_repeat_tickets, sum_repeat_amount_list_price, sum_repeat_amount_paid, frac_users_retained, frac_tickets_retained, frac_listprice_retained, frac_amountpaid_retained, old_month, old_num_consumers, old_repeat_consumers, old_num_tickets, old_sum_amount_list_price, old_sum_amount_paid);
CREATE VIEW public.user_retention_1week AS
 SELECT user_retention_by_week.week,
    user_retention_by_week.num_consumers,
    user_retention_by_week.repeat_consumers,
    user_retention_by_week.num_tickets,
    user_retention_by_week.sum_amount_list_price,
    user_retention_by_week.sum_amount_paid,
    user_retention_by_week.num_repeat_tickets,
    user_retention_by_week.sum_repeat_amount_list_price,
    user_retention_by_week.sum_repeat_amount_paid,
    user_retention_by_week.frac_users_retained,
    user_retention_by_week.frac_tickets_retained,
    user_retention_by_week.frac_listprice_retained,
    user_retention_by_week.frac_amountpaid_retained,
    user_retention_by_week.old_week,
    user_retention_by_week.old_num_consumers,
    user_retention_by_week.old_repeat_consumers,
    user_retention_by_week.old_num_tickets,
    user_retention_by_week.old_sum_amount_list_price,
    user_retention_by_week.old_sum_amount_paid
   FROM public.user_retention_by_week(1) user_retention_by_week(week, num_consumers, repeat_consumers, num_tickets, sum_amount_list_price, sum_amount_paid, num_repeat_tickets, sum_repeat_amount_list_price, sum_repeat_amount_paid, frac_users_retained, frac_tickets_retained, frac_listprice_retained, frac_amountpaid_retained, old_week, old_num_consumers, old_repeat_consumers, old_num_tickets, old_sum_amount_list_price, old_sum_amount_paid);
CREATE VIEW public.byte_epcssold_5weeks AS
 SELECT o.order_id,
    o.first_name,
    o.last_name,
    o.kiosk_id,
    o.kiosk_title,
    o.email,
    o.amount_paid,
    o.payment_system,
    o.transaction_id,
    o.approval_code,
    o.status_code,
    o.status_message,
    o.status,
    o.batch_id,
    o.created,
    o.auth_amount,
    o.data_token,
    o.time_opened,
    o.time_closed,
    o.card_hash,
    o.state,
    o.archived,
    o.stamp,
    o.last_update,
    o.balance,
    o.delta,
    o.coupon_id,
    o.coupon,
    o.refund,
    o.receipt,
    o.campus_id,
    o.amount_list_price,
    o.notes,
    o.time_door_opened,
    o.time_door_closed,
    o.client_name,
    o.estd_num_users,
    o.ts,
    o.full_name,
    o.door_opened_secs,
    o.month,
    o.week,
    o.date,
    o.dayofweek,
    o.hour,
    o.dowhour,
    o.uniq_user,
    lp.epc,
    lp.label_order_id,
    lp.label_status,
    lp.label_price,
    lp.time_created,
    lp.time_added,
    lp.time_updated,
    lp.ts_created,
    lp.ts_added,
    lp.ts_updated,
    lp.label_kiosk_id,
    lp.product_id,
    lp.product_title,
    lp.product_archived,
    lp.product_vendor,
    lp.product_price,
    lp.product_cost,
    lp.product_shelf_life_days,
    lp.product_attributes,
    lp.product_categories,
    lp.consumer_category,
    lp.product_source
   FROM (public.byte_tickets_5weeks o
     JOIN public.byte_label_product lp ON (((lp.label_order_id)::text = (o.order_id)::text)))
  WHERE ((lp.label_status)::text = 'sold'::text);
CREATE VIEW public.sales_by_category_120d AS
 SELECT byte_epcssold_120days.consumer_category,
    sum(byte_epcssold_120days.product_price) AS sales_120d,
    sum(public.if(((byte_epcssold_120days.ts >= (now() - '30 days'::interval day)) AND (byte_epcssold_120days.ts <= (now() - '00:00:00'::interval day))), byte_epcssold_120days.product_price, 0.0)) AS sales_0d_30d,
    sum(public.if(((byte_epcssold_120days.ts >= (now() - '60 days'::interval day)) AND (byte_epcssold_120days.ts <= (now() - '30 days'::interval day))), byte_epcssold_120days.product_price, 0.0)) AS sales_30d_60d,
    sum(public.if(((byte_epcssold_120days.ts >= (now() - '90 days'::interval day)) AND (byte_epcssold_120days.ts <= (now() - '60 days'::interval day))), byte_epcssold_120days.product_price, 0.0)) AS sales_60d_90d,
    sum(public.if(((byte_epcssold_120days.ts >= (now() - '120 days'::interval day)) AND (byte_epcssold_120days.ts <= (now() - '90 days'::interval day))), byte_epcssold_120days.product_price, 0.0)) AS sales_90d_120d
   FROM public.byte_epcssold_120days
  GROUP BY byte_epcssold_120days.consumer_category;
CREATE VIEW mixalot.inm_kiosk_sku_disabled AS
 SELECT DISTINCT krbp.kiosk_id,
    sd.id AS sku_id
   FROM (((mixalot.sku_def sd
     JOIN mixalot.sku_property sp ON ((sd.id = sp.sku_id)))
     JOIN mixalot.sku_property_def spd ON ((sp.property_id = spd.id)))
     JOIN mixalot.kiosk_restriction_by_property krbp ON ((krbp.property_id = spd.id)))
UNION
 SELECT DISTINCT kiosk_restriction_by_sku.kiosk_id,
    kiosk_restriction_by_sku.sku_id
   FROM mixalot.kiosk_restriction_by_sku;
CREATE VIEW pantry.tmp_process_order AS
 SELECT ("substring"((tmp_process_order_txt.amount_paid)::text, 5))::numeric(6,2) AS amount_paid,
    tmp_process_order_txt.approval_code,
    tmp_process_order_txt.batch_id,
    tmp_process_order_txt.state,
    tmp_process_order_txt.status,
    tmp_process_order_txt.status_code,
    tmp_process_order_txt.status_message,
    tmp_process_order_txt.transaction_id,
    tmp_process_order_txt.order_id,
    tmp_process_order_txt.id
   FROM pantry.tmp_process_order_txt;
CREATE VIEW public.byte_tickets_120days AS
 SELECT byte_tickets.order_id,
    byte_tickets.first_name,
    byte_tickets.last_name,
    byte_tickets.kiosk_id,
    byte_tickets.kiosk_title,
    byte_tickets.email,
    byte_tickets.amount_paid,
    byte_tickets.payment_system,
    byte_tickets.transaction_id,
    byte_tickets.approval_code,
    byte_tickets.status_code,
    byte_tickets.status_message,
    byte_tickets.status,
    byte_tickets.batch_id,
    byte_tickets.created,
    byte_tickets.auth_amount,
    byte_tickets.data_token,
    byte_tickets.time_opened,
    byte_tickets.time_closed,
    byte_tickets.card_hash,
    byte_tickets.state,
    byte_tickets.archived,
    byte_tickets.stamp,
    byte_tickets.last_update,
    byte_tickets.balance,
    byte_tickets.delta,
    byte_tickets.coupon_id,
    byte_tickets.coupon,
    byte_tickets.refund,
    byte_tickets.receipt,
    byte_tickets.campus_id,
    byte_tickets.amount_list_price,
    byte_tickets.notes,
    byte_tickets.time_door_opened,
    byte_tickets.time_door_closed,
    byte_tickets.client_name,
    byte_tickets.estd_num_users,
    byte_tickets.ts,
    byte_tickets.full_name,
    byte_tickets.door_opened_secs,
    byte_tickets.month,
    byte_tickets.week,
    byte_tickets.date,
    byte_tickets.dayofweek,
    byte_tickets.hour,
    byte_tickets.dowhour,
    byte_tickets.uniq_user
   FROM public.byte_tickets
  WHERE (byte_tickets.ts > (now() - '120 days'::interval day));
CREATE VIEW public.dp_stockouts_2016 AS
 SELECT dp_stockouts.kiosk_id,
    dp_stockouts.order_id,
    dp_stockouts.product_id,
    dp_stockouts.ts,
    dp_stockouts.restock_ts,
    dp_stockouts.restock_order_id,
    dp_stockouts.id,
    dp_stockouts.title,
    dp_stockouts.description,
    dp_stockouts.tiny_description,
    dp_stockouts.short_description,
    dp_stockouts.medium_description,
    dp_stockouts.long_description,
    dp_stockouts.price,
    dp_stockouts.cost,
    dp_stockouts.shelf_time,
    dp_stockouts.campus_id,
    dp_stockouts.image,
    dp_stockouts.image_time,
    dp_stockouts.last_update,
    dp_stockouts.archived,
    dp_stockouts.taxable,
    dp_stockouts.allergens,
    dp_stockouts.attribute_names,
    dp_stockouts.categories,
    dp_stockouts.category_names,
    dp_stockouts.vendor,
    dp_stockouts.source,
    dp_stockouts.notes,
    dp_stockouts.total_cal,
    dp_stockouts.num_servings,
    dp_stockouts.ingredients,
    dp_stockouts.calories,
    dp_stockouts.proteins,
    dp_stockouts.sugar,
    dp_stockouts.carbohydrates,
    dp_stockouts.fat,
    dp_stockouts.consumer_category,
    dp_stockouts.ws_case_size,
    dp_stockouts.kiosk_ship_qty,
    dp_stockouts.ws_case_cost,
    dp_stockouts.pick_station,
    dp_stockouts.fc_title,
    dp_stockouts.pricing_tier,
    dp_stockouts.width_space,
    dp_stockouts.height_space,
    dp_stockouts.depth_space,
    dp_stockouts.slotted_width,
    dp_stockouts.tag_volume,
    dp_stockouts.delivery_option,
    dp_stockouts.kiosk_title,
    dp_stockouts.address,
    dp_stockouts.location_x,
    dp_stockouts.location_y,
    dp_stockouts.client_name,
    dp_stockouts.tags,
    dp_stockouts.estd_num_users,
    dp_stockouts.month,
    dp_stockouts.week,
    dp_stockouts.date
   FROM public.dp_stockouts
  WHERE ((dp_stockouts.ts >= '2016-01-01 08:00:00+00'::timestamp with time zone) AND (dp_stockouts.ts <= '2017-01-01 08:00:00+00'::timestamp with time zone));
CREATE VIEW public.dp_products AS
 SELECT byte_products.id,
    byte_products.title,
    byte_products.vendor,
    byte_products.price,
    byte_products.cost,
    byte_products.shelf_life_days,
    byte_products.attributes,
    byte_products.categories
   FROM public.byte_products;
CREATE VIEW public.dp_spoilage_weekly_kiosk_pct AS
 SELECT dp_spoilage_weekly_kiosk_product_pct.week,
    dp_spoilage_weekly_kiosk_product_pct.kiosk_id,
    sum(dp_spoilage_weekly_kiosk_product_pct.spoiled) AS spoiled_units,
    sum(dp_spoilage_weekly_kiosk_product_pct.sold) AS sold_units,
    public.frac(sum(dp_spoilage_weekly_kiosk_product_pct.spoiled), sum(dp_spoilage_weekly_kiosk_product_pct.sold)) AS spoiled_frac_units,
    sum(dp_spoilage_weekly_kiosk_product_pct.revenue) AS revenue,
    sum(dp_spoilage_weekly_kiosk_product_pct.cost) AS cost,
    sum((dp_spoilage_weekly_kiosk_product_pct.spoiled * dp_spoilage_weekly_kiosk_product_pct.unit_cost)) AS spoilage_dolr,
    sum(dp_spoilage_weekly_kiosk_product_pct.net_profit) AS net_profit,
    public.if((sum(dp_spoilage_weekly_kiosk_product_pct.sold) = (0)::numeric), 9999.0, (sum((dp_spoilage_weekly_kiosk_product_pct.spoiled * dp_spoilage_weekly_kiosk_product_pct.unit_cost)) / sum(dp_spoilage_weekly_kiosk_product_pct.revenue))) AS spoilage_frac,
    min((dp_spoilage_weekly_kiosk_product_pct.kiosk_title)::text) AS kiosk_title,
    bool_and(dp_spoilage_weekly_kiosk_product_pct.new_kiosk) AS new_kiosk
   FROM public.dp_spoilage_weekly_kiosk_product_pct
  GROUP BY dp_spoilage_weekly_kiosk_product_pct.week, dp_spoilage_weekly_kiosk_product_pct.kiosk_id
  ORDER BY dp_spoilage_weekly_kiosk_product_pct.kiosk_id, dp_spoilage_weekly_kiosk_product_pct.week DESC;
CREATE VIEW public.sys_uptime AS
 SELECT (now() - pg_stat_activity.backend_start) AS uptime
   FROM pg_stat_activity
  WHERE (pg_stat_activity.pid = pg_backend_pid());
CREATE VIEW public.user_retention_tickets AS
 SELECT byte_tickets.week,
    byte_tickets.month,
    (((byte_tickets.client_name)::text || '--'::text) || byte_tickets.uniq_user) AS consumer_id,
    byte_tickets.amount_list_price,
    byte_tickets.amount_paid
   FROM public.byte_tickets
  WHERE (byte_tickets.uniq_user <> ALL (ARRAY['F.OfflineMode'::text, 'F.Complimentary'::text]));
CREATE VIEW mixalot.inm_demand AS
 SELECT demand.kiosk_id,
    demand.fc_title,
    demand.qty
   FROM mixalot.inm_data demand
  WHERE ((demand.data_type = 'Plan Demand'::text) AND (demand.qty > 0) AND (demand.import_ts = ( SELECT max(dc_sku.import_ts) AS max
           FROM mixalot.inm_data dc_sku
          WHERE (dc_sku.data_type = 'Plan Demand'::text))));
CREATE VIEW mixalot.inm_sku_enabled AS
 SELECT k.id AS kiosk_id,
    s.id AS sku_id
   FROM ((mixalot.inm_byte_kiosk k
     CROSS JOIN mixalot.sku_def s)
     LEFT JOIN mixalot.inm_kiosk_sku_disabled d ON (((k.id = d.kiosk_id) AND (s.id = d.sku_id))))
  WHERE ((d.kiosk_id IS NULL) AND (d.sku_id IS NULL));
CREATE VIEW public.byte_tickets_30days AS
 SELECT byte_tickets.order_id,
    byte_tickets.first_name,
    byte_tickets.last_name,
    byte_tickets.kiosk_id,
    byte_tickets.kiosk_title,
    byte_tickets.email,
    byte_tickets.amount_paid,
    byte_tickets.payment_system,
    byte_tickets.transaction_id,
    byte_tickets.approval_code,
    byte_tickets.status_code,
    byte_tickets.status_message,
    byte_tickets.status,
    byte_tickets.batch_id,
    byte_tickets.created,
    byte_tickets.auth_amount,
    byte_tickets.data_token,
    byte_tickets.time_opened,
    byte_tickets.time_closed,
    byte_tickets.card_hash,
    byte_tickets.state,
    byte_tickets.archived,
    byte_tickets.stamp,
    byte_tickets.last_update,
    byte_tickets.balance,
    byte_tickets.delta,
    byte_tickets.coupon_id,
    byte_tickets.coupon,
    byte_tickets.refund,
    byte_tickets.receipt,
    byte_tickets.campus_id,
    byte_tickets.amount_list_price,
    byte_tickets.notes,
    byte_tickets.time_door_opened,
    byte_tickets.time_door_closed,
    byte_tickets.client_name,
    byte_tickets.estd_num_users,
    byte_tickets.ts,
    byte_tickets.full_name,
    byte_tickets.door_opened_secs,
    byte_tickets.month,
    byte_tickets.week,
    byte_tickets.date,
    byte_tickets.dayofweek,
    byte_tickets.hour,
    byte_tickets.dowhour,
    byte_tickets.uniq_user
   FROM public.byte_tickets
  WHERE (byte_tickets.ts > (now() - '30 days'::interval day));
CREATE VIEW public.byte_epcssold_4weeks AS
 SELECT o.order_id,
    o.first_name,
    o.last_name,
    o.kiosk_id,
    o.kiosk_title,
    o.email,
    o.amount_paid,
    o.payment_system,
    o.transaction_id,
    o.approval_code,
    o.status_code,
    o.status_message,
    o.status,
    o.batch_id,
    o.created,
    o.auth_amount,
    o.data_token,
    o.time_opened,
    o.time_closed,
    o.card_hash,
    o.state,
    o.archived,
    o.stamp,
    o.last_update,
    o.balance,
    o.delta,
    o.coupon_id,
    o.coupon,
    o.refund,
    o.receipt,
    o.campus_id,
    o.amount_list_price,
    o.notes,
    o.time_door_opened,
    o.time_door_closed,
    o.client_name,
    o.estd_num_users,
    o.ts,
    o.full_name,
    o.door_opened_secs,
    o.month,
    o.week,
    o.date,
    o.dayofweek,
    o.hour,
    o.dowhour,
    o.uniq_user,
    lp.epc,
    lp.label_order_id,
    lp.label_status,
    lp.label_price,
    lp.time_created,
    lp.time_added,
    lp.time_updated,
    lp.ts_created,
    lp.ts_added,
    lp.ts_updated,
    lp.label_kiosk_id,
    lp.product_id,
    lp.product_title,
    lp.product_archived,
    lp.product_vendor,
    lp.product_price,
    lp.product_cost,
    lp.product_shelf_life_days,
    lp.product_attributes,
    lp.product_categories,
    lp.consumer_category,
    lp.product_source
   FROM (public.byte_tickets_4weeks o
     JOIN public.byte_label_product lp ON (((lp.label_order_id)::text = (o.order_id)::text)))
  WHERE ((lp.label_status)::text = 'sold'::text);
CREATE VIEW public.byte_epcssold_1year AS
 SELECT o.order_id,
    o.first_name,
    o.last_name,
    o.kiosk_id,
    o.kiosk_title,
    o.email,
    o.amount_paid,
    o.payment_system,
    o.transaction_id,
    o.approval_code,
    o.status_code,
    o.status_message,
    o.status,
    o.batch_id,
    o.created,
    o.auth_amount,
    o.data_token,
    o.time_opened,
    o.time_closed,
    o.card_hash,
    o.state,
    o.archived,
    o.stamp,
    o.last_update,
    o.balance,
    o.delta,
    o.coupon_id,
    o.coupon,
    o.refund,
    o.receipt,
    o.campus_id,
    o.amount_list_price,
    o.notes,
    o.time_door_opened,
    o.time_door_closed,
    o.client_name,
    o.estd_num_users,
    o.ts,
    o.full_name,
    o.door_opened_secs,
    o.month,
    o.week,
    o.date,
    o.dayofweek,
    o.hour,
    o.dowhour,
    o.uniq_user,
    lp.epc,
    lp.label_order_id,
    lp.label_status,
    lp.label_price,
    lp.time_created,
    lp.time_added,
    lp.time_updated,
    lp.ts_created,
    lp.ts_added,
    lp.ts_updated,
    lp.label_kiosk_id,
    lp.product_id,
    lp.product_title,
    lp.product_archived,
    lp.product_vendor,
    lp.product_price,
    lp.product_cost,
    lp.product_shelf_life_days,
    lp.product_attributes,
    lp.product_categories,
    lp.consumer_category,
    lp.product_source
   FROM (public.byte_tickets_1year o
     JOIN public.byte_label_product lp ON (((lp.label_order_id)::text = (o.order_id)::text)))
  WHERE ((lp.label_status)::text = 'sold'::text);
CREATE VIEW public.byte_tickets_2015 AS
 SELECT byte_tickets.order_id,
    byte_tickets.first_name,
    byte_tickets.last_name,
    byte_tickets.kiosk_id,
    byte_tickets.kiosk_title,
    byte_tickets.email,
    byte_tickets.amount_paid,
    byte_tickets.payment_system,
    byte_tickets.transaction_id,
    byte_tickets.approval_code,
    byte_tickets.status_code,
    byte_tickets.status_message,
    byte_tickets.status,
    byte_tickets.batch_id,
    byte_tickets.created,
    byte_tickets.auth_amount,
    byte_tickets.data_token,
    byte_tickets.time_opened,
    byte_tickets.time_closed,
    byte_tickets.card_hash,
    byte_tickets.state,
    byte_tickets.archived,
    byte_tickets.stamp,
    byte_tickets.last_update,
    byte_tickets.balance,
    byte_tickets.delta,
    byte_tickets.coupon_id,
    byte_tickets.coupon,
    byte_tickets.refund,
    byte_tickets.receipt,
    byte_tickets.campus_id,
    byte_tickets.amount_list_price,
    byte_tickets.notes,
    byte_tickets.time_door_opened,
    byte_tickets.time_door_closed,
    byte_tickets.client_name,
    byte_tickets.estd_num_users,
    byte_tickets.ts,
    byte_tickets.full_name,
    byte_tickets.door_opened_secs,
    byte_tickets.month,
    byte_tickets.week,
    byte_tickets.date,
    byte_tickets.dayofweek,
    byte_tickets.hour,
    byte_tickets.dowhour,
    byte_tickets.uniq_user
   FROM public.byte_tickets
  WHERE ((byte_tickets.ts >= '2015-01-01 08:00:00+00'::timestamp with time zone) AND (byte_tickets.ts < '2016-01-01 08:00:00+00'::timestamp with time zone));
CREATE VIEW public.dp_epcssold_2017 AS
 SELECT dp_epcssold.order_id,
    dp_epcssold.first_name,
    dp_epcssold.last_name,
    dp_epcssold.kiosk_id,
    dp_epcssold.kiosk_title,
    dp_epcssold.email,
    dp_epcssold.amount_paid,
    dp_epcssold.payment_system,
    dp_epcssold.transaction_id,
    dp_epcssold.approval_code,
    dp_epcssold.status_code,
    dp_epcssold.status_message,
    dp_epcssold.status,
    dp_epcssold.batch_id,
    dp_epcssold.created,
    dp_epcssold.auth_amount,
    dp_epcssold.data_token,
    dp_epcssold.time_opened,
    dp_epcssold.time_closed,
    dp_epcssold.card_hash,
    dp_epcssold.state,
    dp_epcssold.archived,
    dp_epcssold.stamp,
    dp_epcssold.last_update,
    dp_epcssold.balance,
    dp_epcssold.delta,
    dp_epcssold.coupon_id,
    dp_epcssold.coupon,
    dp_epcssold.refund,
    dp_epcssold.receipt,
    dp_epcssold.campus_id,
    dp_epcssold.amount_list_price,
    dp_epcssold.notes,
    dp_epcssold.time_door_opened,
    dp_epcssold.time_door_closed,
    dp_epcssold.client_name,
    dp_epcssold.estd_num_users,
    dp_epcssold.ts,
    dp_epcssold.full_name,
    dp_epcssold.door_opened_secs,
    dp_epcssold.month,
    dp_epcssold.week,
    dp_epcssold.date,
    dp_epcssold.dayofweek,
    dp_epcssold.hour,
    dp_epcssold.dowhour,
    dp_epcssold.uniq_user,
    dp_epcssold.epc,
    dp_epcssold.label_order_id,
    dp_epcssold.label_status,
    dp_epcssold.label_price,
    dp_epcssold.time_created,
    dp_epcssold.time_added,
    dp_epcssold.time_updated,
    dp_epcssold.ts_created,
    dp_epcssold.ts_added,
    dp_epcssold.ts_updated,
    dp_epcssold.label_kiosk_id,
    dp_epcssold.product_id,
    dp_epcssold.product_title,
    dp_epcssold.product_archived,
    dp_epcssold.product_vendor,
    dp_epcssold.product_price,
    dp_epcssold.product_cost,
    dp_epcssold.product_shelf_life_days,
    dp_epcssold.product_attributes,
    dp_epcssold.product_categories,
    dp_epcssold.consumer_category,
    dp_epcssold.product_source
   FROM public.dp_epcssold
  WHERE ((dp_epcssold.ts >= '2017-01-01 08:00:00+00'::timestamp with time zone) AND (dp_epcssold.ts <= '2018-01-01 08:00:00+00'::timestamp with time zone));
CREATE VIEW public.stockout_runs_weighted AS
 WITH _unused AS (
         SELECT 1
        ), stockout_runs_weighted AS (
         SELECT st.kiosk_id,
            st.product_id,
            st.stockout_len,
            min(st.ts) AS ts,
            max(st.restock_ts) AS restock_ts,
            min((st.cat)::text) AS cat,
            sum(sa.avg_cat_kiosk_sales) AS avg_cat_kiosk_sales,
            sum(sa.avg_cat_sales) AS avg_cat_sales,
            sum(sa.avg_kiosk_sales) AS avg_kiosk_sales
           FROM (public.stockout_dowhours st
             JOIN public.stockout_avg_kiosk_cat_sales_dowhour sa ON (((st.dowhour = sa.dowhour) AND (st.kiosk_id = sa.kiosk_id) AND ((st.cat)::text = (sa.cat)::text))))
          GROUP BY st.kiosk_id, st.product_id, st.stockout_len
        )
 SELECT stockout_runs_weighted.kiosk_id,
    stockout_runs_weighted.product_id,
    stockout_runs_weighted.stockout_len,
    stockout_runs_weighted.ts,
    stockout_runs_weighted.restock_ts,
    stockout_runs_weighted.cat,
    stockout_runs_weighted.avg_cat_kiosk_sales,
    stockout_runs_weighted.avg_cat_sales,
    stockout_runs_weighted.avg_kiosk_sales
   FROM stockout_runs_weighted;
CREATE VIEW public.dbg_stockout_weighted_stats AS
 SELECT count(*) AS count,
    count(DISTINCT stockout_dowhours.kiosk_id) AS kiosks,
    count(DISTINCT stockout_dowhours.product_id) AS products,
    count(DISTINCT stockout_dowhours.dowhour) AS dowhours,
    count(DISTINCT stockout_dowhours.cat) AS cats
   FROM public.stockout_dowhours;
CREATE VIEW public.dp_spoilage_2016 AS
 SELECT dp_spoilage.kiosk_id,
    dp_spoilage.order_id,
    dp_spoilage.epc,
    dp_spoilage.product_id,
    dp_spoilage.ts_added,
    dp_spoilage.ts_removed,
    dp_spoilage.id,
    dp_spoilage.title,
    dp_spoilage.description,
    dp_spoilage.tiny_description,
    dp_spoilage.short_description,
    dp_spoilage.medium_description,
    dp_spoilage.long_description,
    dp_spoilage.price,
    dp_spoilage.cost,
    dp_spoilage.shelf_time,
    dp_spoilage.campus_id,
    dp_spoilage.image,
    dp_spoilage.image_time,
    dp_spoilage.last_update,
    dp_spoilage.archived,
    dp_spoilage.taxable,
    dp_spoilage.allergens,
    dp_spoilage.attribute_names,
    dp_spoilage.categories,
    dp_spoilage.category_names,
    dp_spoilage.vendor,
    dp_spoilage.source,
    dp_spoilage.notes,
    dp_spoilage.total_cal,
    dp_spoilage.num_servings,
    dp_spoilage.ingredients,
    dp_spoilage.calories,
    dp_spoilage.proteins,
    dp_spoilage.sugar,
    dp_spoilage.carbohydrates,
    dp_spoilage.fat,
    dp_spoilage.consumer_category,
    dp_spoilage.ws_case_size,
    dp_spoilage.kiosk_ship_qty,
    dp_spoilage.ws_case_cost,
    dp_spoilage.pick_station,
    dp_spoilage.fc_title,
    dp_spoilage.pricing_tier,
    dp_spoilage.width_space,
    dp_spoilage.height_space,
    dp_spoilage.depth_space,
    dp_spoilage.slotted_width,
    dp_spoilage.tag_volume,
    dp_spoilage.delivery_option,
    dp_spoilage.kiosk_title,
    dp_spoilage.address,
    dp_spoilage.location_x,
    dp_spoilage.location_y,
    dp_spoilage.client_name,
    dp_spoilage.tags,
    dp_spoilage.estd_num_users,
    dp_spoilage.month,
    dp_spoilage.week,
    dp_spoilage.date
   FROM public.dp_spoilage
  WHERE ((dp_spoilage.ts_removed >= '2016-01-01 08:00:00+00'::timestamp with time zone) AND (dp_spoilage.ts_removed <= '2017-01-01 08:00:00+00'::timestamp with time zone));
CREATE VIEW public.byte_tickets_5days AS
 SELECT byte_tickets.order_id,
    byte_tickets.first_name,
    byte_tickets.last_name,
    byte_tickets.kiosk_id,
    byte_tickets.kiosk_title,
    byte_tickets.email,
    byte_tickets.amount_paid,
    byte_tickets.payment_system,
    byte_tickets.transaction_id,
    byte_tickets.approval_code,
    byte_tickets.status_code,
    byte_tickets.status_message,
    byte_tickets.status,
    byte_tickets.batch_id,
    byte_tickets.created,
    byte_tickets.auth_amount,
    byte_tickets.data_token,
    byte_tickets.time_opened,
    byte_tickets.time_closed,
    byte_tickets.card_hash,
    byte_tickets.state,
    byte_tickets.archived,
    byte_tickets.stamp,
    byte_tickets.last_update,
    byte_tickets.balance,
    byte_tickets.delta,
    byte_tickets.coupon_id,
    byte_tickets.coupon,
    byte_tickets.refund,
    byte_tickets.receipt,
    byte_tickets.campus_id,
    byte_tickets.amount_list_price,
    byte_tickets.notes,
    byte_tickets.time_door_opened,
    byte_tickets.time_door_closed,
    byte_tickets.client_name,
    byte_tickets.estd_num_users,
    byte_tickets.ts,
    byte_tickets.full_name,
    byte_tickets.door_opened_secs,
    byte_tickets.month,
    byte_tickets.week,
    byte_tickets.date,
    byte_tickets.dayofweek,
    byte_tickets.hour,
    byte_tickets.dowhour,
    byte_tickets.uniq_user
   FROM public.byte_tickets
  WHERE (byte_tickets.ts > (now() - '5 days'::interval day));
CREATE VIEW public.dp_spoilage_monthly_product_pct AS
 SELECT dp_spoilage_monthly_kiosk_product_pct.month,
    dp_spoilage_monthly_kiosk_product_pct.product_id,
    sum(dp_spoilage_monthly_kiosk_product_pct.spoiled) AS spoiled_units,
    sum(dp_spoilage_monthly_kiosk_product_pct.sold) AS sold_units,
    public.frac(sum(dp_spoilage_monthly_kiosk_product_pct.spoiled), sum(dp_spoilage_monthly_kiosk_product_pct.sold)) AS spoiled_frac_units,
    sum(dp_spoilage_monthly_kiosk_product_pct.revenue) AS revenue,
    sum(dp_spoilage_monthly_kiosk_product_pct.cost) AS cost,
    sum(((dp_spoilage_monthly_kiosk_product_pct.spoiled)::numeric * dp_spoilage_monthly_kiosk_product_pct.unit_cost)) AS spoilage_dolr,
    sum(dp_spoilage_monthly_kiosk_product_pct.net_profit) AS net_profit,
    public.if((sum(dp_spoilage_monthly_kiosk_product_pct.sold) = (0)::numeric), 9999.0, (sum(((dp_spoilage_monthly_kiosk_product_pct.spoiled)::numeric * dp_spoilage_monthly_kiosk_product_pct.unit_cost)) / sum(dp_spoilage_monthly_kiosk_product_pct.revenue))) AS spoilage_frac_dolr
   FROM public.dp_spoilage_monthly_kiosk_product_pct
  GROUP BY dp_spoilage_monthly_kiosk_product_pct.month, dp_spoilage_monthly_kiosk_product_pct.product_id
  ORDER BY dp_spoilage_monthly_kiosk_product_pct.product_id, dp_spoilage_monthly_kiosk_product_pct.month DESC;