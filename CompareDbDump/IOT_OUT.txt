-> iot-schema-out.sql <- Results in
-> erp-schema-out.sql <- Results in
--
-- PostgreSQL database dump
--

-- Dumped from database version 10.6
-- Dumped by pg_dump version 11.5

SET statement_timeout = 0;
false SET
HERE false SET
HERE map[statement_timeout:SET statement_timeout = 0;]
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SELECT pg_catalog.set_config('search_path', '', false);
SELECT pg_catalog.set_config('search_path', '', false);
SET check_function_bodies = false;
SET xmloption = content;
SET client_min_messages = warning;
SET row_security = off;

--
-- Name: aws_dms; Type: SCHEMA; Schema: -; Owner: dbservice
--

CREATE SCHEMA aws_dms;


ALTER SCHEMA aws_dms OWNER TO dbservice;

--
-- Name: beta; Type: SCHEMA; Schema: -; Owner: dbservice
--

CREATE SCHEMA beta;


ALTER SCHEMA beta OWNER TO dbservice;

--
-- Name: SCHEMA beta; Type: COMMENT; Schema: -; Owner: dbservice
--

COMMENT ON SCHEMA beta IS 'development schema';


--
-- Name: byt_devops; Type: SCHEMA; Schema: -; Owner: dbservice
--

CREATE SCHEMA byt_devops;


ALTER SCHEMA byt_devops OWNER TO dbservice;

--
-- Name: byte_pgdu; Type: SCHEMA; Schema: -; Owner: dbservice
--

CREATE SCHEMA byte_pgdu;


ALTER SCHEMA byte_pgdu OWNER TO dbservice;

--
-- Name: develop; Type: SCHEMA; Schema: -; Owner: dbservice
--

CREATE SCHEMA develop;


ALTER SCHEMA develop OWNER TO dbservice;

--
-- Name: dms7; Type: SCHEMA; Schema: -; Owner: dbservice
--

CREATE SCHEMA dms7;


ALTER SCHEMA dms7 OWNER TO dbservice;

--
-- Name: fnrenames; Type: SCHEMA; Schema: -; Owner: dbservice
--

CREATE SCHEMA fnrenames;


ALTER SCHEMA fnrenames OWNER TO dbservice;

--
-- Name: inm; Type: SCHEMA; Schema: -; Owner: dbservice
--

CREATE SCHEMA inm;


ALTER SCHEMA inm OWNER TO dbservice;

--
-- Name: SCHEMA inm; Type: COMMENT; Schema: -; Owner: dbservice
--

COMMENT ON SCHEMA inm IS 'Demand planning';


--
-- Name: inm_backup; Type: SCHEMA; Schema: -; Owner: dbservice
--

CREATE SCHEMA inm_backup;


ALTER SCHEMA inm_backup OWNER TO dbservice;

--
-- Name: SCHEMA inm_backup; Type: COMMENT; Schema: -; Owner: dbservice
--

COMMENT ON SCHEMA inm_backup IS 'back up of tables containing inm settings such as kiosk_sku_preference before the latest changes.';


--
-- Name: inm_beta; Type: SCHEMA; Schema: -; Owner: dbservice
--

CREATE SCHEMA inm_beta;


ALTER SCHEMA inm_beta OWNER TO dbservice;

--
-- Name: SCHEMA inm_beta; Type: COMMENT; Schema: -; Owner: dbservice
--

COMMENT ON SCHEMA inm_beta IS 'New schema to be used by LambdaZen. Contains iINM related objects plus new versions of other general objects currently in pantry schema such as KIOSK and KIOSK related tables.';


--
-- Name: inm_test; Type: SCHEMA; Schema: -; Owner: dbservice
--

CREATE SCHEMA inm_test;


ALTER SCHEMA inm_test OWNER TO dbservice;

--
-- Name: SCHEMA inm_test; Type: COMMENT; Schema: -; Owner: dbservice
--

COMMENT ON SCHEMA inm_test IS 'Where as inm schema will contain production pick result, inm_test will contain test pick results so that they do not affect actual inm production stats.';


--
-- Name: iplanner; Type: SCHEMA; Schema: -; Owner: dbservice
--

CREATE SCHEMA iplanner;


ALTER SCHEMA iplanner OWNER TO dbservice;

--
-- Name: mixalot; Type: SCHEMA; Schema: -; Owner: dbservice
--

CREATE SCHEMA mixalot;


ALTER SCHEMA mixalot OWNER TO dbservice;

--
-- Name: monitor; Type: SCHEMA; Schema: -; Owner: dbservice
--

CREATE SCHEMA monitor;


ALTER SCHEMA monitor OWNER TO dbservice;

--
-- Name: SCHEMA monitor; Type: COMMENT; Schema: -; Owner: dbservice
--

COMMENT ON SCHEMA monitor IS 'stores kiosk monitor data';


--
-- Name: pantry; Type: SCHEMA; Schema: -; Owner: dbservice
--

CREATE SCHEMA pantry;


ALTER SCHEMA pantry OWNER TO dbservice;

--
-- Name: report; Type: SCHEMA; Schema: -; Owner: dbservice
--

CREATE SCHEMA report;


ALTER SCHEMA report OWNER TO dbservice;

--
-- Name: rptg; Type: SCHEMA; Schema: -; Owner: dbservice
--

CREATE SCHEMA rptg;


ALTER SCHEMA rptg OWNER TO dbservice;

--
-- Name: test; Type: SCHEMA; Schema: -; Owner: dbservice
--

CREATE SCHEMA test;


ALTER SCHEMA test OWNER TO dbservice;

--
-- Name: util; Type: SCHEMA; Schema: -; Owner: dbservice
--

CREATE SCHEMA util;


ALTER SCHEMA util OWNER TO dbservice;

--
-- Name: plperl; Type: PROCEDURAL LANGUAGE; Schema: -; Owner: dbservice
--

CREATE OR REPLACE PROCEDURAL LANGUAGE plperl;


ALTER PROCEDURAL LANGUAGE plperl OWNER TO dbservice;

--
-- Name: btree_gin; Type: EXTENSION; Schema: -; Owner: 
--

CREATE EXTENSION IF NOT EXISTS btree_gin WITH SCHEMA public;


--
-- Name: EXTENSION btree_gin; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION btree_gin IS 'support for indexing common datatypes in GIN';


--
-- Name: intarray; Type: EXTENSION; Schema: -; Owner: 
--

CREATE EXTENSION IF NOT EXISTS intarray WITH SCHEMA public;


--
-- Name: EXTENSION intarray; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION intarray IS 'functions, operators, and index support for 1-D arrays of integers';


--
-- Name: pg_stat_statements; Type: EXTENSION; Schema: -; Owner: 
--

CREATE EXTENSION IF NOT EXISTS pg_stat_statements WITH SCHEMA public;


--
-- Name: EXTENSION pg_stat_statements; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION pg_stat_statements IS 'track execution statistics of all SQL statements executed';


--
-- Name: pg_trgm; Type: EXTENSION; Schema: -; Owner: 
--

CREATE EXTENSION IF NOT EXISTS pg_trgm WITH SCHEMA public;


--
-- Name: EXTENSION pg_trgm; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION pg_trgm IS 'text similarity measurement and index searching based on trigrams';


--
-- Name: tablefunc; Type: EXTENSION; Schema: -; Owner: 
--

CREATE EXTENSION IF NOT EXISTS tablefunc WITH SCHEMA public;


--
-- Name: EXTENSION tablefunc; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION tablefunc IS 'functions that manipulate whole tables, including crosstab';


--
-- Name: text100; Type: DOMAIN; Schema: inm_beta; Owner: dbservice
--

CREATE DOMAIN inm_beta.text100 AS text
	CONSTRAINT text100_check CHECK ((length(VALUE) <= 30));


ALTER DOMAIN inm_beta.text100 OWNER TO dbservice;

--
-- Name: text100_nb; Type: DOMAIN; Schema: inm_beta; Owner: dbservice
--

CREATE DOMAIN inm_beta.text100_nb AS inm_beta.text100
	CONSTRAINT text100_nb_check CHECK ((length((VALUE)::text) >= 1));


ALTER DOMAIN inm_beta.text100_nb OWNER TO dbservice;

--
-- Name: text10k; Type: DOMAIN; Schema: inm_beta; Owner: dbservice
--

CREATE DOMAIN inm_beta.text10k AS text
	CONSTRAINT text10k_check CHECK ((length(VALUE) <= 10000));


ALTER DOMAIN inm_beta.text10k OWNER TO dbservice;

--
-- Name: text1k; Type: DOMAIN; Schema: inm_beta; Owner: dbservice
--

CREATE DOMAIN inm_beta.text1k AS text
	CONSTRAINT text1k_check CHECK ((length(VALUE) <= 1000));


ALTER DOMAIN inm_beta.text1k OWNER TO dbservice;

--
-- Name: text200; Type: DOMAIN; Schema: inm_beta; Owner: dbservice
--

CREATE DOMAIN inm_beta.text200 AS text
	CONSTRAINT text200_check CHECK ((length(VALUE) <= 200));


ALTER DOMAIN inm_beta.text200 OWNER TO dbservice;

--
-- Name: text2k; Type: DOMAIN; Schema: inm_beta; Owner: dbservice
--

CREATE DOMAIN inm_beta.text2k AS text
	CONSTRAINT text2k_check CHECK ((length(VALUE) <= 2000));


ALTER DOMAIN inm_beta.text2k OWNER TO dbservice;

--
-- Name: text400; Type: DOMAIN; Schema: inm_beta; Owner: dbservice
--

CREATE DOMAIN inm_beta.text400 AS text
	CONSTRAINT text400_check CHECK ((length(VALUE) <= 400));


ALTER DOMAIN inm_beta.text400 OWNER TO dbservice;

--
-- Name: text4k; Type: DOMAIN; Schema: inm_beta; Owner: dbservice
--

CREATE DOMAIN inm_beta.text4k AS text
	CONSTRAINT text4k_check CHECK ((length(VALUE) <= 4000));


ALTER DOMAIN inm_beta.text4k OWNER TO dbservice;

--
-- Name: text_name; Type: DOMAIN; Schema: inm_beta; Owner: dbservice
--

CREATE DOMAIN inm_beta.text_name AS text
	CONSTRAINT text_name_check CHECK ((length(VALUE) <= 100));


ALTER DOMAIN inm_beta.text_name OWNER TO dbservice;

--
-- Name: bringg_vs_optimo_delta(date, date); Type: FUNCTION; Schema: beta; Owner: dbservice
--

CREATE FUNCTION beta.bringg_vs_optimo_delta(start_date date, end_date date) RETURNS TABLE(bringg_kid integer, bringg_task_id bigint, bringg_ts timestamp with time zone, optimo_ts timestamp with time zone, optimo_kid integer)
    LANGUAGE plpgsql
    AS $$

/*
Purpose - compare pick to restock
Input - 
start_date: first pick date to consider
end_date: last pick date to consider
Output - 
difference between Bringg and Optimo routes
*/

declare target_date date;
declare pick_window_start timestamp with time zone;
declare pick_window_end timestamp with time zone;
begin
set timezone to 'US/Pacific';
return query
select cast(b.kid as integer) b_kid, b.task_id, b.route_date_time b_ts, o.route_date_time o_ts, o.location_number o_kid
from bringg.order b 
full outer join mixalot.route_stop o
on cast(b.kid as integer) = o.location_number and b.route_date_time::date = o.route_date_time::date and  o.location_number <> -1
where (b.route_date_time::date between start_date and end_date or o.route_date_time::date between start_date and end_date)
and (o.route_date_time is null or b.route_date_time is null)
order by coalesce(b.route_date_time, o.route_date_time);

end;

$$;


ALTER FUNCTION beta.bringg_vs_optimo_delta(start_date date, end_date date) OWNER TO dbservice;

--
-- Name: compare_pick_vs_delivery(date, date); Type: FUNCTION; Schema: beta; Owner: dbservice
--

CREATE FUNCTION beta.compare_pick_vs_delivery(start_date date, end_date date DEFAULT NULL::date) RETURNS TABLE(kiosk_id integer, route_date date, restocker text, product_id integer, pick_qty integer, restock_qty integer, discrepancy integer)
    LANGUAGE plpgsql
    AS $$

/*
Purpose - compare pick to restock
Input - 
	start_date: first pick date to consider
	end_date: last pick date to consider. If not given, compute the result for only start_date
Output - 
	kiosk_id: id for kiosk
	route_date: delivery date
	kiosk_title: kiosk name
	product_id: what picked/allocated
	pick_qty: quantity above product_id picked
	restock_qty: quantity of above product_id for the same route_date
	discrepancy: restock_qty - pick_quantity for target_date  
*/

declare target_date date;
declare pick_window_start timestamp with time zone;
declare pick_window_end timestamp with time zone;
begin
	set timezone to 'US/Pacific';
	return query
		select a.kiosk_id, a.route_date, r.restocker, a.sku_id, cast(sum(a.qty) as integer), 
			coalesce(cast(sum(l.total) as integer), 0), cast(coalesce(sum(l.total), 0) - sum(a.qty) as integer)
			from inm.pick_allocation a 
			left join 
				(select to_timestamp(time_created)::date restock_date, pantry.label.kiosk_id, pantry.label.product_id, count(*) total
					from pantry.label group by 1,2,3) l
					on a.route_date = l.restock_date and a.kiosk_id=l.kiosk_id and a.sku_id = l.product_id
			left join 
					-- restocker
					(select distinct to_timestamp(created)::date route_date, o.kiosk_id, first_name || ' ' || last_name restocker from pantry.order o
						where order_id like 'RE%' and to_timestamp(created)::date between start_date and end_date + 1 order by 1,2) r
					on r.route_date = a.route_date and r.kiosk_id = a.kiosk_id
			where a.route_date between start_date and end_date
		group by 1, 2, 3, 4;
end;

$$;


ALTER FUNCTION beta.compare_pick_vs_delivery(start_date date, end_date date) OWNER TO dbservice;

--
-- Name: compare_pick_vs_delivery_by_sku(date, date); Type: FUNCTION; Schema: beta; Owner: dbservice
--

CREATE FUNCTION beta.compare_pick_vs_delivery_by_sku(start_date date, end_date date DEFAULT NULL::date) RETURNS TABLE(route_date date, driver_name character varying, restocker text, product_id integer, pick_qty integer, restock_qty integer, discrepancy integer)
    LANGUAGE plpgsql
    AS $$

/*
Purpose - compare pick to restock
Input - 
	start_date: first pick date to consider
	end_date: last pick date to consider. If not given, compute the result for only start_date
Output - 
	kiosk_id: id for kiosk
	route_date: delivery date
	kiosk_title: kiosk name
	product_id: what picked/allocated
	pick_qty: quantity above product_id picked
	restock_qty: quantity above product_id restocked between target_date and the following delivery date_time for the kiosk
	discrepancy: restock_qty - pick_quantity for target_date  
*/

declare target_date date;
declare pick_window_start timestamp with time zone;
declare pick_window_end timestamp with time zone;
begin
	set timezone to 'US/Pacific';
	return query
		select allocation.route_date, allocation.driver_name, restock.restocker, allocation.sku_id, cast(sum(allocation.total) as integer), 
			cast(sum(restock.total) as integer), cast(sum(allocation.total) - sum(restock.total) as integer)
			
			-- route_date, driver_name, sku_id, qty
			from (select a.route_date, route.driver_name, a.sku_id, sum(a.qty) total
				  from inm.pick_allocation a 
					left join inm.pick_route route
					on a.route_date = route.route_date and a.kiosk_id = route.kiosk_id
				  	group by 1,2,3) allocation
				
			left join 
				-- restock_date, restocker, sku, qty
				(select to_timestamp(l.time_created)::date restock_date, r.restocker, l.product_id, count(*) total
					from pantry.label l
				 	left join 
					-- restocker
					(select distinct to_timestamp(created)::date route_date, o.kiosk_id, first_name || ' ' || last_name restocker from pantry.order o
						where order_id like 'RE%' and to_timestamp(created)::date between start_date and end_date + 1 order by 1,2) r
				 	on to_timestamp(l.time_created)::date = r.route_date and l.kiosk_id = r.kiosk_id
				 
				 	group by 1,2,3) restock
					
					on restock.restock_date = allocation.route_date and restock.product_id = allocation.sku_id and restock.restocker = allocation.driver_name
			where allocation.route_date between start_date and end_date
		group by 1, 2, 3,4;
end;

$$;


ALTER FUNCTION beta.compare_pick_vs_delivery_by_sku(start_date date, end_date date) OWNER TO dbservice;

--
-- Name: compare_pick_vs_delivery_ignore_null(date, date); Type: FUNCTION; Schema: beta; Owner: dbservice
--

CREATE FUNCTION beta.compare_pick_vs_delivery_ignore_null(start_date date, end_date date DEFAULT NULL::date) RETURNS TABLE(kiosk_id integer, route_date date, restocker text, product_id integer, pick_qty integer, restock_qty integer, discrepancy integer)
    LANGUAGE plpgsql
    AS $$

/*
Purpose - compare pick to restock
Input - 
	start_date: first pick date to consider
	end_date: last pick date to consider. If not given, compute the result for only start_date
Output - 
	kiosk_id: id for kiosk
	route_date: delivery date
	kiosk_title: kiosk name
	product_id: what picked/allocated
	pick_qty: quantity above product_id picked
	restock_qty: quantity above product_id restocked between target_date and the following delivery date_time for the kiosk
	discrepancy: restock_qty - pick_quantity for target_date  
*/

declare target_date date;
declare pick_window_start timestamp with time zone;
declare pick_window_end timestamp with time zone;
begin
	set timezone to 'US/Pacific';
	return query
		select a.kiosk_id, a.route_date, r.restocker, a.sku_id, cast(sum(a.qty) as integer), 
			cast(sum(l.total) as integer), cast(sum(a.qty) - sum(l.total) as integer)
			from inm.pick_allocation a 
			left join 
				(select to_timestamp(time_created)::date restock_date, pantry.label.kiosk_id, pantry.label.product_id, count(*) total
					from pantry.label group by 1,2,3) l
					on a.route_date = l.restock_date and a.kiosk_id=l.kiosk_id and a.sku_id = l.product_id
			left join 
					-- restocker
					(select distinct to_timestamp(created)::date route_date, o.kiosk_id, first_name || ' ' || last_name restocker from pantry.order o
						where order_id like 'RE%' and to_timestamp(created)::date between start_date and end_date + 1 order by 1,2) r
					on r.route_date = a.route_date and r.kiosk_id = a.kiosk_id
			where a.route_date between start_date and end_date
		group by 1, 2, 3, 4;
end;

$$;


ALTER FUNCTION beta.compare_pick_vs_delivery_ignore_null(start_date date, end_date date) OWNER TO dbservice;

--
-- Name: compare_pick_vs_delivery_test(date, date); Type: FUNCTION; Schema: beta; Owner: dbservice
--

CREATE FUNCTION beta.compare_pick_vs_delivery_test(start_date date, end_date date DEFAULT NULL::date) RETURNS TABLE(kiosk_id integer, route_date date, kiosk_title character varying, driver_name character varying, restocker text, product_id integer, pick_qty bigint, restock_qty bigint, discrepancy bigint)
    LANGUAGE plpgsql
    AS $$

/*
Purpose - compare pick to restock
Input - 
	start_date: first pick date to consider
	end_date: last pick date to consider. If not given, compute the result for only start_date
Output - 
	kiosk_id: id for kiosk
	route_date: delivery date
	kiosk_title: kiosk name
	product_id: what picked/allocated
	pick_qty: quantity above product_id picked
	restock_qty: quantity above product_id restocked between target_date and the following delivery date_time for the kiosk
	discrepancy: restock_qty - pick_quantity for target_date  
*/

declare target_date date;
declare pick_window_start timestamp with time zone;
declare pick_window_end timestamp with time zone;
begin
	set timezone to 'US/Pacific';
	if end_date is null
		then end_date = start_date;
	end if;
	for target_date in select * from generate_series(start_date, end_date, interval '1 days') loop
		pick_window_start = cast(target_date as timestamp with time zone) + interval '13 hours';
		pick_window_end = pick_window_start + interval '22 hours';

		return query
			select
				a.kiosk_id, a.route_date, k.title, d.driver_name, r.restocker, a.sku_id, a.pick_qty, coalesce(rs.restock_qty, 0) restock_qty, coalesce(rs.restock_qty, 0) - a.pick_qty discrepancy
				from
					-- next 2 delivery schedules for each kiosks
					(select t1.kiosk_id, t1.route_date_time, t1.next_delivery_ts, t1.driver_name from inm.pick_get_plan_kiosk(pick_window_start, pick_window_end) t1) d
					join
					-- allocation
					(select t2.kiosk_id, t2.route_date, t2.sku_id, sum(t2.qty) pick_qty
						from inm.pick_allocation t2
						where pick_date = target_date
						group by 1,2,3) a
					on d.kiosk_id = a.kiosk_id and d.route_date_time::date = a.route_date

				left join
					-- restock
					(select t3.kiosk_id, to_timestamp(time_added)::date restock_date, t3.product_id, count(*) restock_qty
					  from pantry.label t3
					  where to_timestamp(time_added) between pick_window_start and pick_window_start + interval '2 days' -- optimize to a safe upper limit of 2 days
					  group by 1,2,3) rs
					on a.kiosk_id = rs.kiosk_id and a.route_date = rs.restock_date and a.sku_id = rs.product_id -- now match exactly restock_date to route_date
					
				left join 
					-- restocker
					(select distinct to_timestamp(created)::date route_date, o.kiosk_id, first_name || ' ' || last_name restocker from pantry.order o
						where order_id like 'RE%' and to_timestamp(created)::date between target_date and target_date + 1 order by 1,2) r
					on r.route_date = a.route_date and r.kiosk_id = a.kiosk_id

				join pantry.kiosk k on a.kiosk_id = k.id and k.campus_id = 87
				order by a.kiosk_id;
		end loop;
end;

$$;


ALTER FUNCTION beta.compare_pick_vs_delivery_test(start_date date, end_date date) OWNER TO dbservice;

--
-- Name: compare_pick_vs_delivery_v2(date, date); Type: FUNCTION; Schema: beta; Owner: dbservice
--

CREATE FUNCTION beta.compare_pick_vs_delivery_v2(start_date date, end_date date DEFAULT NULL::date) RETURNS TABLE(kiosk_id integer, route_date date, product_id integer, pick_qty integer, restock_qty integer, discrepancy integer)
    LANGUAGE plpgsql
    AS $$

/*
Purpose - compare pick to restock
Input - 
	start_date: first pick date to consider
	end_date: last pick date to consider. If not given, compute the result for only start_date
Output - 
	kiosk_id: id for kiosk
	route_date: delivery date
	kiosk_title: kiosk name
	product_id: what picked/allocated
	pick_qty: quantity above product_id picked
	restock_qty: quantity above product_id restocked between target_date and the following delivery date_time for the kiosk
	discrepancy: restock_qty - pick_quantity for target_date  
*/

declare target_date date;
declare pick_window_start timestamp with time zone;
declare pick_window_end timestamp with time zone;
begin
	set timezone to 'US/Pacific';
	return query
		select a.kiosk_id, a.route_date, a.sku_id, cast(sum(a.qty) as integer), cast(sum(l.total) as integer), cast(sum(a.qty) - sum(l.total) as integer)
			from inm.pick_allocation a 
			left join 
				(select to_timestamp(time_created)::date restock_date, pantry.label.kiosk_id, pantry.label.product_id, count(*) total
					from pantry.label group by 1,2,3) l
					on a.route_date = l.restock_date and a.kiosk_id=l.kiosk_id and a.sku_id = l.product_id
			where a.route_date between start_date and end_date
		group by 1, 2, 3;
end;

$$;


ALTER FUNCTION beta.compare_pick_vs_delivery_v2(start_date date, end_date date) OWNER TO dbservice;

--
-- Name: compare_pick_vs_delivery_v3(date, date); Type: FUNCTION; Schema: beta; Owner: dbservice
--

CREATE FUNCTION beta.compare_pick_vs_delivery_v3(start_date date, end_date date DEFAULT NULL::date) RETURNS TABLE(kiosk_id integer, route_date date, restocker text, product_id integer, pick_qty integer, restock_qty integer, discrepancy integer)
    LANGUAGE plpgsql
    AS $$

/*
Purpose - compare pick to restock
Input - 
	start_date: first pick date to consider
	end_date: last pick date to consider. If not given, compute the result for only start_date
Output - 
	kiosk_id: id for kiosk
	route_date: delivery date
	kiosk_title: kiosk name
	product_id: what picked/allocated
	pick_qty: quantity above product_id picked
	restock_qty: quantity of above product_id for the same route_date
	discrepancy: restock_qty - pick_quantity for target_date  
*/

declare target_date date;
declare pick_window_start timestamp with time zone;
declare pick_window_end timestamp with time zone;
begin
	set timezone to 'US/Pacific';
	return query
		select a.kiosk_id, a.route_date, r.restocker, a.sku_id, cast(sum(a.qty) as integer), 
			coalesce(cast(sum(l.total) as integer), 0), cast(coalesce(sum(l.total), 0) - sum(a.qty) as integer)
			from inm.pick_allocation a 
			left join 
				(select to_timestamp(time_created)::date restock_date, pantry.label.kiosk_id, pantry.label.product_id, count(*) total
					from pantry.label group by 1,2,3) l
					on a.route_date = l.restock_date and a.kiosk_id=l.kiosk_id and a.sku_id = l.product_id
			left join 
					-- restocker
					(select distinct to_timestamp(created)::date route_date, o.kiosk_id, first_name || ' ' || last_name restocker from pantry.order o
						where order_id like 'RE%' and to_timestamp(created)::date between start_date and end_date + 1 order by 1,2) r
					on r.route_date = a.route_date and r.kiosk_id = a.kiosk_id
			where a.route_date between start_date and end_date
		group by 1, 2, 3, 4;
end;

$$;


ALTER FUNCTION beta.compare_pick_vs_delivery_v3(start_date date, end_date date) OWNER TO dbservice;

--
-- Name: get_label_stats(date, date, integer[]); Type: FUNCTION; Schema: beta; Owner: dbservice
--

CREATE FUNCTION beta.get_label_stats(start_date date, end_date date, product_list integer[]) RETURNS TABLE(label_epc character varying, label_total bigint, label_order_total bigint, label_order_sold_total bigint, history_total bigint, history_unique_order_total bigint, history_unique_kid_total bigint, history_min_ts timestamp without time zone, history_max_ts timestamp without time zone, history_last_kid bigint, spoilage_total bigint, byte_spoilage_total bigint, label_spoilage_total bigint, label_ok_total bigint)
    LANGUAGE plpgsql
    AS $$

/*
Purpose: compute label stats
Input: 
	start_date, end_date of label created
	list of kiosks
Return
	stats
*/
begin
	return query
		select t0.epc, coalesce(t1.label_total, 0), coalesce(t2.label_order_total, 0), coalesce(t3.label_order_sold_total, 0), coalesce(t4.history_total, 0),
		coalesce(t5.history_unique_order_total, 0), coalesce(t6.history_unique_kid_total, 0),
		cast(t7.history_min_ts as timestamp), cast(t7.history_max_ts as timestamp), coalesce(t8.history_last_kid, 0), 
		coalesce(t9.spoilage_total, 0), coalesce(t10.byte_spoilage_total, 0), coalesce(t11.label_spoilage_total, 0), coalesce(t12.label_ok_total, 0)
	
		from
			(select distinct epc
				from pantry.label l
			 		join pantry.kiosk k on l.kiosk_id = k.id and k.campus_id = 87 and k.enable_reporting = 1
				where to_timestamp(time_added) between start_date and end_date
					and product_id in (select unnest(product_list))
			)t0
			
		left join 
			-- label table: number of records
			(
			select epc, count(*) label_total 
				from pantry.label
				where to_timestamp(time_added) between start_date and end_date
			 	group by epc
			)t1 on t0.epc = t1.epc
			
		left join 
			-- label table: number of records with order_id
			(
			select epc, count(*) label_order_total 
				from pantry.label
				where to_timestamp(time_added) between start_date and end_date
				and order_id is not null 
			 	group by epc
			)t2 on t0.epc = t2.epc
			
		left join 
			-- label table: number of records with order_id and status = sold
			(
			select epc, count(*) label_order_sold_total 
				from pantry.label
				where to_timestamp(time_added) between start_date and end_date
				and order_id is not null and status='sold'
			 	group by epc
			)t3 on t0.epc = t3.epc
			
		left join
			-- history table: number of records
			(select h.epc, count(*) history_total 
			 	from 
			 
					(select distinct epc
						from pantry.label
						where to_timestamp(time_added) between start_date and end_date
					) l
				join pantry.history h on l.epc = h.epc
				group by h.epc
			)t4  on t0.epc = t4.epc
			
		left join
			-- history table: number of unique order
			(select h.epc, count(distinct h.order_id) history_unique_order_total 
			 	from 
					(select distinct epc
						from pantry.label
						where to_timestamp(time_added) between start_date and end_date
					) l
				join pantry.history h on l.epc = h.epc and h.order_id is not null
				group by h.epc
			)t5 on t0.epc = t5.epc
			
		left join
			-- history table: number of unique kid 
			(select h.epc, count(distinct h.kiosk_id) history_unique_kid_total 
				from 
					(select distinct epc
						from pantry.label
						where to_timestamp(time_added) between start_date and end_date
					) l
				join pantry.history h on l.epc = h.epc and h.kiosk_id is not null
				group by h.epc
			)t6 on t0.epc = t6.epc
			
		left join
		-- history table: min and max record time
		(select h.epc, min(to_timestamp(time)) history_min_ts, max(to_timestamp(time)) history_max_ts
			from 
				(select distinct epc
					from pantry.label
					where to_timestamp(time_added) between start_date and end_date
				) l
			join pantry.history h on l.epc = h.epc
		 	group by h.epc
		)t7 on t0.epc = t7.epc
		
		left join
		-- history table: last kid
			(select h_disctinct_last_kid.epc, h_disctinct_last_kid.kiosk_id history_last_kid
				from 
					(select distinct epc
						from pantry.label
						where to_timestamp(time_added) between start_date and end_date
					) l
					join 
					(select distinct epc, kiosk_id
					 from
						(select epc, kiosk_id, to_timestamp(time) ts,
								rank() over (partition by epc order by time desc) r
						from pantry.history
						where to_timestamp(time) >= start_date and kiosk_id is not null
						) h_last_kid where r = 1) h_disctinct_last_kid
					on l.epc = h_disctinct_last_kid.epc
			)t8 on t0.epc = t8.epc
		
		left join
		-- Spoilage table indicator for each EPC: number of records
		(select s.epc, count(*) spoilage_total
			from
				(select distinct epc
					from pantry.label
					where to_timestamp(time_added) between start_date and end_date
				) l
				join pantry.spoilage s on l.epc = s.epc
				group by s.epc
		)t9 on t0.epc = t9.epc
		
		left join
		-- Byte spoilage table indicator for each EPC: number of records
		(select bs.epc, count(*) byte_spoilage_total
			from
				(select distinct epc
					from pantry.label
					where to_timestamp(time_added) between start_date and end_date
				) l 
			join public.byte_spoilage bs
				on l.epc = bs.epc
			group by bs.epc
		)t10 on t0.epc = t10.epc
		
		left join
		-- Spoilage table indicator for each EPC: number of spoils in label
		(select epc, count(*) label_spoilage_total
			from pantry.label
			where to_timestamp(time_added) between start_date and end_date
			and status = 'out' and order_id like 'RE%' group by 1
		)t11 on t0.epc = t11.epc

		left join
		-- label ok indicator for each EPC: number of records in label table where status is OK but no order_id
		(select epc, count(*) label_ok_total
			from pantry.label
			where to_timestamp(time_added) between start_date and end_date
			and status = 'ok' and order_id is null group by 1
		)t12 on t0.epc = t12.epc;
end;

$$;


ALTER FUNCTION beta.get_label_stats(start_date date, end_date date, product_list integer[]) OWNER TO dbservice;

--
-- Name: get_label_stats(date, date, integer[], integer[]); Type: FUNCTION; Schema: beta; Owner: dbservice
--

CREATE FUNCTION beta.get_label_stats(start_date date, end_date date, product_list integer[], kiosk_list integer[]) RETURNS TABLE(label_epc character varying, label_total bigint, label_order_total bigint, label_order_sold_total bigint, history_total bigint, history_unique_order_total bigint, history_unique_kid_total bigint, history_min_ts timestamp without time zone, history_max_ts timestamp without time zone, history_last_kid bigint, spoilage_total bigint, byte_spoilage_total bigint, label_spoilage_total bigint, label_ok_total bigint)
    LANGUAGE plpgsql
    AS $$

/*
Purpose: compute label stats
Input: 
	start_date, end_date of label created
	list of kiosks
Return
	stats
*/
begin
	return query
		select t0.epc, coalesce(t1.label_total, 0), coalesce(t2.label_order_total, 0), coalesce(t3.label_order_sold_total, 0), coalesce(t4.history_total, 0),
		coalesce(t5.history_unique_order_total, 0), coalesce(t6.history_unique_kid_total, 0),
		cast(t7.history_min_ts as timestamp), cast(t7.history_max_ts as timestamp), coalesce(t8.history_last_kid, 0), coalesce(t9.spoilage_total, 0),
		coalesce(t10.byte_spoilage_total, 0), coalesce(t11.label_spoilage_total, 0), coalesce(t12.label_ok_total, 0)
	
		from
			(select distinct epc
				from pantry.label l
			 	join pantry.kiosk k on l.kiosk_id = k.id and k.campus_id = 87 and k.enable_reporting = 1
				where to_timestamp(time_added) between start_date and end_date
					and product_id in (select unnest(product_list))
			  		and kiosk_id in (select unnest(kiosk_list))
			)t0
			
		left join 
			-- label table: number of records
			(
			select epc, count(*) label_total 
				from pantry.label
				where to_timestamp(time_added) between start_date and end_date
			 	group by epc
			)t1 on t0.epc = t1.epc
			
		left join 
			-- label table: number of records with order_id
			(
			select epc, count(*) label_order_total 
				from pantry.label
				where to_timestamp(time_added) between start_date and end_date
				and order_id is not null 
			 	group by epc
			)t2 on t0.epc = t2.epc
			
		left join 
			-- label table: number of records with order_id and status = sold
			(
			select epc, count(*) label_order_sold_total 
				from pantry.label
				where to_timestamp(time_added) between start_date and end_date
				and order_id is not null and status='sold'
			 	group by epc
			)t3 on t0.epc = t3.epc
			
		left join
			-- history table: number of records
			(select h.epc, count(*) history_total 
			 	from 
			 
					(select distinct epc
						from pantry.label
						where to_timestamp(time_added) between start_date and end_date
					) l
				join pantry.history h on l.epc = h.epc
				group by h.epc
			)t4  on t0.epc = t4.epc
			
		left join
			-- history table: number of unique order
			(select h.epc, count(distinct h.order_id) history_unique_order_total 
			 	from 
					(select distinct epc
						from pantry.label
						where to_timestamp(time_added) between start_date and end_date
					) l
				join pantry.history h on l.epc = h.epc and h.order_id is not null
				group by h.epc
			)t5 on t0.epc = t5.epc
			
		left join
			-- history table: number of unique kid 
			(select h.epc, count(distinct h.kiosk_id) history_unique_kid_total 
				from 
					(select distinct epc
						from pantry.label
						where to_timestamp(time_added) between start_date and end_date
					) l
				join pantry.history h on l.epc = h.epc and h.kiosk_id is not null
				group by h.epc
			)t6 on t0.epc = t6.epc
			
		left join
		-- history table: min, max record time
		(select h.epc, min(to_timestamp(time)) history_min_ts, max(to_timestamp(time)) history_max_ts
			from 
				(select distinct epc
					from pantry.label
					where to_timestamp(time_added) between start_date and end_date
				) l
			join pantry.history h on l.epc = h.epc
		 	group by h.epc
		)t7 on t0.epc = t7.epc
		
		left join
		-- history table: last kid
			(select h_disctinct_last_kid.epc, h_disctinct_last_kid.kiosk_id history_last_kid
				from 
					(select distinct epc
						from pantry.label
						where to_timestamp(time_added) between start_date and end_date
					) l
					join 
					(select distinct epc, kiosk_id
					 from
						(select epc, kiosk_id, to_timestamp(time) ts,
								rank() over (partition by epc order by time desc) r
						from pantry.history
						where to_timestamp(time) >= start_date and kiosk_id is not null
						) h_last_kid where r = 1) h_disctinct_last_kid
					on l.epc = h_disctinct_last_kid.epc
			)t8 on t0.epc = t8.epc
		
		left join
		-- Spoilage table indicator for each EPC: number of records
		(select s.epc, count(*) spoilage_total
			from
				(select distinct epc
					from pantry.label
					where to_timestamp(time_added) between start_date and end_date
				) l
				join pantry.spoilage s on l.epc = s.epc
				group by s.epc
		)t9 on t0.epc = t9.epc
		
		left join
		-- Byte spoilage table indicator for each EPC: number of records
		(select bs.epc, count(*) byte_spoilage_total
			from
				(select distinct epc
					from pantry.label
					where to_timestamp(time_added) between start_date and end_date
				) l 
			join public.byte_spoilage bs
				on l.epc = bs.epc
			group by bs.epc
		)t10 on t0.epc = t10.epc
		
		left join
		-- Spoilage table indicator for each EPC: number of spoils in label
		(select epc, count(*) label_spoilage_total
			from pantry.label
			where to_timestamp(time_added) between start_date and end_date
			and status = 'out' and order_id like 'RE%' group by 1
		)t11 on t0.epc = t11.epc
		
		left join
		-- label ok indicator for each EPC: number of records in label table where status is OK but no order_id
		(select epc, count(*) label_ok_total
			from pantry.label
			where to_timestamp(time_added) between start_date and end_date
			and status = 'ok' and order_id is null group by 1
		)t12 on t0.epc = t12.epc;
end;

$$;


ALTER FUNCTION beta.get_label_stats(start_date date, end_date date, product_list integer[], kiosk_list integer[]) OWNER TO dbservice;

--
-- Name: get_label_stats_v0(date, date, integer[]); Type: FUNCTION; Schema: beta; Owner: dbservice
--

CREATE FUNCTION beta.get_label_stats_v0(start_date date, end_date date, product_list integer[]) RETURNS TABLE(label_epc character varying, label_total bigint, label_order_total bigint, label_order_sold_total bigint, history_total bigint, history_unique_order_total bigint, history_unique_kid_total bigint, history_min_ts timestamp without time zone, history_max_ts timestamp without time zone, history_last_kid bigint, spoilage_total bigint)
    LANGUAGE plpgsql
    AS $$

/*
Purpose: compute label stats
Input: 
	start_date, end_date of label created
	list of kiosks
Return
	stats
*/
begin
	return query
		select t0.epc, coalesce(t1.label_total, 0), coalesce(t2.label_order_total, 0), coalesce(t3.label_order_sold_total, 0), coalesce(t4.history_total, 0),
		coalesce(t5.history_unique_order_total, 0), coalesce(t6.history_unique_kid_total, 0),
		cast(t7.history_min_ts as timestamp), cast(t7.history_max_ts as timestamp), coalesce(t8.history_last_kid, 0), coalesce(t9.spoilage_total, 0)
	
		from
			(select distinct epc
				from pantry.label l
			 		join pantry.kiosk k on l.kiosk_id = k.id and k.campus_id = 87
				where to_timestamp(time_added) between start_date and end_date
					and product_id in (select unnest(product_list))
			)t0
			
		left join 
			-- label table: number of records
			(
			select epc, count(*) label_total 
				from pantry.label
				where to_timestamp(time_added) between start_date and end_date
			 	group by epc
			)t1 on t0.epc = t1.epc
			
		left join 
			-- label table: number of records with order_id
			(
			select epc, count(*) label_order_total 
				from pantry.label
				where to_timestamp(time_added) between start_date and end_date
				and order_id is not null 
			 	group by epc
			)t2 on t0.epc = t2.epc
			
		left join 
			-- label table: number of records with order_id and status = sold
			(
			select epc, count(*) label_order_sold_total 
				from pantry.label
				where to_timestamp(time_added) between start_date and end_date
				and order_id is not null and status='sold'
			 	group by epc
			)t3 on t0.epc = t3.epc
			
		left join
			-- history table: number of records
			(select h.epc, count(*) history_total 
			 	from 
			 
					(select distinct epc
						from pantry.label
						where to_timestamp(time_added) between start_date and end_date
					) l
				join pantry.history h on l.epc = h.epc
				group by h.epc
			)t4  on t0.epc = t4.epc
			
		left join
			-- history table: number of unique order
			(select h.epc, count(distinct h.order_id) history_unique_order_total 
			 	from 
					(select distinct epc
						from pantry.label
						where to_timestamp(time_added) between start_date and end_date
					) l
				join pantry.history h on l.epc = h.epc and h.order_id is not null
				group by h.epc
			)t5 on t0.epc = t5.epc
			
		left join
			-- history table: number of unique kid 
			(select h.epc, count(distinct h.kiosk_id) history_unique_kid_total 
				from 
					(select distinct epc
						from pantry.label
						where to_timestamp(time_added) between start_date and end_date
					) l
				join pantry.history h on l.epc = h.epc and h.kiosk_id is not null
				group by h.epc
			)t6 on t0.epc = t6.epc
			
		left join
		-- history table: min and max record time
		(select h.epc, min(to_timestamp(time)) history_min_ts, max(to_timestamp(time)) history_max_ts
			from 
				(select distinct epc
					from pantry.label
					where to_timestamp(time_added) between start_date and end_date
				) l
			join pantry.history h on l.epc = h.epc
		 	group by h.epc
		)t7 on t0.epc = t7.epc
		
		left join
		-- history table: last kid
			(select h_disctinct_last_kid.epc, h_disctinct_last_kid.kiosk_id history_last_kid
				from 
					(select distinct epc
						from pantry.label
						where to_timestamp(time_added) between start_date and end_date
					) l
					join 
					(select distinct epc, kiosk_id
					 from
						(select epc, kiosk_id, to_timestamp(time) ts,
								rank() over (partition by epc order by time desc) r
						from pantry.history
						where kiosk_id is not null
						) h_last_kid) h_disctinct_last_kid
					on l.epc = h_disctinct_last_kid.epc
			)t8 on t0.epc = t8.epc
		
		left join
		-- Spoilage table indicator for each EPC: number of records
		(select s.epc, count(*) spoilage_total
			from
				(select distinct epc
					from pantry.label
					where to_timestamp(time_added) between start_date and end_date
				) l
				join pantry.spoilage s on l.epc = s.epc
				group by s.epc
		)t9 on t0.epc = t9.epc;
end;

$$;


ALTER FUNCTION beta.get_label_stats_v0(start_date date, end_date date, product_list integer[]) OWNER TO dbservice;

--
-- Name: pick_audit(date, date); Type: FUNCTION; Schema: beta; Owner: dbservice
--

CREATE FUNCTION beta.pick_audit(start_date date, end_date date DEFAULT NULL::date) RETURNS TABLE(kiosk_id integer, route_date date, restocker text, product_id integer, pick_qty integer, restock_qty integer, discrepancy integer)
    LANGUAGE plpgsql
    AS $$

/*
Purpose - compare pick to restock
Input - 
	start_date: first pick date to consider
	end_date: last pick date to consider. If not given, compute the result for only start_date
Output - 
	kiosk_id: id for kiosk
	route_date: delivery date
	kiosk_title: kiosk name
	product_id: what picked/allocated
	pick_qty: quantity above product_id picked
	restock_qty: quantity of above product_id for the same route_date
	discrepancy: restock_qty - pick_quantity for target_date  
*/

declare target_date date;
declare pick_window_start timestamp with time zone;
declare pick_window_end timestamp with time zone;
begin
	set timezone to 'US/Pacific';
	return query
		select a.kiosk_id, a.route_date, r.restocker, a.sku_id, cast(sum(a.qty) as integer), 
			coalesce(cast(sum(l.total) as integer), 0), cast(coalesce(sum(l.total), 0) - sum(a.qty) as integer)
			from inm.pick_allocation a 
			left join 
				(select to_timestamp(time_created)::date restock_date, pantry.label.kiosk_id, pantry.label.product_id, count(*) total
					from pantry.label group by 1,2,3) l
					on a.route_date = l.restock_date and a.kiosk_id=l.kiosk_id and a.sku_id = l.product_id
			left join 
					-- restocker
					(select distinct to_timestamp(created)::date route_date, o.kiosk_id, first_name || ' ' || last_name restocker from pantry.order o
						where order_id like 'RE%' and to_timestamp(created)::date between start_date and end_date + 1 order by 1,2) r
					on r.route_date = a.route_date and r.kiosk_id = a.kiosk_id
			where a.route_date between start_date and end_date
		group by 1, 2, 3, 4;
end;

$$;


ALTER FUNCTION beta.pick_audit(start_date date, end_date date) OWNER TO dbservice;

--
-- Name: pick_get_delivery_schedule_optimo(date); Type: FUNCTION; Schema: beta; Owner: dbservice
--

CREATE FUNCTION beta.pick_get_delivery_schedule_optimo(target_date date) RETURNS TABLE(driver_name character varying, route_date_time timestamp with time zone, kiosk_id integer, kiosk_title character varying, address character varying, delivery_order integer)
    LANGUAGE plpgsql
    AS $$

	declare latest_import_ts timestamp;
	declare plan_window_start timestamp;
	declare plan_window_stop timestamp;

/*
Purpose: return INM delivery schedule for a pick window.
Input
	target_date: pick_date
Return
	Data to generate the drivers sheets
*/
begin
	-- calculate various date params
	select max(import_ts) from mixalot.inm_data into latest_import_ts;
	select i.route_date from mixalot.inm_data i
		where import_ts = latest_import_ts and data_type = 'Plan Window Start'
		into plan_window_start;
	select i.route_date from mixalot.inm_data i
		where import_ts = latest_import_ts and data_type = 'Plan Window Stop'
		into plan_window_stop;
	
	return query
		select rs.driver_name, rs.route_date_time, location_number kiosk_id, k.title kiosk_title, k.address, rs.stop_number delivery_order
			from mixalot.route_stop rs join pantry.kiosk k on rs.location_number = k.id
			where rs.route_date_time between plan_window_start and plan_window_stop;
end;

$$;


ALTER FUNCTION beta.pick_get_delivery_schedule_optimo(target_date date) OWNER TO dbservice;

--
-- Name: pick_get_order_by_sales_4wk(timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: beta; Owner: dbservice
--

CREATE FUNCTION beta.pick_get_order_by_sales_4wk(start_ts timestamp with time zone, end_ts timestamp with time zone) RETURNS TABLE(kiosk_id integer, route_date_time timestamp with time zone, sku_group_id integer, fc_title character varying, plan_qty integer)
    LANGUAGE plpgsql ROWS 10000
    AS $$

/*
Purpose - return INM order for the next sale period which is the time between the deliveries of this pick and the next pick
Input -
  start_ts: plan window start date time with time zone
  end_ts: plan window end date time with time zone
Return -
  kiosk_id: together with route_date_time is unique for the plan window
  route_date_time: route starting date time
  fc_title: sku group name
  plan_qty: order quantity for the above fc_title for the next sale period
*/

-- FIX ME: 
-- handle missing past data
-- check kid with multiple deliveries
begin
	return query
		select four_weeks.kiosk_id, four_weeks.route_date_time, four_weeks.id, four_weeks.fc_title, cast (sum(qty) as integer)
		from
			(-- week -1
			select pk.kiosk_id, pk.route_date_time, sga.id, p.fc_title, count(*) qty
				from inm.pick_get_plan_kiosk(start_ts, end_ts) pk
					join pantry.label l on pk.kiosk_id=l.kiosk_id
					join pantry.product p on l.product_id = p.id
					left join inm.sku_group_attribute sga on sga.title = p.fc_title
					where l.status in ('out', 'sold') and to_timestamp(l.time_updated) between pk.route_date_time - interval '7 days' and pk.next_delivery_ts - interval '7 days'
					group by 1,2,3,4
			union
			-- week -2
			select pk.kiosk_id, pk.route_date_time, sga.id, p.fc_title, count(*) qty
				from inm.pick_get_plan_kiosk(start_ts, end_ts) pk
					join pantry.label l on pk.kiosk_id=l.kiosk_id
					join pantry.product p on l.product_id = p.id
					left join inm.sku_group_attribute sga on sga.title = p.fc_title
					where l.status in ('out', 'sold') and to_timestamp(l.time_updated) between pk.route_date_time - interval '14 days' and pk.next_delivery_ts - interval '14 days'
					group by 1,2,3,4
			union
			-- week -3
			select pk.kiosk_id, pk.route_date_time, sga.id, p.fc_title, count(*) qty
				from inm.pick_get_plan_kiosk(start_ts, end_ts) pk
					join pantry.label l on pk.kiosk_id=l.kiosk_id
					join pantry.product p on l.product_id = p.id
					left join inm.sku_group_attribute sga on sga.title = p.fc_title
					where l.status in ('out', 'sold') and to_timestamp(l.time_updated) between pk.route_date_time - interval '21 days' and pk.next_delivery_ts - interval '21 days'
					group by 1,2,3,4

			union
			-- week -4
			select pk.kiosk_id, pk.route_date_time, sga.id, p.fc_title, count(*) qty
				from inm.pick_get_plan_kiosk(start_ts, end_ts) pk
					join pantry.label l on pk.kiosk_id=l.kiosk_id
					join pantry.product p on l.product_id = p.id
					left join inm.sku_group_attribute sga on sga.title = p.fc_title
					where l.status in ('out', 'sold') and to_timestamp(l.time_updated) between pk.route_date_time - interval '28 days' and pk.next_delivery_ts - interval '28 days'
					group by 1,2,3,4
				) four_weeks
				
				group by 1, 2, 3, 4;
	end;

$$;


ALTER FUNCTION beta.pick_get_order_by_sales_4wk(start_ts timestamp with time zone, end_ts timestamp with time zone) OWNER TO dbservice;

--
-- Name: pick_get_order_by_sales_4wk_avg(timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: beta; Owner: dbservice
--

CREATE FUNCTION beta.pick_get_order_by_sales_4wk_avg(start_ts timestamp with time zone, end_ts timestamp with time zone) RETURNS TABLE(kiosk_id integer, route_date_time timestamp with time zone, sku_group_id integer, fc_title character varying, plan_qty integer)
    LANGUAGE plpgsql ROWS 10000
    AS $$

/*
Purpose - return INM order for the next sale period which is the time between the deliveries of this pick and the next pick
Input -
  start_ts: plan window start date time with time zone
  end_ts: plan window end date time with time zone
Return -
  kiosk_id: together with route_date_time is unique for the plan window
  route_date_time: route starting date time
  fc_title: sku group name
  plan_qty: order quantity for the above fc_title for the next sale period
*/

-- FIX ME: 
-- check kid with multiple deliveries
begin
	return query
		select q.kiosk_id, q.route_date_time, q.sku_group_id, q.fc_title, cast(ceiling(q.plan_qty/a.weeks_with_sales) as integer)
			from inm.pick_get_order_by_sales_4wks_availability(start_ts, end_ts) a
			join inm.pick_get_order_by_sales_4wk(start_ts, end_ts) q
			on a.kiosk_id = q.kiosk_id;
end;

$$;


ALTER FUNCTION beta.pick_get_order_by_sales_4wk_avg(start_ts timestamp with time zone, end_ts timestamp with time zone) OWNER TO dbservice;

--
-- Name: pick_get_order_by_sales_4wks_availability(timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: beta; Owner: dbservice
--

CREATE FUNCTION beta.pick_get_order_by_sales_4wks_availability(start_ts timestamp with time zone, end_ts timestamp with time zone) RETURNS TABLE(kiosk_id integer, weeks_with_sales smallint)
    LANGUAGE plpgsql ROWS 10000
    AS $$

/*
Purpose - return sales data availability for the last 4 weeks
Input -
  start_ts: plan window start date time with time zone
  end_ts: plan window end date time with time zone
Return -
  kiosk_id: together with route_date_time is unique for the plan window
  route_date_time: route starting date time
  week_count: 0-4 which indicates the number of weeks sales data is available
*/

begin
	return query
		select weeks_available.kiosk_id, cast(sum(available) as smallint)
		from
			(
			-- week -1
			select wk_minus_1.kiosk_id,
				case when count(*) >= 1 then 1 else 0 end as available from
				(select pk.kiosk_id, count(*)
					from inm.pick_get_plan_kiosk(start_ts, end_ts) pk
					join pantry.label l on pk.kiosk_id=l.kiosk_id
					where l.status in ('out', 'sold') and to_timestamp(l.time_updated) between pk.route_date_time - interval '7 days' and pk.next_delivery_ts - interval '7 days'
					group by 1) wk_minus_1
					group by 1
					
			union all 
			-- week -2
			select wk_minus_2.kiosk_id,
				case when count(*) >= 1 then 1 else 0 end as available from
				(select pk.kiosk_id, count(*)
					from inm.pick_get_plan_kiosk(start_ts, end_ts) pk
					join pantry.label l on pk.kiosk_id=l.kiosk_id
					where l.status in ('out', 'sold') and to_timestamp(l.time_updated) between pk.route_date_time - interval '14 days' and pk.next_delivery_ts - interval '14 days'
					group by 1) wk_minus_2
					group by 1
			
			union all
			-- week -3
			select wk_minus_3.kiosk_id,
				case when count(*) >= 1 then 1 else 0 end as available from
				(select pk.kiosk_id, count(*)
					from inm.pick_get_plan_kiosk(start_ts, end_ts) pk
					join pantry.label l on pk.kiosk_id=l.kiosk_id
					where l.status in ('out', 'sold') and to_timestamp(l.time_updated) between pk.route_date_time - interval '21 days' and pk.next_delivery_ts - interval '21 days'
					group by 1) wk_minus_3
					group by 1
				
			union all	
			-- week -4
			select wk_minus_4.kiosk_id,
				case when count(*) >= 1 then 1 else 0 end as available from
				(select pk.kiosk_id, count(*)
					from inm.pick_get_plan_kiosk(start_ts, end_ts) pk
					join pantry.label l on pk.kiosk_id=l.kiosk_id
					where l.status in ('out', 'sold') and to_timestamp(l.time_updated) between pk.route_date_time - interval '28 days' and pk.next_delivery_ts - interval '28 days'
					group by 1) wk_minus_4
					group by 1
			) weeks_available
			group by 1;
	end;

$$;


ALTER FUNCTION beta.pick_get_order_by_sales_4wks_availability(start_ts timestamp with time zone, end_ts timestamp with time zone) OWNER TO dbservice;

--
-- Name: sku_pick_order(timestamp with time zone); Type: FUNCTION; Schema: beta; Owner: dbservice
--

CREATE FUNCTION beta.sku_pick_order(target_ts timestamp with time zone) RETURNS TABLE(sku_id integer, pick_order integer)
    LANGUAGE plpgsql
    AS $$
declare latest_import_ts timestamp with time zone;

/*
Purpose: return a sku pick_order for the most recent import data for a given date
*/
begin
	select max(import_ts) from mixalot.inm_data
		where import_ts <= target_ts and data_type = 'Warehouse SKU Inventory'
		into latest_import_ts;
	
	return query
		select distinct product_id, d.sort_order
		  from mixalot.inm_data d
		  where import_ts = latest_import_ts and data_type = 'Warehouse SKU Inventory'
	  	and qty > 0;	
end;

$$;


ALTER FUNCTION beta.sku_pick_order(target_ts timestamp with time zone) OWNER TO dbservice;

--
-- Name: test_insert(integer, integer); Type: FUNCTION; Schema: beta; Owner: dbservice
--

CREATE FUNCTION beta.test_insert(n integer, m integer, OUT submitted_data integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$

/*
Purpose - Submit a pick with task_option controlling how to deal with conflict.

Input -
  target_date: pick date
  overwrite: 0 or 1. If 1, overwrite old pick.
  timeout_seconds: minimum amount of time the task can be in status = "started" before it's considered timed out 
Return -
  submitted_status:
  	submitted - pick submitted.
	started - a pick already in progress for target date.
	ready - a completed pick already existed (and overwrite=0)
*/

begin
	insert into beta.test(n) values (n+m);
	submitted_data = n+m;
end;

$$;


ALTER FUNCTION beta.test_insert(n integer, m integer, OUT submitted_data integer) OWNER TO dbservice;

--
-- Name: fn_kiosk_audit_log_insert(); Type: FUNCTION; Schema: fnrenames; Owner: dbservice
--

CREATE FUNCTION fnrenames.fn_kiosk_audit_log_insert() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
INSERT INTO pantry.kiosk_audit_log (
    kiosk_id, archived, enable_reporting, enable_monitoring
) VALUES (
    NEW.id, NEW.archived, NEW.enable_reporting, NEW.enable_monitoring
);
RETURN NEW;
END;
$$;


ALTER FUNCTION fnrenames.fn_kiosk_audit_log_insert() OWNER TO dbservice;

--
-- Name: fn_kiosk_audit_log_update(); Type: FUNCTION; Schema: fnrenames; Owner: dbservice
--

CREATE FUNCTION fnrenames.fn_kiosk_audit_log_update() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
IF (
 NEW.archived != OLD.archived
 OR
 NEW.enable_reporting != OLD.enable_reporting
 OR
 NEW.enable_monitoring != OLD.enable_monitoring
) THEN
 INSERT INTO pantry.kiosk_audit_log (
    kiosk_id, archived, enable_reporting, enable_monitoring
 ) VALUES (
    OLD.id, NEW.archived, NEW.enable_reporting, NEW.enable_monitoring
);
END IF;
RETURN NEW;
END;
$$;


ALTER FUNCTION fnrenames.fn_kiosk_audit_log_update() OWNER TO dbservice;

--
-- Name: fn_ro_order_update_full_price(character varying); Type: FUNCTION; Schema: fnrenames; Owner: dbservice
--

CREATE FUNCTION fnrenames.fn_ro_order_update_full_price(orderid character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
    orderid varchar(135);
BEGIN
UPDATE pantry.ro_order
SET
    real_full_price = rt.rfp, full_price = ft.fp, created = rt.tc
FROM (
    SELECT
        CASE WHEN (o.state <> 'NonTrans')
            THEN
                COALESCE(SUM(l.price), 0)
            ELSE
                0
            END AS rfp,
            o.order_id,
            date_part('epoch', CURRENT_TIMESTAMP)::int as tc
    FROM pantry.label l
    JOIN pantry.order o ON o.order_id = l.order_id
    WHERE l.order_id = orderid
    GROUP BY o.order_id
) rt JOIN (
    SELECT
        CASE WHEN (o.state <> 'NonTrans')
            THEN
                COALESCE(SUM(l.price), 0)
            ELSE
                0
            END AS fp,
        o.order_id
    FROM pantry.label l
    JOIN pantry.order o ON o.order_id = l.order_id
    JOIN pantry.kiosk k ON k.id = o.kiosk_id
    JOIN pantry.product p ON p.id = l.product_id
    JOIN pantry.group_campus gc1 ON gc1.campus_id = k.campus_id AND gc1.owner = 1
    JOIN pantry.group_campus gc2 ON gc2.campus_id = p.campus_id AND gc2.owner = 1
    WHERE l.order_id = orderid
    AND gc1.group_id = gc2.group_id
    GROUP BY o.order_id
) ft ON rt.order_id = ft.order_id
WHERE ro_order.order_id = orderid;
END
$$;


ALTER FUNCTION fnrenames.fn_ro_order_update_full_price(orderid character varying) OWNER TO dbservice;

--
-- Name: pg_create_logical_replication_slot(name, name, boolean); Type: FUNCTION; Schema: fnrenames; Owner: dbservice
--

CREATE FUNCTION fnrenames.pg_create_logical_replication_slot(slot_name name, plugin name, temporary boolean DEFAULT false, OUT slot_name name, OUT xlog_position pg_lsn) RETURNS record
    LANGUAGE sql
    AS $$
   SELECT slot_name::NAME, lsn::pg_lsn FROM pg_catalog.pg_create_logical_replication_slot(slot_name, plugin,
   temporary); $$;


ALTER FUNCTION fnrenames.pg_create_logical_replication_slot(slot_name name, plugin name, temporary boolean, OUT slot_name name, OUT xlog_position pg_lsn) OWNER TO dbservice;

--
-- Name: pg_current_xlog_flush_location(); Type: FUNCTION; Schema: fnrenames; Owner: dbservice
--

CREATE FUNCTION fnrenames.pg_current_xlog_flush_location() RETURNS pg_lsn
    LANGUAGE sql
    AS $$
   SELECT pg_current_wal_flush_lsn(); $$;


ALTER FUNCTION fnrenames.pg_current_xlog_flush_location() OWNER TO dbservice;

--
-- Name: pg_current_xlog_insert_location(); Type: FUNCTION; Schema: fnrenames; Owner: dbservice
--

CREATE FUNCTION fnrenames.pg_current_xlog_insert_location() RETURNS pg_lsn
    LANGUAGE sql
    AS $$
   SELECT pg_current_wal_insert_lsn(); $$;


ALTER FUNCTION fnrenames.pg_current_xlog_insert_location() OWNER TO dbservice;

--
-- Name: pg_current_xlog_location(); Type: FUNCTION; Schema: fnrenames; Owner: dbservice
--

CREATE FUNCTION fnrenames.pg_current_xlog_location() RETURNS pg_lsn
    LANGUAGE sql
    AS $$
   SELECT pg_current_wal_lsn(); $$;


ALTER FUNCTION fnrenames.pg_current_xlog_location() OWNER TO dbservice;

--
-- Name: pg_is_xlog_replay_paused(); Type: FUNCTION; Schema: fnrenames; Owner: dbservice
--

CREATE FUNCTION fnrenames.pg_is_xlog_replay_paused() RETURNS boolean
    LANGUAGE sql
    AS $$
   SELECT pg_is_wal_replay_paused(); $$;


ALTER FUNCTION fnrenames.pg_is_xlog_replay_paused() OWNER TO dbservice;

--
-- Name: pg_last_xlog_receive_location(); Type: FUNCTION; Schema: fnrenames; Owner: dbservice
--

CREATE FUNCTION fnrenames.pg_last_xlog_receive_location() RETURNS pg_lsn
    LANGUAGE sql
    AS $$
   SELECT pg_last_wal_receive_lsn(); $$;


ALTER FUNCTION fnrenames.pg_last_xlog_receive_location() OWNER TO dbservice;

--
-- Name: pg_last_xlog_replay_location(); Type: FUNCTION; Schema: fnrenames; Owner: dbservice
--

CREATE FUNCTION fnrenames.pg_last_xlog_replay_location() RETURNS pg_lsn
    LANGUAGE sql
    AS $$
   SELECT pg_last_wal_replay_lsn(); $$;


ALTER FUNCTION fnrenames.pg_last_xlog_replay_location() OWNER TO dbservice;

--
-- Name: pg_switch_xlog(); Type: FUNCTION; Schema: fnrenames; Owner: dbservice
--

CREATE FUNCTION fnrenames.pg_switch_xlog() RETURNS pg_lsn
    LANGUAGE sql
    AS $$
   SELECT pg_switch_wal(); $$;


ALTER FUNCTION fnrenames.pg_switch_xlog() OWNER TO dbservice;

--
-- Name: pg_xlog_location_diff(pg_lsn, pg_lsn); Type: FUNCTION; Schema: fnrenames; Owner: dbservice
--

CREATE FUNCTION fnrenames.pg_xlog_location_diff(lsn1 pg_lsn, lsn2 pg_lsn) RETURNS numeric
    LANGUAGE sql
    AS $$
   SELECT pg_wal_lsn_diff(lsn1, lsn2); $$;


ALTER FUNCTION fnrenames.pg_xlog_location_diff(lsn1 pg_lsn, lsn2 pg_lsn) OWNER TO dbservice;

--
-- Name: pg_xlog_replay_pause(); Type: FUNCTION; Schema: fnrenames; Owner: dbservice
--

CREATE FUNCTION fnrenames.pg_xlog_replay_pause() RETURNS void
    LANGUAGE sql
    AS $$
   SELECT pg_wal_replay_pause(); $$;


ALTER FUNCTION fnrenames.pg_xlog_replay_pause() OWNER TO dbservice;

--
-- Name: pg_xlog_replay_resume(); Type: FUNCTION; Schema: fnrenames; Owner: dbservice
--

CREATE FUNCTION fnrenames.pg_xlog_replay_resume() RETURNS void
    LANGUAGE sql
    AS $$
   SELECT pg_wal_replay_resume(); $$;


ALTER FUNCTION fnrenames.pg_xlog_replay_resume() OWNER TO dbservice;

--
-- Name: pg_xlogfile_name(pg_lsn); Type: FUNCTION; Schema: fnrenames; Owner: dbservice
--

CREATE FUNCTION fnrenames.pg_xlogfile_name(lsn pg_lsn) RETURNS text
    LANGUAGE sql
    AS $$
   SELECT pg_walfile_name(lsn); $$;


ALTER FUNCTION fnrenames.pg_xlogfile_name(lsn pg_lsn) OWNER TO dbservice;

--
-- Name: pg_xlogfile_name_offset(pg_lsn); Type: FUNCTION; Schema: fnrenames; Owner: dbservice
--

CREATE FUNCTION fnrenames.pg_xlogfile_name_offset(lsn pg_lsn, OUT text, OUT integer) RETURNS record
    LANGUAGE sql
    AS $$
   SELECT pg_walfile_name_offset(lsn); $$;


ALTER FUNCTION fnrenames.pg_xlogfile_name_offset(lsn pg_lsn, OUT text, OUT integer) OWNER TO dbservice;

--
-- Name: pick_get_order_with_velocity(timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: fnrenames; Owner: dbservice
--

CREATE FUNCTION fnrenames.pick_get_order_with_velocity(start_ts timestamp with time zone, end_ts timestamp with time zone) RETURNS TABLE(kiosk_id integer, route_date_time timestamp with time zone, sku_group_id integer, fc_title text, week_demand_qty numeric, plan_demand_qty numeric, plan_order_qty numeric)
    LANGUAGE plpgsql
    AS $$
  /*
  Purpose - return INM order based on sales ratio for pick sales period (time between deliveries)
  Input -
    start_ts: plan window start date time with time zone
    end_ts: plan window end date time with time zone
  Return -
    kiosk_id: together with route_date_time is unique for the plan window
    route_date_time: route starting date time
    fc_title: sku group name
    week_demand_qty: demand based on once a week delivery (without minimum)
    plan_demand_qty: demand based on sales ratio for pick sales period (without minimum)
    plan_order_qty: order based on sales ratio for pick sales period
  */

begin
	return query
		--  Given
		--		sales period = time between this pick delivery and next pick delivery (may be changed to pick times in the future)
		--		inm.demand_weekly = week demand
		--		sr.sales_ratio = sale ratio for this sum items sold for pick sales period for the last 4 weeks vs items sold for the last 4 weeks 
		-- 	if item is restricted (inm_qty=0), then set demand to 0. 
		--  else 
		--		if item doesn't exist in the kiosk (inv.count is null), set its inv count to 0
		-- 		order_before_min_max = 2.0 * sr.sales_ratio * inm.demand_weekly - inv.count
		-- 		final_order = min + order_before_min_max, capped by max as defined for each sku group
	  -- 20190213, changed 1.4 to 2.0 to increase levels in the kiosks
		
		select sr.kiosk_id, sr.route_date_time, sga.id, dwbv.fc_title, dwbv.demand_weekly as week_demand_qty, 
			cast(2.0 * sr.sales_ratio * dwbv.demand_weekly as numeric (8,2)) plan_demand_qty,
			case 
				-- restricted item if demand_weekly is 0 or kiosk_sku_group manual scale is zero
				when dwbv.demand_weekly = 0 or ksms.scale = 0.0 then 0 
				else
					ceiling(
						-- change minimum is 0 (don't remove from a kiosk)
						least(greatest(least(2.0 * sr.sales_ratio * dwbv.demand_weekly, dwbv.demand_weekly) + sga.minimum_kiosk_qty - coalesce(inv.count, 0),
											  0) /* change negative demand to 0 */
								   , sga.maximum_kiosk_qty))
			end as plan_order_qty -- end case
					   
			from inm.pick_get_sales_period_ratio(start_ts, end_ts) sr
			
				join inm.pick_get_demand_weekly_by_velocity() dwbv
					on sr.kiosk_id = dwbv.kiosk_id 
												
				join inm.sku_group_attribute sga
					on sga.title = dwbv.fc_title			
				left join inm.kiosk_projected_stock inv
					on dwbv.kiosk_id = inv.kiosk_id and dwbv.fc_title = inv.fc_title
				left join inm.kiosk_sku_group_manual_scale ksms
					on sr.kiosk_id = ksms.kiosk_id and sga.id = ksms.sku_group_id;				
	end;

$$;


ALTER FUNCTION fnrenames.pick_get_order_with_velocity(start_ts timestamp with time zone, end_ts timestamp with time zone) OWNER TO dbservice;

--
-- Name: allocation_ratio_by_sku_group(date); Type: FUNCTION; Schema: inm; Owner: dbservice
--

CREATE FUNCTION inm.allocation_ratio_by_sku_group(target_date date) RETURNS TABLE(sku_group character varying, warehouse_qty bigint, order_total bigint, allocation_total bigint, allocation_percentage integer)
    LANGUAGE plpgsql
    AS $$

begin
	return query
		select a.fc_title, inv.total , o.order_total, a.allocation_total,  cast(100*a.allocation_total/cast(o.order_total as decimal) as integer) allocation_percentage
			from
				(select pick_date, sku_group_id, sum(qty) order_total
				from inm.pick_demand
				group by 1,2) o
			left join
				(select pick_date, sgs.fc_title, sgs.sku_group_id, sum(qty) allocation_total
				from inm.pick_allocation a
				join inm.view_sku_sku_group sgs
				on a.sku_id = sgs.product_id
				group by 1,2,3)a
				on a.pick_date = o.pick_date and o.sku_group_id = a.sku_group_id
				
			left join
				(select sgs.fc_title, sum(qty) total 
				 	from mixalot.inm_data i
				 		join inm.view_sku_sku_group sgs
							on i.product_id = sgs.product_id
					where import_ts = (select max(import_ts) from mixalot.inm_data 
									   where import_ts::date = target_date) and data_type = 'Warehouse SKU Inventory'
				 	group by 1				 
					) inv
					
				on a.fc_title = inv.fc_title
			where a.pick_date = target_date;
end

$$;


ALTER FUNCTION inm.allocation_ratio_by_sku_group(target_date date) OWNER TO dbservice;

--
-- Name: allocation_ratio_by_sku_group_test(date); Type: FUNCTION; Schema: inm; Owner: dbservice
--

CREATE FUNCTION inm.allocation_ratio_by_sku_group_test(target_date date) RETURNS TABLE(sku_group character varying, order_total bigint, allocation_total bigint, allocation_percentage integer)
    LANGUAGE plpgsql
    AS $$

begin
	return query
		select a.fc_title, o.order_total, a.allocation_total,  cast(100*a.allocation_total/cast(o.order_total as decimal) as integer) allocation_percentage
			from
				(select pick_date, sku_group_id, sum(qty) order_total
				from inm.pick_demand
				group by 1,2) o
			left join
				(select pick_date, sgs.fc_title, sgs.sku_group_id, sum(qty) allocation_total
				from inm.pick_allocation a
				join inm.view_sku_sku_group sgs
				on a.sku_id = sgs.product_id
				group by 1,2,3)a
				on a.pick_date = o.pick_date and o.sku_group_id = a.sku_group_id;
				
end

$$;


ALTER FUNCTION inm.allocation_ratio_by_sku_group_test(target_date date) OWNER TO dbservice;

--
-- Name: f_kiosk_sku_group_sku_pick_stats(timestamp with time zone); Type: FUNCTION; Schema: inm; Owner: dbservice
--

CREATE FUNCTION inm.f_kiosk_sku_group_sku_pick_stats(pick_time timestamp with time zone) RETURNS TABLE(kiosk_id integer, sku_group character varying, sku_group_id integer, sku integer, kiosk_on_route integer, kiosk_sku_enabled integer, kiosk_priority integer, sku_priority integer, sku_group_demand_week integer, kiosk_demand_plan_ratio numeric, sku_group_inventory_qty integer, sku_inventory_actual_qty integer, sku_group_inventory_actual_qty integer, sku_group_min_qty integer, sku_group_order_qty integer, sku_group_allocation_total integer, sku_allocation_qty integer, fleet_sku_group_order_total integer, fleet_sku_group_allocation_total integer, fleet_sku_allocation_total integer, warehouse_sku_inventory_stickered integer, warehouse_sku_inventory_unstickered integer, warehouse_sku_group_inventory_stickered integer, warehouse_sku_group_inventory_unstickered integer, substituted character varying, substituted_qty character varying, substituting character varying, substituting_qty character varying, sku_rejection integer, sku_preference_velocity numeric, sku_preference_normalized integer)
    LANGUAGE plpgsql
    AS $$

begin
  return query
    -- TODO: improve inventory actual computation
    select k.kiosk_id::int kiosk_id,
           p.sku_group sku_group,
           sg.sku_group_id sku_group_id,
           p.sku::int sku,
           coalesce(pr.on_route, 0) kiosk_on_route,
           coalesce(kpd.enabled, 1) kiosk_sku_enabled,
           coalesce(ppk.priority, 100) kiosk_priority,
           coalesce(pps.priority, 100) sku_priority,
           coalesce(pgo.demand_week, 0) sku_group_demand_week,
           coalesce(kdpr.kiosk_demand_plan_ratio, 0) kiosk_demand_plan_ratio,
           coalesce(pi.inventory_qty, 0) sku_group_inventory_qty,
           coalesce(l.stock_count, 0)::int sku_inventory_actual_qty,
           coalesce(sum(l.stock_count) over (partition by sg.sku_group, k.kiosk_id), 0)::int sku_group_inventory_actual_qty,
           coalesce(sga.sku_group_min_qty, 0) sku_group_min_qty,
           coalesce(pd.order_qty, 0) sku_group_order_qty,
           coalesce(sum(pa.allocation_qty) over (partition by sg.sku_group, k.kiosk_id), 0)::int sku_group_allocation_total,
           coalesce(pa.allocation_qty, 0) sku_allocation_qty,
           coalesce((sum(pd.order_qty) over (partition by sg.sku_group))/(count(p.sku) over (partition by sg.sku_group, k.kiosk_id)), 0)::int fleet_sku_group_order_total,
           coalesce(sum(pa.allocation_qty) over (partition by sg.sku_group), 0)::int fleet_sku_group_allocation_total,
           coalesce(sum(pa.allocation_qty) over (partition by p.sku), 0)::int fleet_sku_allocation_total,
           coalesce(wi.inventory_stickered, 0) warehouse_sku_inventory_stickered,
           coalesce(wi.inventory_unstickered, 0) warehouse_sku_inventory_unstickered,
           coalesce(sum(wi.inventory_stickered) over (partition by sg.sku_group, k.kiosk_id), 0)::int warehouse_sku_group_inventory_stickered,
           coalesce(sum(wi.inventory_unstickered) over (partition by sg.sku_group, k.kiosk_id), 0)::int warehouse_sku_group_inventory_unstickered,
           ps.substituted::varchar substituted,
           ps.substituted_qty::varchar substituted_qty,
           ps2.substituting::varchar substituting,
           ps2.substituting_qty::varchar substituting_qty,
           coalesce(pre.rejection, 0)::int sku_rejection,
           ksv.preference sku_preference_velocity,
           ppks.preference::int sku_preference_normalized
    from (
           select k.id as kiosk_id
           from pantry.kiosk k
           where k.campus_id=87
             and k.archived=0
             and k.enable_reporting=1
         ) k

           cross join (
      select p.fc_title sku_group,
             p.id sku
      from pantry.product p
      where p.campus_id=87
        and p.archived=0
        and p.fc_title is not null
        and p.fc_title!='N/A'
    ) p

           left join (
      select sg.fc_title sku_group,
             sg.id sku_group_id
      from inm.sku_group sg
    ) sg on p.sku_group=sg.sku_group

           left join (
      select pr.kiosk_id kiosk_id,
             1 on_route
      from inm.pick_route pr
      where pr.pick_date=pick_time::date
    ) pr on k.kiosk_id=pr.kiosk_id

           left join (
      -- warehouse inventory
      select wi.product_id sku,
             wi.units_per_case*wi.stickered_cases+wi.stickered_units inventory_stickered,
             wi.units_per_case*wi.unstickered_cases+wi.unstickered_units inventory_unstickered
      from inm.warehouse_inventory wi
      where wi.inventory_date=pick_time::date
    ) wi on p.sku=wi.sku

           left join (
      --  demand_week
      select pgo.kiosk_id kiosk_id,
             pgo.fc_title sku_group,
             pgo.week_qty demand_week
      from inm.pick_get_order(pick_time::date+interval '21 hours', pick_time::date+interval '43 hours') pgo
    ) pgo on k.kiosk_id=pgo.kiosk_id and p.sku_group=pgo.sku_group

           left join (
      -- kiosk inventory
      select pi.kiosk_id kiosk_id,
             pi.sku_group_id sku_group_id,
             pi.qty inventory_qty
      from inm.pick_inventory pi
      where pi.pick_date=pick_time::date
    ) pi on k.kiosk_id=pi.kiosk_id and sg.sku_group_id=pi.sku_group_id

           left join (
      -- order
      select pd.kiosk_id kiosk_id,
             pd.sku_group_id sku_group_id,
             pd.qty order_qty
      from inm.pick_demand pd
      where pd.pick_date=pick_time::date
    ) pd on k.kiosk_id=pd.kiosk_id and sg.sku_group_id=pd.sku_group_id

           left join (
      -- allocation
      select pa.kiosk_id kiosk_id,
             pa.sku_id sku,
             pa.qty allocation_qty
      from inm.pick_allocation pa
      where pa.pick_date=pick_time::date
    ) pa on k.kiosk_id=pa.kiosk_id and p.sku=pa.sku

           left join (
      select ppk.kiosk_id kiosk_id,
             ppk.priority priority
      from inm.pick_priority_kiosk ppk
    ) ppk on k.kiosk_id=ppk.kiosk_id

           left join (
      select pps.sku_id sku,
             pps.priority priority
      from inm.pick_priority_sku pps
    ) pps on p.sku=pps.sku

           left join (
      select kpd.kiosk_id kiosk_id,
             kpd.product_id sku,
             case when kpd.product_id is not null then 0
                  else 1
               end as enabled
      from inm.kiosk_product_disabled kpd
    ) kpd on k.kiosk_id=kpd.kiosk_id and p.sku=kpd.sku

           left join (
      select l.kiosk_id as kiosk_id,
             p.fc_title as sku_group,
             l.product_id as sku,
             count(*) as stock_count
      from pantry.label l
             left join pantry.product p
                       on l.product_id=p.id
      where to_timestamp(time_added) < pick_time
        and to_timestamp(time_updated) > pick_time
        and p.campus_id=87
        and p.archived=0
        and p.fc_title is not null
        and p.fc_title!='N/A'
      group by l.kiosk_id,
               p.fc_title,
               l.product_id
    ) l on k.kiosk_id=l.kiosk_id and p.sku=l.sku

           left join (
      select ps.substituting_sku_group_id sku_group_id,
             string_agg(ps.substituted_sku_group_id::text, ',' order by ps.substituted_sku_group_id asc) substituted,
             string_agg(ps.qty::text, ',' order by ps.substituted_sku_group_id) substituted_qty
      from inm.pick_substitution ps
      where ps.pick_date=pick_time::date
      group by ps.substituting_sku_group_id
    ) ps on sg.sku_group_id=ps.sku_group_id

           left join (
      select ps.substituted_sku_group_id sku_group_id,
             string_agg(ps.substituting_sku_group_id::text, ',' order by ps.substituting_sku_group_id asc) substituting,
             string_agg(ps.qty::text, ',' order by ps.substituting_sku_group_id) substituting_qty
      from inm.pick_substitution ps
      where ps.pick_date=pick_time::date
      group by ps.substituted_sku_group_id
    ) ps2 on sg.sku_group_id=ps2.sku_group_id

           left join (
      select pre.kiosk_id kiosk_id,
             pre.item_id  sku,
             count(pre.reason) as rejection
      from inm.pick_rejection pre
      where pre.pick_date=pick_time::date
        and item_type = 'sku_id'
      group by pre.kiosk_id,
               pre.item_id
    ) pre on k.kiosk_id=pre.kiosk_id and p.sku=pre.sku

           left join (
      select ksv.kiosk_id kiosk_id,
             ksv.sku sku,
             ksv.preference preference
      from inm.v_kiosk_sku_velocity ksv
    ) ksv on k.kiosk_id=ksv.kiosk_id and p.sku=ksv.sku

           left join (
      select ppks.kiosk_id kiosk_id,
             ppks.sku_id sku,
             ppks.preference preference
      from mixalot.pick_preference_kiosk_sku ppks
    ) ppks on k.kiosk_id=ppks.kiosk_id and p.sku=ppks.sku

           left join (
      select sga.id as sku_group_id,
             sga.minimum_kiosk_qty as sku_group_min_qty
      from inm.sku_group_attribute sga
    ) sga on sg.sku_group_id=sga.sku_group_id

           left join (
      select kdpr.kiosk_id kiosk_id,
             case when extract(dow from pick_time)=0 then d0_plan_demand_ratio
                  when extract(dow from pick_time)=1 then d1_plan_demand_ratio
                  when extract(dow from pick_time)=2 then d2_plan_demand_ratio
                  when extract(dow from pick_time)=3 then d3_plan_demand_ratio
                  when extract(dow from pick_time)=4 then d4_plan_demand_ratio
                  else 0
               end kiosk_demand_plan_ratio
      from inm.v_kiosk_demand_plan_ratio kdpr
    ) kdpr on k.kiosk_id=kdpr.kiosk_id

    order by k.kiosk_id asc,
             p.sku_group asc,
             p.sku asc;

end;

$$;


ALTER FUNCTION inm.f_kiosk_sku_group_sku_pick_stats(pick_time timestamp with time zone) OWNER TO dbservice;

--
-- Name: get_all_pull_list(integer); Type: FUNCTION; Schema: inm; Owner: dbservice
--

CREATE FUNCTION inm.get_all_pull_list(given_kiosk_id integer) RETURNS TABLE(category character varying, kiosk_id_ bigint, kiosk_title_ character varying, product_id_ bigint, product_tile_ character varying, epc character varying)
    LANGUAGE plpgsql
    AS $$
    BEGIN
        RETURN QUERY
        --- This function runs all pull_list functions.
        --- SEE ENG-555
        SELECT *
    FROM inm.get_spoilage_pull_list(given_kiosk_id)
 UNION ALL
 SELECT *
    FROM inm.get_performance_pull_list(given_kiosk_id);
        END;
$$;


ALTER FUNCTION inm.get_all_pull_list(given_kiosk_id integer) OWNER TO dbservice;

--
-- Name: get_performance_pull_list(integer); Type: FUNCTION; Schema: inm; Owner: dbservice
--

CREATE FUNCTION inm.get_performance_pull_list(given_kiosk_id integer) RETURNS TABLE(category character varying, kiosk_id_ integer, kiosk_title_ character varying, product_id_ integer, product_tile_ character varying, epc character varying)
    LANGUAGE plpgsql
    AS $$
    BEGIN
        RETURN QUERY
        /* This query is used to identify skus that do not sell well in a given kiosk. A poor
        performing sku meets the following criteria
          1. Qualifier - SKU has been present in the kiosk for 4 weeks (28 days)(not consecutive).
          2. Spoilage >= 30% of sales over 3 of the past 6 weeks.
          3. No sales in past 2 weeks when the item was available (there has to be a least one
          SKU present in the kiosk every single day of those 2 weeks) OR  less than 50% of sku fleet
           average (by month).
         SEE ENG-555
        This query takes less than a minute to run for 1 kiosk and 7 minutes to run for all kiosks
        */
        SELECT 'LOW PERFORMANCE'::varchar as category,
            SKU_performance_qualifiers.kid as kiosk_id_,
            SKU_performance_qualifiers.k_title as kiosk_title_,
            SKU_performance_qualifiers.pid as product_id_,
            SKU_performance_qualifiers.p_title as product_tile_,
            (SKU_performance_qualifiers.epc)::varchar as epc
            /* The following subquery selects all kiosk/sku combination that qualify to be analyzed
            for poor performance. A kiosk/sku combination qualifies to be analyzed for poor
            performance if a given sku has been present in a given kiosk for 28 days (4 weeks) non
            consecutively.
            */
            FROM (SELECT *
                --- How many days a given kiosk has seen a given sku
                FROM (SELECT kiosk_id as kid,
                product_id as pid,
                k_title,
                p_title,
                sum(status) as number_of_days_in_kiosk
                    /* List of all date/kiosk/sku combination and whether the given sku has been
                    seen by the given kiosk on a given day*/
                    FROM (SELECT kiosk_id,
                        product_id,
                        date::date,
                        k.title as k_title,
                        p.title as p_title,
                        --- per day, if a product was present in a given kiosk, status = 1, else 0
                        CASE WHEN count(*) > 0 THEN 1 else 0 END as status
                        FROM inventory_history ih
                        JOIN pantry.kiosk k
                        ON ih.kiosk_id = k.id
                        JOIN pantry.product p
                        ON ih.product_id = p.id
                        WHERE k.campus_id = 87
                        AND p.campus_id = 87
                        AND k.enable_reporting = 1
                        AND k.id = given_kiosk_id
                        AND k.archived = 0
                        AND p.archived = 0
                        GROUP BY kiosk_id, product_id, date, p.title, k.title
                    ) as sku_kiosk_status_per_day
                    GROUP BY kiosk_id, product_id, k_title, p_title
                ) as sum_days_product_in_kiosk
                JOIN (SELECT kiosk_id,
                        product_id,
                        l.epc
                        FROM pantry.label l
                        JOIN pantry.kiosk k on k.id  = l.kiosk_id
                        JOIN pantry.product p on p.id  = l.product_id
                        WHERE status = 'ok'
                        AND k.enable_reporting = 1
                        AND p.campus_id = 87
                        AND k.id = given_kiosk_id
                    ) as in_kiosk
                    ON sum_days_product_in_kiosk.kid = in_kiosk.kiosk_id
                    AND sum_days_product_in_kiosk.pid = in_kiosk.product_id
                WHERE number_of_days_in_kiosk >= 28
            ) as SKU_performance_qualifiers

            /* The following is set up to analyze if a given sku in a given kiosk has a spoilage % (
            (spoilage/sales)* 100) >= 30% over 3 of the past 6 weeks. To set this up, we will get a
            weekly spoilage for each sku per kiosk. We will then use LAG() OVER (PARTITION BY)
            in order to have all weeks spoilage values in one row. The row containing all
            spoilage values will be the 6th row of each kiosk/sku combination (week_rank = 6) */
            LEFT JOIN (SELECT week_rank,
                kid,
                k_title,
                pid,
                p_title,
                COALESCE(lag(second_week_spoilage) OVER (PARTITION BY kid, pid ORDER BY week_rank), 0)
                    as first_week_spoilage,
                second_week_spoilage,
                third_week_spoilage,
                fourth_week_spoilage,
                fifth_week_spoilage,
                spoilage_percent as sixth_week_spoilage
                FROM (SELECT *
                    FROM (SELECT *,
                        lag(third_week_spoilage) OVER (Partition by kid, pid ORDER BY week_rank)
                            as second_week_spoilage
                        FROM (SELECT *,
                            lag(fourth_week_spoilage) OVER (Partition by kid, pid ORDER BY week_rank)
                                as third_week_spoilage
                            FROM (SELECT *,
                                lag(fifth_week_spoilage) OVER (Partition by kid, pid ORDER BY week_rank)
                                    as fourth_week_spoilage
                                FROM (SELECT week,
                                    week_rank,
                                    kid,
                                    k_title,
                                    pid,
                                    p_title,
                                    spoilage_percent ,
                                    lag(spoilage_percent) OVER (Partition by kid, pid ORDER BY week_rank)
                                        as fifth_week_spoilage
                                    --- Calculate given sku in given kiosk spoilage per week
                                    FROM (SELECT all_weeks_kiosks_products.week,
                                        all_weeks_kiosks_products.week_rank,
                                        all_weeks_kiosks_products.kid,
                                        all_weeks_kiosks_products.k_title,
                                        all_weeks_kiosks_products.pid,
                                        all_weeks_kiosks_products.p_title,
                                        COALESCE(total_spoilage, 0) as spoilage,
                                        COALESCE(total_sales, 0) as total_sales,
                                        COALESCE(ROUND(100.0 * (COALESCE(total_spoilage, 0)/
                                            NULLIF(COALESCE(total_sales, 0),0)),2),0) as spoilage_percent
                                        --- Get all kiosks, products and weeks
                                        FROM (SELECT week_and_rank.week,
                                            kid,
                                            k_title,
                                            pid,
                                            p_title,
                                            week_and_rank.week_rank
                                            --- Get all weeks within the last 6 weeks, excluding this current week
                                            FROM (SELECT week,
                                                rank() OVER (ORDER BY week) as week_rank
                                                FROM (SELECT distinct(EXTRACT('week' FROM dd)) as week
                                                FROM generate_series( (NOW()::DATE-EXTRACT(DOW FROM NOW())::INTEGER -6)::date
                                                    - INTERVAL '6 weeks' , (NOW()::DATE-EXTRACT(DOW FROM NOW())::INTEGER -6)::date,
                                                    '1 day'::interval) dd
                                                ) as weeks
                                                GROUP BY week
                                            ) as week_and_rank
                                            --- Get all kiosks and skus
                                            CROSS JOIN (SELECT k.id as kid,
                                                k.title as k_title,
                                                p.id as pid,
                                                p.title as p_title
                                                FROM pantry.kiosk k
                                                CROSS JOIN
                                                pantry.product p
                                                WHERE k.campus_id = 87
                                                AND p.campus_id = 87
                                                AND k.enable_reporting = 1
                                                AND k.id = given_kiosk_id
                                                AND k.archived = 0
                                                AND p.archived = 0
                                            ) as kiosk_and_product
                                        ) as all_weeks_kiosks_products
                                        --- Get sales per week for the last 6 weeks (not including current week)
                                        LEFT JOIN (SELECT EXTRACT('week' FROM to_timestamp(created)::date)
                                                as week,
                                        l.kiosk_id,
                                        l.product_id,
                                        sum(l.price) as total_sales
                                        FROM byte_tickets bt
                                        JOIN pantry.label l
                                        ON bt.order_id = l.order_id
                                        WHERE to_timestamp(created)::date>= (NOW()::DATE-EXTRACT(DOW FROM NOW())::INTEGER
                                            -6)::date - INTERVAL '6 weeks'
                                        AND to_timestamp(created)::date <= (NOW()::DATE-EXTRACT(DOW FROM NOW())::INTEGER
                                            -7)::date
                                        GROUP BY l.kiosk_id, l.product_id, EXTRACT('week' FROM to_timestamp(created)::date)
                                        ) as sales_per_week
                                        ON all_weeks_kiosks_products.kid = sales_per_week.kiosk_id
                                        AND all_weeks_kiosks_products.pid = sales_per_week.product_id
                                        AND all_weeks_kiosks_products.week = sales_per_week.week
                                        --- Get spoilage per week for the last 6 weeks (not including current week)
                                        LEFT JOIN (SELECT EXTRACT('week' FROM date::date) as week,
                                        kiosk_id,
                                        product_id,
                                        sum(cost) as total_spoilage
                                        FROM byte_spoilage
                                        WHERE date::date>= (NOW()::DATE-EXTRACT(DOW FROM NOW())::INTEGER -6)::date
                                            - INTERVAL '6 weeks'
                                        AND date::date <= (NOW()::DATE-EXTRACT(DOW FROM NOW())::INTEGER -7)::date
                                        GROUP BY kiosk_id, product_id, EXTRACT('week' FROM date::date)
                                        ) as spoilage_per_week
                                        ON all_weeks_kiosks_products.kid = spoilage_per_week.kiosk_id
                                        AND all_weeks_kiosks_products.pid = spoilage_per_week.product_id
                                        AND all_weeks_kiosks_products.week = spoilage_per_week.week
                                    ) as spoilage_percent_per_week
                                ) as lag_second_spoilage
                            ) as lag_third_spoilage
                        ) as lag_fourth_spoilage
                    ) as lag_fifth_spoilage
                ) as lag_sixth_spoilage
            --- the 6th row contains all weeks' spoilage info
            WHERE week_rank = 6
            ) as spoilage_per_week
            ON SKU_performance_qualifiers.kid = spoilage_per_week.kid
            AND SKU_performance_qualifiers.pid = spoilage_per_week.pid

            /* The following subquery is set up to analyze if a sku's total sales in a given kiosk last
            month is less than 50% of the sku's entire fleet average. To do this, we need a sku's average
            sale across the entire fleet last month, and the sku's total sale in a given kiosk last month
            */
            LEFT JOIN (SELECT kiosk_and_product.kid,
                kiosk_and_product.pid,
                COALESCE(avg_sku_sales.avg_sales_across_all_fleet, 0)/ 2 as fifty_percent_avg_sales_across_all_fleet,
                COALESCE(avg_sku_sales.avg_sales_across_all_fleet, 0) as avg_sales_across_all_fleet,
                COALESCE(sum_kiosk_sales_per_kiosk.sales_per_kiosk, 0) as sales_per_kiosk
                --- Average sku sales across all fleet for the last month
                FROM (SELECT k.id as kid,
                    k.title as k_title,
                    p.id as pid,
                    p.title as p_title
                    FROM pantry.kiosk k
                    CROSS JOIN
                    pantry.product p
                    WHERE k.campus_id = 87
                    AND p.campus_id = 87
                    AND k.enable_reporting = 1
                    AND k.id = given_kiosk_id
                    AND k.archived = 0
                    AND p.archived = 0
                ) as kiosk_and_product
                LEFT JOIN (SELECT product_id,
                    avg(sales_per_kiosk) as avg_sales_across_all_fleet
                    --- Total sku sales in a given kiosk for the last month
                    FROM (SELECT product_id,
                        bt.kiosk_id,
                        count(*) as sales_per_kiosk
                        FROM byte_tickets bt
                        JOIN pantry.label l
                        ON bt.order_id = l.order_id
                        WHERE to_timestamp(bt.created)::date >= now()::date - interval '1 month'
                        GROUP BY product_id, bt.kiosk_id
                    ) as sum_sales_per_kiosk_last_month
                    GROUP BY product_id
                ) as avg_sku_sales
                ON avg_sku_sales.product_id = kiosk_and_product.pid
                --- Total sku sales in a given kiosk for the last month
                LEFT JOIN (SELECT product_id ,
                    bt.kiosk_id,
                    count(*) as sales_per_kiosk
                    FROM byte_tickets bt
                    JOIN pantry.label l
                    ON bt.order_id = l.order_id
                    WHERE to_timestamp(bt.created)::date >= now()::date - interval '1 month'
                    GROUP BY product_id, bt.kiosk_id
                ) as sum_kiosk_sales_per_kiosk
                ON kiosk_and_product.pid = sum_kiosk_sales_per_kiosk.product_id
                AND kiosk_and_product.kid = sum_kiosk_sales_per_kiosk.kiosk_id
            ) as low_sales
            ON  SKU_performance_qualifiers.kid = low_sales.kid
            AND SKU_performance_qualifiers.pid = low_sales.pid

            /*The following subquery is used to determine if there were no sku sales in the last 2
            consecutive weeks when the sku was available. This means that we need to look for the last 14
            consecutive days where a given sku was in a given kiosk during all days of those 14
            consecutive days.
            */
            LEFT JOIN (SELECT get_date.kiosk_id,
                get_date.k_title,
                get_date.product_id,
                get_date.p_title,
                get_date.date as last_date_with_previous_14_consecutive_item_present,
                COALESCE(total_price, 0) as total_price_last_consecutive_14_days
                --- Get the last date where the product was in the kiosk for at least 14 consecutive days from that day
                FROM (SELECT kiosk_id,
                    k_title,
                    product_id,
                    p_title,
                    max(date) as date
                    FROM (SELECT kiosk_id,
                        k_title,
                        product_id,
                        p_title,
                        number_in_fridge_consecutively,
                        date
                        FROM (SELECT *,
                            /* We use rank() OVER (PARTITION BY) as a way to determine when a sku has been
                            in a kiosk consecutively. It will tell how many days a sku has
                            been in a kiosk for consecutive days.
                            I used the method described in
                            https://stackoverflow.com/questions/47654348/postgres-rank-based-on-consecutive-values
                            */
                            rank() OVER (PARTITION BY kiosk_id, product_id, days_passed_since_last_present,
                                rank_2 - rank_1 ORDER BY date) as number_in_fridge_consecutively
                            FROM (SELECT *
                                FROM (SELECT *,
                                    rank() OVER (PARTITION BY kiosk_id, product_id, days_passed_since_last_present
                                        ORDER BY date::date) as rank_1,
                                    rank() OVER (PARTITION BY kiosk_id, product_id ORDER BY date::date) as rank_2
                                    /* Get all dates where a sku was present in a kiosk,
                                    and how many days has passed since that same sku was present in
                                    that same kiosk
                                    */
                                    FROM (SELECT ih.kiosk_id,
                                        k.title as k_title,
                                        ih.product_id,
                                        p.title as p_title,
                                        --- per day, if a product was present in a given kiosk, status = 1, else 0
                                        CASE WHEN count(*) > 0 THEN 1 else 0 END as status,
                                        ih.date::date,
                                        ih.date::date - lag(ih.date::date) OVER (PARTITION BY ih.kiosk_id, ih.product_id
                                            ORDER BY ih.date::date) as days_passed_since_last_present
                                        FROM inventory_history ih
                                        JOIN pantry.kiosk k
                                        ON ih.kiosk_id = k.id
                                        JOIN pantry.product p
                                        ON ih.product_id = p.id
                                        WHERE k.campus_id = 87
                                        AND p.campus_id = 87
                                        AND k.enable_reporting = 1
                                        AND k.id = given_kiosk_id
                                        AND p.archived = 0
                                        AND k.archived = 0
                                        GROUP BY ih.kiosk_id, ih.product_id, ih.date, p.title, k.title
                                    ) as get_days_passed_since_last_present
                                ) as set_up_for_ranking_part_1
                                /* Before we do the ranking, we need to get rid of any rows that are not
                                consecutive in days. Those are found where rank_1 = 1. Not doing so will
                                result in inaccurate ranking */
                                WHERE rank_1 !=1
                            ) set_up_for_ranking_part_2
                        ) as ranking
                        --- SELECT all rows that have had 14 days or more consecutive
                         WHERE number_in_fridge_consecutively >= 14
                    ) as consecutive_for_2_weeks_max_date
                    GROUP BY kiosk_id,  k_title, product_id,  p_title
                )  as get_date
                --- For each day, get the total sales for the last 14 days, including the chosen day
                LEFT JOIN (SELECT p1.date,
                    p1.kiosk_id,
                    p1.product_id,
                    SUM(p2.price) total_price
                    FROM (SELECT to_timestamp(bt.created)::date as date,
                    l.kiosk_id,
                    l.product_id,
                    sum(l.price) as price
                    FROM byte_tickets bt
                    JOIN pantry.label l
                    ON bt.order_id = l.order_id
                    GROUP BY l.kiosk_id, l.product_id, to_timestamp(bt.created)::date
                ) as p1
                    INNER JOIN (SELECT to_timestamp(bt.created)::date as date,
                    l.kiosk_id,
                    l.product_id,
                    sum(l.price) as price
                    FROM byte_tickets bt
                    JOIN pantry.label l
                    ON bt.order_id = l.order_id
                    GROUP BY l.kiosk_id, l.product_id, to_timestamp(bt.created)::date
                ) as p2
                ON p1.kiosk_id = p2.kiosk_id
                AND p1.product_id = p2.product_id
                AND p2.date BETWEEN (p1.date - INTERVAL '14 DAY') AND p1.date
                 GROUP BY p1.kiosk_id, p1.product_id, p1.date
                 ORDER BY p1.kiosk_id, p1.date
             )sales on get_date.date = sales.date
                AND get_date.kiosk_id = sales.kiosk_id
                AND get_date.product_id = sales.product_id
            ) as no_sales_last_2_weeks
            ON SKU_performance_qualifiers.kid = no_sales_last_2_weeks.kiosk_id
            AND SKU_performance_qualifiers.pid = no_sales_last_2_weeks.product_id
            ----Below are all the filters we need to apply
            --- less than 50% of sku fleet average OR  No sales in past 2 weeks when the item was available
            WHERE (
                ( fifty_percent_avg_sales_across_all_fleet > sales_per_kiosk)
                OR
                (total_price_last_consecutive_14_days = 0)
            )
            /* Where Spoilage >= 30% of sales over 3 of the past 6 weeks. I used the combination calculator
            found on https://www.mathsisfun.com/combinatorics/combinations-permutations-calculator.html
            to generate all week_spoilage combinations.*/
            AND ((first_week_spoilage >= 30 AND second_week_spoilage >= 30 AND third_week_spoilage >= 30) OR
                (first_week_spoilage >= 30 AND second_week_spoilage >= 30 AND fourth_week_spoilage >= 30) OR
                (first_week_spoilage >= 30 AND second_week_spoilage >= 30 AND fifth_week_spoilage >= 30) OR
                (first_week_spoilage >= 30 AND second_week_spoilage >= 30 AND sixth_week_spoilage >= 30) OR
                (first_week_spoilage >= 30 AND third_week_spoilage >= 30 AND fourth_week_spoilage >= 30) OR
                (first_week_spoilage >= 30 AND third_week_spoilage >= 30 AND fifth_week_spoilage >= 30) OR
                (first_week_spoilage >= 30 AND third_week_spoilage >= 30 AND sixth_week_spoilage >= 30) OR
                (first_week_spoilage >= 30 AND fourth_week_spoilage >= 30 AND fifth_week_spoilage >= 30) OR
                (first_week_spoilage >= 30 AND fourth_week_spoilage >= 30 AND sixth_week_spoilage >= 30) OR
                (first_week_spoilage >= 30 AND fifth_week_spoilage >= 30 AND sixth_week_spoilage >= 30) OR
                (second_week_spoilage >= 30 AND third_week_spoilage >= 30 AND fourth_week_spoilage >= 30) OR
                (second_week_spoilage >= 30 AND third_week_spoilage >= 30 AND fifth_week_spoilage >= 30) OR
                (second_week_spoilage >= 30 AND third_week_spoilage >= 30 AND sixth_week_spoilage >= 30) OR
                (second_week_spoilage >= 30 AND fourth_week_spoilage >= 30 AND fifth_week_spoilage >= 30) OR
                (second_week_spoilage >= 30 AND fourth_week_spoilage >= 30 AND sixth_week_spoilage >= 30) OR
                (second_week_spoilage >= 30 AND fifth_week_spoilage >= 30 AND sixth_week_spoilage >= 30) OR
                (third_week_spoilage >= 30 AND fourth_week_spoilage >= 30 AND fifth_week_spoilage >= 30) OR
                (third_week_spoilage >= 30 AND fourth_week_spoilage >= 30 AND sixth_week_spoilage >= 30) OR
                (third_week_spoilage >= 30 AND fifth_week_spoilage >= 30 AND sixth_week_spoilage >= 30) OR
                (fourth_week_spoilage >= 30 AND fifth_week_spoilage >= 30 AND sixth_week_spoilage >=30)
            );

    END;
$$;


ALTER FUNCTION inm.get_performance_pull_list(given_kiosk_id integer) OWNER TO dbservice;

--
-- Name: get_pull_date(timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: inm; Owner: dbservice
--

CREATE FUNCTION inm.get_pull_date(plan_window_start timestamp with time zone, plan_window_stop timestamp with time zone) RETURNS TABLE(kiosk_id integer, delivery_date date, pull_date date)
    LANGUAGE plpgsql
    AS $$
  /*
    Purpose: return INM pull date aka next delivery date
    Note: this used to be part of mixalot.plan_kiosk, but due to unreliable time portion of route_stop.route_date_time,
    this pull_date function is created to restrict the result to date portion of the data which is accurate and sufficient
    because pull_date doesn't need accurate time unlike mixalot.plan_kiosk.
    */
begin
	return query
		select ds.kiosk_id, ds.delivery_date_time::date, ps.pull_date_time::date
			from
			-- kiosk_id, delivery_date
			(select t.kiosk_id, t.delivery_date_time  from
				(select location_number as kiosk_id, rs.route_date_time as delivery_date_time,
					rank() over (partition by location_number order by rs.route_date_time) as r
					from mixalot.route_stop rs
					where rs.route_date_time >= plan_window_start -- look at routes starting at plan winddow start
					and location_number > 0) t
					where r = 1) ds

			left join
      (select o.kiosk_id kiosk_id,
             --o.pull_date_time as pull_date_time_old,
             if(o.os=0, o.pull_date_time, (o.pull_date_time - interval '1 day'*(o.os+1))) pull_date_time
             --if(o.os=0, o.os, o.os+1) as offset
      from (
        select nd.kiosk_id,
          nd.pull_date_time,
          nd.pull_dow,
          nd.pull_dow-os.os as pull_dow_os,
          mod((7+nd.pull_dow-os.os)::integer,7) as pull_dow_os_mod,
          os.os,
          ks.kiosk_sale_daily as kiosk_sale_daily,
          row_number() over (partition by nd.kiosk_id order by (nd.pull_dow-os.os) desc) as row_number
        from (
          select t.kiosk_id,
            t.delivery_date_time - interval '1 day' pull_date_time,
            EXTRACT(DOW from (t.delivery_date_time - interval '1 day')) as pull_dow
          from (
            select location_number as kiosk_id, rs.route_date_time::date as delivery_date_time,
              rank() over (partition by location_number order by rs.route_date_time) as r
            from mixalot.route_stop rs
            where rs.route_date_time >= plan_window_start -- look at routes starting at plan window start
              and location_number > 0) t
          where r = 2
          ) nd
        cross join (
          select generate_series as os from generate_series(0, 6)
          ) os
        left join (
          select vksh.kiosk_id, vksh.dow, sum(vksh.units_sold_normalized) as kiosk_sale_daily from inm.v_kiosk_sale_hourly vksh group by vksh.kiosk_id, vksh.dow
          ) ks
        on nd.kiosk_id=ks.kiosk_id and mod((7+nd.pull_dow-os.os)::integer,7)=ks.dow
        where ks.kiosk_sale_daily>=0.05
        order by nd.kiosk_id asc, (nd.pull_dow-os.os) desc
        ) o
      where o.row_number=1) ps
-- kiosk_id, pull_date
-- 			(select t.kiosk_id, t.delivery_date_time - interval '1 day' pull_date_time from
-- 				(select location_number as kiosk_id, rs.route_date_time::date as delivery_date_time,
-- 					rank() over (partition by location_number order by rs.route_date_time) as r
-- 					from mixalot.route_stop rs
-- 					where rs.route_date_time >= plan_window_start -- look at routes starting at plan window start
-- 					and location_number > 0) t
-- 					where r = 2) ps

			on ds.kiosk_id = ps.kiosk_id
			join pantry.kiosk k on ds.kiosk_id = k.id
			where ds.delivery_date_time between plan_window_start and plan_window_stop
			and k.campus_id= 87;	
end;

$$;


ALTER FUNCTION inm.get_pull_date(plan_window_start timestamp with time zone, plan_window_stop timestamp with time zone) OWNER TO dbservice;

--
-- Name: get_spoilage_pull_list(); Type: FUNCTION; Schema: inm; Owner: dbservice
--

CREATE FUNCTION inm.get_spoilage_pull_list() RETURNS TABLE(category character varying, kiosk_id bigint, kiosk_title character varying, product_id bigint, product_tile character varying, epc character varying)
    LANGUAGE plpgsql
    AS $$
    BEGIN
        RETURN QUERY
/*
This query is used to identify items that will spoil before the next delivery.
This function does not use kiosk id as an input.
It return expected spoilage for the whole Byte fleet.
A spoiled item uses the following
criteria:
if ( skuShelfLife <= 7 days ) {
if ( skuEpcDateAdded + kioskNextDelvieryDate > skuShelfLife )
{Show in pull list (red);}
}
else if ( skuShelfLife > 7 days && skuShelfLife <= 30 days ){
if ( skuEpcDateAdded + kioskNextDelvieryDate > skuShelfLife )
{Show in check list (yellow);}
}
SEE ENG-555
*/
        SELECT CASE WHEN shelf_time <= 7 THEN 'SPOILAGE RED'::varchar ELSE 'SPOILAGE YELLOW'::varchar END as category,
            l.kiosk_id as kiosk_id,
            k.title as kiosk_title,
            l.product_id as product_id,
            p.title as product_tile,
            l.epc as epc
            FROM pantry.label l
            JOIN pantry.product p ON l.product_id = p.id
            JOIN pantry.kiosk k ON l.kiosk_id = k.id
            --- Get next delivery date
            JOIN (select location_number,
                min(route_date_time) as next_delivery_date
                FROM mixalot.route_stop
                WHERE route_date_time::date > now()::date
                GROUP BY location_number
            ) as next_delivery
            ON l.kiosk_id = next_delivery.location_number
            WHERE l.status = 'ok'
            AND k.archived = 0
            AND k.enable_monitoring = 1
            AND k.campus_id = 87
            AND p.campus_id = 87
            AND (
                    (
                        shelf_time <= 7
                        AND
                        (next_delivery.next_delivery_date::date - to_timestamp(l.time_added)::date) > p.shelf_time
                    )
                    OR
                    (
                        shelf_time > 7
                        AND shelf_time <= 30
                        AND
                        (next_delivery.next_delivery_date::date - to_timestamp(l.time_added)::date) > p.shelf_time
                    )
                )
            ORDER BY kiosk_id, category;
    END;
$$;


ALTER FUNCTION inm.get_spoilage_pull_list() OWNER TO dbservice;

--
-- Name: get_spoilage_pull_list(integer); Type: FUNCTION; Schema: inm; Owner: dbservice
--

CREATE FUNCTION inm.get_spoilage_pull_list(given_kiosk_id integer) RETURNS TABLE(category character varying, kiosk_id bigint, kiosk_title character varying, product_id bigint, product_tile character varying, epc character varying)
    LANGUAGE plpgsql
    AS $$
    BEGIN
        RETURN QUERY
/*
This query is used to identify items that will spoil before the next delivery. A spoiled item uses the following
criteria:
if ( skuShelfLife <= 7 days ) {
if ( skuEpcDateAdded + kioskNextDelvieryDate > skuShelfLife )
{Show in pull list (red);}
} 
else if ( skuShelfLife > 7 days && skuShelfLife <= 30 days ){
if ( skuEpcDateAdded + kioskNextDelvieryDate > skuShelfLife )
{Show in check list (yellow);}
}
SEE ENG-555
*/
        SELECT CASE WHEN shelf_time <= 7 THEN 'SPOILAGE RED'::varchar ELSE 'SPOILAGE YELLOW'::varchar END as category,
            l.kiosk_id as kiosk_id,
            k.title as kiosk_title,
            l.product_id as product_id,
            p.title as product_tile,
            l.epc as epc
            FROM pantry.label l
            JOIN pantry.product p ON l.product_id = p.id
            JOIN pantry.kiosk k ON l.kiosk_id = k.id
            --- Get next delivery date
            JOIN (select location_number,
                min(route_date_time) as next_delivery_date
                FROM mixalot.route_stop
                WHERE route_date_time::date > now()::date
                GROUP BY location_number
            ) as next_delivery
            ON l.kiosk_id = next_delivery.location_number
            WHERE l.status = 'ok'
            AND k.archived = 0
            AND k.enable_monitoring = 1
            AND k.campus_id = 87
            AND p.campus_id = 87
            AND (
                    (
                        shelf_time <= 7
                        AND
                        (next_delivery.next_delivery_date::date - to_timestamp(l.time_added)::date) > p.shelf_time
                    )
                    OR
                    (
                        shelf_time > 7
                        AND shelf_time <= 30
                        AND
                        (next_delivery.next_delivery_date::date - to_timestamp(l.time_added)::date) > p.shelf_time
                    )
                )
            AND l.kiosk_id = given_kiosk_id
            ORDER BY 2,1;
    END;
$$;


ALTER FUNCTION inm.get_spoilage_pull_list(given_kiosk_id integer) OWNER TO dbservice;

--
-- Name: pick_check_restriction(date); Type: FUNCTION; Schema: inm; Owner: dbservice
--

CREATE FUNCTION inm.pick_check_restriction(_pick_date date) RETURNS TABLE(kiosk_id integer, product_id integer)
    LANGUAGE plpgsql
    AS $$

/*
Purpose: return restricted products found in allocation
*/

begin
	return query
		select a.kiosk_id, a.sku_id
			from (select * from inm.pick_allocation a where a.pick_date = _pick_date) a
				join inm.kiosk_product_disabled d on a.kiosk_id = d.kiosk_id and a.sku_id = d.product_id;
end;

$$;


ALTER FUNCTION inm.pick_check_restriction(_pick_date date) OWNER TO dbservice;

--
-- Name: FUNCTION pick_check_restriction(_pick_date date); Type: COMMENT; Schema: inm; Owner: dbservice
--

COMMENT ON FUNCTION inm.pick_check_restriction(_pick_date date) IS 'Run this after a pick to find restricted products in allocation.';


--
-- Name: pick_get_delivery_schedule(date); Type: FUNCTION; Schema: inm; Owner: dbservice
--

CREATE FUNCTION inm.pick_get_delivery_schedule(pick_date date) RETURNS TABLE(driver_name character varying, route_date_time timestamp with time zone, kiosk_id integer, kiosk_title character varying, address character varying, delivery_order integer)
    LANGUAGE plpgsql
    AS $$

	
	declare 
		latest_import_ts timestamp;
		pst_plan_window_start_str text;
		plan_window_start timestamp with time zone;
	 	plan_window_stop timestamp with time zone;

/*
Purpose: return INM delivery schedule for a pick window.
Input
	target_date: pick_date
Return
	Data to generate the drivers sheets
*/
begin
	if pick_date is not null
		then
			-- compose US/Pacific start window timestamp string
			pst_plan_window_start_str = cast(pick_date as text) || ' 13:00 -8';	
			select into plan_window_start cast(pst_plan_window_start_str as timestamp with time zone);
			plan_window_stop = plan_window_start + interval '22 hours';
			
		-- fixme: remove when obsolete
		-- backward compat with run pick using inm gsheets with plan window imported into mixalot.inm_data
		else
			select max(import_ts) from mixalot.inm_data into latest_import_ts;
			select i.route_date from mixalot.inm_data i
				where import_ts = latest_import_ts and data_type = 'Plan Window Start'
				into plan_window_start;
			select i.route_date from mixalot.inm_data i
				where import_ts = latest_import_ts and data_type = 'Plan Window Stop'
				into plan_window_stop;
		end if;
	
	return query
		select rs.driver_name, rs.route_date_time, location_number kiosk_id, k.title kiosk_title, k.address, rs.stop_number delivery_order
			from mixalot.route_stop rs join pantry.kiosk k on rs.location_number = k.id
			where rs.route_date_time between plan_window_start and plan_window_stop;
end;

$$;


ALTER FUNCTION inm.pick_get_delivery_schedule(pick_date date) OWNER TO dbservice;

--
-- Name: pick_get_delivery_schedule_optimo(date); Type: FUNCTION; Schema: inm; Owner: dbservice
--

CREATE FUNCTION inm.pick_get_delivery_schedule_optimo(target_date date) RETURNS TABLE(driver_name character varying, route_date_time timestamp with time zone, kiosk_id integer, kiosk_title character varying, address character varying, delivery_order integer)
    LANGUAGE plpgsql
    AS $$

	declare latest_import_ts timestamp;
	declare plan_window_start timestamp;
	declare plan_window_stop timestamp;

/*
Purpose: return INM delivery schedule for a pick window.
Input
	target_date: pick_date
Return
	Data to generate the drivers sheets
*/
begin
	-- calculate various date params
	select max(import_ts) from mixalot.inm_data into latest_import_ts;
	select i.route_date from mixalot.inm_data i
		where import_ts = latest_import_ts and data_type = 'Plan Window Start'
		into plan_window_start;
	select i.route_date from mixalot.inm_data i
		where import_ts = latest_import_ts and data_type = 'Plan Window Stop'
		into plan_window_stop;
	
	return query
		select rs.driver_name, rs.route_date_time, location_number kiosk_id, k.title kiosk_title, k.address, rs.stop_number delivery_order
			from mixalot.route_stop rs join pantry.kiosk k on rs.location_number = k.id
			where rs.route_date_time between plan_window_start and plan_window_stop;
end;

$$;


ALTER FUNCTION inm.pick_get_delivery_schedule_optimo(target_date date) OWNER TO dbservice;

--
-- Name: pick_get_demand_weekly_by_velocity(); Type: FUNCTION; Schema: inm; Owner: dbservice
--

CREATE FUNCTION inm.pick_get_demand_weekly_by_velocity() RETURNS TABLE(kiosk_id bigint, sku_group_id integer, fc_title text, kc_start_level numeric, kc_min_level numeric, kc_manual_multiplier numeric, sgc_default_level numeric, sgc_scale numeric, ksms_scale numeric, ws_live bigint, velocity_demand numeric, demand_weekly numeric)
    LANGUAGE plpgsql
    AS $$

/*
Revision Date: 2019-01-09
Purpose: return INM weekly demand by velocity
*/

begin
	return query
		select cast(dwwom.kiosk_id as bigint),
			dwwom.sku_group_id,
			dwwom.sku_group,
			dwwom.kc_start_level,
			dwwom.kc_min_level,
			dwwom.kc_manual_multiplier,
			dwwom.sgc_default_level,
			dwwom.sgc_scale,
			dwwom.ksms_scale,
			dwwom.ws_live,
			dwwom.preference_count,
		
			case when dwwom.ws_live < 4
			then greatest(dwwom.start_count, dwwom.preference_count)
			else greatest(dwwom.min_count, dwwom.preference_count)
			end as wk_demand
		
		from inm.pick_get_demand_weekly_wo_min() dwwom;
end;

$$;


ALTER FUNCTION inm.pick_get_demand_weekly_by_velocity() OWNER TO dbservice;

--
-- Name: pick_get_demand_weekly_wo_min(); Type: FUNCTION; Schema: inm; Owner: dbservice
--

CREATE FUNCTION inm.pick_get_demand_weekly_wo_min() RETURNS TABLE(kiosk_id integer, sku_group_id integer, sku_group text, sample_size bigint, preference numeric, ws_avg numeric, ws_std numeric, ws_live bigint, kc_start_level numeric, kc_min_level numeric, kc_manual_multiplier numeric, sgc_default_level numeric, sgc_scale numeric, ksms_scale numeric, start_count numeric, min_count numeric, scaled_preference numeric, scaled_preference_total numeric, preference_count numeric)
    LANGUAGE plpgsql
    AS $$
  /*
  Revision date: 2019-01-09
  Purpose: return INM weekly demand without min by velocity
  */

begin
	return query
select kc.kiosk_id as kiosk_id, 
	sg.id as sku_group_id,
	cast(sg.fc_title as text) as sku_group,
	coalesce(dwwom.sample_size, 0) as sample_size, -- dwwom missing some records for archived/old kiosks
	coalesce(dwwom.preference, 0.00) as preference, -- dwwom missing some records for archived/old kiosks
	max(coalesce(dwwom.ws_avg, 0.00)) over (partition by kc.kiosk_id) as ws_avg, --dwwom missing some records for archived/old kiosks
	max(coalesce(dwwom.ws_std, 0.00)) over (partition by kc.kiosk_id) as ws_std, --dwwom missing some records for archived/old kiosks
	max(coalesce(dwwom.ws_live, 0)) over (partition by kc.kiosk_id) as ws_live, -- dwwom missing some records for archived/old kiosks
	kc.start_level as kc_start_level,
	kc.min_level as kc_min_level,
	kc.manual_multiplier as kc_manual_multiplier, 
	sgc.default_level as sgc_default_level,
	sgc.scale as sgc_scale,
	coalesce(ksms.scale, 1.00) as ksms_scale,
	round(kc.start_level*kc.manual_multiplier*sgc.scale*coalesce(ksms.scale, 1.00)*sgc.default_level, 2) as start_count,
	round(kc.min_level*kc.manual_multiplier*sgc.scale*coalesce(ksms.scale, 1.00)*sgc.default_level, 2) as min_count,
	round(coalesce(dwwom.preference, 0.00)*kc.manual_multiplier*sgc.scale*coalesce(ksms.scale, 1.00), 2) as scaled_preference,
	round(sum(coalesce(dwwom.preference, 0.00)*kc.manual_multiplier*sgc.scale*coalesce(ksms.scale, 1.00)) over (partition by kc.kiosk_id), 2) as scaled_preference_total,
	round(coalesce(dwwom.ws_avg + dwwom.ws_std, 0.00) * (coalesce(dwwom.preference, 0.00)*kc.manual_multiplier*sgc.scale*coalesce(ksms.scale, 1.00) / greatest(0.01, sum(coalesce(dwwom.preference, 0.00)*kc.manual_multiplier*sgc.scale*coalesce(ksms.scale, 1.00)) over (partition by kc.kiosk_id))), 2) as preference_count
from inm.sku_group sg
cross join inm.kiosk_control kc
left join inm.kiosk_sku_group_manual_scale ksms on ksms.kiosk_id=kc.kiosk_id and ksms.sku_group_id=sg.id
left join inm.sku_group_control sgc on sgc.sku_group_id = sg.id
left join 
	(select t4.kiosk_id,
		t4.sku_group,
		t4.sample_size,
		t4.dt_avg,
		t4.dt_std,
		t4.w_departure_time,
		t4.preference,
		t6.ws_avg,
		t6.ws_std,
		t6.ws_live
	from (
		select t3.kiosk_id, 
			t3.sku_group, 
			count(t3.purchase_index) as sample_size,
			round((avg(t3.departure_time))::numeric, 2) as dt_avg,
			coalesce(round((stddev(t3.departure_time))::numeric, 2), 0) as dt_std,
			round(sum(t3.departure_time*t3.w)/sum(t3.w)::numeric, 2) as w_departure_time,
			least(round(1.00/(sum(t3.departure_time*t3.w)/sum(t3.w))::numeric, 2), case when count(t3.purchase_index)=1 then 0.10 else 0.20 end) as preference
		from (
			select *,
				greatest(coalesce(round((t2.time_sold - greatest(t2.last_sale, t2.time_stocked))::numeric/3600, 2), 50.00), 1.00) as departure_time,
				0 as qty_sold,
				1 as w
				--(t2.purchase_index - t2.last_purchase_index) as qty_sold,
				--coalesce(round((t2.purchase_index - t2.last_purchase_index)::numeric/greatest(coalesce((t2.time_sold - greatest(t2.last_sale, t2.time_stocked))::numeric/3600, 100.00), 1.00), 2), 1.00) as w
			from (
				select *,
					lag(t1.time_sold, 1) over (partition by t1.kiosk_id, t1.sku_group order by t1.time_sold) as last_sale,
					lag(t1.purchase_index, 1) over (partition by t1.kiosk_id, t1.sku_group order by t1.time_sold) as last_purchase_index
				from (
					select k.kiosk_id,
						p.sku_group,
						l.time_stocked,
						l.time_sold,
						l.purchase_index
					from (
						select k.id as kiosk_id
						from pantry.kiosk k
						where k.campus_id=87
							and k.archived=0
							and k.enable_reporting=1
							--and k.id=1274
					) k
					cross join (
						select distinct fc_title as sku_group
						from pantry.product p
						where p.campus_id=87
							and p.archived=0
							and p.fc_title is not null
							and p.fc_title!='N/A'
						order by p.fc_title asc
					) p
					left outer join (
						select l.kiosk_id as kiosk_id,
							p.fc_title as sku_group,
							l.time_created as time_stocked, 
							l.time_updated as time_sold,
							row_number() over (partition by l.kiosk_id order by l.time_updated) as purchase_index
						from pantry.label l
							join pantry.product p on l.product_id=p.id
						where l.kiosk_id is not null
							and l.status='sold'
							and to_timestamp(l.time_updated) at time zone 'US/Pacific' > date_trunc('week', current_timestamp) - interval '24 weeks'
							and p.campus_id=87
							and p.archived=0
							and p.fc_title is not null
					) l on k.kiosk_id=l.kiosk_id and p.sku_group=l.sku_group
					order by k.kiosk_id, p.sku_group, l.purchase_index
				) t1
			) t2
		) t3
		group by t3.kiosk_id, t3.sku_group
	) t4
	join 
	-- get sale average and standard diviation
	(select t5.kiosk_id, round(avg(units_sold), 2) ws_avg, round(stddev(units_sold), 2) ws_std, count(units_sold) ws_live
		from (
			-- get units sold per week over last 3 month
			SELECT concat(kk.kiosk_id::character varying(4), ' ', kk.woy) AS key,
				kk.kiosk_id,
				kk.woy,
				ss.units_sold
			FROM (
				SELECT k.id AS kiosk_id,
					generate_series(1, 52) AS woy
				FROM pantry.kiosk k
				WHERE k.campus_id = 87 AND k.archived = 0 AND k.enable_reporting = 1 AND k.enable_monitoring = 1) kk
			LEFT JOIN ( 
				SELECT s.kiosk_id,
					date_part('week'::text, s.ts) AS woy,
					count(*) AS units_sold
				FROM byte_epcssold_3months s
				GROUP BY s.kiosk_id, (date_part('week'::text, s.ts))) ss ON kk.kiosk_id = ss.kiosk_id AND kk.woy::double precision = ss.woy
			ORDER BY ss.kiosk_id, ss.woy) t5
		group by t5.kiosk_id
		order by t5.kiosk_id asc
	) t6 on t4.kiosk_id=t6.kiosk_id) dwwom on dwwom.kiosk_id = kc.kiosk_id and dwwom.sku_group = sg.fc_title;

			
end;

$$;


ALTER FUNCTION inm.pick_get_demand_weekly_wo_min() OWNER TO dbservice;

--
-- Name: pick_get_order(timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: inm; Owner: dbservice
--

CREATE FUNCTION inm.pick_get_order(start_ts timestamp with time zone, end_ts timestamp with time zone) RETURNS TABLE(kiosk_id integer, route_date_time timestamp with time zone, sku_group_id integer, fc_title text, week_qty integer, plan_qty integer)
    LANGUAGE plpgsql ROWS 10000
    AS $$
  /*
    Purpose - return INM order for the next sale period which is the time between the deliveries of this pick and the next pick
    Comment - Why go through this function and not call pick_get_order_with_velocity(start_date, end_date) directly? There are 2 reasons:
      1. We can replace pick_get_order_with_velocity with a newer fucntion here and not having to change the client code to test the new function.
      2. pick_get_order_with_velocity returns richer data that can be used for troubleshooting which is not necessary for production.
    
    Input -
      start_ts: plan window start date time with time zone
      end_ts: plan window end date time with time zone
    Return -
      kiosk_id: together with route_date_time is unique for the plan window
      route_date_time: route starting date time
      fc_title: sku group name
      plan_qty: order quantity for the above fc_title for the next sale period
    */

declare latest_import_ts_for_pick_window timestamp with time zone;
begin
	/* update pick_preference_kiosk_sku */
-- 	truncate mixalot.pick_preference_kiosk_sku;
-- 	insert into mixalot.pick_preference_kiosk_sku
-- 		select i.kiosk_id, i.sku, cast(i.preference * 100 as integer) from mixalot.inm_sku_velocity i;

	return query
		-- seletively comment to use week order calc or between delivery order calc
		
		-- sales ratio
		-- select osr.kiosk_id, osr.route_date_time, osr.sku_group_id, osr.fc_title, osr.week_demand_qty, cast(osr.plan_order_qty as integer) from inm.pick_get_order_with_sales_ratio(start_ts, end_ts) osr;
		
		-- with sales ratio and velocity
		select distinct ov.kiosk_id, ov.route_date_time, ov.sku_group_id, ov.fc_title,
			cast(ceiling(ov.week_demand_qty) as integer), cast(ceiling(ov.plan_order_qty) as integer)
			from inm.pick_get_order_with_velocity(start_ts, end_ts) ov;
		
end;

$$;


ALTER FUNCTION inm.pick_get_order(start_ts timestamp with time zone, end_ts timestamp with time zone) OWNER TO dbservice;

--
-- Name: pick_get_order_with_velocity(timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: inm; Owner: dbservice
--

CREATE FUNCTION inm.pick_get_order_with_velocity(start_ts timestamp with time zone, end_ts timestamp with time zone) RETURNS TABLE(kiosk_id integer, route_date_time timestamp with time zone, sku_group_id integer, fc_title text, week_demand_qty numeric, plan_demand_qty numeric, plan_order_qty numeric)
    LANGUAGE plpgsql
    AS $$
  /*
    Purpose - return INM order based on sales ratio for pick sales period (time between deliveries)
    Input -
      start_ts: plan window start date time with time zone
      end_ts: plan window end date time with time zone
    Return -
      kiosk_id: together with route_date_time is unique for the plan window
      route_date_time: route starting date time
      fc_title: sku group name
      week_demand_qty: demand based on once a week delivery (without minimum)
      plan_demand_qty: demand based on sales ratio for pick sales period (without minimum)
      plan_order_qty: order based on sales ratio for pick sales period
    */

begin
	return query
		--  Given
		--		sales period = time between this pick delivery and next pick delivery (may be changed to pick times in the future)
		--		inm.demand_weekly = week demand
		--		sr.sales_ratio = sale ratio for this sum items sold for pick sales period for the last 4 weeks vs items sold for the last 4 weeks 
		-- 	if item is restricted (inm_qty=0), then set demand to 0. 
		--  else 
		--		if item doesn't exist in the kiosk (inv.count is null), set its inv count to 0
		-- 		order_before_min_max = 2.0 * sr.sales_ratio * inm.demand_weekly - inv.count
		-- 		final_order = min + order_before_min_max, capped by max as defined for each sku group
        -- 20190213, changed 1.4 to 2.0 to increase levels in the kiosks
		
		select sr.kiosk_id, sr.route_date_time, sga.id, dwbv.fc_title, dwbv.demand_weekly as week_demand_qty, 
			cast(1.7 * sr.sales_ratio * dwbv.demand_weekly as numeric (8,2)) plan_demand_qty,
			case 
				-- restricted item if demand_weekly is 0 or kiosk_sku_group manual scale is zero
				when dwbv.demand_weekly = 0 or ksms.scale = 0.0 then 0 
				else
					ceiling(
						-- change minimum is 0 (don't remove from a kiosk)
						least(greatest(least(1.7 * sr.sales_ratio * dwbv.demand_weekly, dwbv.demand_weekly) + sga.minimum_kiosk_qty - coalesce(inv.count, 0),
											  0) /* change negative demand to 0 */
								   , sga.maximum_kiosk_qty))
			end as plan_order_qty -- end case
					   
			from inm.pick_get_sales_period_ratio(start_ts, end_ts) sr
			
				join inm.pick_get_demand_weekly_by_velocity() dwbv
					on sr.kiosk_id = dwbv.kiosk_id 
												
				join inm.sku_group_attribute sga
					on sga.title = dwbv.fc_title			
				left join inm.kiosk_projected_stock inv
					on dwbv.kiosk_id = inv.kiosk_id and dwbv.fc_title = inv.fc_title
				left join inm.kiosk_sku_group_manual_scale ksms
					on sr.kiosk_id = ksms.kiosk_id and sga.id = ksms.sku_group_id;				
	end;

$$;


ALTER FUNCTION inm.pick_get_order_with_velocity(start_ts timestamp with time zone, end_ts timestamp with time zone) OWNER TO dbservice;

--
-- Name: pick_get_plan_kiosk(date); Type: FUNCTION; Schema: inm; Owner: dbservice
--

CREATE FUNCTION inm.pick_get_plan_kiosk(pick_date date) RETURNS TABLE(kiosk_id integer, route_date_time timestamp with time zone, driver_name character varying, location_name character varying, next_delivery_ts timestamp with time zone, time_to_next_delivery interval, days_to_next_delivery double precision, delivery_order bigint)
    LANGUAGE plpgsql
    AS $$

declare
	pst_plan_window_start_str text;
	plan_window_start timestamp with time zone;
	plan_window_stop timestamp with time zone;
/*
Purpose: return INM plan kiosks for a pick date.
*/

begin
	-- compose US/Pacific start window timestamp string
	pst_plan_window_start_str = cast(pick_date as text) || ' 13:00 -8';
	
	select into plan_window_start cast(pst_plan_window_start_str as timestamp with time zone);
	plan_window_stop = plan_window_start + interval '22 hours';
	return query
		select * from inm.pick_get_plan_kiosk(plan_window_start, plan_window_stop);
end;

$$;


ALTER FUNCTION inm.pick_get_plan_kiosk(pick_date date) OWNER TO dbservice;

--
-- Name: pick_get_plan_kiosk(timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: inm; Owner: dbservice
--

CREATE FUNCTION inm.pick_get_plan_kiosk(plan_window_start timestamp with time zone, plan_window_stop timestamp with time zone) RETURNS TABLE(kiosk_id integer, route_date_time timestamp with time zone, driver_name character varying, location_name character varying, next_delivery_ts timestamp with time zone, time_to_next_delivery interval, days_to_next_delivery double precision, delivery_order bigint)
    LANGUAGE plpgsql
    AS $$

/*
Purpose: return INM plan kiosks for a pick window.
*/

begin
	return query
		-- comment appropriate line to switch between optimo and bringg
		select * from inm.pick_get_plan_kiosk_optimo(plan_window_start, plan_window_stop);
		-- select * from inm.pick_get_plan_kiosk_bringg(plan_window_start, plan_window_stop);
end;

$$;


ALTER FUNCTION inm.pick_get_plan_kiosk(plan_window_start timestamp with time zone, plan_window_stop timestamp with time zone) OWNER TO dbservice;

--
-- Name: pick_get_plan_kiosk_bringg(timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: inm; Owner: dbservice
--

CREATE FUNCTION inm.pick_get_plan_kiosk_bringg(plan_window_start timestamp with time zone, plan_window_stop timestamp with time zone) RETURNS TABLE(kiosk_id integer, route_date_time timestamp with time zone, driver_name character varying, location_name character varying, next_delivery_ts timestamp with time zone, time_to_next_delivery interval, days_to_next_delivery double precision, delivery_order bigint)
    LANGUAGE plpgsql
    AS $$

/*
Purpose: return INM plan kiosks for a pick window.
*/

begin
	return query
		select ds.kiosk_id, ds.route_date_time, ds.driver_name, k.title, ps.next_delivery_ts,
		ps.next_delivery_ts - ds.route_date_time as time_to_next_delivery,		
		  case 
		  	when ps.next_delivery_ts - ds.route_date_time between interval '12 hours' and interval '24 hours' then 1
			else extract(day from ps.next_delivery_ts - ds.route_date_time)
			end as days_to_next_delivery,
		  row_number() over (order by ds.route_date_time asc) as delivery_order
		 		
		from
		-- kiosk_id, delivery_date
		(select t.kiosk_id, t.route_date_time, t.driver_name from
			(select cast(kid as integer) as kiosk_id, rs.route_date_time, rs.driver_name,
				rank() over (partition by kid, rs.route_date_time order by rs.route_date_time) as r
				from bringg.order rs
				where rs.route_date_time >= plan_window_start -- look at routes starting at plan winddow start
			 	and rs.status <> 7
				) t
				where r = 1) ds

		left join 
		-- kiosk_id, pull_date
		(select t.kiosk_id, t.route_date_time next_delivery_ts from
			(select cast(kid as integer) as kiosk_id, rs.route_date_time,
				rank() over (partition by kid order by rs.route_date_time) as r
				from bringg.order rs
				where rs.route_date_time >= plan_window_start -- look at routes starting at plan window start
			 	and rs.status <> 7
				) t
				where r = 2) ps

			on ds.kiosk_id = ps.kiosk_id
			join pantry.kiosk k on ds.kiosk_id = k.id
			where ds.route_date_time between plan_window_start and plan_window_stop
			and k.campus_id= 87;	
end;

$$;


ALTER FUNCTION inm.pick_get_plan_kiosk_bringg(plan_window_start timestamp with time zone, plan_window_stop timestamp with time zone) OWNER TO dbservice;

--
-- Name: pick_get_plan_kiosk_disabled_product(date); Type: FUNCTION; Schema: inm; Owner: dbservice
--

CREATE FUNCTION inm.pick_get_plan_kiosk_disabled_product(pick_date date) RETURNS TABLE(kiosk_id bigint, product_id integer)
    LANGUAGE plpgsql
    AS $$

declare 
	plan_window_start timestamp with time zone;
	plan_window_stop timestamp with time zone;
/*
Purpose: return disabled products for kiosks on the pick for a pick date.
*/

begin
	return query
		select dp.kiosk_id, dp.product_id
		from inm.pick_get_plan_kiosk(pick_date) pk
			join inm.kiosk_product_disabled dp on pk.kiosk_id = dp.kiosk_id;
end;

$$;


ALTER FUNCTION inm.pick_get_plan_kiosk_disabled_product(pick_date date) OWNER TO dbservice;

--
-- Name: pick_get_plan_kiosk_optimo(timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: inm; Owner: dbservice
--

CREATE FUNCTION inm.pick_get_plan_kiosk_optimo(plan_window_start timestamp with time zone, plan_window_stop timestamp with time zone) RETURNS TABLE(kiosk_id integer, route_date_time timestamp with time zone, driver_name character varying, location_name character varying, next_delivery_ts timestamp with time zone, time_to_next_delivery interval, days_to_next_delivery double precision, delivery_order bigint)
    LANGUAGE plpgsql
    AS $$

/*
Purpose: return INM plan kiosks for a pick window.
*/

begin
	return query
		select ds.kiosk_id, ds.route_date_time, ds.driver_name, ds.location_name, ps.next_delivery_ts,
		ps.next_delivery_ts - ds.route_date_time as time_to_next_delivery,		
		  case 
		  	when ps.next_delivery_ts - ds.route_date_time between interval '12 hours' and interval '24 hours' then 1
			else extract(day from ps.next_delivery_ts - ds.route_date_time)
			end as days_to_next_delivery,
		  row_number() over (order by ds.route_date_time asc) as delivery_order
		  
		
		from
		-- kiosk_id, delivery_date
		(select t.kiosk_id, t.route_date_time, t.driver_name, t.location_name from
			(select location_number as kiosk_id, rs.route_date_time, rs.driver_name, rs.location_name,
				rank() over (partition by location_number, rs.route_date_time order by rs.route_date_time) as r
				from mixalot.route_stop rs
				where rs.route_date_time >= plan_window_start -- look at routes starting at plan winddow start
				and location_number > 0) t
				where r = 1) ds

		left join 
		-- kiosk_id, pull_date
		(select t.kiosk_id, t.route_date_time next_delivery_ts from
			(select location_number as kiosk_id, rs.route_date_time,
				rank() over (partition by location_number order by rs.route_date_time) as r
				from mixalot.route_stop rs
				where rs.route_date_time >= plan_window_start -- look at routes starting at plan window start
				and location_number > 0) t
				where r = 2) ps

			on ds.kiosk_id = ps.kiosk_id
			join pantry.kiosk k on ds.kiosk_id = k.id
			where ds.route_date_time between plan_window_start and plan_window_stop
			and k.campus_id= 87;	
end;

$$;


ALTER FUNCTION inm.pick_get_plan_kiosk_optimo(plan_window_start timestamp with time zone, plan_window_stop timestamp with time zone) OWNER TO dbservice;

--
-- Name: pick_get_plan_kiosk_projected_stock(timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: inm; Owner: dbservice
--

CREATE FUNCTION inm.pick_get_plan_kiosk_projected_stock(plan_window_start timestamp with time zone, plan_window_stop timestamp with time zone) RETURNS TABLE(kiosk_id integer, fc_title character varying, qty integer)
    LANGUAGE plpgsql
    AS $$
  /*
    Purpose: return projected stock for plan kiosks for a pick window.
    */

begin
	return query
		select pk.kiosk_id, kps.fc_title, cast(kps.count as integer) from inm_beta.pick_get_plan_kiosk(plan_window_start, plan_window_stop) pk			
		left join inm.kiosk_projected_stock kps on pk.kiosk_id = kps.kiosk_id
			where kps.fc_title is not null;
end;
$$;


ALTER FUNCTION inm.pick_get_plan_kiosk_projected_stock(plan_window_start timestamp with time zone, plan_window_stop timestamp with time zone) OWNER TO dbservice;

--
-- Name: pick_get_sales_period_ratio(timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: inm; Owner: dbservice
--

CREATE FUNCTION inm.pick_get_sales_period_ratio(start_ts timestamp with time zone, end_ts timestamp with time zone) RETURNS TABLE(kiosk_id integer, route_date_time timestamp with time zone, sales_ratio numeric)
    LANGUAGE plpgsql ROWS 10000
    AS $$

  /*
  Purpose - return INM the ratio of the next sale period(time between the deliveries of this pick and the next pick) vs sales for the week using 12 week history
  Input -
    start_ts: plan window start date time with time zone
    end_ts: plan window end date time with time zone
  Return -
    kiosk_id: together with route_date_time is unique for the plan window
    route_date_time: route starting date time
    fc_title: sku group name
    plan_qty: order quantity for the above fc_title for the next sale period
  */

begin	
	return query
		select scheduled_kiosks.kiosk_id, scheduled_kiosks.route_date_time, coalesce(existing_kiosk_with_sales_ratio.ratio, 1.0/3.0)
			from inm.pick_get_plan_kiosk(start_ts, end_ts) scheduled_kiosks -- all the kiosks on route
				left join -- kiosks with sales history
					(
					select whole_12_weeks.kiosk_id, whole_12_weeks.route_date_time, 
						case when whole_12_weeks.qty < 5 then 1.0/3.0 -- new kiosk, assume period sale is 1/3 of total week
							else cast(period_12_weeks.qty as decimal)/cast(whole_12_weeks.qty as decimal)
							end ratio		
					from
						-- count of sales for the whole previous 4 weeks 
						(select pk.kiosk_id, pk.route_date_time, count(*) qty 
							from inm.pick_get_plan_kiosk(start_ts, end_ts) pk
								join pantry.label l on pk.kiosk_id=l.kiosk_id
								where l.status in ('sold') -- 20190213 changed from ('out', 'sold')
									and to_timestamp(l.time_updated) between
										pk.next_delivery_ts - interval '91 days'
										and pk.next_delivery_ts - interval '7 days'
							group by 1, 2
						 ) whole_12_weeks

						join 

						-- count of sales for the sales peiod of previous 4 weeks 
						(
						select pk.kiosk_id, pk.route_date_time, count(*) qty
							from inm.pick_get_plan_kiosk(start_ts, end_ts) pk
								join pantry.label l on pk.kiosk_id=l.kiosk_id
								where l.status in ('sold') and  -- 20190213 changed from ('out', 'sold')
									(
									 to_timestamp(l.time_updated) between now() - interval '7 days'  + interval '4 hours' and pk.next_delivery_ts - interval '7 days'  + interval '4 hours' or
									 to_timestamp(l.time_updated) between now() - interval '14 days' + interval '4 hours' and pk.next_delivery_ts - interval '14 days' + interval '4 hours' or
									 to_timestamp(l.time_updated) between now() - interval '21 days' + interval '4 hours' and pk.next_delivery_ts - interval '21 days' + interval '4 hours' or
									 to_timestamp(l.time_updated) between now() - interval '28 days' + interval '4 hours' and pk.next_delivery_ts - interval '28 days' + interval '4 hours' or

									 to_timestamp(l.time_updated) between now() - interval '35 days' + interval '4 hours' and pk.next_delivery_ts - interval '35 days' + interval '4 hours' or
									 to_timestamp(l.time_updated) between now() - interval '42 days' + interval '4 hours' and pk.next_delivery_ts - interval '42 days' + interval '4 hours' or
									 to_timestamp(l.time_updated) between now() - interval '49 days' + interval '4 hours' and pk.next_delivery_ts - interval '49 days' + interval '4 hours' or
									 to_timestamp(l.time_updated) between now() - interval '56 days' + interval '4 hours' and pk.next_delivery_ts - interval '56 days' + interval '4 hours' or

									 to_timestamp(l.time_updated) between now() - interval '63 days' + interval '4 hours' and pk.next_delivery_ts - interval '63 days' + interval '4 hours' or
									 to_timestamp(l.time_updated) between now() - interval '70 days' + interval '4 hours' and pk.next_delivery_ts - interval '70 days' + interval '4 hours' or
									 to_timestamp(l.time_updated) between now() - interval '77 days' + interval '4 hours' and pk.next_delivery_ts - interval '77 days' + interval '4 hours' or
									 to_timestamp(l.time_updated) between now() - interval '84 days' + interval '4 hours' and pk.next_delivery_ts - interval '84 days' + interval '4 hours'
									 
									/*
									 to_timestamp(l.time_updated) between pk.route_date_time - interval '7 days'  + interval '4 hours' and pk.next_delivery_ts - interval '7 days'  + interval '4 hours' or
 									 to_timestamp(l.time_updated) between pk.route_date_time - interval '14 days' + interval '4 hours' and pk.next_delivery_ts - interval '14 days' + interval '4 hours' or
 									 to_timestamp(l.time_updated) between pk.route_date_time - interval '21 days' + interval '4 hours' and pk.next_delivery_ts - interval '21 days' + interval '4 hours' or
 									 to_timestamp(l.time_updated) between pk.route_date_time - interval '28 days' + interval '4 hours' and pk.next_delivery_ts - interval '28 days' + interval '4 hours' or

 									 to_timestamp(l.time_updated) between pk.route_date_time - interval '35 days' + interval '4 hours' and pk.next_delivery_ts - interval '35 days' + interval '4 hours' or
 									 to_timestamp(l.time_updated) between pk.route_date_time - interval '42 days' + interval '4 hours' and pk.next_delivery_ts - interval '42 days' + interval '4 hours' or
 									 to_timestamp(l.time_updated) between pk.route_date_time - interval '49 days' + interval '4 hours' and pk.next_delivery_ts - interval '49 days' + interval '4 hours' or
 									 to_timestamp(l.time_updated) between pk.route_date_time - interval '56 days' + interval '4 hours' and pk.next_delivery_ts - interval '56 days' + interval '4 hours' or

 									 to_timestamp(l.time_updated) between pk.route_date_time - interval '63 days' + interval '4 hours' and pk.next_delivery_ts - interval '63 days' + interval '4 hours' or
 									 to_timestamp(l.time_updated) between pk.route_date_time - interval '70 days' + interval '4 hours' and pk.next_delivery_ts - interval '70 days' + interval '4 hours' or
 									 to_timestamp(l.time_updated) between pk.route_date_time - interval '77 days' + interval '4 hours' and pk.next_delivery_ts - interval '77 days' + interval '4 hours' or
 									 to_timestamp(l.time_updated) between pk.route_date_time - interval '84 days' + interval '4 hours' and pk.next_delivery_ts - interval '84 days' + interval '4 hours'
									*/

									)
								group by 1, 2
							) period_12_weeks

						on whole_12_weeks.kiosk_id = period_12_weeks.kiosk_id
					 ) existing_kiosk_with_sales_ratio 
					 
				on scheduled_kiosks.kiosk_id = existing_kiosk_with_sales_ratio.kiosk_id and scheduled_kiosks.route_date_time = existing_kiosk_with_sales_ratio.route_date_time;
					
	end;

$$;


ALTER FUNCTION inm.pick_get_sales_period_ratio(start_ts timestamp with time zone, end_ts timestamp with time zone) OWNER TO dbservice;

--
-- Name: pick_get_summary(date); Type: FUNCTION; Schema: inm; Owner: dbservice
--

CREATE FUNCTION inm.pick_get_summary(target_date date) RETURNS TABLE(property text, name text, value text)
    LANGUAGE plpgsql
    AS $$

/*
Returns pick summary for a given date.
*/

declare 
	pick_tickets_generated integer;
	-- one-based arrays of 3 numbers, 1 for target date and 2 for the same weekday one and two weeks ago
	ticket integer ARRAY;
	demand integer ARRAY;
	allocation integer ARRAY;
	property text;
	name text;
	value text;
	total integer;
	result_row record;
	kiosks_added text;
	kiosks_removed text;
	percentage integer;

begin
	
	FOR i IN 0..2 LOOP
 		select count(*) from inm.pick_route where pick_date = target_date - 7*i  into total;
		ticket[i+1] = total; -- convert to one-based index
		select sum(qty) from inm.pick_demand where pick_date = target_date - 7*i into total;
		demand[i+1] = total;
		select sum(qty) from inm.pick_allocation where pick_date = target_date - 7*i into total;
		allocation[i+1] = total;
   	END LOOP;
	
	select array_to_string(array_agg(cast (kiosk_id as varchar) order by kiosk_id), ',') from inm.pick_route 
		where pick_date = target_date and kiosk_id not in
			(select kiosk_id from inm.pick_route where pick_date = target_date - 7)
	into kiosks_added;
	
	select array_to_string(array_agg(cast (kiosk_id as varchar) order by kiosk_id), ',') from inm.pick_route 
		where pick_date = target_date - 7  and kiosk_id not in
			(select kiosk_id from inm.pick_route where pick_date = target_date)
	into kiosks_removed;
		
	property = 'stats';
	name = 'pick tickets today/ -7 days/ -14 days: ';
	value = ticket[1] || '/' || ticket[2] || '/' || ticket[3];
	return query select property, name, value;
	
	property = 'stats';
	name = 'demand qty today/ -7 days/ -14 days: ';
	value = coalesce(demand[1], 0) || '/' || coalesce(demand[2],0) || '/' || coalesce(demand[3],0);
	return query select property, name, value;
	
	property = 'stats';
	name = 'allocation qty today/ -7 days/ -14 days: ';
	value = coalesce(allocation[1], 0) || '/' || coalesce(allocation[2], 0) || '/' || coalesce(allocation[3], 0);
	return query select property, name, value;
	
	property = 'stats';
	name = 'kiosks added';
	value = kiosks_added;
	return query select property, name, value;
	
	property = 'stats';
	name = 'kiosks removed';
	value = kiosks_removed;
	return query select property, name, value;
	
-- 	property = 'stats';
-- 	name = 'allocation summary';
-- 	percentage = 100*cast(demand[1] as decimal)/cast(allocation[1] as decimal);
-- 	value = 'allocation: ' || allocation[1] || ', demand: ' || demand[1] || ', allocation percentage: ' || percentage;
-- 	return query select property, name, value;
end

$$;


ALTER FUNCTION inm.pick_get_summary(target_date date) OWNER TO dbservice;

--
-- Name: pick_get_ticket(date); Type: FUNCTION; Schema: inm; Owner: dbservice
--

CREATE FUNCTION inm.pick_get_ticket(target_date date) RETURNS TABLE(pick_station bigint, vendor character varying, item_code bigint, item_name character varying, site_code bigint, site_name character varying, proposed_supply integer, total_pick_qty bigint, total_pick_sku integer, driver_name character varying, route_date date, route_time time without time zone, route_date_time timestamp without time zone, route_number character varying, restrictions text, address character varying, pull_date date, delivery_order integer, pick_order integer)
    LANGUAGE plpgsql
    AS $$

	declare latest_import_ts timestamp;
	declare plan_window_start timestamp;
	declare plan_window_stop timestamp;
begin
	-- return pick ticket data for the latest pick
	
	-- calculate various date params
	select max(import_ts) from mixalot.inm_data into latest_import_ts;
	select i.route_date from mixalot.inm_data i
		where import_ts = latest_import_ts and data_type = 'Plan Window Start'
		into plan_window_start;
	select i.route_date from mixalot.inm_data i
		where import_ts = latest_import_ts and data_type = 'Plan Window Stop'
		into plan_window_stop;
	
	if target_date is null
		then target_date = plan_window_start::date;
	end if;
		
	return query
		select 
				p.pick_station, p.vendor, p.id, p.title ItemName,
				k.id sitecode, k.title sitename, a.qty proposed_supply, 
				sum(a.qty) over(partition by k.id, route.route_date) total_pick_qty,
				-1 total_pick_sku, route.driver_name DriverName,
				route.route_date RouteDate, route.route_time RouteTime,
				route.route_date + route.route_time route_date_time, route.route_number,
				r.restrictions,
				k.address,
				pd.pull_date,
				cast(route.delivery_order as integer),
				spo.pick_order
			from inm.pick_allocation a 
				left join pantry.kiosk k on a.kiosk_id = k.id
				-- left join mixalot.inm_kiosk_restriction_list r on k.id = r.kiosk_id
				left join inm.kiosk_restriction_list r on k.id = r.kiosk_id
				join pantry.product p on a.sku_id = p.id
				
				-- FIXME remove all following comments after verify 2018-12-05
				-- Actually, need to compare both route_date and route_time so the next line is not correct
				-- join inm.pick_route route on a.route_date=route.route_date and a.kiosk_id = route.kiosk_id 
				-- so instead use this line:
				join inm.pick_route route on a.pick_date=route.pick_date and a.route_date = route.route_date and a.kiosk_id = route.kiosk_id
				
				left join inm.get_pull_date(plan_window_start, plan_window_stop) pd on a.kiosk_id = pd.kiosk_id
				left join mixalot.sku_pick_order(latest_import_ts) spo on p.id = spo.sku_id
			where k.campus_id = 87
			and a.pick_date = target_date;
end

$$;


ALTER FUNCTION inm.pick_get_ticket(target_date date) OWNER TO dbservice;

--
-- Name: pick_submit(date, integer, integer); Type: FUNCTION; Schema: inm; Owner: dbservice
--

CREATE FUNCTION inm.pick_submit(target_date date, overwrite integer DEFAULT 0, wait_time_seconds integer DEFAULT 300, OUT submit_status text) RETURNS text
    LANGUAGE plpgsql
    AS $$

/*
Purpose - Submit a pick with task_option controlling how to deal with conflict.

Input -
  target_date: pick date
  overwrite: 0 or 1. If 1, overwrite old pick.
  timeout_seconds: minimum amount of time the task can be in status = "started" before it's considered timed out 
Return -
  submitted_status:
  	submitted - pick submitted.
	started - a pick already in progress for target date.
	ready - a completed pick already existed (and overwrite=0)
*/

declare
	_status text;

begin
	-- delete existing pick for target date if overwrite=1
	if overwrite = 1 
		then delete from inm.pick_list where pick_date = target_date;
	-- delete failed and timed out items
	else 
		delete from inm.pick_list p
			-- where (pick_date = target_date and create_ts + wait_time_seconds < now())
			where (pick_date = target_date 
				   	and extract(epoch from now() - create_ts) > timeout_seconds)
				or status = 'failed';
	end if;
	
	-- remaining pick_list entry for target date is a pick that is in progress and should not be deleted  
	select status
		from inm.pick_list where pick_date = target_date
		into _status;
			
	if _status is null
		then insert into inm.pick_list(pick_date, timeout_seconds) values(target_date, wait_time_seconds);
		submit_status = 'submitted';
	else submit_status = _status;		
	end if;
end;

$$;


ALTER FUNCTION inm.pick_submit(target_date date, overwrite integer, wait_time_seconds integer, OUT submit_status text) OWNER TO dbservice;

--
-- Name: sync_restriction_by_property(integer, character varying); Type: FUNCTION; Schema: inm; Owner: dbservice
--

CREATE FUNCTION inm.sync_restriction_by_property(kiosk_id integer, restriction character varying) RETURNS TABLE(status character varying)
    LANGUAGE plpgsql ROWS 10
    AS $$

begin
	-- sync restrictions by properties with inm gsheets.
	
	-- boiler plate function...to be completed
	-- update inm.restrictions set kiosk...
		
	return query
		select 
		    'Ok';
end

$$;


ALTER FUNCTION inm.sync_restriction_by_property(kiosk_id integer, restriction character varying) OWNER TO dbservice;

--
-- Name: pick_get_delivery_schedule(date); Type: FUNCTION; Schema: inm_backup; Owner: dbservice
--

CREATE FUNCTION inm_backup.pick_get_delivery_schedule(target_date date) RETURNS TABLE(driver_name character varying, route_date_time timestamp with time zone, kiosk_id integer, kiosk_title character varying, address character varying, delivery_order integer)
    LANGUAGE plpgsql
    AS $$

	declare latest_import_ts timestamp;
	declare plan_window_start timestamp;
	declare plan_window_stop timestamp;

/*
Purpose: return INM delivery schedule for a pick window.
Input
	target_date: pick_date
Return
	Data to generate the drivers sheets
*/
begin
	return query
		-- comment appropriate line to switch between optimo and bringg
		select * from inm.pick_get_delivery_schedule_optimo(target_date);
		--select * from inm.pick_get_delivery_schedule_bringg(target_date);
end;

$$;


ALTER FUNCTION inm_backup.pick_get_delivery_schedule(target_date date) OWNER TO dbservice;

--
-- Name: pick_get_demand_weekly_by_velocity(); Type: FUNCTION; Schema: inm_backup; Owner: dbservice
--

CREATE FUNCTION inm_backup.pick_get_demand_weekly_by_velocity() RETURNS TABLE(kiosk_id bigint, sku_group_id integer, fc_title text, demand_weekly numeric)
    LANGUAGE plpgsql
    AS $$

/*
Purpose: return INM weekly demand by velocity
*/

begin
	return query
		select dwwom.kiosk_id , sg.id, cast(sg.fc_title as text),
			cast(
				-- kiosk live less than 4 week
				case when ws_live < 4
				then greatest(
					coalesce (demand_weekly_wo_min, 0),
					kc.start_level * sgc.default_level * coalesce(ksms.scale, 1.0) * kc.manual_multiplier * sgc.scale
					)
				-- kiosk live longer than 4 week
				else greatest(
					coalesce (demand_weekly_wo_min, 0),
					kc.min_level * sgc.default_level * coalesce(ksms.scale, 1.0) * kc.scale * kc.manual_multiplier * sgc.scale
					)
				end as decimal(4,2)) as wk_demand
				
			from  inm.pick_get_demand_weekly_wo_min() dwwom
				  left join inm.kiosk_control kc on dwwom.kiosk_id = kc.kiosk_id
				  left join inm.sku_group sg on dwwom.sku_group = sg.fc_title
				  left join inm.sku_group_control sgc on sgc.sku_group_id = sg.id
				  left join inm.kiosk_sku_group_manual_scale ksms on ksms.kiosk_id = dwwom.kiosk_id and ksms.sku_group_id = sg.id;
end;

$$;


ALTER FUNCTION inm_backup.pick_get_demand_weekly_by_velocity() OWNER TO dbservice;

--
-- Name: pick_get_demand_weekly_by_velocity_20190108(); Type: FUNCTION; Schema: inm_backup; Owner: dbservice
--

CREATE FUNCTION inm_backup.pick_get_demand_weekly_by_velocity_20190108() RETURNS TABLE(kiosk_id bigint, sku_group_id integer, fc_title text, demand_weekly numeric, kc_start_level numeric, kc_min_level numeric, kc_scale numeric, kc_manual_multiplier numeric, sgc_default_level numeric, sgc_scale numeric, ksms_scale numeric, ws_live bigint, velocity_demand numeric)
    LANGUAGE plpgsql
    AS $$
/*
Purpose: return INM weekly demand by velocity
*/

begin
	return query
		select cast(kc.kiosk_id as bigint) , sg.id, cast(sg.fc_title as text),
			cast(
				-- kiosk live less than 4 week
				case when coalesce(dwwom.ws_live, 0) < 4
				then greatest(
					coalesce (demand_weekly_wo_min * coalesce(ksms.scale, 1.0) * kc.manual_multiplier * sgc.scale, 0),
					coalesce (kc.start_level * sgc.default_level * kc.manual_multiplier * sgc.scale, 0)
					)
				-- kiosk live longer than 4 week
				else greatest(
					coalesce (demand_weekly_wo_min * coalesce(ksms.scale, 1.0) * kc.manual_multiplier * sgc.scale, 0),
					coalesce (kc.min_level * sgc.default_level * coalesce(ksms.scale, 1.0) * kc.manual_multiplier * sgc.scale, 0)
					)
				end as decimal(4,2)) as wk_demand,
				
				kc.start_level, kc.min_level, kc.scale, kc.manual_multiplier, sgc.default_level, sgc.scale, coalesce(ksms.scale, 1.0) , coalesce(dwwom.ws_live, 0),
				dwwom.demand_weekly_wo_min
				
			from inm.sku_group sg
				cross join inm.kiosk_control kc
				left join inm.kiosk_sku_group_manual_scale ksms on ksms.kiosk_id=kc.kiosk_id and ksms.sku_group_id=sg.id
				left join inm.sku_group_control sgc on sgc.sku_group_id = sg.id
				left join inm.pick_get_demand_weekly_wo_min() dwwom on dwwom.kiosk_id = kc.kiosk_id and dwwom.sku_group = sg.fc_title;
end;

$$;


ALTER FUNCTION inm_backup.pick_get_demand_weekly_by_velocity_20190108() OWNER TO dbservice;

--
-- Name: pick_get_demand_weekly_wo_min_20190108(); Type: FUNCTION; Schema: inm_backup; Owner: dbservice
--

CREATE FUNCTION inm_backup.pick_get_demand_weekly_wo_min_20190108() RETURNS TABLE(kiosk_id bigint, sku_group character varying, sample_size bigint, dt_avg numeric, dt_std numeric, w_departure_time numeric, preference numeric, pref_total numeric, ws_avg numeric, ws_std numeric, ws_live bigint, demand_weekly_wo_min numeric)
    LANGUAGE plpgsql
    AS $$

/*
Purpose: return INM weekly demand without min by velocity
*/

begin
	return query
			select *,
	round((t7.preference/t7.pref_total)*(t7.ws_avg+t7.ws_std), 2) as demand_weekly_wo_min
from (
	select t4.kiosk_id,
		t4.sku_group,
		t4.sample_size,
		t4.dt_avg,
		t4.dt_std,
		t4.w_departure_time,
		t4.preference,
		sum(t4.preference) over (partition by t4.kiosk_id) as pref_total,
		t6.ws_avg,
		t6.ws_std,
		t6.ws_live
	from (
		select t3.kiosk_id, 
			t3.sku_group, 
			count(t3.purchase_index) as sample_size,
			round((avg(t3.departure_time))::numeric, 2) as dt_avg,
			coalesce(round((stddev(t3.departure_time))::numeric, 2), 0) as dt_std,
			round(sum(t3.departure_time*t3.w)/sum(t3.w)::numeric, 2) as w_departure_time,
			least(round(1.00/(sum(t3.departure_time*t3.w)/sum(t3.w))::numeric, 2), 0.20) as preference
		from (
			select *,
				greatest(coalesce(round((t2.time_sold - greatest(t2.last_sale, t2.time_stocked))::numeric/3600, 2), 50.00), 1.00) as departure_time,
				0 as qty_sold,
				1 as w
				--(t2.purchase_index - t2.last_purchase_index) as qty_sold,
				--coalesce(round((t2.purchase_index - t2.last_purchase_index)::numeric/greatest(coalesce((t2.time_sold - greatest(t2.last_sale, t2.time_stocked))::numeric/3600, 100.00), 1.00), 2), 1.00) as w
			from (
				select *,
					lag(t1.time_sold, 1) over (partition by t1.kiosk_id, t1.sku_group order by t1.time_sold) as last_sale,
					lag(t1.purchase_index, 1) over (partition by t1.kiosk_id, t1.sku_group order by t1.time_sold) as last_purchase_index
				from (
					select k.kiosk_id,
						p.sku_group,
						l.time_stocked,
						l.time_sold,
						l.purchase_index
					from (
						select k.id as kiosk_id
						from pantry.kiosk k
						where k.campus_id=87
							and k.archived=0
							and k.enable_reporting=1
							--and k.id=1274
					) k
					cross join (
						select distinct fc_title as sku_group
						from pantry.product p
						where p.campus_id=87
							and p.archived=0
							and p.fc_title is not null
							and p.fc_title!='N/A'
						order by p.fc_title asc
					) p
					left outer join (
						select l.kiosk_id as kiosk_id,
							p.fc_title as sku_group,
							l.time_created as time_stocked, 
							l.time_updated as time_sold,
							row_number() over (partition by l.kiosk_id order by l.time_updated) as purchase_index
						from pantry.label l
							join pantry.product p on l.product_id=p.id
						where l.kiosk_id is not null
							and l.status='sold'
							and to_timestamp(l.time_updated) at time zone 'US/Pacific' > date_trunc('week', current_timestamp) - interval '24 weeks'
							and p.campus_id=87
							and p.archived=0
							and p.fc_title is not null
					) l on k.kiosk_id=l.kiosk_id and p.sku_group=l.sku_group
					order by k.kiosk_id, p.sku_group, l.purchase_index
				) t1
			) t2
		) t3
		group by t3.kiosk_id, t3.sku_group
	) t4
	join 
	(select t5.kiosk_id, round(avg(units_sold), 2) ws_avg, round(stddev(units_sold), 2) ws_std, count(units_sold) ws_live
		from (
			SELECT concat(kk.kiosk_id::character varying(4), ' ', kk.woy) AS key,
				kk.kiosk_id,
				kk.woy,
				ss.units_sold
			FROM (
				SELECT k.id AS kiosk_id,
					generate_series(1, 52) AS woy
				FROM pantry.kiosk k
				WHERE k.campus_id = 87 AND k.archived = 0 AND k.enable_reporting = 1 AND k.enable_monitoring = 1) kk
			LEFT JOIN ( 
				SELECT s.kiosk_id,
					date_part('week'::text, s.ts) AS woy,
					count(*) AS units_sold
				FROM byte_epcssold_3months s
				GROUP BY s.kiosk_id, (date_part('week'::text, s.ts))) ss ON kk.kiosk_id = ss.kiosk_id AND kk.woy::double precision = ss.woy
			ORDER BY ss.kiosk_id, ss.woy) t5
		group by t5.kiosk_id
		order by t5.kiosk_id asc
	) t6 on t4.kiosk_id=t6.kiosk_id) t7;

			
end;

$$;


ALTER FUNCTION inm_backup.pick_get_demand_weekly_wo_min_20190108() OWNER TO dbservice;

--
-- Name: pick_get_order_with_sales_ratio(timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: inm_backup; Owner: dbservice
--

CREATE FUNCTION inm_backup.pick_get_order_with_sales_ratio(start_ts timestamp with time zone, end_ts timestamp with time zone) RETURNS TABLE(kiosk_id integer, route_date_time timestamp with time zone, sku_group_id integer, fc_title text, week_demand_qty integer, plan_demand_qty numeric, plan_order_qty numeric)
    LANGUAGE plpgsql
    AS $$
  /*
  Purpose - return INM order based on sales ratio for pick sales period (time between deliveries)
  Input -
    start_ts: plan window start date time with time zone
    end_ts: plan window end date time with time zone
  Return -
    kiosk_id: together with route_date_time is unique for the plan window
    route_date_time: route starting date time
    fc_title: sku group name
    week_demand_qty: demand based on once a week delivery (without minimum)
    plan_demand_qty: demand based on sales ratio for pick sales period (without minimum)
    plan_order_qty: order based on sales ratio for pick sales period
  */

declare latest_import_ts_for_pick_window timestamp with time zone;
begin
  -- get the latest import_ts for the same day as start_ts
  select max(import_ts) from mixalot.inm_data i
  where import_ts::date = start_ts::date and data_type = 'Par Unconstrained wo Min' -- make sure import contain this data_type
    into latest_import_ts_for_pick_window;
  return query
    --  Given
    --		sales period = time between this pick delivery and next pick delivery (may be changed to pick times in the future)
    --		inm.qty = week demand
    --		sr.sales_ratio = sale ratio for this sum items sold for pick sales period for the last 4 weeks vs items sold for the last 4 weeks 
    -- 	if item is restricted (inm_qty=0), then set demand to 0. 
    --  else 
    --		if item doesn't exist in the kiosk (inv.count is null), set its inv count to 0
    -- 		order_before_min_max = 1.4 * sr.sales_ratio * inm.qty - inv.count
    -- 		final_order = min + order_before_min_max, capped by max as defined for each sku group

    -- FIXME: temp increase for after Thanksgiving. Change mutiplier from 1.52 (in 2 places below) to 1.4 on 2018-12-17
    select sr.kiosk_id, sr.route_date_time, sga.id, inm.fc_title, inm.qty week_demand_qty,
           cast(1.52 * sr.sales_ratio * inm.qty as numeric (8,2)) plan_demand_qty,
           case
             -- restricted item
             when inm.qty = 0 then 0
             else
               -- cap at week_qty
               least(
                 -- change minimum is 0 (don't remove from a kiosk)
                   least(greatest(ceiling(1.52 * sr.sales_ratio * inm.qty) + sga.minimum_kiosk_qty - coalesce(inv.count, 0),
                                  0) /* change negative demand to 0 */
                     , sga.maximum_kiosk_qty),
                   inm.qty)
             end as plan_order_qty -- end case

    from inm.pick_get_sales_period_ratio(start_ts, end_ts) sr
           join mixalot.inm_data inm
                on sr.kiosk_id = inm.kiosk_id
                  and inm.data_type = 'Par Unconstrained wo Min'
                  and inm.import_ts = latest_import_ts_for_pick_window
           join inm.sku_group_attribute sga
                on sga.title = inm.fc_title
           left join mixalot.inm_kiosk_projected_stock inv
                     on inm.kiosk_id = inv.kiosk_id and inm.fc_title = inv.fc_title;
end;

$$;


ALTER FUNCTION inm_backup.pick_get_order_with_sales_ratio(start_ts timestamp with time zone, end_ts timestamp with time zone) OWNER TO dbservice;

--
-- Name: pick_get_order_with_velocity(timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: inm_backup; Owner: dbservice
--

CREATE FUNCTION inm_backup.pick_get_order_with_velocity(start_ts timestamp with time zone, end_ts timestamp with time zone) RETURNS TABLE(kiosk_id integer, route_date_time timestamp with time zone, sku_group_id integer, fc_title text, week_demand_qty numeric, plan_demand_qty numeric, plan_order_qty numeric)
    LANGUAGE plpgsql
    AS $$

/*
Purpose - return INM order based on sales ratio for pick sales period (time between deliveries)
Input -
  start_ts: plan window start date time with time zone
  end_ts: plan window end date time with time zone
Return -
  kiosk_id: together with route_date_time is unique for the plan window
  route_date_time: route starting date time
  fc_title: sku group name
  week_demand_qty: demand based on once a week delivery (without minimum)
  plan_demand_qty: demand based on sales ratio for pick sales period (without minimum)
  plan_order_qty: order based on sales ratio for pick sales period
*/

begin
	return query
		--  Given
		--		sales period = time between this pick delivery and next pick delivery (may be changed to pick times in the future)
		--		inm.demand_weekly = week demand
		--		sr.sales_ratio = sale ratio for this sum items sold for pick sales period for the last 4 weeks vs items sold for the last 4 weeks 
		-- 	if item is restricted (inm_qty=0), then set demand to 0. 
		--  else 
		--		if item doesn't exist in the kiosk (inv.count is null), set its inv count to 0
		-- 		order_before_min_max = 1.4 * sr.sales_ratio * inm.demand_weekly - inv.count
		-- 		final_order = min + order_before_min_max, capped by max as defined for each sku group
		
		select sr.kiosk_id, sr.route_date_time, sga.id, dwbv.fc_title, dwbv.demand_weekly as week_demand_qty, 
			cast(1.4 * sr.sales_ratio * dwbv.demand_weekly as numeric (8,2)) plan_demand_qty,
			case 
				-- restricted item if demand_weekly is 0 or kiosk_sku_group manual scale is zero
				when dwbv.demand_weekly = 0 or ksms.scale = 0.0 then 0 
				else
					-- cap at week_qty
					least(
						-- change minimum is 0 (don't remove from a kiosk)
						least(greatest(ceiling(1.4 * sr.sales_ratio * dwbv.demand_weekly) + sga.minimum_kiosk_qty - coalesce(inv.count, 0),
											  0) /* change negative demand to 0 */
								   , sga.maximum_kiosk_qty),
						dwbv.demand_weekly)
			end as plan_order_qty -- end case
					   
			from inm.pick_get_sales_period_ratio(start_ts, end_ts) sr
			
				join inm.pick_get_demand_weekly_by_velocity() dwbv
					on sr.kiosk_id = dwbv.kiosk_id 
												
				join inm.sku_group_attribute sga
					on sga.title = dwbv.fc_title			
				left join mixalot.inm_kiosk_projected_stock inv
					on dwbv.kiosk_id = inv.kiosk_id and dwbv.fc_title = inv.fc_title
				left join inm.kiosk_sku_group_manual_scale ksms
					on sr.kiosk_id = ksms.kiosk_id and sga.id = ksms.sku_group_id;				
	end;

$$;


ALTER FUNCTION inm_backup.pick_get_order_with_velocity(start_ts timestamp with time zone, end_ts timestamp with time zone) OWNER TO dbservice;

--
-- Name: pick_get_plan_kiosk_bringg(timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: inm_backup; Owner: dbservice
--

CREATE FUNCTION inm_backup.pick_get_plan_kiosk_bringg(plan_window_start timestamp with time zone, plan_window_stop timestamp with time zone) RETURNS TABLE(kiosk_id integer, route_date_time timestamp with time zone, driver_name character varying, location_name character varying, next_delivery_ts timestamp with time zone, time_to_next_delivery interval, days_to_next_delivery double precision, delivery_order bigint)
    LANGUAGE plpgsql
    AS $$

/*
Purpose: return INM plan kiosks for a pick window.
*/

begin
	return query
		select ds.kiosk_id, ds.route_date_time, ds.driver_name, k.title, ps.next_delivery_ts,
		ps.next_delivery_ts - ds.route_date_time as time_to_next_delivery,		
		  case 
		  	when ps.next_delivery_ts - ds.route_date_time between interval '12 hours' and interval '24 hours' then 1
			else extract(day from ps.next_delivery_ts - ds.route_date_time)
			end as days_to_next_delivery,
		  row_number() over (order by ds.route_date_time asc) as delivery_order
		 		
		from
		-- kiosk_id, delivery_date
		(select t.kiosk_id, t.route_date_time, t.driver_name from
			(select cast(kid as integer) as kiosk_id, rs.route_date_time, rs.driver_name,
				rank() over (partition by kid, rs.route_date_time order by rs.route_date_time) as r
				from bringg.order rs
				where rs.route_date_time >= plan_window_start -- look at routes starting at plan winddow start
			 	and rs.status <> 7
				) t
				where r = 1) ds

		left join 
		-- kiosk_id, pull_date
		(select t.kiosk_id, t.route_date_time next_delivery_ts from
			(select cast(kid as integer) as kiosk_id, rs.route_date_time,
				rank() over (partition by kid order by rs.route_date_time) as r
				from bringg.order rs
				where rs.route_date_time >= plan_window_start -- look at routes starting at plan window start
			 	and rs.status <> 7
				) t
				where r = 2) ps

			on ds.kiosk_id = ps.kiosk_id
			join pantry.kiosk k on ds.kiosk_id = k.id
			where ds.route_date_time between plan_window_start and plan_window_stop
			and k.campus_id= 87;	
end;

$$;


ALTER FUNCTION inm_backup.pick_get_plan_kiosk_bringg(plan_window_start timestamp with time zone, plan_window_stop timestamp with time zone) OWNER TO dbservice;

--
-- Name: pick_get_ticket(date); Type: FUNCTION; Schema: inm_backup; Owner: dbservice
--

CREATE FUNCTION inm_backup.pick_get_ticket(target_date date) RETURNS TABLE(pick_station bigint, vendor character varying, item_code bigint, item_name character varying, site_code bigint, site_name character varying, proposed_supply integer, total_pick_qty bigint, total_pick_sku integer, driver_name character varying, route_date date, route_time time without time zone, route_date_time timestamp without time zone, route_number character varying, restrictions text, address character varying, pull_date date, delivery_order integer, pick_order integer)
    LANGUAGE plpgsql
    AS $$

	declare latest_import_ts timestamp;
	declare plan_window_start timestamp;
	declare plan_window_stop timestamp;
begin
	-- return pick ticket data for the latest pick
	
	-- calculate various date params
	select max(import_ts) from mixalot.inm_data into latest_import_ts;
	select i.route_date from mixalot.inm_data i
		where import_ts = latest_import_ts and data_type = 'Plan Window Start'
		into plan_window_start;
	select i.route_date from mixalot.inm_data i
		where import_ts = latest_import_ts and data_type = 'Plan Window Stop'
		into plan_window_stop;
	
	if target_date is null
		then target_date = plan_window_start::date;
	end if;
		
	return query
		select 
				p.pick_station, p.vendor, p.id, p.title ItemName,
				k.id sitecode, k.title sitename, a.qty proposed_supply, 
				sum(a.qty) over(partition by k.id, route.route_date) total_pick_qty,
				-1 total_pick_sku, route.driver_name DriverName,
				route.route_date RouteDate, route.route_time RouteTime,
				route.route_date + route.route_time route_date_time, route.route_number,
				r.restrictions,
				k.address,
				pd.pull_date,
				cast(route.delivery_order as integer),
				spo.pick_order
			from inm.pick_allocation a 
				left join pantry.kiosk k on a.kiosk_id = k.id
				-- left join mixalot.inm_kiosk_restriction_list r on k.id = r.kiosk_id
				left join inm.kiosk_restriction_list r on k.id = r.kiosk_id
				join pantry.product p on a.sku_id = p.id
				
				-- FIXME remove all following comments after verify 2018-12-05
				-- Actually, need to compare both route_date and route_time so the next line is not correct
				-- join inm.pick_route route on a.route_date=route.route_date and a.kiosk_id = route.kiosk_id 
				-- so instead use this line:
				join inm.pick_route route on a.pick_date=route.pick_date and a.route_date = route.route_date and a.kiosk_id = route.kiosk_id
				
				left join inm.get_pull_date(plan_window_start, plan_window_stop) pd on a.kiosk_id = pd.kiosk_id
				left join mixalot.sku_pick_order(latest_import_ts) spo on p.id = spo.sku_id
			where k.campus_id = 87
			and a.pick_date = target_date;
end

$$;


ALTER FUNCTION inm_backup.pick_get_ticket(target_date date) OWNER TO dbservice;

--
-- Name: pick_get_demand_weekly_by_velocity(); Type: FUNCTION; Schema: inm_beta; Owner: dbservice
--

CREATE FUNCTION inm_beta.pick_get_demand_weekly_by_velocity() RETURNS TABLE(kiosk_id bigint, sku_group_id integer, fc_title text, demand_weekly numeric, kc_start_level numeric, kc_min_level numeric, kc_scale numeric, kc_manual_multiplier numeric, sgc_default_level numeric, sgc_scale numeric, ksms_scale numeric, ws_live bigint, velocity_demand numeric)
    LANGUAGE plpgsql
    AS $$

/*
Purpose: return INM weekly demand by velocity
*/

begin
	return query
		select cast(kc.kiosk_id as bigint) , sg.id, cast(sg.fc_title as text),
			cast(
				-- kiosk live less than 4 week
				case when coalesce(dwwom.ws_live, 0) < 4
				then greatest(
					coalesce (demand_weekly_wo_min, 0),
					kc.start_level * sgc.default_level * coalesce(ksms.scale, 1.0) * kc.manual_multiplier * sgc.scale
					)
				-- kiosk live longer than 4 week
				else greatest(
					coalesce (demand_weekly_wo_min, 0),
					kc.min_level * sgc.default_level * coalesce(ksms.scale, 1.0) * kc.scale * kc.manual_multiplier * sgc.scale
					)
				end as decimal(4,2)) as wk_demand,
				
				kc.start_level, kc.min_level, kc.scale, kc.manual_multiplier, sgc.default_level, sgc.scale, coalesce(ksms.scale, 1.0) , coalesce(dwwom.ws_live, 0),
				dwwom.demand_weekly_wo_min
				
			from inm.sku_group sg
				cross join inm.kiosk_control kc
				left join inm.kiosk_sku_group_manual_scale ksms on ksms.kiosk_id=kc.kiosk_id and ksms.sku_group_id=sg.id
				left join inm.sku_group_control sgc on sgc.sku_group_id = sg.id
				left join inm.pick_get_demand_weekly_wo_min() dwwom on dwwom.kiosk_id = kc.kiosk_id and dwwom.sku_group = sg.fc_title;
end;

$$;


ALTER FUNCTION inm_beta.pick_get_demand_weekly_by_velocity() OWNER TO dbservice;

--
-- Name: pick_get_demand_weekly_wo_min(); Type: FUNCTION; Schema: inm_beta; Owner: dbservice
--

CREATE FUNCTION inm_beta.pick_get_demand_weekly_wo_min() RETURNS TABLE(kiosk_id bigint, sku_group character varying, sample_size bigint, dt_avg numeric, dt_std numeric, w_departure_time numeric, preference numeric, pref_total numeric, ws_avg numeric, ws_std numeric, ws_live bigint, demand_weekly_wo_min numeric)
    LANGUAGE plpgsql
    AS $$

/*
Purpose: return INM weekly demand without min by velocity
*/

begin
	return query
			select *,
	round((t7.preference/t7.pref_total)*(t7.ws_avg+t7.ws_std), 2) as demand_weekly_wo_min
from (
	select t4.kiosk_id,
		t4.sku_group,
		t4.sample_size,
		t4.dt_avg,
		t4.dt_std,
		t4.w_departure_time,
		t4.preference,
		sum(t4.preference) over (partition by t4.kiosk_id) as pref_total,
		t6.ws_avg,
		t6.ws_std,
		t6.ws_live
	from (
		select t3.kiosk_id, 
			t3.sku_group, 
			count(t3.purchase_index) as sample_size,
			round((avg(t3.departure_time))::numeric, 2) as dt_avg,
			coalesce(round((stddev(t3.departure_time))::numeric, 2), 0) as dt_std,
			round(sum(t3.departure_time*t3.w)/sum(t3.w)::numeric, 2) as w_departure_time,
			least(round(1.00/(sum(t3.departure_time*t3.w)/sum(t3.w))::numeric, 2), 0.20) as preference
		from (
			select *,
				greatest(coalesce(round((t2.time_sold - greatest(t2.last_sale, t2.time_stocked))::numeric/3600, 2), 50.00), 1.00) as departure_time,
				0 as qty_sold,
				1 as w
				--(t2.purchase_index - t2.last_purchase_index) as qty_sold,
				--coalesce(round((t2.purchase_index - t2.last_purchase_index)::numeric/greatest(coalesce((t2.time_sold - greatest(t2.last_sale, t2.time_stocked))::numeric/3600, 100.00), 1.00), 2), 1.00) as w
			from (
				select *,
					lag(t1.time_sold, 1) over (partition by t1.kiosk_id, t1.sku_group order by t1.time_sold) as last_sale,
					lag(t1.purchase_index, 1) over (partition by t1.kiosk_id, t1.sku_group order by t1.time_sold) as last_purchase_index
				from (
					select k.kiosk_id,
						p.sku_group,
						l.time_stocked,
						l.time_sold,
						l.purchase_index
					from (
						select k.id as kiosk_id
						from pantry.kiosk k
						where k.campus_id=87
							and k.archived=0
							and k.enable_reporting=1
							--and k.id=1274
					) k
					cross join (
						select distinct fc_title as sku_group
						from pantry.product p
						where p.campus_id=87
							and p.archived=0
							and p.fc_title is not null
							and p.fc_title!='N/A'
						order by p.fc_title asc
					) p
					left outer join (
						select l.kiosk_id as kiosk_id,
							p.fc_title as sku_group,
							l.time_created as time_stocked, 
							l.time_updated as time_sold,
							row_number() over (partition by l.kiosk_id order by l.time_updated) as purchase_index
						from pantry.label l
							join pantry.product p on l.product_id=p.id
						where l.kiosk_id is not null
							and l.status='sold'
							and to_timestamp(l.time_updated) at time zone 'US/Pacific' > date_trunc('week', current_timestamp) - interval '24 weeks'
							and p.campus_id=87
							and p.archived=0
							and p.fc_title is not null
					) l on k.kiosk_id=l.kiosk_id and p.sku_group=l.sku_group
					order by k.kiosk_id, p.sku_group, l.purchase_index
				) t1
			) t2
		) t3
		group by t3.kiosk_id, t3.sku_group
	) t4
	join 
	(select t5.kiosk_id, round(avg(units_sold), 2) ws_avg, round(stddev(units_sold), 2) ws_std, count(units_sold) ws_live
		from (
			SELECT concat(kk.kiosk_id::character varying(4), ' ', kk.woy) AS key,
				kk.kiosk_id,
				kk.woy,
				ss.units_sold
			FROM (
				SELECT k.id AS kiosk_id,
					generate_series(1, 52) AS woy
				FROM pantry.kiosk k
				WHERE k.campus_id = 87 AND k.archived = 0 AND k.enable_reporting = 1 AND k.enable_monitoring = 1) kk
			LEFT JOIN ( 
				SELECT s.kiosk_id,
					date_part('week'::text, s.ts) AS woy,
					count(*) AS units_sold
				FROM byte_epcssold_3months s
				GROUP BY s.kiosk_id, (date_part('week'::text, s.ts))) ss ON kk.kiosk_id = ss.kiosk_id AND kk.woy::double precision = ss.woy
			ORDER BY ss.kiosk_id, ss.woy) t5
		group by t5.kiosk_id
		order by t5.kiosk_id asc
	) t6 on t4.kiosk_id=t6.kiosk_id) t7;

			
end;

$$;


ALTER FUNCTION inm_beta.pick_get_demand_weekly_wo_min() OWNER TO dbservice;

--
-- Name: pick_get_order(timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: inm_beta; Owner: dbservice
--

CREATE FUNCTION inm_beta.pick_get_order(start_ts timestamp with time zone, end_ts timestamp with time zone) RETURNS TABLE(kiosk_id integer, route_date_time timestamp with time zone, sku_group_id integer, fc_title text, week_qty integer, plan_qty integer)
    LANGUAGE plpgsql ROWS 10000
    AS $$

/*
Purpose - return INM order for the next sale period which is the time between the deliveries of this pick and the next pick
Comment - Why go through this function and not call pick_get_order_with_velocity(start_date, end_date) directly? There are 2 reasons:
	1. We can replace pick_get_order_with_velocity with a newer fucntion here and not having to change the client code to test the new function.
	2. pick_get_order_with_velocity returns richer data that can be used for troubleshooting which is not necessary for production.

Input -
  start_ts: plan window start date time with time zone
  end_ts: plan window end date time with time zone
Return -
  kiosk_id: together with route_date_time is unique for the plan window
  route_date_time: route starting date time
  fc_title: sku group name
  plan_qty: order quantity for the above fc_title for the next sale period
*/

begin
	return query
		-- with sales ratio and velocity
		select ov.kiosk_id, ov.route_date_time, ov.sku_group_id, ov.fc_title, cast(ov.week_demand_qty as integer), cast(ov.plan_order_qty as integer) from inm_beta.pick_get_order_with_velocity(start_ts, end_ts) ov;
		
end;

$$;


ALTER FUNCTION inm_beta.pick_get_order(start_ts timestamp with time zone, end_ts timestamp with time zone) OWNER TO dbservice;

--
-- Name: pick_get_order_with_velocity(timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: inm_beta; Owner: dbservice
--

CREATE FUNCTION inm_beta.pick_get_order_with_velocity(start_ts timestamp with time zone, end_ts timestamp with time zone) RETURNS TABLE(kiosk_id integer, route_date_time timestamp with time zone, sku_group_id integer, fc_title text, week_demand_qty numeric, plan_demand_qty numeric, plan_order_qty numeric)
    LANGUAGE plpgsql
    AS $$

/*
Purpose - return INM order based on sales ratio for pick sales period (time between deliveries)
Input -
  start_ts: plan window start date time with time zone
  end_ts: plan window end date time with time zone
Return -
  kiosk_id: together with route_date_time is unique for the plan window
  route_date_time: route starting date time
  fc_title: sku group name
  week_demand_qty: demand based on once a week delivery (without minimum)
  plan_demand_qty: demand based on sales ratio for pick sales period (without minimum)
  plan_order_qty: order based on sales ratio for pick sales period
*/

begin
	return query
		--  Given
		--		sales period = time between this pick delivery and next pick delivery (may be changed to pick times in the future)
		--		inm.demand_weekly = week demand
		--		sr.sales_ratio = sale ratio for this sum items sold for pick sales period for the last 4 weeks vs items sold for the last 4 weeks 
		-- 	if item is restricted (inm_qty=0), then set demand to 0. 
		--  else 
		--		if item doesn't exist in the kiosk (inv.count is null), set its inv count to 0
		-- 		order_before_min_max = 1.4 * sr.sales_ratio * inm.demand_weekly - inv.count
		-- 		final_order = min + order_before_min_max, capped by max as defined for each sku group
		
		select sr.kiosk_id, sr.route_date_time, sgc.sku_group_id, dwbv.fc_title, dwbv.demand_weekly as week_demand_qty, 
			cast(1.4 * sr.sales_ratio * dwbv.demand_weekly as numeric (8,2)) plan_demand_qty,
			case 
				-- restricted item if demand_weekly is 0 or kiosk_sku_group manual scale is zero
				when dwbv.demand_weekly = 0 or ksms.scale = 0.0 then 0 
				else
					ceiling(
						-- change minimum is 0 (don't remove from a kiosk)
						least(greatest(least(1.4 * sr.sales_ratio * dwbv.demand_weekly, dwbv.demand_weekly) + sgc.min_qty - coalesce(inv.count, 0),
											  0) /* change negative demand to 0 */
								   , sgc.max_qty))
			end as plan_order_qty -- end case
					   
			from inm_beta.pick_get_sales_period_ratio(start_ts, end_ts) sr
			
				join inm_beta.pick_get_demand_weekly_by_velocity() dwbv
					on sr.kiosk_id = dwbv.kiosk_id 											
				join inm_beta.sku_group_control sgc
					on sgc.sku_group_id = dwbv.sku_group_id			
				left join mixalot.inm_kiosk_projected_stock inv
					on dwbv.kiosk_id = inv.kiosk_id and dwbv.fc_title = inv.fc_title
				left join inm_beta.kiosk_sku_group_manual_scale ksms
					on sr.kiosk_id = ksms.kiosk_id and sgc.sku_group_id = ksms.sku_group_id;				
	end;

$$;


ALTER FUNCTION inm_beta.pick_get_order_with_velocity(start_ts timestamp with time zone, end_ts timestamp with time zone) OWNER TO dbservice;

--
-- Name: pick_get_plan_kiosk(date); Type: FUNCTION; Schema: inm_beta; Owner: dbservice
--

CREATE FUNCTION inm_beta.pick_get_plan_kiosk(pick_date date) RETURNS TABLE(kiosk_id integer, route_date_time timestamp with time zone, driver_name character varying, location_name character varying, next_delivery_ts timestamp with time zone, time_to_next_delivery interval, days_to_next_delivery double precision, delivery_order bigint)
    LANGUAGE plpgsql
    AS $$

declare
	pst_plan_window_start_str text;
	plan_window_start timestamp with time zone;
	plan_window_stop timestamp with time zone;
/*
Purpose: return INM plan kiosks for a pick date.
*/

begin
	-- compose US/Pacific start window timestamp string
	pst_plan_window_start_str = cast(pick_date as text) || ' 13:00 -8';
	
	select into plan_window_start cast(pst_plan_window_start_str as timestamp with time zone);
	plan_window_stop = plan_window_start + interval '22 hours';
	return query
		select * from inm_beta.pick_get_plan_kiosk(plan_window_start, plan_window_stop);
end;

$$;


ALTER FUNCTION inm_beta.pick_get_plan_kiosk(pick_date date) OWNER TO dbservice;

--
-- Name: pick_get_plan_kiosk(timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: inm_beta; Owner: dbservice
--

CREATE FUNCTION inm_beta.pick_get_plan_kiosk(plan_window_start timestamp with time zone, plan_window_stop timestamp with time zone) RETURNS TABLE(kiosk_id integer, route_date_time timestamp with time zone, driver_name character varying, location_name character varying, next_delivery_ts timestamp with time zone, time_to_next_delivery interval, days_to_next_delivery double precision, delivery_order bigint)
    LANGUAGE plpgsql
    AS $$

/*
Purpose: return INM plan kiosks for a pick window.
*/

begin
	return query
		select ds.kiosk_id, ds.route_date_time, ds.driver_name, ds.location_name, ps.next_delivery_ts,
		ps.next_delivery_ts - ds.route_date_time as time_to_next_delivery,		
		  case 
		  	when ps.next_delivery_ts - ds.route_date_time between interval '12 hours' and interval '24 hours' then 1
			else extract(day from ps.next_delivery_ts - ds.route_date_time)
			end as days_to_next_delivery,
		  row_number() over (order by ds.route_date_time asc) as delivery_order
		  
		
		from
		-- kiosk_id, delivery_date
		(select t.kiosk_id, t.route_date_time, t.driver_name, t.location_name from
			(select location_number as kiosk_id, rs.route_date_time, rs.driver_name, rs.location_name,
				rank() over (partition by location_number, rs.route_date_time order by rs.route_date_time) as r
				from mixalot.route_stop rs
				where rs.route_date_time >= plan_window_start -- look at routes starting at plan winddow start
				and location_number > 0) t
				where r = 1) ds

		left join 
		-- kiosk_id, pull_date
		(select t.kiosk_id, t.route_date_time next_delivery_ts from
			(select location_number as kiosk_id, rs.route_date_time,
				rank() over (partition by location_number order by rs.route_date_time) as r
				from mixalot.route_stop rs
				where rs.route_date_time >= plan_window_start -- look at routes starting at plan window start
				and location_number > 0) t
				where r = 2) ps

			on ds.kiosk_id = ps.kiosk_id
			join pantry.kiosk k on ds.kiosk_id = k.id
			where ds.route_date_time between plan_window_start and plan_window_stop
			and k.campus_id= 87;	
end;

$$;


ALTER FUNCTION inm_beta.pick_get_plan_kiosk(plan_window_start timestamp with time zone, plan_window_stop timestamp with time zone) OWNER TO dbservice;

--
-- Name: pick_get_plan_kiosk_disabled_product(date); Type: FUNCTION; Schema: inm_beta; Owner: dbservice
--

CREATE FUNCTION inm_beta.pick_get_plan_kiosk_disabled_product(pick_date date) RETURNS TABLE(kiosk_id bigint, product_id integer)
    LANGUAGE plpgsql
    AS $$

/*
Purpose: return disabled products for kiosks on the pick for a pick date.
*/

begin
	return query
		select dp.kiosk_id, dp.product_id
		from inm.pick_get_plan_kiosk(pick_date) pk
			join inm.kiosk_product_disabled dp on pk.kiosk_id = dp.kiosk_id;
end;

$$;


ALTER FUNCTION inm_beta.pick_get_plan_kiosk_disabled_product(pick_date date) OWNER TO dbservice;

--
-- Name: pick_get_plan_kiosk_projected_stock(timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: inm_beta; Owner: dbservice
--

CREATE FUNCTION inm_beta.pick_get_plan_kiosk_projected_stock(plan_window_start timestamp with time zone, plan_window_stop timestamp with time zone) RETURNS TABLE(kiosk_id integer, fc_title character varying, qty integer)
    LANGUAGE plpgsql
    AS $$

/*
Purpose: return projected stock for plan kiosks for a pick window.
*/

begin
	return query
		select pk.kiosk_id, kps.fc_title, cast(kps.count as integer) from inm_beta.pick_get_plan_kiosk(plan_window_start, plan_window_stop) pk			
		left join inm_beta.kiosk_projected_stock kps on pk.kiosk_id = kps.kiosk_id
			where kps.fc_title is not null;
end;

$$;


ALTER FUNCTION inm_beta.pick_get_plan_kiosk_projected_stock(plan_window_start timestamp with time zone, plan_window_stop timestamp with time zone) OWNER TO dbservice;

--
-- Name: pick_get_sales_period_ratio(timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: inm_beta; Owner: dbservice
--

CREATE FUNCTION inm_beta.pick_get_sales_period_ratio(start_ts timestamp with time zone, end_ts timestamp with time zone) RETURNS TABLE(kiosk_id integer, route_date_time timestamp with time zone, sales_ratio numeric)
    LANGUAGE plpgsql ROWS 10000
    AS $$
  /*
  Purpose - return INM the ratio of the next sale period(time between the deliveries of this pick and the next pick) vs sales for the week using 12 week history
  Input -
    start_ts: plan window start date time with time zone
    end_ts: plan window end date time with time zone
  Return -
    kiosk_id: together with route_date_time is unique for the plan window
    route_date_time: route starting date time
    fc_title: sku group name
    plan_qty: order quantity for the above fc_title for the next sale period
  */

  -- FIX ME:
  -- handle missing past data
  -- check kid with multiple deliveries
begin
  return query
    select scheduled_kiosks.kiosk_id, scheduled_kiosks.route_date_time, coalesce(existing_kiosk_with_sales_ratio.ratio, 1.0/3.0)
    from inm.pick_get_plan_kiosk(start_ts, end_ts) scheduled_kiosks -- all the kiosks on route
           left join -- kiosks with sales history
      (
        select whole_12_weeks.kiosk_id, whole_12_weeks.route_date_time,
               case when whole_12_weeks.qty < 5 then 1.0/3.0 -- new kiosk, assume period sale is 1/3 of total week
                    else cast(period_12_weeks.qty as decimal)/cast(whole_12_weeks.qty as decimal)
                 end ratio
        from
          -- count of sales for the whole previous 12 weeks
          (select pk.kiosk_id, pk.route_date_time, count(*) qty
           from inm.pick_get_plan_kiosk(start_ts, end_ts) pk
                  join pantry.label l on pk.kiosk_id=l.kiosk_id
           where l.status in ('sold')
             and to_timestamp(l.time_updated) between
               pk.next_delivery_ts - interval '91 days'
             and pk.next_delivery_ts - interval '7 days'
           group by 1, 2
          ) whole_12_weeks

            join

          -- count of sales for the sales peiod of previous 4 weeks
            (
              select pk.kiosk_id, pk.route_date_time, count(*) qty
              from inm.pick_get_plan_kiosk(start_ts, end_ts) pk
                     join pantry.label l on pk.kiosk_id=l.kiosk_id
              where l.status in ('sold') and
                (
                    to_timestamp(l.time_updated) between pk.route_date_time - interval '7 days' + interval '4 hours' and pk.next_delivery_ts - interval '7 days'  + interval '4 hours' or
                    to_timestamp(l.time_updated) between pk.route_date_time - interval '14 days'  + interval '4 hours' and pk.next_delivery_ts - interval '14 days'  + interval '4 hours' or
                    to_timestamp(l.time_updated) between pk.route_date_time - interval '21 days'  + interval '4 hours' and pk.next_delivery_ts - interval '21 days'  + interval '4 hours' or
                    to_timestamp(l.time_updated) between pk.route_date_time - interval '28 days'  + interval '4 hours' and pk.next_delivery_ts - interval '28 days' + interval '4 hours' or

                    to_timestamp(l.time_updated) between pk.route_date_time - interval '35 days' + interval '4 hours' and pk.next_delivery_ts - interval '35 days'  + interval '4 hours' or
                    to_timestamp(l.time_updated) between pk.route_date_time - interval '42 days' + interval '4 hours' and pk.next_delivery_ts - interval '42 days'  + interval '4 hours' or
                    to_timestamp(l.time_updated) between pk.route_date_time - interval '49 days' + interval '4 hours' and pk.next_delivery_ts - interval '49 days'  + interval '4 hours' or
                    to_timestamp(l.time_updated) between pk.route_date_time - interval '56 days' + interval '4 hours' and pk.next_delivery_ts - interval '56 days'  + interval '4 hours' or

                    to_timestamp(l.time_updated) between pk.route_date_time - interval '63 days' + interval '4 hours' and pk.next_delivery_ts - interval '63 days'  + interval '4 hours' or
                    to_timestamp(l.time_updated) between pk.route_date_time - interval '70 days' + interval '4 hours' and pk.next_delivery_ts - interval '70 days'  + interval '4 hours' or
                    to_timestamp(l.time_updated) between pk.route_date_time - interval '77 days' + interval '4 hours' and pk.next_delivery_ts - interval '77 days'  + interval '4 hours' or
                    to_timestamp(l.time_updated) between pk.route_date_time - interval '84 days' + interval '4 hours' and pk.next_delivery_ts - interval '84 days'  + interval '4 hours'
                  )
              group by 1, 2
            ) period_12_weeks

          on whole_12_weeks.kiosk_id = period_12_weeks.kiosk_id
      ) existing_kiosk_with_sales_ratio

                     on scheduled_kiosks.kiosk_id = existing_kiosk_with_sales_ratio.kiosk_id and scheduled_kiosks.route_date_time = existing_kiosk_with_sales_ratio.route_date_time;

end;

$$;


ALTER FUNCTION inm_beta.pick_get_sales_period_ratio(start_ts timestamp with time zone, end_ts timestamp with time zone) OWNER TO dbservice;

--
-- Name: pick_get_sales_period_ratio_4wks(timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: inm_beta; Owner: dbservice
--

CREATE FUNCTION inm_beta.pick_get_sales_period_ratio_4wks(start_ts timestamp with time zone, end_ts timestamp with time zone) RETURNS TABLE(kiosk_id integer, route_date_time timestamp with time zone, sales_ratio numeric)
    LANGUAGE plpgsql ROWS 10000
    AS $$

/*
Purpose - return INM the ratio of the next sale period(time between the deliveries of this pick and the next pick) vs sales for the week
Input -
  start_ts: plan window start date time with time zone
  end_ts: plan window end date time with time zone
Return -
  kiosk_id: together with route_date_time is unique for the plan window
  route_date_time: route starting date time
  fc_title: sku group name
  plan_qty: order quantity for the above fc_title for the next sale period
*/

-- FIX ME: 
-- handle missing past data
-- check kid with multiple deliveries
begin	
	return query
		select scheduled_kiosks.kiosk_id, scheduled_kiosks.route_date_time, coalesce(existing_kiosk_with_sales_ratio.ratio, 1.0/3.0)
			from inm.pick_get_plan_kiosk(start_ts, end_ts) scheduled_kiosks -- all the kiosks on route
				left join -- kiosks with sales history
					(
					select whole_4_weeks.kiosk_id, whole_4_weeks.route_date_time, 
						case when whole_4_weeks.qty < 5 then 1.0/3.0 -- new kiosk, assume period sale is 1/3 of total week
							else cast(period_4_weeks.qty as decimal)/cast(whole_4_weeks.qty as decimal)
							end ratio		
					from
						-- count of sales for the whole previous 4 weeks 
						(select pk.kiosk_id, pk.route_date_time, count(*) qty 
							from inm.pick_get_plan_kiosk(start_ts, end_ts) pk
								join pantry.label l on pk.kiosk_id=l.kiosk_id
								where l.status in ('out', 'sold')
									and to_timestamp(l.time_updated) between
										pk.next_delivery_ts - interval '35 days'
										and pk.next_delivery_ts - interval '7 days'
							group by 1, 2
						 ) whole_4_weeks

						join 

						-- count of sales for the sales peiod of previous 4 weeks 
						(
						select pk.kiosk_id, pk.route_date_time, count(*) qty
							from inm.pick_get_plan_kiosk(start_ts, end_ts) pk
								join pantry.label l on pk.kiosk_id=l.kiosk_id
								where l.status in ('out', 'sold') and 
									(to_timestamp(l.time_updated) between pk.route_date_time - interval '7 days' + interval '4 hours' and pk.next_delivery_ts - interval '7 days'  + interval '4 hours' or
									 to_timestamp(l.time_updated) between pk.route_date_time - interval '14 days'  + interval '4 hours' and pk.next_delivery_ts - interval '14 days'  + interval '4 hours' or
									 to_timestamp(l.time_updated) between pk.route_date_time - interval '21 days'  + interval '4 hours' and pk.next_delivery_ts - interval '21 days'  + interval '4 hours' or
									 to_timestamp(l.time_updated) between pk.route_date_time - interval '28 days'  + interval '4 hours' and pk.next_delivery_ts - interval '28 days' + interval '4 hours')
								group by 1, 2
							) period_4_weeks

						on whole_4_weeks.kiosk_id = period_4_weeks.kiosk_id
					 ) existing_kiosk_with_sales_ratio 
					 
				on scheduled_kiosks.kiosk_id = existing_kiosk_with_sales_ratio.kiosk_id and scheduled_kiosks.route_date_time = existing_kiosk_with_sales_ratio.route_date_time;
					
	end;

$$;


ALTER FUNCTION inm_beta.pick_get_sales_period_ratio_4wks(start_ts timestamp with time zone, end_ts timestamp with time zone) OWNER TO dbservice;

--
-- Name: compare_pick_vs_delivery(date, date); Type: FUNCTION; Schema: inm_test; Owner: dbservice
--

CREATE FUNCTION inm_test.compare_pick_vs_delivery(start_date date, end_date date DEFAULT NULL::date) RETURNS TABLE(kiosk_id integer, route_date date, kiosk_title character varying, product_id integer, pick_qty bigint, restock_qty bigint, discrepancy bigint)
    LANGUAGE plpgsql
    AS $$

/*
Purpose - compare pick to restock
Input - 
	start_date: first pick date to consider
	end_date: last pick date to consider. If not given, compute the result for only start_date
Output - 
	kiosk_id: id for kiosk
	route_date: delivery date
	kiosk_title: kiosk name
	product_id: what picked/allocated
	pick_qty: quantity above product_id picked
	restock_qty: quantity above product_id restocked between target_date and the following delivery date_time for the kiosk
	discrepancy: restock_qty - pick_quantity for target_date  
*/

declare target_date date;
declare pick_window_start timestamp with time zone;
declare pick_window_end timestamp with time zone;
begin
	if end_date is null
		then end_date = start_date;
	end if;
	for target_date in select * from generate_series(start_date, end_date, interval '1 days') loop
		pick_window_start = cast(target_date as timestamp with time zone) + interval '13 hours';
		pick_window_end = pick_window_start + interval '22 hours';

		return query
			select
				a.kiosk_id, a.route_date, k.title, a.sku_id, a.pick_qty, rs.restock_qty, coalesce(rs.restock_qty, 0) - a.pick_qty discrepancy
				from
					-- next 2 delivery schedules for each kiosks
					(select t1.kiosk_id, t1.route_date_time, t1.next_delivery_ts from inm.pick_get_plan_kiosk(pick_window_start, pick_window_end) t1) d
				join
					-- allocation
					(select t2.kiosk_id, t2.route_date, t2.sku_id, sum(t2.qty) pick_qty
						from inm.pick_allocation t2
						where pick_date = target_date
						group by 1,2,3) a
					on d.kiosk_id = a.kiosk_id and d.route_date_time::date = a.route_date

				left join
					(select t3.kiosk_id, to_timestamp(time_added)::date restock_date, t3.product_id, count(*) restock_qty
					  from pantry.label t3
					  where to_timestamp(time_added) between pick_window_start and cast(pick_window_start as timestamp) + interval '2 days' -- limit to potential pick time frame
					  group by 1,2,3 having count(*) >= 1) rs

				on a.kiosk_id = rs.kiosk_id and a.route_date = rs.restock_date and a.sku_id = rs.product_id

				join pantry.kiosk k on a.kiosk_id = k.id
				order by a.kiosk_id;
		end loop;
end;

$$;


ALTER FUNCTION inm_test.compare_pick_vs_delivery(start_date date, end_date date) OWNER TO dbservice;

--
-- Name: pick_check_restriction(date); Type: FUNCTION; Schema: inm_test; Owner: dbservice
--

CREATE FUNCTION inm_test.pick_check_restriction(_pick_date date) RETURNS TABLE(kiosk_id integer, product_id integer)
    LANGUAGE plpgsql
    AS $$

/*
Purpose: return restricted products found in allocation
*/

begin
	return query
		select a.kiosk_id, a.sku_id
			from (select * from inm_test.pick_allocation a where a.pick_date = _pick_date) a
				join inm.kiosk_product_disabled d on a.kiosk_id = d.kiosk_id and a.sku_id = d.product_id;
end;

$$;


ALTER FUNCTION inm_test.pick_check_restriction(_pick_date date) OWNER TO dbservice;

--
-- Name: pick_get_order_with_sales_ratio(timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: inm_test; Owner: dbservice
--

CREATE FUNCTION inm_test.pick_get_order_with_sales_ratio(start_ts timestamp with time zone, end_ts timestamp with time zone) RETURNS TABLE(kiosk_id integer, route_date_time timestamp with time zone, sku_group_id integer, fc_title text, week_demand_qty integer, plan_demand_qty numeric, plan_order_qty numeric)
    LANGUAGE plpgsql
    AS $$

/*
Purpose - return INM order based on sales ratio for pick sales period (time between deliveries)
Input -
  start_ts: plan window start date time with time zone
  end_ts: plan window end date time with time zone
Return -
  kiosk_id: together with route_date_time is unique for the plan window
  route_date_time: route starting date time
  fc_title: sku group name
  week_demand_qty: demand based on once a week delivery (without minimum)
  plan_demand_qty: demand based on sales ratio for pick sales period (without minimum)
  plan_order_qty: order based on sales ratio for pick sales period
*/

declare latest_import_ts_for_pick_window timestamp with time zone;
begin
	-- get the latest import_ts for the same day as start_ts
	select max(import_ts) from mixalot.inm_data i
		where import_ts::date = start_ts::date and data_type = 'Par Unconstrained wo Min' -- make sure import contain this data_type
		into latest_import_ts_for_pick_window;
	return query
		--  Given
		--		sales period = time between this pick delivery and next pick delivery (may be changed to pick times in the future)
		--		inm.qty = week demand
		--		sr.sales_ratio = sale ratio for this sum items sold for pick sales period for the last 4 weeks vs items sold for the last 4 weeks 
		-- 	if item is restricted (inm_qty=0), then set demand to 0. 
		--  else 
		--		if item doesn't exist in the kiosk (inv.count is null), set its inv count to 0
		-- 		order_before_min_max = 1.4 * sr.sales_ratio * inm.qty - inv.count
		-- 		final_order = min + order_before_min_max, capped by max as defined for each sku group
		select sr.kiosk_id, sr.route_date_time, sga.id, inm.fc_title, inm.qty week_demand_qty, 
			cast(1.4 * sr.sales_ratio * inm.qty as numeric (8,2)) plan_demand_qty,
			case 
				when inm.qty = 0 then 0 -- restricted item
				else
					-- cap at week_qty
					least(
						-- change minimum is 0 (don't remove from a kiosk)
						least(greatest(ceiling(1.4 * sr.sales_ratio * inm.qty) + sga.minimum_kiosk_qty - coalesce(inv.count, 0),
											  0) /* change negative demand to 0 */
								   , sga.maximum_kiosk_qty),
						inm.qty)
			end as plan_order_qty -- end case
					   
			from inm.pick_get_sales_period_ratio(start_ts, end_ts) sr
				join mixalot.inm_data inm
					on sr.kiosk_id = inm.kiosk_id
						and inm.data_type = 'Par Unconstrained wo Min'					
						and inm.import_ts = latest_import_ts_for_pick_window						
				join inm.sku_group_attribute sga
					on sga.title = inm.fc_title			
				left join mixalot.inm_kiosk_projected_stock inv
					on inm.kiosk_id = inv.kiosk_id and inm.fc_title = inv.fc_title;
	end;

$$;


ALTER FUNCTION inm_test.pick_get_order_with_sales_ratio(start_ts timestamp with time zone, end_ts timestamp with time zone) OWNER TO dbservice;

--
-- Name: pick_get_plan_demand(timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: inm_test; Owner: dbservice
--

CREATE FUNCTION inm_test.pick_get_plan_demand(start_ts timestamp with time zone, end_ts timestamp with time zone) RETURNS TABLE(kiosk_id integer, route_date_time timestamp with time zone, sku_group_id integer, fc_title text, week_qty integer, plan_qty integer)
    LANGUAGE plpgsql
    AS $$

/*
Purpose - return INM plan demand for a pick window.
Input -
  start_ts: plan window start date time with time zone
  end_ts: plan window end date time with time zone
Return -
  kiosk_id: together with route_date_time is unique for the plan window
  route_date_time: route starting date time
  fc_title: sku group name
  week_qty: demand based on once a week delivery
  plan_qty: demand based on time to next delivery
*/

declare latest_import_ts_for_pick_window timestamp with time zone;
begin
	-- get the latest import_ts for the same day as start_ts
	select max(import_ts) from mixalot.inm_data i
		where import_ts::date = start_ts::date and data_type = 'Par Unconstrained wo Min' -- make sure import contain this data_type
		into latest_import_ts_for_pick_window;
	return query
		-- Given
		-- 		default 3 days if days_to_next_delivery is not known: coalesce(days_to_next_delivery, 3)
		-- 		if item doesn't exist in the kiosk (inv.count is null), set its inv count to 0: coalesce(inv.count, 0)
		-- 		inm.qty is weekly demand
		-- bring 1.8 times the total demand until the next delivery plus the minimum, capped by min and max as defined for each sku group, 
		select pk.kiosk_id, pk.route_date_time, sga.id, inm.fc_title, inm.qty week_qty,
			case 
				when inm.qty = 0 then 0
				else 	
					least(cast(greatest(ceiling(1.8 * inm.qty * coalesce(days_to_next_delivery, 3)/7) + sga.minimum_kiosk_qty - coalesce(inv.count, 0),
										  sga.minimum_kiosk_qty - inv.count, /* ensure minimum quantity */
										  0) /* change negative demand to 0 */
							   as integer), sga.maximum_kiosk_qty) 
			end as plan_qty -- case
					   
			  from mixalot.plan_kiosk(start_ts, end_ts) pk
			  
			join mixalot.inm_data inm
				on pk.kiosk_id = inm.kiosk_id
					and inm.data_type = 'Par Unconstrained wo Min'					
					and inm.import_ts = latest_import_ts_for_pick_window
					
			join mixalot.sku_group_attribute sga
				on sga.title = inm.fc_title
			
			--fixme: use this block and remove next block after testing
 			left join mixalot.inm_kiosk_projected_stock inv
			
			-- use the next block of inv to test rerun to keep inv level at given date.
-- 			left join
-- 				(select i.kiosk_id, s.title fc_title, i.qty count
-- 					from mixalot.pick_inventory i join mixalot.sku_group_def s on i.sku_group_id = s.id
-- 					where pick_date = '2018-09-16') inv
			
 				on inm.kiosk_id = inv.kiosk_id and inm.fc_title = inv.fc_title;
end;

$$;


ALTER FUNCTION inm_test.pick_get_plan_demand(start_ts timestamp with time zone, end_ts timestamp with time zone) OWNER TO dbservice;

--
-- Name: pick_get_plan_demand(numeric, timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: inm_test; Owner: dbservice
--

CREATE FUNCTION inm_test.pick_get_plan_demand(allocation_factor numeric, start_ts timestamp with time zone, end_ts timestamp with time zone) RETURNS TABLE(kiosk_id integer, route_date_time timestamp with time zone, fc_title text, week_qty integer, plan_qty integer)
    LANGUAGE plpgsql
    AS $$

/*
Purpose - return INM plan demand for a pick window.
Input -
  start_ts: plan window start date time with time zone
  end_ts: plan window end date time with time zone
Return -
  kiosk_id: together with route_date_time is unique for the plan window
  route_date_time: route starting date time
  fc_title: sku group name
  week_qty: demand based on once a week delivery
  plan_qty: demand based on time to next delivery
*/

declare latest_import_ts_for_pick_window timestamp with time zone;
begin
	-- get the latest import_ts for the same day as start_ts
	select max(import_ts) from mixalot.inm_data i
		where import_ts::date = start_ts::date and data_type = 'Par Unconstrained wo Min' -- make sure import contain this data_type
		into latest_import_ts_for_pick_window;
	return query
		-- Given
		-- 		default 3 days if days_to_next_delivery is not known: coalesce(days_to_next_delivery, 3)
		-- 		if item doesn't exist in the kiosk (inv.count is null), set its inv count to 0: coalesce(inv.count, 0)
		-- 		inm.qty is weekly demand
		-- bring 1.8 times the total demand until the next delivery plus the minimum, capped by min and max as defined for each sku group, 
		select pk.kiosk_id, pk.route_date_time, inm.fc_title, inm.qty week_qty,
			least(cast(greatest(ceiling(allocation_factor * inm.qty * coalesce(days_to_next_delivery, 3)/7) + sga.minimum_kiosk_qty - coalesce(inv.count, 0),
								  sga.minimum_kiosk_qty - inv.count, /* ensure minimum quantity */
							   	  0) /* change negative demand to 0 */
					   as integer), sga.maximum_kiosk_qty) plan_qty
			  from mixalot.plan_kiosk(start_ts, end_ts) pk
			join mixalot.inm_data inm
				on pk.kiosk_id = inm.kiosk_id
					and inm.data_type = 'Par Unconstrained wo Min'					
					and inm.import_ts = latest_import_ts_for_pick_window
					
			join mixalot.sku_group_attribute sga
				on sga.title = inm.fc_title
			
 			left join mixalot.inm_kiosk_projected_stock inv
			
			-- use the next block of inv to test rerun to keep inv level at given date.
-- 			left join
-- 				(select i.kiosk_id, s.title fc_title, i.qty count
-- 					from mixalot.pick_inventory i join mixalot.sku_group_def s on i.sku_group_id = s.id
-- 					where pick_date = '2018-09-13') inv
			
 				on inm.kiosk_id = inv.kiosk_id and inm.fc_title = inv.fc_title;
end;

$$;


ALTER FUNCTION inm_test.pick_get_plan_demand(allocation_factor numeric, start_ts timestamp with time zone, end_ts timestamp with time zone) OWNER TO dbservice;

--
-- Name: pick_get_plan_demand_w_manual(timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: inm_test; Owner: dbservice
--

CREATE FUNCTION inm_test.pick_get_plan_demand_w_manual(start_ts timestamp with time zone, end_ts timestamp with time zone) RETURNS TABLE(kiosk_id integer, route_date_time timestamp with time zone, sku_group_id integer, fc_title text, week_qty integer, plan_qty integer)
    LANGUAGE plpgsql
    AS $$

/*
Purpose - return INM plan demand for a pick window.
Input -
  start_ts: plan window start date time with time zone
  end_ts: plan window end date time with time zone
Return -
  kiosk_id: together with route_date_time is unique for the plan window
  route_date_time: route starting date time
  fc_title: sku group name
  week_qty: demand based on once a week delivery
  plan_qty: demand based on time to next delivery
*/

declare latest_import_ts_for_pick_window timestamp with time zone;
begin
	-- get the latest import_ts for the same day as start_ts
	select max(import_ts) from mixalot.inm_data i
		where import_ts::date = start_ts::date and data_type = 'Par Unconstrained wo Min' -- make sure import contain this data_type
		into latest_import_ts_for_pick_window;
	return query
		-- Given
		-- 		default 3 days if days_to_next_delivery is not known: coalesce(days_to_next_delivery, 3)
		-- 		if item doesn't exist in the kiosk (inv.count is null), set its inv count to 0: coalesce(inv.count, 0)
		-- 		inm.qty is weekly demand
		-- bring 1.8 times the total demand until the next delivery plus the minimum, capped by min and max as defined for each sku group, 
		select pk.kiosk_id, pk.route_date_time, sga.id, inm.fc_title, inm.qty week_qty,
			case 
				when inm.qty = 0 then 0
				else 	
					least(cast(greatest(ceiling(1.8 * inm.qty * coalesce(days_to_next_delivery, 3)/7) + sga.minimum_kiosk_qty - coalesce(inv.count, 0),
										  sga.minimum_kiosk_qty - inv.count, /* ensure minimum quantity */
										  0) /* change negative demand to 0 */
							   as integer), sga.maximum_kiosk_qty) 
			end as plan_qty -- case
					   
			  from mixalot.plan_kiosk(start_ts, end_ts) pk
			  
			join mixalot.inm_data inm
				on pk.kiosk_id = inm.kiosk_id
					and inm.data_type = 'Par Unconstrained wo Min'					
					and inm.import_ts = latest_import_ts_for_pick_window
					
			join mixalot.sku_group_attribute sga
				on sga.title = inm.fc_title
			
			--fixme: use this block and remove next block after testing
 			left join mixalot.inm_kiosk_projected_stock inv
			
			-- use the next block of inv to test rerun to keep inv level at given date.
-- 			left join
-- 				(select i.kiosk_id, s.title fc_title, i.qty count
-- 					from mixalot.pick_inventory i join mixalot.sku_group_def s on i.sku_group_id = s.id
-- 					where pick_date = '2018-09-16') inv
			
 				on inm.kiosk_id = inv.kiosk_id and inm.fc_title = inv.fc_title;
end;

$$;


ALTER FUNCTION inm_test.pick_get_plan_demand_w_manual(start_ts timestamp with time zone, end_ts timestamp with time zone) OWNER TO dbservice;

--
-- Name: pick_get_sales_period_ratio(timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: inm_test; Owner: dbservice
--

CREATE FUNCTION inm_test.pick_get_sales_period_ratio(start_ts timestamp with time zone, end_ts timestamp with time zone) RETURNS TABLE(kiosk_id integer, route_date_time timestamp with time zone, sales_ratio numeric)
    LANGUAGE plpgsql ROWS 10000
    AS $$

/*
Purpose - return INM the ratio of the next sale period(time between the deliveries of this pick and the next pick) vs sales for the week
Input -
  start_ts: plan window start date time with time zone
  end_ts: plan window end date time with time zone
Return -
  kiosk_id: together with route_date_time is unique for the plan window
  route_date_time: route starting date time
  fc_title: sku group name
  plan_qty: order quantity for the above fc_title for the next sale period
*/

-- FIX ME: 
-- handle missing past data
-- check kid with multiple deliveries
begin	
	return query
		select scheduled_kiosks.kiosk_id, scheduled_kiosks.route_date_time, coalesce(existing_kiosk_with_sales_ratio.ratio, 1.0/3.0)
			from inm.pick_get_plan_kiosk(start_ts, end_ts) scheduled_kiosks
				left join
					(
					select whole_4_weeks.kiosk_id, whole_4_weeks.route_date_time, 
						case when whole_4_weeks.qty < 5 then 1.0/3.0 -- new kiosk, assume period sale is 1/3 of total week
							else cast(period_4_weeks.qty as decimal)/cast(whole_4_weeks.qty as decimal)
							end ratio		
					from
						-- count of sales for the whole previous 4 weeks 
						(select pk.kiosk_id, pk.route_date_time, count(*) qty 
							from inm.pick_get_plan_kiosk(start_ts, end_ts) pk
								join pantry.label l on pk.kiosk_id=l.kiosk_id
								where l.status in ('out', 'sold')
									and to_timestamp(l.time_updated) between
										pk.next_delivery_ts - interval '35 days'
										and pk.next_delivery_ts - interval '7 days'
							group by 1, 2
						 ) whole_4_weeks

						join 

						-- count of sales for the sales peiod of previous 4 weeks 
						(
						select pk.kiosk_id, pk.route_date_time, count(*) qty
							from inm.pick_get_plan_kiosk(start_ts, end_ts) pk
								join pantry.label l on pk.kiosk_id=l.kiosk_id
								where l.status in ('out', 'sold') and 
									(to_timestamp(l.time_updated) between pk.route_date_time - interval '7 days' + interval '4 hours' and pk.next_delivery_ts - interval '7 days'  + interval '4 hours' or
									 to_timestamp(l.time_updated) between pk.route_date_time - interval '14 days'  + interval '4 hours' and pk.next_delivery_ts - interval '14 days'  + interval '4 hours' or
									 to_timestamp(l.time_updated) between pk.route_date_time - interval '21 days'  + interval '4 hours' and pk.next_delivery_ts - interval '21 days'  + interval '4 hours' or
									 to_timestamp(l.time_updated) between pk.route_date_time - interval '28 days'  + interval '4 hours' and pk.next_delivery_ts - interval '28 days' + interval '4 hours')
								group by 1, 2
							) period_4_weeks

						on whole_4_weeks.kiosk_id = period_4_weeks.kiosk_id
					 ) existing_kiosk_with_sales_ratio
				on scheduled_kiosks.kiosk_id = existing_kiosk_with_sales_ratio.kiosk_id and scheduled_kiosks.route_date_time = existing_kiosk_with_sales_ratio.route_date_time;
					
	end;

$$;


ALTER FUNCTION inm_test.pick_get_sales_period_ratio(start_ts timestamp with time zone, end_ts timestamp with time zone) OWNER TO dbservice;

--
-- Name: pick_inventory_insert(); Type: FUNCTION; Schema: inm_test; Owner: dbservice
--

CREATE FUNCTION inm_test.pick_inventory_insert() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
  begin
  	new.route_date = new.pick_date;
  	return new;
  end;
	
$$;


ALTER FUNCTION inm_test.pick_inventory_insert() OWNER TO dbservice;

--
-- Name: sales_ratio_debug(timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: inm_test; Owner: dbservice
--

CREATE FUNCTION inm_test.sales_ratio_debug(start_ts timestamp with time zone, end_ts timestamp with time zone) RETURNS TABLE(kiosk_id integer, route_date_time timestamp with time zone, sales_ratio numeric, whole_qty bigint, period_qty bigint)
    LANGUAGE plpgsql ROWS 10000
    AS $$
  /*
  Purpose - return INM the ratio of the next sale period(time between the deliveries of this pick and the next pick) vs sales for the week using 12 week history
  Input -
    start_ts: plan window start date time with time zone
    end_ts: plan window end date time with time zone
  Return -
    kiosk_id: together with route_date_time is unique for the plan window
    route_date_time: route starting date time
    fc_title: sku group name
    plan_qty: order quantity for the above fc_title for the next sale period
  */

  -- FIX ME:
  -- handle missing past data
  -- check kid with multiple deliveries
begin
  return query
    select scheduled_kiosks.kiosk_id, scheduled_kiosks.route_date_time, coalesce(existing_kiosk_with_sales_ratio.ratio, 1.0/3.0),
           existing_kiosk_with_sales_ratio.whole_qty, existing_kiosk_with_sales_ratio.period_qty
    from inm.pick_get_plan_kiosk(start_ts, end_ts) scheduled_kiosks -- all the kiosks on route
           left join -- kiosks with sales history
      (
        select whole_12_weeks.kiosk_id, whole_12_weeks.route_date_time,
               case when whole_12_weeks.qty < 5 then 1.0/3.0 -- new kiosk, assume period sale is 1/3 of total week
                    else cast(period_12_weeks.qty as decimal)/cast(whole_12_weeks.qty as decimal)
                 end ratio, whole_12_weeks.qty whole_qty, period_12_weeks.qty period_qty
        from
          -- count of sales for the whole previous 12 weeks
          (select pk.kiosk_id, pk.route_date_time, count(*) qty
           from inm.pick_get_plan_kiosk(start_ts, end_ts) pk
                  join pantry.label l on pk.kiosk_id=l.kiosk_id
           where l.status in ('out', 'sold')
             and to_timestamp(l.time_updated) between
               pk.next_delivery_ts - interval '91 days'
             and pk.next_delivery_ts - interval '7 days'
           group by 1, 2
          ) whole_12_weeks

            join

          -- count of sales for the sales peiod of previous 4 weeks
            (
              select pk.kiosk_id, pk.route_date_time, count(*) qty
              from inm.pick_get_plan_kiosk(start_ts, end_ts) pk
                     join pantry.label l on pk.kiosk_id=l.kiosk_id
              where l.status in ('out', 'sold') and
                (
                    to_timestamp(l.time_updated) between pk.route_date_time - interval '7 days' + interval '4 hours' and pk.next_delivery_ts - interval '7 days'  + interval '4 hours' or
                    to_timestamp(l.time_updated) between pk.route_date_time - interval '14 days'  + interval '4 hours' and pk.next_delivery_ts - interval '14 days'  + interval '4 hours' or
                    to_timestamp(l.time_updated) between pk.route_date_time - interval '21 days'  + interval '4 hours' and pk.next_delivery_ts - interval '21 days'  + interval '4 hours' or
                    to_timestamp(l.time_updated) between pk.route_date_time - interval '28 days'  + interval '4 hours' and pk.next_delivery_ts - interval '28 days' + interval '4 hours' or

                    to_timestamp(l.time_updated) between pk.route_date_time - interval '35 days' + interval '4 hours' and pk.next_delivery_ts - interval '35 days'  + interval '4 hours' or
                    to_timestamp(l.time_updated) between pk.route_date_time - interval '42 days' + interval '4 hours' and pk.next_delivery_ts - interval '42 days'  + interval '4 hours' or
                    to_timestamp(l.time_updated) between pk.route_date_time - interval '49 days' + interval '4 hours' and pk.next_delivery_ts - interval '49 days'  + interval '4 hours' or
                    to_timestamp(l.time_updated) between pk.route_date_time - interval '56 days' + interval '4 hours' and pk.next_delivery_ts - interval '56 days'  + interval '4 hours' or

                    to_timestamp(l.time_updated) between pk.route_date_time - interval '63 days' + interval '4 hours' and pk.next_delivery_ts - interval '63 days'  + interval '4 hours' or
                    to_timestamp(l.time_updated) between pk.route_date_time - interval '70 days' + interval '4 hours' and pk.next_delivery_ts - interval '70 days'  + interval '4 hours' or
                    to_timestamp(l.time_updated) between pk.route_date_time - interval '77 days' + interval '4 hours' and pk.next_delivery_ts - interval '77 days'  + interval '4 hours' or
                    to_timestamp(l.time_updated) between pk.route_date_time - interval '84 days' + interval '4 hours' and pk.next_delivery_ts - interval '84 days'  + interval '4 hours'
                  )
              group by 1, 2
            ) period_12_weeks

          on whole_12_weeks.kiosk_id = period_12_weeks.kiosk_id
      ) existing_kiosk_with_sales_ratio

                     on scheduled_kiosks.kiosk_id = existing_kiosk_with_sales_ratio.kiosk_id and scheduled_kiosks.route_date_time = existing_kiosk_with_sales_ratio.route_date_time;

end;

$$;


ALTER FUNCTION inm_test.sales_ratio_debug(start_ts timestamp with time zone, end_ts timestamp with time zone) OWNER TO dbservice;

--
-- Name: test_demand(timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: inm_test; Owner: dbservice
--

CREATE FUNCTION inm_test.test_demand(start_ts timestamp with time zone, end_ts timestamp with time zone) RETURNS TABLE(kiosk_id integer, route_date_time timestamp with time zone, fc_title text, week_qty integer, plan_qty integer, loopback_start_ts timestamp with time zone, loopback_end_ts timestamp with time zone)
    LANGUAGE plpgsql
    AS $$

/*
Purpose - return INM plan demand for a pick window.
Input -
  start_ts: plan window start date time with time zone
  end_ts: plan window end date time with time zone
Return -
  kiosk_id: together with route_date_time is unique for the plan window
  route_date_time: route starting date time
  fc_title: sku group name
  week_qty: demand based on once a week delivery
  plan_qty: demand based on time to next delivery
*/

declare latest_import_ts_for_pick_window timestamp with time zone;
begin	
	select max(import_ts) from mixalot.inm_data
		where import_ts >= start_ts::date
		into latest_import_ts_for_pick_window;
	return query
		select pk.kiosk_id, pk.route_date_time, demand.fc_title, demand.qty week_qty,
			demand.qty/2 plan_qty, -- test
			start_ts, end_ts
			  from mixalot.plan_kiosk(start_ts, end_ts) pk
			join (select d.kiosk_id, d.route_date, cast(s.title as text) fc_title, d.qty qty
					from mixalot.pick_demand d join mixalot.sku_group_def s on d.sku_group_id = s.id
					where pick_date = latest_import_ts_for_pick_window::date
					) demand
			
 				on pk.kiosk_id = demand.kiosk_id and pk.route_date_time::date = demand.route_date;
end;

$$;


ALTER FUNCTION inm_test.test_demand(start_ts timestamp with time zone, end_ts timestamp with time zone) OWNER TO dbservice;

--
-- Name: backup_pick_allocation(date); Type: FUNCTION; Schema: mixalot; Owner: dbservice
--

CREATE FUNCTION mixalot.backup_pick_allocation(target_pick_date date) RETURNS void
    LANGUAGE plpgsql
    AS $$

declare today_date date;
begin
  delete from mixalot_backup.pick_inventory where pick_date = target_pick_date;
  insert into mixalot_backup.pick_inventory select * from mixalot.pick_inventory
  	where pick_date = target_pick_date;
	
  delete from mixalot_backup.pick_demand where pick_date = target_pick_date;
  insert into mixalot_backup.pick_demand select * from mixalot.pick_demand
  	where pick_date = target_pick_date;
	
  delete from mixalot_backup.pick_allocation where pick_date = target_pick_date;
  insert into mixalot_backup.pick_allocation select * from mixalot.pick_allocation
  	where pick_date = target_pick_date;
	
delete from mixalot_backup.pick_substitution where pick_date = target_pick_date;
  insert into mixalot_backup.pick_substitution select * from mixalot.pick_substitution
	where pick_date = target_pick_date;
	
delete from mixalot_backup.pick_route where pick_date = target_pick_date;
  insert into mixalot_backup.pick_route select * from mixalot.pick_route
	where pick_date = target_pick_date;
	
end;

$$;


ALTER FUNCTION mixalot.backup_pick_allocation(target_pick_date date) OWNER TO dbservice;

--
-- Name: pick_allocation_insert(); Type: FUNCTION; Schema: mixalot; Owner: dbservice
--

CREATE FUNCTION mixalot.pick_allocation_insert() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
	new.route_date = new.pick_date;
	return new;
end;
$$;


ALTER FUNCTION mixalot.pick_allocation_insert() OWNER TO dbservice;

--
-- Name: pick_demand_insert(); Type: FUNCTION; Schema: mixalot; Owner: dbservice
--

CREATE FUNCTION mixalot.pick_demand_insert() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
	new.route_date = new.pick_date;
	return new;
end;
$$;


ALTER FUNCTION mixalot.pick_demand_insert() OWNER TO dbservice;

--
-- Name: pick_get_delivery_schedule(timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: mixalot; Owner: dbservice
--

CREATE FUNCTION mixalot.pick_get_delivery_schedule(start_ts timestamp with time zone, end_ts timestamp with time zone) RETURNS TABLE(kiosk_id integer, driver_name character varying, route_date_time timestamp with time zone, location_name character varying, delivery_order bigint)
    LANGUAGE plpgsql
    AS $$
/*
Purpose: return INM delivery schedule for a pick window.
*/
begin
	return query
		select pk.kiosk_id, r.driver_name, r.route_date_time, pk.location_name, pk.delivery_order
			from mixalot.route r join mixalot.pick_get_plan_kiosks(start_ts, end_ts) pk
				on r.route_date_time = pk.route_date_time and r.driver_name = pk.driver_name
				where r.route_date_time between start_ts and end_ts;
end;

$$;


ALTER FUNCTION mixalot.pick_get_delivery_schedule(start_ts timestamp with time zone, end_ts timestamp with time zone) OWNER TO dbservice;

--
-- Name: pick_get_gsheets_plan_demand(timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: mixalot; Owner: dbservice
--

CREATE FUNCTION mixalot.pick_get_gsheets_plan_demand(start_ts timestamp with time zone, end_ts timestamp with time zone) RETURNS TABLE(kiosk_id integer, route_date_time timestamp with time zone, fc_title text, week_qty integer, plan_qty integer)
    LANGUAGE plpgsql
    AS $$

/*
Purpose - return INM plan demand from gsheets for a pick window.
Input -
  start_ts: plan window start date time with time zone
  end_ts: plan window end date time with time zone
Return -
  kiosk_id: together with route_date_time is unique for the plan window
  route_date_time: route starting date time
  fc_title: sku group name
  week_qty: demand based on once a week delivery
  plan_qty: demand based on time to next delivery
*/

declare latest_import_ts_for_pick_window timestamp with time zone;
begin	
	select max(import_ts) from mixalot.inm_data
		where import_ts >= start_ts::date
		into latest_import_ts_for_pick_window;
	return query
		select pk.kiosk_id, pk.route_date_time, inm.fc_title, inm.qty, 
			cast(ceiling(1.4 * inm.qty * days_to_next_delivery/7) as integer)
			  from mixalot.pick_get_plan_kiosks(start_ts, end_ts) pk
			join mixalot.inm_data inm
			on pk.kiosk_id = inm.kiosk_id
			and inm.data_type = 'Plan Demand'
			and inm.import_ts = latest_import_ts_for_pick_window;
end;

$$;


ALTER FUNCTION mixalot.pick_get_gsheets_plan_demand(start_ts timestamp with time zone, end_ts timestamp with time zone) OWNER TO dbservice;

--
-- Name: pick_get_plan_demand(timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: mixalot; Owner: dbservice
--

CREATE FUNCTION mixalot.pick_get_plan_demand(start_ts timestamp with time zone, end_ts timestamp with time zone) RETURNS TABLE(kiosk_id integer, route_date_time timestamp with time zone, sku_group_id integer, fc_title text, plan_qty integer)
    LANGUAGE plpgsql
    AS $$

/*
Purpose - return INM plan demand for a pick window.
Input -
  start_ts: plan window start date time with time zone
  end_ts: plan window end date time with time zone
Return -
  kiosk_id: together with route_date_time is unique for the plan window
  route_date_time: route starting date time
  fc_title: sku group name
  week_qty: demand based on once a week delivery
  plan_qty: demand based on time to next delivery
*/

declare latest_import_ts_for_pick_window timestamp with time zone;
begin
	-- get the latest import_ts for the same day as start_ts
	select max(import_ts) from mixalot.inm_data i
		where import_ts::date = start_ts::date
		into latest_import_ts_for_pick_window;
	return query
		select pk.kiosk_id, pk.route_date_time, sga.id, inm.fc_title, least(inm.qty, sga.maximum_kiosk_qty) plan_qty
			  from mixalot.plan_kiosk(start_ts, end_ts) pk
			join mixalot.inm_data inm
				on pk.kiosk_id = inm.kiosk_id
					and inm.data_type = 'Plan Demand'					
					and inm.import_ts = latest_import_ts_for_pick_window
					
			join mixalot.sku_group_attribute sga
				on sga.title = inm.fc_title;		
end;

$$;


ALTER FUNCTION mixalot.pick_get_plan_demand(start_ts timestamp with time zone, end_ts timestamp with time zone) OWNER TO dbservice;

--
-- Name: pick_get_summary(date); Type: FUNCTION; Schema: mixalot; Owner: dbservice
--

CREATE FUNCTION mixalot.pick_get_summary(target_date date) RETURNS TABLE(property text, name text, value text)
    LANGUAGE plpgsql
    AS $$

declare pick_tickets_generated integer;

-- one-based arrays of 3 numbers, 1 for target date and 2 for the same weekday one and two weeks ago
declare ticket integer ARRAY;
declare demand integer ARRAY;
declare allocation integer ARRAY;

declare property text;
declare name text;
declare value text;
declare total integer;
declare result_row record;

declare kiosks_added text;
declare kiosks_removed text;

begin
	
	FOR i IN 0..2 LOOP
 		select count(*) from inm.pick_route where pick_date = target_date - 7*i  into total;
		ticket[i+1] = total; -- convert to one-based index
		select sum(qty) from inm.pick_demand where pick_date = target_date - 7*i into total;
		demand[i+1] = total;
		select sum(qty) from inm.pick_allocation where pick_date = target_date - 7*i into total;
		allocation[i+1] = total;
   	END LOOP;
	
	select array_to_string(array_agg(cast (kiosk_id as varchar) order by kiosk_id), ',') from inm.pick_route 
		where pick_date = target_date and kiosk_id not in
			(select kiosk_id from inm.pick_route where pick_date = target_date - 7)
	into kiosks_added;
	
	select array_to_string(array_agg(cast (kiosk_id as varchar) order by kiosk_id), ',') from inm.pick_route 
		where pick_date = target_date - 7  and kiosk_id not in
			(select kiosk_id from inm.pick_route where pick_date = target_date)
	into kiosks_removed;
		
	property = 'stats';
	name = 'pick tickets today/ -7 days/ -14 days: ';
	value = ticket[1] || '/' || ticket[2] || '/' || ticket[3];
	return query select property, name, value;
	
	property = 'stats';
	name = 'demand qty today/ -7 days/ -14 days: ';
	value = demand[1] || '/' || demand[2] || '/' || demand[3];
	return query select property, name, value;
	
	property = 'stats';
	name = 'allocation qty today/ -7 days/ -14 days: ';
	value = allocation[1] || '/' || allocation[2] || '/' || allocation[3];
	return query select property, name, value;
	
	property = 'stats';
	name = 'kiosks added';
	value = kiosks_added;
	return query select property, name, value;
	
	property = 'stats';
	name = 'kiosks removed';
	value = kiosks_removed;
	return query select property, name, value;
	
	property = 'stats';
	name = 'allocation summary';
	value = 'allocation: ' || allocation[1] || ', demand: ' || demand[1] || ', allocation percentage: ' ||  cast(100*demand[1]/allocation[1] as integer);
	return query select property, name, value;
end

$$;


ALTER FUNCTION mixalot.pick_get_summary(target_date date) OWNER TO dbservice;

--
-- Name: pick_inventory_insert(); Type: FUNCTION; Schema: mixalot; Owner: dbservice
--

CREATE FUNCTION mixalot.pick_inventory_insert() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
  begin
  	new.route_date = new.pick_date;
  	return new;
  end;
  $$;


ALTER FUNCTION mixalot.pick_inventory_insert() OWNER TO dbservice;

--
-- Name: pick_summary(date); Type: FUNCTION; Schema: mixalot; Owner: dbservice
--

CREATE FUNCTION mixalot.pick_summary(target_date date) RETURNS TABLE(property text, name text, value text)
    LANGUAGE plpgsql
    AS $$

declare pick_tickets_generated integer;

-- one-based arrays of 3 numbers, 1 for target date and 2 for the same weekday one and two weeks ago
declare ticket integer ARRAY;
declare demand integer ARRAY;
declare allocation integer ARRAY;

declare property text;
declare name text;
declare value text;
declare total integer;
declare result_row record;

declare kiosks_added text;
declare kiosks_removed text;

begin
	
	FOR i IN 0..2 LOOP
 		select count(*) from inm.pick_route where pick_date = target_date - 7*i  into total;
		ticket[i+1] = total; -- convert to one-based index
		select sum(qty) from inm.pick_demand where pick_date = target_date - 7*i into total;
		demand[i+1] = total;
		select sum(qty) from inm.pick_allocation where pick_date = target_date - 7*i into total;
		allocation[i+1] = total;
   	END LOOP;
	
	select array_to_string(array_agg(cast (kiosk_id as varchar) order by kiosk_id), ',') from inm.pick_route 
		where pick_date = target_date and kiosk_id not in
			(select kiosk_id from inm.pick_route where pick_date = target_date - 7)
	into kiosks_added;
	
	select array_to_string(array_agg(cast (kiosk_id as varchar) order by kiosk_id), ',') from inm.pick_route 
		where pick_date = target_date - 7  and kiosk_id not in
			(select kiosk_id from inm.pick_route where pick_date = target_date)
	into kiosks_removed;
		
	property = 'stats';
	name = 'pick tickets today/ -7 days/ -14 days: ';
	value = ticket[1] || '/' || ticket[2] || '/' || ticket[3];
	return query select property, name, value;
	
	property = 'stats';
	name = 'demand qty today/ -7 days/ -14 days: ';
	value = demand[1] || '/' || demand[2] || '/' || demand[3];
	return query select property, name, value;
	
	property = 'stats';
	name = 'allocation qty today/ -7 days/ -14 days: ';
	value = allocation[1] || '/' || allocation[2] || '/' || allocation[3];
	return query select property, name, value;
	
	property = 'stats';
	name = 'kiosks added';
	value = kiosks_added;
	return query select property, name, value;
	
	property = 'stats';
	name = 'kiosks removed';
	value = kiosks_removed;
	return query select property, name, value;
	
end

$$;


ALTER FUNCTION mixalot.pick_summary(target_date date) OWNER TO dbservice;

--
-- Name: pick_ticket(date); Type: FUNCTION; Schema: mixalot; Owner: dbservice
--

CREATE FUNCTION mixalot.pick_ticket(target_date date) RETURNS TABLE(pick_station bigint, vendor character varying, item_code bigint, item_name character varying, site_code bigint, site_name character varying, proposed_supply integer, total_pick_qty bigint, total_pick_sku integer, driver_name character varying, route_date date, route_time time without time zone, route_date_time timestamp without time zone, route_number character varying, restrictions text, address character varying, pull_date date, delivery_order integer, pick_order integer)
    LANGUAGE plpgsql
    AS $$

	declare latest_import_ts timestamp;
	declare plan_window_start timestamp;
	declare plan_window_stop timestamp;
begin
	-- return pick ticket data for the latest pick
	
	-- calculate various date params
	select max(import_ts) from mixalot.inm_data into latest_import_ts;
	select i.route_date from mixalot.inm_data i
		where import_ts = latest_import_ts and data_type = 'Plan Window Start'
		into plan_window_start;
	select i.route_date from mixalot.inm_data i
		where import_ts = latest_import_ts and data_type = 'Plan Window Stop'
		into plan_window_stop;
	
	if target_date is null
		then target_date = plan_window_start::date;
	end if;
		
	return query
		select 
				p.pick_station, p.vendor, p.id, p.title ItemName,
				k.id sitecode, k.title sitename, a.qty proposed_supply, 
				sum(a.qty) over(partition by k.id, route.route_date) total_pick_qty,
				-1 total_pick_sku, 
				route.driver_name DriverName, route.route_date RouteDate, route.route_time RouteTime,
				route.route_date + route.route_time route_date_time, route.route_number,
				r.restrictions,
				k.address,
				pd.pull_date,
				cast(route.delivery_order as integer),
				spo.pick_order
			from mixalot.pick_allocation a 
				left join pantry.kiosk k on a.kiosk_id = k.id
				left join mixalot.inm_kiosk_restriction_list r on k.id = r.kiosk_id
				join pantry.product p on a.sku_id = p.id
				join mixalot.pick_route route on a.route_date=route.route_date and a.kiosk_id = route.kiosk_id
				left join mixalot.pull_date(plan_window_start, plan_window_stop) pd on a.kiosk_id = pd.kiosk_id
				left join mixalot.sku_pick_order(latest_import_ts) spo on p.id = spo.sku_id
			where k.campus_id = 87
			and a.pick_date = target_date;
end

$$;


ALTER FUNCTION mixalot.pick_ticket(target_date date) OWNER TO dbservice;

--
-- Name: plan_kiosk(timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: mixalot; Owner: dbservice
--

CREATE FUNCTION mixalot.plan_kiosk(plan_window_start timestamp with time zone, plan_window_stop timestamp with time zone) RETURNS TABLE(kiosk_id integer, route_date_time timestamp with time zone, driver_name character varying, location_name character varying, next_delivery_ts timestamp with time zone, time_to_next_delivery interval, days_to_next_delivery double precision, delivery_order bigint)
    LANGUAGE plpgsql
    AS $$

/*
Purpose: return INM plan kiosks for a pick window.
*/

begin
	return query
		select ds.kiosk_id, ds.route_date_time, ds.driver_name, ds.location_name, ps.next_delivery_ts,
		ps.next_delivery_ts - ds.route_date_time as time_to_next_delivery,		
		  case 
		  	when ps.next_delivery_ts - ds.route_date_time between interval '12 hours' and interval '24 hours' then 1
			else extract(day from ps.next_delivery_ts - ds.route_date_time)
			end as days_to_next_delivery,
		  row_number() over (order by ds.route_date_time asc) as delivery_order
		  
		
		from
		-- kiosk_id, delivery_date
		(select t.kiosk_id, t.route_date_time, t.driver_name, t.location_name from
			(select location_number as kiosk_id, rs.route_date_time, rs.driver_name, rs.location_name,
				rank() over (partition by location_number order by rs.route_date_time) as r
				from mixalot.route_stop rs
				where rs.route_date_time >= plan_window_start -- look at routes starting at plan winddow start
				and location_number > 0) t
				where r = 1) ds

		left join 
		-- kiosk_id, pull_date
		(select t.kiosk_id, t.route_date_time next_delivery_ts from
			(select location_number as kiosk_id, rs.route_date_time,
				rank() over (partition by location_number order by rs.route_date_time) as r
				from mixalot.route_stop rs
				where rs.route_date_time >= plan_window_start -- look at routes starting at plan window start
				and location_number > 0) t
				where r = 2) ps

			on ds.kiosk_id = ps.kiosk_id
			join pantry.kiosk k on ds.kiosk_id = k.id
			where ds.route_date_time between plan_window_start and plan_window_stop
			and k.campus_id= 87;	
end;

$$;


ALTER FUNCTION mixalot.plan_kiosk(plan_window_start timestamp with time zone, plan_window_stop timestamp with time zone) OWNER TO dbservice;

--
-- Name: set_sequence_val_max(name, name, boolean); Type: FUNCTION; Schema: mixalot; Owner: dbservice
--

CREATE FUNCTION mixalot.set_sequence_val_max(schema_name name, table_name name DEFAULT NULL::name, raise_notice boolean DEFAULT false) RETURNS void
    LANGUAGE plpgsql
    AS $$

-- Sets all the sequences in the schema "schema_name" to the max(id) of every table (or a specific table, if name is supplied)
-- Examples:
--  SELECT setval_max('public');
--  SELECT setval_max('public','mytable');
--  SELECT setval_max('public',null,true);
--  SELECT setval_max('public','mytable',true);

DECLARE
    row_data RECORD;
    sql_code TEXT;

BEGIN
    IF ((SELECT COUNT(*) FROM pg_namespace WHERE nspname = schema_name) = 0) THEN
        RAISE EXCEPTION 'The schema "%" does not exist', schema_name;
    END IF;

    FOR sql_code IN
        SELECT 'SELECT SETVAL(' ||quote_literal(N.nspname || '.' || S.relname)|| ', MAX(' ||quote_ident(C.attname)|| ') ) FROM ' || quote_ident(N.nspname) || '.' || quote_ident(T.relname)|| ';' AS sql_code
            FROM pg_class AS S
            INNER JOIN pg_depend AS D ON S.oid = D.objid
            INNER JOIN pg_class AS T ON D.refobjid = T.oid
            INNER JOIN pg_attribute AS C ON D.refobjid = C.attrelid AND D.refobjsubid = C.attnum
            INNER JOIN pg_namespace N ON N.oid = S.relnamespace
            WHERE S.relkind = 'S' AND N.nspname = schema_name AND (table_name IS NULL OR T.relname = table_name)
            ORDER BY S.relname
    LOOP
        IF (raise_notice) THEN
            RAISE NOTICE 'sql_code: %', sql_code;
        END IF;
        EXECUTE sql_code;
    END LOOP;
END;
$$;


ALTER FUNCTION mixalot.set_sequence_val_max(schema_name name, table_name name, raise_notice boolean) OWNER TO dbservice;

--
-- Name: sku_pick_order(timestamp with time zone); Type: FUNCTION; Schema: mixalot; Owner: dbservice
--

CREATE FUNCTION mixalot.sku_pick_order(target_ts timestamp with time zone) RETURNS TABLE(sku_id integer, pick_order integer)
    LANGUAGE plpgsql
    AS $$

declare latest_import_ts timestamp with time zone;

/*
Purpose: return a sku pick_order for the most recent import data for a given date
*/
begin
	select max(import_ts) from mixalot.inm_data
		where import_ts <= target_ts and data_type = 'Warehouse SKU Inventory'
		into latest_import_ts;
	
	return query
		select distinct product_id, d.sort_order
		  from mixalot.inm_data d
		  where import_ts = latest_import_ts and data_type = 'Warehouse SKU Inventory';	
end;

$$;


ALTER FUNCTION mixalot.sku_pick_order(target_ts timestamp with time zone) OWNER TO dbservice;

--
-- Name: fn_add_to_watch(bigint, character varying); Type: FUNCTION; Schema: pantry; Owner: dbservice
--

CREATE FUNCTION pantry.fn_add_to_watch(label_id bigint, order_id character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$ 
BEGIN 
  INSERT INTO pantry.tmp_watcher
              ( 
                          label_id,
                          order_id,                           
                          created
              ) 
  VALUES (
  		label_id, order_id, (SELECT date_part('epoch',CURRENT_TIMESTAMP)::int)
  	);
END
$$;


ALTER FUNCTION pantry.fn_add_to_watch(label_id bigint, order_id character varying) OWNER TO dbservice;

--
-- Name: fn_audit_campus_attribute(); Type: FUNCTION; Schema: pantry; Owner: dbservice
--

CREATE FUNCTION pantry.fn_audit_campus_attribute() RETURNS trigger
    LANGUAGE plpgsql
    AS $$

   BEGIN
   IF (TG_OP = 'INSERT') THEN
       INSERT INTO pantry.history_campus_attribute(campus_id,gad_id,value,time_modified,action)
       VALUES(NEW.campus_id, NEW.key_id, NEW.value, now(),'INSERT');
       RETURN NEW;
   ELSEIF (TG_OP = 'UPDATE') THEN
       INSERT INTO pantry.history_campus_attribute(campus_id,gad_id,value,time_modified,action)
       VALUES(NEW.campus_id, NEW.key_id, NEW.value, now(),'UPDATE');
       RETURN NEW;
   ELSEIF (TG_OP = 'DELETE') THEN
       INSERT INTO pantry.history_campus_attribute(campus_id,gad_id,value,time_modified,action)
       VALUES(OLD.campus_id, OLD.key_id, OLD.value, now(),'DELETE');
       RETURN OLD;
   END IF;
   RETURN NULL; -- result is ignored since this is an AFTER trigger
END;
$$;


ALTER FUNCTION pantry.fn_audit_campus_attribute() OWNER TO dbservice;

--
-- Name: fn_audit_global_attribute_def(); Type: FUNCTION; Schema: pantry; Owner: dbservice
--

CREATE FUNCTION pantry.fn_audit_global_attribute_def() RETURNS trigger
    LANGUAGE plpgsql
    AS $$

   BEGIN
   IF (TG_OP = 'INSERT') THEN
       INSERT INTO pantry.history_global_attribute_def(key,value,time_modified,action)
       VALUES(NEW.key,NEW.default_value, now(),'INSERT');
       RETURN NEW;
   ELSEIF (TG_OP = 'UPDATE') THEN
       INSERT INTO pantry.history_global_attribute_def(key,value,time_modified,action)
       VALUES(NEW.key,NEW.default_value,now(),'UPDATE');
       RETURN NEW;
   ELSEIF (TG_OP = 'DELETE') THEN
       INSERT INTO pantry.history_global_attribute_def(key,value,time_modified,action)
       VALUES(OLD.key,OLD.default_value,now(),'DELETE');
       RETURN OLD;
   END IF;
   RETURN NULL; -- result is ignored since this is an AFTER trigger
END;
$$;


ALTER FUNCTION pantry.fn_audit_global_attribute_def() OWNER TO dbservice;

--
-- Name: fn_audit_kiosk_attribute(); Type: FUNCTION; Schema: pantry; Owner: dbservice
--

CREATE FUNCTION pantry.fn_audit_kiosk_attribute() RETURNS trigger
    LANGUAGE plpgsql
    AS $$

   BEGIN
   IF (TG_OP = 'INSERT') THEN
       INSERT INTO pantry.history_kiosk_attribute(kiosk_id,gad_id,value,time_modified,action)
       VALUES(NEW.kiosk_id, NEW.key_id, NEW.value, now(),'INSERT');
       RETURN NEW;
   ELSEIF (TG_OP = 'UPDATE') THEN
       INSERT INTO pantry.history_kiosk_attribute(kiosk_id,gad_id,value,time_modified,action)
       VALUES(NEW.kiosk_id, NEW.key_id, NEW.value, now(),'UPDATE');
       RETURN NEW;
   ELSEIF (TG_OP = 'DELETE') THEN
       INSERT INTO pantry.history_kiosk_attribute(kiosk_id,gad_id,value,time_modified,action)
       VALUES(OLD.kiosk_id, OLD.key_id, OLD.value, now(),'DELETE');
       RETURN OLD;
   END IF;
   RETURN NULL; -- result is ignored since this is an AFTER trigger
END;
$$;


ALTER FUNCTION pantry.fn_audit_kiosk_attribute() OWNER TO dbservice;

--
-- Name: fn_audit_kiosk_device(); Type: FUNCTION; Schema: pantry; Owner: dbservice
--

CREATE FUNCTION pantry.fn_audit_kiosk_device() RETURNS trigger
    LANGUAGE plpgsql
    AS $$

   BEGIN
   IF (TG_OP = 'INSERT') THEN
       INSERT INTO pantry.history_kiosk_device(kiosk_id,payload,time_modified,action)
       VALUES(NEW.kiosk_id, NEW.payload, now(),'INSERT');
       RETURN NEW;
   ELSEIF (TG_OP = 'UPDATE') THEN
       INSERT INTO pantry.history_kiosk_device(kiosk_id,payload,time_modified,action)
       VALUES(NEW.kiosk_id, NEW.payload, now(),'UPDATE');
       RETURN NEW;
   ELSEIF (TG_OP = 'DELETE') THEN
       INSERT INTO pantry.history_kiosk_device(kiosk_id,payload,time_modified,action)
       VALUES(OLD.kiosk_id, OLD.payload, now(),'DELETE');
       RETURN OLD;
   END IF;
   RETURN NULL; -- result is ignored since this is an AFTER trigger
END;
$$;


ALTER FUNCTION pantry.fn_audit_kiosk_device() OWNER TO dbservice;

--
-- Name: fn_audit_kiosk_service_version(); Type: FUNCTION; Schema: pantry; Owner: dbservice
--

CREATE FUNCTION pantry.fn_audit_kiosk_service_version() RETURNS trigger
    LANGUAGE plpgsql
    AS $$

   BEGIN
   IF (TG_OP = 'INSERT') THEN
       INSERT INTO pantry.history_kiosk_service_version(kiosk_id,service,version,time_modified,action)
       VALUES(NEW.kiosk_id, NEW.service, NEW.version, now(),'INSERT');
       RETURN NEW;
   ELSEIF (TG_OP = 'UPDATE') THEN
       INSERT INTO pantry.history_kiosk_service_version(kiosk_id,service,version,time_modified,action)
       VALUES(NEW.kiosk_id, NEW.service, NEW.version, now(),'UPDATE');
       RETURN NEW;
   ELSEIF (TG_OP = 'DELETE') THEN
       INSERT INTO pantry.history_kiosk_service_version(kiosk_id,service,version,time_modified,action)
       VALUES(OLD.kiosk_id, OLD.service, OLD.version, now(),'DELETE');
       RETURN OLD;
   END IF;
   RETURN NULL; -- result is ignored since this is an AFTER trigger
END;
$$;


ALTER FUNCTION pantry.fn_audit_kiosk_service_version() OWNER TO dbservice;

--
-- Name: fn_campus_insert(); Type: FUNCTION; Schema: pantry; Owner: dbservice
--

CREATE FUNCTION pantry.fn_campus_insert() RETURNS trigger
    LANGUAGE plpgsql
    AS $$ 
BEGIN 
   INSERT INTO pantry.group_campus (group_id, campus_id)
    VALUES(1, NEW.id);		
  RETURN NEW; 
END; 
$$;


ALTER FUNCTION pantry.fn_campus_insert() OWNER TO dbservice;

--
-- Name: fn_card_insert(); Type: FUNCTION; Schema: pantry; Owner: dbservice
--

CREATE FUNCTION pantry.fn_card_insert() RETURNS trigger
    LANGUAGE plpgsql
    AS $$ 
BEGIN 
 	UPDATE pantry.ro_order 
	SET    customer_full_name = concat_ws(' ', coalesce(trim(NEW.first_name), o.payment_system), coalesce(trim(NEW.last_name), substring(NEW.number, -8)))
	FROM pantry.order o 
	WHERE pantry.ro_order.order_id = o.order_id AND o.card_hash = NEW.hash;
  RETURN NEW; 
END; 
$$;


ALTER FUNCTION pantry.fn_card_insert() OWNER TO dbservice;

--
-- Name: fn_discount_delete(); Type: FUNCTION; Schema: pantry; Owner: dbservice
--

CREATE FUNCTION pantry.fn_discount_delete() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
UPDATE pantry.discount_history 
SET end_time = (SELECT date_part('epoch',CURRENT_TIMESTAMP)::int) 
WHERE discount_id = OLD.id AND end_time IS NULL;
RETURN NEW;
END;
$$;


ALTER FUNCTION pantry.fn_discount_delete() OWNER TO dbservice;

--
-- Name: fn_discount_insert(); Type: FUNCTION; Schema: pantry; Owner: dbservice
--

CREATE FUNCTION pantry.fn_discount_insert() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
 BEGIN
        INSERT INTO pantry.discount_history (kiosk_id, product_id, value, start_time, end_time, discount_id)
    VALUES(NEW.kiosk_id, NEW.product_id, NEW.value,  EXTRACT(epoch FROM NOW()) , NULL, NEW.id);
RETURN NEW;
END;
$$;


ALTER FUNCTION pantry.fn_discount_insert() OWNER TO dbservice;

--
-- Name: fn_discount_update(); Type: FUNCTION; Schema: pantry; Owner: dbservice
--

CREATE FUNCTION pantry.fn_discount_update() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
	UPDATE pantry.discount_history SET end_time = EXTRACT(epoch FROM NOW()) WHERE discount_id = OLD.id AND end_time IS NULL;
	INSERT INTO pantry.discount_history (kiosk_id, product_id, value, start_time, end_time, discount_id)
    VALUES(NEW.kiosk_id, NEW.product_id, NEW.value, EXTRACT(epoch FROM NOW()) + 1, NULL, NEW.id);
RETURN NEW;
END;


$$;


ALTER FUNCTION pantry.fn_discount_update() OWNER TO dbservice;

--
-- Name: fn_kiosk_audit_log_insert(); Type: FUNCTION; Schema: pantry; Owner: dbservice
--

CREATE FUNCTION pantry.fn_kiosk_audit_log_insert() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
INSERT INTO pantry.kiosk_audit_log (
    kiosk_id, archived, enable_reporting, enable_monitoring
) VALUES (
    NEW.id, NEW.archived, NEW.enable_reporting, NEW.enable_monitoring
);
RETURN NEW;
END;
$$;


ALTER FUNCTION pantry.fn_kiosk_audit_log_insert() OWNER TO dbservice;

--
-- Name: fn_kiosk_audit_log_update(); Type: FUNCTION; Schema: pantry; Owner: dbservice
--

CREATE FUNCTION pantry.fn_kiosk_audit_log_update() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
IF (
 NEW.archived != OLD.archived
 OR
 NEW.enable_reporting != OLD.enable_reporting
 OR
 NEW.enable_monitoring != OLD.enable_monitoring
) THEN
 INSERT INTO pantry.kiosk_audit_log (
    kiosk_id, archived, enable_reporting, enable_monitoring
 ) VALUES (
    OLD.id, NEW.archived, NEW.enable_reporting, NEW.enable_monitoring
);
END IF;
RETURN NEW;
END;
$$;


ALTER FUNCTION pantry.fn_kiosk_audit_log_update() OWNER TO dbservice;

--
-- Name: fn_kiosk_status_insert(); Type: FUNCTION; Schema: pantry; Owner: dbservice
--

CREATE FUNCTION pantry.fn_kiosk_status_insert() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  last_kiosk_status_time BIGINT;
  status_is_newer BOOLEAN;
BEGIN

  -- calculate if status about to be inserted is newer than that in last_kiosk_status
  SELECT time from pantry.last_kiosk_status WHERE kiosk_id = new.kiosk_id
         INTO last_kiosk_status_time;
  status_is_newer =  (last_kiosk_status_time is null) or new.time > last_kiosk_status_time;

  IF status_is_newer
    THEN
      INSERT INTO pantry.last_kiosk_status
        (kiosk_id, kiosk_temperature, kit_temperature, power, battery_level, rfid_0, rfid_1, rfid_2, rfid_3, rfid_4,
         rfid_5, rfid_6, rfid_7, time, modem_signal_percentage, modem_signal_type, ip, temperature_tags,
         kiosk_temperature_source, kiosk_temperature_count, app_uptime, system_uptime, is_locked,
         num_payment_messages_pending_sync)
        VALUES (NEW.kiosk_id, NEW.kiosk_temperature, NEW.kit_temperature, NEW.power, NEW.battery_level, NEW.rfid_0,
                NEW.rfid_1, NEW.rfid_2, NEW.rfid_3, NEW.rfid_4, NEW.rfid_5, NEW.rfid_6, NEW.rfid_7, NEW.time,
                NEW.modem_signal_percentage, NEW.modem_signal_type, NEW.ip, NEW.temperature_tags,
                NEW.kiosk_temperature_source, NEW.kiosk_temperature_count, NEW.app_uptime, NEW.system_uptime,
                NEW.is_locked, NEW.num_payment_messages_pending_sync)
        ON conflict (kiosk_id) DO
        UPDATE
        SET
          kiosk_id = excluded.kiosk_id,
          kiosk_temperature = excluded.kiosk_temperature,
          kit_temperature = excluded.kit_temperature,
          power = excluded.power,
          battery_level = excluded.battery_level,
          rfid_0 = excluded.rfid_0,
          rfid_1 = excluded.rfid_1,
          rfid_2 = excluded.rfid_2,
          rfid_3 = excluded.rfid_3,
          rfid_4 = excluded.rfid_4,
          rfid_5 = excluded.rfid_5,
          rfid_6 = excluded.rfid_6,
          rfid_7 = excluded.rfid_7,
          time = excluded.time,
          modem_signal_percentage = excluded.modem_signal_percentage,
          modem_signal_type = excluded.modem_signal_type,
          ip = excluded.ip,
          temperature_tags = excluded.temperature_tags,
          kiosk_temperature_source = excluded.kiosk_temperature_source,
          kiosk_temperature_count = excluded.kiosk_temperature_count,
          app_uptime = excluded.app_uptime,
          system_uptime = excluded.system_uptime,
          is_locked = excluded.is_locked,
          num_payment_messages_pending_sync = excluded.num_payment_messages_pending_sync;
  END IF;

RETURN NEW;
END;
$$;


ALTER FUNCTION pantry.fn_kiosk_status_insert() OWNER TO dbservice;

--
-- Name: fn_kiosk_update(); Type: FUNCTION; Schema: pantry; Owner: dbservice
--

CREATE FUNCTION pantry.fn_kiosk_update() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
IF (NEW.archived <> OLD.archived OR NEW.campus_id <> OLD.campus_id) THEN
      UPDATE pantry.ro_order roo        
      SET campus_id = k.campus_id, 
      archived = 
      	CASE WHEN (k.archived = 1 OR o.archived = 1) 
      		THEN 1 
      		ELSE 0 
      	END
      FROM pantry.kiosk k, pantry.order o
      WHERE k.id = NEW.id AND roo.order_id = o.order_id AND k.id = roo.kiosk_id;
    END IF;
RETURN NEW;
END;
$$;


ALTER FUNCTION pantry.fn_kiosk_update() OWNER TO dbservice;

--
-- Name: fn_label_delete(); Type: FUNCTION; Schema: pantry; Owner: dbservice
--

CREATE FUNCTION pantry.fn_label_delete() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    IF OLD.order_id IS NOT NULL THEN
      SELECT pantry.fn_add_to_watch(OLD.id, OLD.order_id);
    END IF;
RETURN NEW;
END;
$$;


ALTER FUNCTION pantry.fn_label_delete() OWNER TO dbservice;

--
-- Name: fn_label_insert(); Type: FUNCTION; Schema: pantry; Owner: dbservice
--

CREATE FUNCTION pantry.fn_label_insert() RETURNS trigger
    LANGUAGE plpgsql
    AS $$ 
BEGIN
   IF NEW.order_id is NOT NULL THEN 
   	PERFORM pantry.fn_add_to_watch(NEW.id, NEW.order_id);		
   END IF;	
  RETURN NEW; 
END; 
$$;


ALTER FUNCTION pantry.fn_label_insert() OWNER TO dbservice;

--
-- Name: fn_label_update(); Type: FUNCTION; Schema: pantry; Owner: dbservice
--

CREATE FUNCTION pantry.fn_label_update() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  IF (OLD.order_id IS NOT NULL OR NEW.order_id IS NOT NULL) THEN
      IF NEW.order_id = OLD.order_id THEN
        IF NEW.price <> OLD.price THEN
          PERFORM pantry.fn_add_to_watch(NEW.id, NEW.order_id);
        END IF;
      ELSE
        IF NEW.order_id IS NOT NULL THEN
          PERFORM pantry.fn_add_to_watch(NEW.id, NEW.order_id);
        END IF;
        IF OLD.order_id IS NOT NULL THEN
          PERFORM pantry.fn_add_to_watch(NEW.id, OLD.order_id);
        END IF;
      END IF;
    END IF;
RETURN NEW;
END;
$$;


ALTER FUNCTION pantry.fn_label_update() OWNER TO dbservice;

--
-- Name: fn_order_insert(); Type: FUNCTION; Schema: pantry; Owner: dbservice
--

CREATE FUNCTION pantry.fn_order_insert() RETURNS trigger
    LANGUAGE plpgsql
    AS $$ 
BEGIN 
   PERFORM pantry.fn_ro_order_set_order(NEW.order_id);		
  RETURN NEW; 
END; 
$$;


ALTER FUNCTION pantry.fn_order_insert() OWNER TO dbservice;

--
-- Name: fn_order_update(); Type: FUNCTION; Schema: pantry; Owner: dbservice
--

CREATE FUNCTION pantry.fn_order_update() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
IF (NEW.kiosk_id <> OLD.kiosk_id OR NEW.kiosk_title <> OLD.kiosk_title 
    OR NEW.created <> OLD.created OR NEW.state <> OLD.state 
    OR NEW.archived <> OLD.archived 
    OR NEW.amount_list_price IS DISTINCT FROM OLD.amount_list_price) THEN
      PERFORM pantry.fn_ro_order_set_order(NEW.order_id);
    END IF;
RETURN NEW;
END;
$$;


ALTER FUNCTION pantry.fn_order_update() OWNER TO dbservice;

--
-- Name: fn_product_delete(); Type: FUNCTION; Schema: pantry; Owner: dbservice
--

CREATE FUNCTION pantry.fn_product_delete() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
	UPDATE pantry.product_history SET end_time = EXTRACT(epoch FROM NOW()) WHERE product_id = OLD.id AND end_time IS NULL;
RETURN NEW;
END;
$$;


ALTER FUNCTION pantry.fn_product_delete() OWNER TO dbservice;

--
-- Name: fn_product_insert(); Type: FUNCTION; Schema: pantry; Owner: dbservice
--

CREATE FUNCTION pantry.fn_product_insert() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
 BEGIN
    INSERT INTO pantry.product_history (price, cost, start_time, end_time, product_id, campus_id)
    VALUES(NEW.price, NEW.cost, (SELECT date_part('epoch',CURRENT_TIMESTAMP)::int), NULL, NEW.id, NEW.campus_id);
      
RETURN NEW;
END;
$$;


ALTER FUNCTION pantry.fn_product_insert() OWNER TO dbservice;

--
-- Name: fn_product_stats_by_kiosk(); Type: FUNCTION; Schema: pantry; Owner: dbservice
--

CREATE FUNCTION pantry.fn_product_stats_by_kiosk() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
        IF NEW.timestamp IS NULL THEN				
                NEW.timestamp = EXTRACT(epoch FROM NOW());
        END IF;
RETURN NEW;		
END;
$$;


ALTER FUNCTION pantry.fn_product_stats_by_kiosk() OWNER TO dbservice;

--
-- Name: fn_product_update(); Type: FUNCTION; Schema: pantry; Owner: dbservice
--

CREATE FUNCTION pantry.fn_product_update() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN

    IF NEW.price <> OLD.price OR NEW.cost <> OLD.cost THEN
		UPDATE pantry.product_history SET end_time = EXTRACT(epoch FROM NOW()) WHERE product_id = OLD.id AND end_time IS NULL;
		INSERT INTO pantry.product_history (price, cost, start_time, end_time, product_id, campus_id)
		VALUES(NEW.price, NEW.cost, EXTRACT(epoch FROM NOW()) + 1, NULL, NEW.id, NEW.campus_id);
    END IF;

RETURN NEW;
END;
$$;


ALTER FUNCTION pantry.fn_product_update() OWNER TO dbservice;

--
-- Name: fn_ro_order_set_order(character varying); Type: FUNCTION; Schema: pantry; Owner: dbservice
--

CREATE FUNCTION pantry.fn_ro_order_set_order(orderid character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$ 
BEGIN 
  INSERT INTO pantry.ro_order 
              ( 
                          order_id, 
                          campus_id, 
                          kiosk_id, 
                          kiosk_title, 
                          created, 
                          state, 
                          customer_full_name, 
                          archived 
              ) 
  SELECT    o.order_id, 
            k.campus_id, 
            o.kiosk_id, 
            o.kiosk_title, 
            o.created, 
            o.state, 
            concat_ws(' ', coalesce(trim(c.first_name), o.payment_system), coalesce(trim(c.last_name), substring(c.NUMBER, -8))) customer_full_name,
            cast( 
            CASE 
                      WHEN( 
                                          k.archived = 1 
                                OR        o.archived = 1) THEN 1::bigint 
                      ELSE 0::                                    bigint 
            END AS                                                bigint) 
  FROM      pantry.ORDER o 
  left join pantry.kiosk k 
  ON        k.id = o.kiosk_id 
  left join pantry.card c 
  ON        c.hash = o.card_hash 
  WHERE     o.order_id = orderid
  LIMIT 1
  ON conflict (order_id) DO 
  UPDATE 
  SET    campus_id = excluded.campus_id, 
         kiosk_id = excluded.kiosk_id, 
         kiosk_title = excluded.kiosk_title, 
         created = excluded.created, 
         state = excluded.state, 
         customer_full_name = excluded.customer_full_name;
PERFORM pantry.fn_ro_order_update_full_price(orderId);                                                                                                                                                                                                                                 
END
$$;


ALTER FUNCTION pantry.fn_ro_order_set_order(orderid character varying) OWNER TO dbservice;

--
-- Name: fn_ro_order_update_full_price(character varying); Type: FUNCTION; Schema: pantry; Owner: dbservice
--

CREATE FUNCTION pantry.fn_ro_order_update_full_price(orderid character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
UPDATE pantry.ro_order
    SET
      real_full_price = (
        SELECT                   
                        CASE WHEN (o.state <> 'NonTrans')
                          THEN
                                  COALESCE(SUM(l.price), 0)
                          ELSE
                                  0
                          END
        FROM pantry.label l
          JOIN pantry.order o ON o.order_id = l.order_id
        WHERE l.order_id = orderId
                GROUP BY o.state  
      ),
      full_price = (
        SELECT                   
                        CASE WHEN (o.state <> 'NonTrans')
                          THEN
                                  COALESCE(SUM(l.price), 0)
                          ELSE
                                  0
                          END
        FROM pantry.label l
          JOIN pantry.order o ON o.order_id = l.order_id
          JOIN pantry.kiosk k ON k.id = o.kiosk_id
          JOIN pantry.product p ON p.id = l.product_id
          JOIN pantry.group_campus gc1 ON gc1.campus_id = k.campus_id AND gc1.owner = 1
          JOIN pantry.group_campus gc2 ON gc2.campus_id = p.campus_id AND gc2.owner = 1
        WHERE l.order_id = orderId
              AND gc1.group_id = gc2.group_id
                GROUP BY o.state  
      ),
      time_updated = (SELECT date_part('epoch',CURRENT_TIMESTAMP)::int)
    WHERE ro_order.order_id = orderId;
END
$$;


ALTER FUNCTION pantry.fn_ro_order_update_full_price(orderid character varying) OWNER TO dbservice;

--
-- Name: fn_spoilage_insert(); Type: FUNCTION; Schema: pantry; Owner: dbservice
--

CREATE FUNCTION pantry.fn_spoilage_insert() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
        IF NEW.timestamp IS NULL THEN				
                NEW.timestamp = EXTRACT(epoch FROM NOW());
        END IF;
RETURN NEW;		
END;
$$;


ALTER FUNCTION pantry.fn_spoilage_insert() OWNER TO dbservice;

--
-- Name: get_permissions(integer); Type: FUNCTION; Schema: pantry; Owner: dbservice
--

CREATE FUNCTION pantry.get_permissions(a integer) RETURNS TABLE(role_id integer, permission character varying, api character varying, isfrontend integer)
    LANGUAGE plpgsql
    AS $$ 
BEGIN
    RETURN QUERY SELECT h.role_id, h.permission, h.api, h.isFrontend FROM pantry.HIERARCHY(a, 1) h; 
END;
$$;


ALTER FUNCTION pantry.get_permissions(a integer) OWNER TO dbservice;

--
-- Name: hierarchy(integer, integer); Type: FUNCTION; Schema: pantry; Owner: dbservice
--

CREATE FUNCTION pantry.hierarchy(givenid integer, initial integer) RETURNS TABLE(role_id integer, permission character varying, api character varying, isfrontend integer)
    LANGUAGE plpgsql
    AS $$ 
    DECLARE next_id INT;

    DECLARE cur1 REFCURSOR;
    DECLARE cur2 REFCURSOR;
BEGIN
    IF initial=1 THEN
 DROP TABLE IF EXISTS OUT_TEMP;
        CREATE TEMPORARY TABLE OUT_TEMP (role_id int, permission varchar(255), api varchar(255), isFrontend int);
    END IF;

    IF GivenID IS NULL then
        OPEN cur2 FOR SELECT id FROM pantry.role;
        LOOP
            FETCH cur2 INTO next_id;

     EXIT WHEN NOT FOUND;

            PERFORM pantry.Hierarchy(next_id, -1);
        END LOOP;

        CLOSE cur2;
    ELSE
        INSERT INTO OUT_TEMP(role_id, permission, api, isFrontend) (SELECT null, p.permission, p.api, p."isFrontend" FROM pantry.permission_mapping pm JOIN pantry.permission p ON p.id =pm.permission_id WHERE pm.role_id = GivenID);
        OPEN cur1 FOR SELECT rm.role_id FROM pantry.role_mapping rm WHERE parent_id = GivenID;
        LOOP
            FETCH cur1 INTO next_id;

            EXIT WHEN NOT FOUND;

            PERFORM pantry.Hierarchy(next_id, 0);
        END LOOP;

        CLOSE cur1;
    END IF;

    IF initial=-1 THEN
        UPDATE OUT_TEMP ot SET role_id = GivenID WHERE ot.role_id IS NULL;
    ELSEIF GivenID IS NULL THEN
        RETURN QUERY SELECT DISTINCT ot.role_id, ot.permission, ot.api, ot.isFrontend FROM OUT_TEMP ot;
 DROP TABLE OUT_TEMP;
    ELSEIF initial = 1 THEN
        RETURN QUERY SELECT DISTINCT ot.permission, ot.api, ot.isFrontend FROM OUT_TEMP;
 DROP TABLE OUT_TEMP;
    END IF;
END;
$$;


ALTER FUNCTION pantry.hierarchy(givenid integer, initial integer) OWNER TO dbservice;

--
-- Name: key_loc_lookup(bigint, character varying); Type: FUNCTION; Schema: pantry; Owner: dbservice
--

CREATE FUNCTION pantry.key_loc_lookup(param_kiosk_id bigint, key_name character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
    gad_val varchar;
    campus_val varchar;
    kiosk_val varchar;
    lookup_campus_id int;

BEGIN
  select campus_id from pantry.kiosk where id = param_kiosk_id into lookup_campus_id;
  select subquery.gad, subquery.campus, subquery.kiosk  from
(
    SELECT
           gad.default_value AS gad,
           ca.value AS campus,
           ka.value  AS kiosk

    FROM pantry.global_attribute_def gad
             LEFT JOIN pantry.campus_attribute ca ON gad.id = ca.key_id and ca.campus_id = lookup_campus_id
             LEFT JOIN pantry.kiosk_attribute ka ON gad.id = ka.key_id and ka.kiosk_id = param_kiosk_id
    WHERE gad.key = key_name
) subquery into gad_val, campus_val, kiosk_val;

IF kiosk_val is not null THEN
  return 'kiosk';
ELSIF campus_val is not null THEN
    return 'campus';
ELSEIF gad_val is not null THEN
    return 'gad';
ELSE
    return 'none';
END IF;

END
$$;


ALTER FUNCTION pantry.key_loc_lookup(param_kiosk_id bigint, key_name character varying) OWNER TO dbservice;

--
-- Name: kiosk_guardrails_ssl_cert_bytetech_co(); Type: FUNCTION; Schema: pantry; Owner: dbservice
--

CREATE FUNCTION pantry.kiosk_guardrails_ssl_cert_bytetech_co() RETURNS trigger
    LANGUAGE plpgsql
    AS $$

declare
  -- create a constant min version 4.4.4
  min_app_version text = '4.4.4';
begin
  if
    -- new record or server_url is changing (use `is distinct` to handle null)
    (tg_op = 'INSERT' or (tg_op = 'UPDATE' and old.server_url is distinct from new.server_url))
    and new.app_vname is not null
    and public.is_older_software_version(new.app_vname::text, min_app_version)
    and trim(new.server_url) ilike '%.bytetech.co'
  then new.server_url = null;
  end if;

  return new;
end;
$$;


ALTER FUNCTION pantry.kiosk_guardrails_ssl_cert_bytetech_co() OWNER TO dbservice;

--
-- Name: awsdms_intercept_ddl(); Type: FUNCTION; Schema: public; Owner: dbservice
--

CREATE FUNCTION public.awsdms_intercept_ddl() RETURNS event_trigger
    LANGUAGE plpgsql
    AS $$
  declare _qry text;
BEGIN
  if (tg_tag='CREATE TABLE' or tg_tag='ALTER TABLE' or tg_tag='DROP TABLE') then
	    SELECT current_query() into _qry;
	    insert into public.awsdms_ddl_audit
	    values
	    (
	    default,current_timestamp,current_user,cast(TXID_CURRENT()as varchar(16)),tg_tag,0,'',current_schema,_qry
	    );
	    delete from public.awsdms_ddl_audit;
 end if;
END;
$$;


ALTER FUNCTION public.awsdms_intercept_ddl() OWNER TO dbservice;

--
-- Name: checkpoint(timestamp without time zone, timestamp without time zone, bigint); Type: FUNCTION; Schema: public; Owner: dbservice
--

CREATE FUNCTION public.checkpoint(receiving_start timestamp without time zone, receiving_stop timestamp without time zone, location_id bigint) RETURNS TABLE(product_source character varying, vendor character varying, sku bigint, product_name character varying, item_count bigint, receiving_date timestamp without time zone)
    LANGUAGE plpgsql
    AS $$
BEGIN
	RETURN query 
    	SELECT o.source,
			o.vendor,
			l.product_id,
			o.title,
    		count(l.epc),
    		to_timestamp(max(l.time_updated)) at TIME zone 'US/Pacific'
		FROM pantry.label l
		JOIN pantry.product o ON l.product_id = o.id
		WHERE to_timestamp(l.time_updated) at TIME zone 'US/Pacific' between receiving_start AND receiving_stop
    		AND kiosk_id = location_id
		GROUP BY o.source, o.vendor, l.product_id, o.title;
END; $$;


ALTER FUNCTION public.checkpoint(receiving_start timestamp without time zone, receiving_stop timestamp without time zone, location_id bigint) OWNER TO dbservice;

--
-- Name: date_round(timestamp with time zone, interval); Type: FUNCTION; Schema: public; Owner: dbservice
--

CREATE FUNCTION public.date_round(base_date timestamp with time zone, round_interval interval) RETURNS timestamp with time zone
    LANGUAGE sql IMMUTABLE
    AS $_$
  SELECT TO_TIMESTAMP((EXTRACT(epoch FROM $1)::INTEGER + EXTRACT(epoch FROM $2)::INTEGER / 2)
                     / EXTRACT(epoch FROM $2)::INTEGER * EXTRACT(epoch FROM $2)::INTEGER)
$_$;


ALTER FUNCTION public.date_round(base_date timestamp with time zone, round_interval interval) OWNER TO dbservice;

--
-- Name: div(numeric, numeric); Type: FUNCTION; Schema: public; Owner: dbservice
--

CREATE FUNCTION public.div(numeric, numeric) RETURNS double precision
    LANGUAGE sql IMMUTABLE
    AS $_$
  SELECT CASE WHEN ($2::float > 0.0) THEN ($1::float / $2::float) ELSE (0.0::float) END
$_$;


ALTER FUNCTION public.div(numeric, numeric) OWNER TO dbservice;

--
-- Name: dowhour(timestamp with time zone); Type: FUNCTION; Schema: public; Owner: dbservice
--

CREATE FUNCTION public.dowhour(timestamp with time zone) RETURNS integer
    LANGUAGE sql IMMUTABLE
    AS $_$
 SELECT ((1+extract(DOW FROM $1))*100 + extract(hour from $1))::int
$_$;


ALTER FUNCTION public.dowhour(timestamp with time zone) OWNER TO dbservice;

--
-- Name: epoch_round(bigint, interval); Type: FUNCTION; Schema: public; Owner: dbservice
--

CREATE FUNCTION public.epoch_round(bigint, round_interval interval) RETURNS timestamp with time zone
    LANGUAGE sql IMMUTABLE
    AS $_$
  SELECT TO_TIMESTAMP((EXTRACT(epoch FROM to_timestamp($1))::INTEGER + EXTRACT(epoch FROM $2)::INTEGER / 2)
                / EXTRACT(epoch FROM $2)::INTEGER * EXTRACT(epoch FROM $2)::INTEGER)
$_$;


ALTER FUNCTION public.epoch_round(bigint, round_interval interval) OWNER TO dbservice;

--
-- Name: f_nr_stockout_minutes(timestamp with time zone, timestamp with time zone, timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: dbservice
--

CREATE FUNCTION public.f_nr_stockout_minutes(ts timestamp with time zone, kiosk_restock_ts timestamp with time zone, hour_start timestamp with time zone, hour_end timestamp with time zone) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
begin

case when kiosk_restock_ts is not null
    and (
      ts between hour_start and hour_end
      or kiosk_restock_ts between hour_start and hour_end
      or (
        hour_start > ts
        and hour_end < kiosk_restock_ts
      )
    )
  then 
    return ((3600.0 -
    -- difference or hour_start and greatest of ts or hour_start
    (extract(epoch from greatest(hour_start, ts)) - extract(epoch from hour_start)) -
    -- difference or hour_end and least of kiosk_restock_ts or hour_end
    (extract(epoch from hour_end) - extract(epoch from least(hour_end, kiosk_restock_ts))))) / 60.0;
  when kiosk_restock_ts is null and date_trunc('hour', ts) <= hour_start
  then
    return (3600.0 - (extract(epoch from greatest(hour_start, ts)) - extract(epoch from hour_start))) / 60.0;
  else
    return 0.0;
  end case;

end
$$;


ALTER FUNCTION public.f_nr_stockout_minutes(ts timestamp with time zone, kiosk_restock_ts timestamp with time zone, hour_start timestamp with time zone, hour_end timestamp with time zone) OWNER TO dbservice;

--
-- Name: fmt_ts(timestamp with time zone); Type: FUNCTION; Schema: public; Owner: dbservice
--

CREATE FUNCTION public.fmt_ts(timestamp with time zone) RETURNS text
    LANGUAGE sql IMMUTABLE
    AS $_$
  SELECT to_char($1, 'YYYY-MM-DD HH24:MI');
$_$;


ALTER FUNCTION public.fmt_ts(timestamp with time zone) OWNER TO dbservice;

--
-- Name: fmt_ts_mmdd(timestamp with time zone); Type: FUNCTION; Schema: public; Owner: dbservice
--

CREATE FUNCTION public.fmt_ts_mmdd(timestamp with time zone) RETURNS text
    LANGUAGE sql IMMUTABLE
    AS $_$
  SELECT to_char($1, 'MM-DD HH24:MI');
$_$;


ALTER FUNCTION public.fmt_ts_mmdd(timestamp with time zone) OWNER TO dbservice;

--
-- Name: frac(numeric, numeric); Type: FUNCTION; Schema: public; Owner: dbservice
--

CREATE FUNCTION public.frac(numeric, numeric) RETURNS double precision
    LANGUAGE sql IMMUTABLE
    AS $_$
 SELECT if( $1::float + $2::float > 0.0, $1::float / ($1::float + $2::float), 0.0::float)
$_$;


ALTER FUNCTION public.frac(numeric, numeric) OWNER TO dbservice;

--
-- Name: get_sum(numeric, numeric); Type: FUNCTION; Schema: public; Owner: dbservice
--

CREATE FUNCTION public.get_sum(a numeric, b numeric) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
BEGIN
 RETURN a + b;
END; $$;


ALTER FUNCTION public.get_sum(a numeric, b numeric) OWNER TO dbservice;

--
-- Name: hash_to_bigint(character varying); Type: FUNCTION; Schema: public; Owner: dbservice
--

CREATE FUNCTION public.hash_to_bigint(hexval character varying) RETURNS bigint
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $$
DECLARE
    result  bigint;
BEGIN
    EXECUTE 'SELECT x''' || hexval || '''::bigint' INTO result;
    RETURN result;
END;
$$;


ALTER FUNCTION public.hash_to_bigint(hexval character varying) OWNER TO dbservice;

--
-- Name: hex_to_int(character varying); Type: FUNCTION; Schema: public; Owner: dbservice
--

CREATE FUNCTION public.hex_to_int(hexval character varying) RETURNS integer
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $$
DECLARE
    result  int;
BEGIN
    EXECUTE 'SELECT x''' || hexval || '''::int' INTO result;
    RETURN result;
END;
$$;


ALTER FUNCTION public.hex_to_int(hexval character varying) OWNER TO dbservice;

--
-- Name: if(boolean, anyelement, anyelement); Type: FUNCTION; Schema: public; Owner: dbservice
--

CREATE FUNCTION public.if(boolean, anyelement, anyelement) RETURNS anyelement
    LANGUAGE sql IMMUTABLE
    AS $_$
  SELECT CASE WHEN ($1) THEN ($2) ELSE ($3) END
$_$;


ALTER FUNCTION public.if(boolean, anyelement, anyelement) OWNER TO dbservice;

--
-- Name: int_hash(text); Type: FUNCTION; Schema: public; Owner: dbservice
--

CREATE FUNCTION public.int_hash(text) RETURNS integer
    LANGUAGE sql IMMUTABLE
    AS $_$
 SELECT abs(('x'||substr(md5($1),1,8))::bit(32)::int);
$_$;


ALTER FUNCTION public.int_hash(text) OWNER TO dbservice;

--
-- Name: interval_hours(interval); Type: FUNCTION; Schema: public; Owner: dbservice
--

CREATE FUNCTION public.interval_hours(interval) RETURNS numeric
    LANGUAGE sql IMMUTABLE
    AS $_$
  SELECT ((extract(hour from (60 * $1))+extract(day from 24 * 60 * $1))/60.0)::numeric(6,2);
$_$;


ALTER FUNCTION public.interval_hours(interval) OWNER TO dbservice;

--
-- Name: is_older_software_version(text, text); Type: FUNCTION; Schema: public; Owner: dbservice
--

CREATE FUNCTION public.is_older_software_version(source_version text, target_version text) RETURNS boolean
    LANGUAGE sql
    AS $$
  select string_to_array(source_version, '.')::int[] < string_to_array(target_version, '.')::int[];
$$;


ALTER FUNCTION public.is_older_software_version(source_version text, target_version text) OWNER TO dbservice;

--
-- Name: make_odd_or_even_sequence(text, text, text); Type: FUNCTION; Schema: public; Owner: dbservice
--

CREATE FUNCTION public.make_odd_or_even_sequence(table_name text, sequence_field_name text, odd_or_even text) RETURNS text
    LANGUAGE plpgsql
    AS $$
declare
  sequence_name text;
  max_id integer;

  -- Modify table sequence to generate only odd or even id
begin
  if odd_or_even not in ('odd', 'even')
  then return 'error: last param has to be either `odd` or `even`';
  end if;

  execute concat('select max(', sequence_field_name, ') from ', table_name) into max_id;
  select pg_get_serial_sequence(table_name, sequence_field_name) into sequence_name;

  execute 'alter sequence ' || sequence_name || ' increment by 2';

  case odd_or_even
    when 'odd' then
      return setval(sequence_name, max_id + mod(max_id + 1, 2));
    when 'even' then
      return setval(sequence_name, max_id + mod(max_id, 2));
    end case;
end;

$$;


ALTER FUNCTION public.make_odd_or_even_sequence(table_name text, sequence_field_name text, odd_or_even text) OWNER TO dbservice;

--
-- Name: monthly_infographic_data(text); Type: FUNCTION; Schema: public; Owner: dbservice
--

CREATE FUNCTION public.monthly_infographic_data(yyyy_mm text) RETURNS TABLE(record_type text, customer_or_kiosk text, kiosks text, transactions bigint, unique_users bigint, vendors_supported bigint, salads_eaten bigint)
    LANGUAGE sql STABLE
    AS $$
SELECT * FROM (
   SELECT 'customer' as record_type,
          client_name AS customer_or_kiosk,
          string_agg(distinct(kiosk_title), '; ') AS kiosks,
          count(distinct(order_id)) AS transactions,
   	  count(distinct(card_hash)) AS unique_users,
	  count(distinct(product_vendor)) AS vendors_supported,
	  sum(if(product_title ilike '%salad%',1,0)) AS salads_eaten
     FROM byte_epcssold
    WHERE ts BETWEEN cast(yyyy_mm AS timestamp) and cast(yyyy_mm AS timestamp) + interval '1' month
 GROUP BY customer_or_kiosk

UNION ALL

   SELECT 'kiosk' as record_type,
          kiosk_title||' (KID '||kiosk_id||')' AS customer_or_kiosk,
          string_agg(distinct(kiosk_title), '; ') AS kiosks,
          count(distinct(order_id)) AS transactions,
   	  count(distinct(card_hash)) AS unique_users,
	  count(distinct(product_vendor)) AS vendors_supported,
	  sum(if(product_title ilike '%salad%',1,0)) AS salads_eaten
     FROM byte_epcssold
    WHERE ts BETWEEN cast(yyyy_mm AS timestamp) and cast(yyyy_mm AS timestamp) + interval '1' month
 GROUP BY customer_or_kiosk
) t ORDER BY record_type, customer_or_kiosk;

$$;


ALTER FUNCTION public.monthly_infographic_data(yyyy_mm text) OWNER TO dbservice;

--
-- Name: path_check(text[]); Type: FUNCTION; Schema: public; Owner: dbservice
--

CREATE FUNCTION public.path_check(VARIADIC kiosk_path text[]) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
	i TEXT;
BEGIN
	FOREACH i IN ARRAY kiosk_path
LOOP 
	RAISE NOTICE '%', i;
END LOOP;
END; $$;


ALTER FUNCTION public.path_check(VARIADIC kiosk_path text[]) OWNER TO dbservice;

--
-- Name: path_check_1_2_3(timestamp without time zone, timestamp without time zone); Type: FUNCTION; Schema: public; Owner: dbservice
--

CREATE FUNCTION public.path_check_1_2_3(receiving_start timestamp without time zone, receiving_stop timestamp without time zone) RETURNS TABLE(epc character varying, stops_count bigint, receiving_date timestamp without time zone)
    LANGUAGE plpgsql
    AS $$
DECLARE
	receiving BIGINT := 522;
	pickpack BIGINT := 523;
	spoilage BIGINT := 524;
BEGIN
	RETURN query
		SELECT *
		FROM 
			(SELECT x.epc, 
    			sum(x.stop_count) AS stops_count, 
    			max(x.time_created) AS time_created
			FROM 
        		(SELECT l.epc,
            		1 AS stop_count,
            		to_timestamp(max(l.time_created)) at TIME zone 'US/Pacific' AS time_created
        		FROM pantry.label l
        		JOIN pantry.product o ON l.product_id = o.id
       			WHERE to_timestamp(l.time_created) at TIME zone 'US/Pacific' between receiving_start AND receiving_stop
           			AND kiosk_id = receiving
       			GROUP BY l.epc
    			UNION
    			SELECT l.epc,
        			1 AS stop_count,
        			to_timestamp(max(l.time_created)) at TIME zone 'US/Pacific' AS time_created
    			FROM pantry.label l
    			JOIN pantry.product o ON l.product_id = o.id
    			WHERE to_timestamp(l.time_created) at TIME zone 'US/Pacific' between receiving_start AND receiving_stop
        			AND kiosk_id = pickpack
    			GROUP BY l.epc
    			UNION
    			SELECT l.epc,
        			1 AS stop_count,
        			to_timestamp(max(l.time_created)) at TIME zone 'US/Pacific' AS time_created
    			FROM pantry.label l
    			JOIN pantry.product o ON l.product_id = o.id
    			WHERE to_timestamp(l.time_created) at TIME zone 'US/Pacific' between receiving_start AND receiving_stop
        			AND kiosk_id != receiving
        			AND kiosk_id != pickpack
					AND kiosk_id != spoilage
    			GROUP BY l.epc) AS x
    		GROUP BY x.epc) as y
		WHERE y.stops_count = 3;
END; $$;


ALTER FUNCTION public.path_check_1_2_3(receiving_start timestamp without time zone, receiving_stop timestamp without time zone) OWNER TO dbservice;

--
-- Name: pct(numeric, numeric); Type: FUNCTION; Schema: public; Owner: dbservice
--

CREATE FUNCTION public.pct(numeric, numeric) RETURNS double precision
    LANGUAGE sql IMMUTABLE
    AS $_$
 SELECT if( $1::float + $2::float > 0.0, 100.0 * $1::float / ($1::float + $2::float), 0.0::float)
$_$;


ALTER FUNCTION public.pct(numeric, numeric) OWNER TO dbservice;

--
-- Name: pick_get_next_delivery(date); Type: FUNCTION; Schema: public; Owner: dbservice
--

CREATE FUNCTION public.pick_get_next_delivery(target_date date) RETURNS TABLE(kiosk_id integer, delivery_ts timestamp with time zone)
    LANGUAGE plpgsql
    AS $$
begin
	return query
		select location_number, schedule_at from
		(select location_number, schedule_at , rank() over (PARTITION BY location_number order by schedule_at) as num
			from mixalot.route_stop where location_number <> -1) ds
		where num = 1;
		-- into kiosk_id, delivery_ts;
end;
$$;


ALTER FUNCTION public.pick_get_next_delivery(target_date date) OWNER TO dbservice;

--
-- Name: pickpack(timestamp without time zone, timestamp without time zone, bigint); Type: FUNCTION; Schema: public; Owner: dbservice
--

CREATE FUNCTION public.pickpack(receiving_start timestamp without time zone, receiving_stop timestamp without time zone, location_id bigint) RETURNS TABLE(product_source character varying, vendor character varying, sku bigint, product_name character varying, item_count bigint, receiving_date timestamp without time zone)
    LANGUAGE plpgsql
    AS $$
BEGIN
	RETURN query 
    	SELECT o.source,
			o.vendor,
			l.product_id,
			o.title,
    		count(l.epc),
    		to_timestamp(max(l.time_created)) at time zone 'US/Pacific'
		FROM pantry.label l
		JOIN pantry.product o on l.product_id = o.id
		WHERE to_timestamp(l.time_created) at time zone 'US/Pacific' between receiving_start and receiving_stop
    		and kiosk_id = location_id
		GROUP BY o.source, o.vendor, l.product_id, o.title;
END; $$;


ALTER FUNCTION public.pickpack(receiving_start timestamp without time zone, receiving_stop timestamp without time zone, location_id bigint) OWNER TO dbservice;

--
-- Name: receiving(timestamp without time zone, timestamp without time zone); Type: FUNCTION; Schema: public; Owner: dbservice
--

CREATE FUNCTION public.receiving(receiving_start timestamp without time zone DEFAULT '2017-11-01 00:00:00'::timestamp without time zone, receiving_stop timestamp without time zone DEFAULT '2017-11-01 23:59:59'::timestamp without time zone) RETURNS TABLE(product_source character varying, vendor character varying, sku bigint, product_name character varying, item_count bigint, receiving_date timestamp without time zone)
    LANGUAGE plpgsql
    AS $$
BEGIN
	RETURN query 
    	SELECT o.source,
			o.vendor,
			l.product_id,
			o.title,
    		count(l.epc),
    		to_timestamp(max(l.time_created)) at time zone 'US/Pacific'
		FROM pantry.label l
		JOIN pantry.product o on l.product_id = o.id
		WHERE to_timestamp(l.time_created) at time zone 'US/Pacific' between receiving_start and receiving_stop
    		and kiosk_id = 790
		GROUP BY o.source, o.vendor, l.product_id, o.title;
END; $$;


ALTER FUNCTION public.receiving(receiving_start timestamp without time zone, receiving_stop timestamp without time zone) OWNER TO dbservice;

--
-- Name: set_sequence_val_max(name, name, boolean); Type: FUNCTION; Schema: public; Owner: dbservice
--

CREATE FUNCTION public.set_sequence_val_max(schema_name name, table_name name DEFAULT NULL::name, raise_notice boolean DEFAULT false) RETURNS void
    LANGUAGE plpgsql
    AS $$

-- Sets all the sequences in the schema "schema_name" to the max(id) of every table (or a specific table, if name is supplied)
-- Examples:
--  SELECT setval_max('public');
--  SELECT setval_max('public','mytable');
--  SELECT setval_max('public',null,true);
--  SELECT setval_max('public','mytable',true);

DECLARE
    row_data RECORD;
    sql_code TEXT;

BEGIN
    IF ((SELECT COUNT(*) FROM pg_namespace WHERE nspname = schema_name) = 0) THEN
        RAISE EXCEPTION 'The schema "%" does not exist', schema_name;
    END IF;

    FOR sql_code IN
        SELECT 'SELECT SETVAL(' ||quote_literal(N.nspname || '.' || S.relname)|| ', MAX(' ||quote_ident(C.attname)|| ') ) FROM ' || quote_ident(N.nspname) || '.' || quote_ident(T.relname)|| ';' AS sql_code
            FROM pg_class AS S
            INNER JOIN pg_depend AS D ON S.oid = D.objid
            INNER JOIN pg_class AS T ON D.refobjid = T.oid
            INNER JOIN pg_attribute AS C ON D.refobjid = C.attrelid AND D.refobjsubid = C.attnum
            INNER JOIN pg_namespace N ON N.oid = S.relnamespace
            WHERE S.relkind = 'S' AND N.nspname = schema_name AND (table_name IS NULL OR T.relname = table_name)
            ORDER BY S.relname
    LOOP
        IF (raise_notice) THEN
            RAISE NOTICE 'sql_code: %', sql_code;
        END IF;
        EXECUTE sql_code;
    END LOOP;
END;
$$;


ALTER FUNCTION public.set_sequence_val_max(schema_name name, table_name name, raise_notice boolean) OWNER TO dbservice;

--
-- Name: shelf_life_bucket(integer); Type: FUNCTION; Schema: public; Owner: dbservice
--

CREATE FUNCTION public.shelf_life_bucket(integer) RETURNS text
    LANGUAGE sql IMMUTABLE
    AS $_$
  SELECT CASE WHEN ($1 <= 10) THEN ($1::text)
              WHEN ($1 <= 14) THEN ('11-14')
              WHEN ($1 <= 21) THEN ('15-21')
              ELSE ('21+') END
$_$;


ALTER FUNCTION public.shelf_life_bucket(integer) OWNER TO dbservice;

--
-- Name: stockout_hours(text, text); Type: FUNCTION; Schema: public; Owner: dbservice
--

CREATE FUNCTION public.stockout_hours(text, text) RETURNS double precision
    LANGUAGE plperl IMMUTABLE
    AS $$
 return 10.5;
$$;


ALTER FUNCTION public.stockout_hours(text, text) OWNER TO dbservice;

--
-- Name: user_retention_by_month(integer); Type: FUNCTION; Schema: public; Owner: dbservice
--

CREATE FUNCTION public.user_retention_by_month(n integer) RETURNS TABLE(month timestamp with time zone, num_consumers bigint, repeat_consumers bigint, num_tickets bigint, sum_amount_list_price numeric, sum_amount_paid numeric, num_repeat_tickets bigint, sum_repeat_amount_list_price numeric, sum_repeat_amount_paid numeric, frac_users_retained numeric, frac_tickets_retained numeric, frac_listprice_retained numeric, frac_amountpaid_retained numeric, old_month timestamp with time zone, old_num_consumers bigint, old_repeat_consumers bigint, old_num_tickets bigint, old_sum_amount_list_price numeric, old_sum_amount_paid numeric)
    LANGUAGE sql STABLE
    AS $$
  -- note: options carefully chosen to support inlining
  -- https://wiki.postgresql.org/wiki/Inlining_of_SQL_functions
  -- (run EXPLAIN on a query and you should see the full expansion, not just
  -- Function Scan .. Function Call:
  WITH consumer_stats AS (
     SELECT consumer_id
           ,month
           ,count(*) AS num_tickets
           ,sum(amount_list_price)::numeric(10,2) AS sum_amount_list_price
           ,sum(amount_paid)::numeric(10,2) AS sum_amount_paid
           ,lag(month, n) OVER (PARTITION BY consumer_id ORDER BY month)
            = month - (n * interval '1 month') OR NULL AS repeat_transaction
     FROM   user_retention_tickets
     GROUP  BY 1, 2
  ), stats AS (
     SELECT month
           ,count(*) AS num_consumers
           ,count(repeat_transaction) AS repeat_consumers
           ,sum(num_tickets)::bigint AS num_tickets
           ,sum(sum_amount_list_price)::numeric(10,2) AS sum_amount_list_price
           ,sum(sum_amount_paid)::numeric(10,2) AS sum_amount_paid
           ,sum(if(repeat_transaction,num_tickets::bigint,0::bigint))::bigint AS num_repeat_tickets
           ,sum(if(repeat_transaction,sum_amount_list_price,0::numeric(10,2)))::numeric(10,2) AS sum_repeat_amount_list_price
           ,sum(if(repeat_transaction,sum_amount_paid,0::numeric(10,2)))::numeric(10,2) AS sum_repeat_amount_paid
     FROM   consumer_stats
     GROUP  BY 1
     ORDER  BY 1
  )
  SELECT t1.*, (t1.repeat_consumers::float / t2.num_consumers)::numeric(10,4) as frac_users_retained,
         (t1.num_repeat_tickets::float / t2.num_tickets)::numeric(10,4) as frac_tickets_retained,
         (t1.sum_repeat_amount_list_price::float / t2.sum_amount_list_price)::numeric(10,4) as frac_listprice_retained,
         (t1.sum_repeat_amount_paid::float / t2.sum_amount_paid)::numeric(10,4) as frac_amountpaid_retained,
         t2.month as old_month, t2.num_consumers as old_num_consumers, t2.repeat_consumers as old_repeat_consumers,
         t2.num_tickets as old_num_tickets, t2.sum_amount_list_price as old_sum_amount_list_price, t2.sum_amount_paid as old_sum_amount_paid
    FROM stats t1 LEFT OUTER JOIN stats t2 ON (t1.month - n * interval '1 month') = t2.month
$$;


ALTER FUNCTION public.user_retention_by_month(n integer) OWNER TO dbservice;

--
-- Name: user_retention_by_week(integer); Type: FUNCTION; Schema: public; Owner: dbservice
--

CREATE FUNCTION public.user_retention_by_week(n integer) RETURNS TABLE(week timestamp with time zone, num_consumers bigint, repeat_consumers bigint, num_tickets bigint, sum_amount_list_price numeric, sum_amount_paid numeric, num_repeat_tickets bigint, sum_repeat_amount_list_price numeric, sum_repeat_amount_paid numeric, frac_users_retained numeric, frac_tickets_retained numeric, frac_listprice_retained numeric, frac_amountpaid_retained numeric, old_week timestamp with time zone, old_num_consumers bigint, old_repeat_consumers bigint, old_num_tickets bigint, old_sum_amount_list_price numeric, old_sum_amount_paid numeric)
    LANGUAGE sql STABLE
    AS $$
  -- note: options carefully chosen to support inlining
  -- https://wiki.postgresql.org/wiki/Inlining_of_SQL_functions
  -- (run EXPLAIN on a query and you should see the full expansion, not just
  -- Function Scan .. Function Call:
  WITH consumer_stats AS (
     SELECT consumer_id
           ,week
           ,count(*) AS num_tickets
           ,sum(amount_list_price)::numeric(10,2) AS sum_amount_list_price
           ,sum(amount_paid)::numeric(10,2) AS sum_amount_paid
           ,lag(week, n) OVER (PARTITION BY consumer_id ORDER BY week)
            = week - (n * 7 * interval '1 day') OR NULL AS repeat_transaction
     FROM   user_retention_tickets
     GROUP  BY 1, 2
  ), stats AS (
     SELECT week
           ,count(*) AS num_consumers
           ,count(repeat_transaction) AS repeat_consumers
           ,sum(num_tickets)::bigint AS num_tickets
           ,sum(sum_amount_list_price)::numeric(10,2) AS sum_amount_list_price
           ,sum(sum_amount_paid)::numeric(10,2) AS sum_amount_paid
           ,sum(if(repeat_transaction,num_tickets::bigint,0::bigint))::bigint AS num_repeat_tickets
           ,sum(if(repeat_transaction,sum_amount_list_price,0::numeric(10,2)))::numeric(10,2) AS sum_repeat_amount_list_price
           ,sum(if(repeat_transaction,sum_amount_paid,0::numeric(10,2)))::numeric(10,2) AS sum_repeat_amount_paid
     FROM   consumer_stats
     GROUP  BY 1
     ORDER  BY 1
  )
  SELECT t1.*, (t1.repeat_consumers::float / t2.num_consumers)::numeric(10,4) as frac_users_retained,
         (t1.num_repeat_tickets::float / t2.num_tickets)::numeric(10,4) as frac_tickets_retained,
         (t1.sum_repeat_amount_list_price::float / t2.sum_amount_list_price)::numeric(10,4) as frac_listprice_retained,
         (t1.sum_repeat_amount_paid::float / t2.sum_amount_paid)::numeric(10,4) as frac_amountpaid_retained,
         t2.week as old_week, t2.num_consumers as old_num_consumers, t2.repeat_consumers as old_repeat_consumers,
         t2.num_tickets as old_num_tickets, t2.sum_amount_list_price as old_sum_amount_list_price, t2.sum_amount_paid as old_sum_amount_paid
    FROM stats t1 LEFT OUTER JOIN stats t2 ON (t1.week - n * 7 * interval '1 day') = t2.week
$$;


ALTER FUNCTION public.user_retention_by_week(n integer) OWNER TO dbservice;

--
-- Name: dependency_tree(oid[]); Type: FUNCTION; Schema: report; Owner: dbservice
--

CREATE FUNCTION report.dependency_tree(object_ids oid[]) RETURNS TABLE(dependency_tree text)
    LANGUAGE sql SECURITY DEFINER
    AS $$
WITH target AS (
  SELECT objid, dependency_chain
  FROM report.dependency
  JOIN unnest(object_ids) AS target(objid) USING (objid)
)
, list AS (
  SELECT DISTINCT
    format('%*s%s %s', -4*level
          , CASE WHEN report.objid = ANY(object_ids) THEN '*' END
          , object_type, object_identity
    ) AS dependency_tree
  , dependency_sort_chain
  FROM target
  JOIN report.dependency report
    ON report.objid = ANY(target.dependency_chain) -- root-bound chain
    OR target.objid = ANY(report.dependency_chain) -- leaf-bound chain
)
SELECT dependency_tree FROM list
ORDER BY dependency_sort_chain;
$$;


ALTER FUNCTION report.dependency_tree(object_ids oid[]) OWNER TO dbservice;

--
-- Name: dependency_tree(text[]); Type: FUNCTION; Schema: report; Owner: dbservice
--

CREATE FUNCTION report.dependency_tree(object_names text[]) RETURNS TABLE(dependency_tree text)
    LANGUAGE sql SECURITY DEFINER
    AS $$
WITH target AS (
  SELECT objid, dependency_chain
  FROM report.dependency
  JOIN unnest(object_names) AS target(objname) ON objid = objname::regclass
)
, list AS (
  SELECT DISTINCT
    format('%*s%s %s', -4*level
          , CASE WHEN object_identity = ANY(object_names) THEN '*' END
          , object_type, object_identity
    ) AS dependency_tree
  , dependency_sort_chain
  FROM target
  JOIN report.dependency report
    ON report.objid = ANY(target.dependency_chain) -- root-bound chain
    OR target.objid = ANY(report.dependency_chain) -- leaf-bound chain
)
SELECT dependency_tree FROM list
ORDER BY dependency_sort_chain;
$$;


ALTER FUNCTION report.dependency_tree(object_names text[]) OWNER TO dbservice;

--
-- Name: dependency_tree(text); Type: FUNCTION; Schema: report; Owner: dbservice
--

CREATE FUNCTION report.dependency_tree(search_pattern text) RETURNS TABLE(dependency_tree text)
    LANGUAGE sql SECURITY DEFINER
    AS $$
WITH target AS (
  SELECT objid, dependency_chain
  FROM report.dependency
  WHERE object_identity ~ search_pattern
)
, list AS (
  SELECT
    format('%*s%s %s', -4*level
          , CASE WHEN object_identity ~ search_pattern THEN '*' END
          , object_type, object_identity
    ) AS dependency_tree
  , dependency_sort_chain
  FROM target
  JOIN report.dependency report
    ON report.objid = ANY(target.dependency_chain) -- root-bound chain
    OR target.objid = ANY(report.dependency_chain) -- leaf-bound chain
  WHERE LENGTH(search_pattern) > 0
  -- Do NOT waste search time on blank/null search_pattern.
  UNION
  -- Query the entire dependencies instead.
  SELECT
    format('%*s%s %s', 4*level, '', object_type, object_identity) AS depedency_tree
  , dependency_sort_chain
  FROM report.dependency
  WHERE LENGTH(COALESCE(search_pattern,'')) = 0
)
SELECT dependency_tree FROM list
ORDER BY dependency_sort_chain;
$$;


ALTER FUNCTION report.dependency_tree(search_pattern text) OWNER TO dbservice;

--
-- Name: byte_losses(date, date); Type: FUNCTION; Schema: rptg; Owner: dbservice
--

CREATE FUNCTION rptg.byte_losses(beginning_date date, ending_date date) RETURNS TABLE(epc character varying, kiosk_id bigint, product_id bigint, time_updated timestamp with time zone, cost numeric, price numeric)
    LANGUAGE plpgsql
    AS $$
    BEGIN
        RETURN QUERY
/*
The following query is used to get non free kiosks and free kiosks lost. SEE
ENG-708. Non free kiosks losses = lost items. Since lost items are always counted as sold for free
free kiosks, Free kiosks losses = 0.
*/
SELECT epc_ as epc,
    kiosk_id_ as kiosk_id,
    product_id_ as product_id,
    time_updated_ as time_updated,
    cost_ as cost,
    price_ as price
    FROM rptg.losses(beginning_date, ending_date) gl
    JOIN pantry.kiosk k
    ON gl.kiosk_id_ = k.id
    WHERE subsidy_info != '100%'
    AND enable_reporting_ = 1
    AND kiosk_campus_id_ = 87
    AND product_campus_id_ = 87;
 END;
$$;


ALTER FUNCTION rptg.byte_losses(beginning_date date, ending_date date) OWNER TO dbservice;

--
-- Name: byte_sales(date, date); Type: FUNCTION; Schema: rptg; Owner: dbservice
--

CREATE FUNCTION rptg.byte_sales(beginning_date date, ending_date date) RETURNS TABLE(epc character varying, order_id character varying, kiosk_id bigint, product_id bigint, time_bought timestamp with time zone, cost numeric, price numeric)
    LANGUAGE plpgsql
    AS $$
    BEGIN
        RETURN QUERY
/*
The following query is used to get all non free kiosks and free kiosks sales. SEE
ENG-708. Byte kiosks sales = non free kiosks sale + free kiosk sales + free kiosk losses.
*/
SELECT epc_ as epc,
    order_id_ as order_id,
    kiosk_id_ as kiosk_id,
    product_id_ as product_id,
    time_bought_ as time_bought,
    cost_ as cost,
    price_ as price
    --- This subquery is used to get the sum price of sold items in free kiosks
    FROM (SELECT epc_,
        order_id_,
        kiosk_id_,
        product_id_,
        time_bought_,
        cost_,
        price_
        FROM rptg.sales(beginning_date, ending_date)  gs
        JOIN pantry.kiosk k
        ON gs.kiosk_id_ = k.id
        WHERE subsidy_info = '100%'
        AND enable_reporting_ = 1
        AND kiosk_campus_id_ = 87
        AND product_campus_id_ = 87
    UNION ALL
    --- This subquery is used to get all lost items in free kiosks
    SELECT epc_,
        NULL as order_id_,
        kiosk_id_,
        product_id_,
        time_updated_ as time_bought_,
        cost_ ,
        price_
        FROM rptg.losses(beginning_date, ending_date)  gl
        JOIN pantry.kiosk k
        ON gl.kiosk_id_ = k.id
        WHERE subsidy_info = '100%'
        AND enable_reporting_ = 1
        AND kiosk_campus_id_ = 87
        AND product_campus_id_ = 87
    UNION ALL
    --- This subquery is used to get all sold items in non-free kiosks
    SELECT epc_,
        order_id_,
        kiosk_id_,
        product_id_,
        time_bought_,
        cost_,
        price_
        FROM rptg.sales(beginning_date, ending_date)  gs
        JOIN pantry.kiosk k
        ON gs.kiosk_id_ = k.id
        WHERE subsidy_info != '100%'
        AND enable_reporting_ = 1
        AND kiosk_campus_id_ = 87
        AND product_campus_id_ = 87
    ) as all_kiosk_sale;
END;
$$;


ALTER FUNCTION rptg.byte_sales(beginning_date date, ending_date date) OWNER TO dbservice;

--
-- Name: losses(date, date); Type: FUNCTION; Schema: rptg; Owner: dbservice
--

CREATE FUNCTION rptg.losses(beginning_date date, ending_date date) RETURNS TABLE(epc_ character varying, kiosk_id_ bigint, product_id_ bigint, time_updated_ timestamp with time zone, cost_ numeric, price_ numeric, kiosk_campus_id_ bigint, product_campus_id_ bigint, enable_reporting_ bigint)
    LANGUAGE plpgsql
    AS $$
    BEGIN
        RETURN QUERY
/*
LOST QUERY From Art's logic: ENG-834
For a given time window W1 (e.g. from beginning_date through ending_date) and an extended time
window W2, with W1 being a subset of W2 (e.g. W1 +1 and -1 month from beginning_date through
ending_date)
Loss: count of unique epc’s which have at least one out label record within W1 and have no sale,
spoil, or inventory records within W2.
An out label record has no order id and has a status of out. For a out label record to be within
time window W1, the label update time needs to be within W1.
*/
SELECT epc as epc_,
        kiosk_id as kiosk_id_,
        product_id as product_id_,
        time_updated as time_updated_,
        cost as cost_,
        price as price_,
        kiosk_campus_id as kiosk_campus_id_,
        product_campus_id as product_campus_id_,
        enable_reporting as enable_reporting_
        FROM (SELECT unique_epcs.epc,
        to_timestamp(all_epc_data.time_updated) as time_updated,
        cost,
        price,
        kiosk_id,
        product_id,
        kiosk_campus_id,
        product_campus_id,
        enable_reporting
        --- There are duplicated EPCs. This subquery selects the most recent distinct out EPC
        FROM(SELECT epc,
            max(time_updated) as time_updated
            FROM pantry.label l
            JOIN pantry.kiosk k
            ON k.id = l.kiosk_id
            JOIN pantry.product p
            ON p.id = l.product_id
            WHERE to_timestamp(time_updated)::date >= beginning_date
            AND to_timestamp(time_updated)::date <= ending_date
            AND l.status = 'out'
            AND l.order_id IS NULL
            GROUP BY epc
        ) as unique_epcs
        /*
        This subquery is used to get the price and cost values for the distinct EPCs we selected
        in the subquery above.
        */
        LEFT JOIN (SELECT epc,
            l.product_id,
            l.time_updated as time_updated,
            --- Get the cost from label, if NULL, get cost from product_history, if NULL get cost
            --- from product, if NULL get 0. label has the most accurate cost info for
            --- the specific epc, then product_history, then product.
            COALESCE(l.cost, ph.cost, p.cost,0) as cost,
            --- Get the price from product_history, if NULL, get price from label, if NULL get price
            --- from product, if NULL get 0. product_history has the most accurate price info for
            --- that time, then label, then product.
            COALESCE(ph.price, l.price, p.price,0) as price,
            l.kiosk_id,
            k.campus_id as kiosk_campus_id,
            p.campus_id as product_campus_id,
            k.enable_reporting
            FROM pantry.label l
            JOIN pantry.kiosk k
            ON k.id = l.kiosk_id
            JOIN pantry.product p
            ON p.id = l.product_id
            LEFT JOIN pantry.product_history ph ON ph.product_id = p.id
            AND l.time_updated >= ph.start_time AND (ph.end_time IS NULL OR l.time_updated <
            ph.end_time)
            AND to_timestamp(time_updated)::date >= beginning_date
            AND to_timestamp(time_updated)::date <= ending_date
            AND l.status = 'out'
            AND l.order_id IS NULL
        ) as all_epc_data
        ON unique_epcs.epc = all_epc_data.epc
        AND unique_epcs.time_updated = all_epc_data.time_updated
    ) as lost_data
    /*
    This subquery is used to eliminate any EPCs that were sold in W2
    (View first comment above to get details on W2)
    */
    WHERE EPC NOT IN (SELECT epc
        FROM pantry.label l
        JOIN pantry.kiosk k
        ON k.id = l.kiosk_id
        JOIN pantry.product p
        ON p.id = l.product_id
        JOIN pantry.order o
        ON o.order_id = l.order_id
        WHERE to_timestamp(created)::date >= (SELECT beginning_date::date - INTERVAL '1 month')
        AND to_timestamp(created)::date <= (SELECT ending_date::date + INTERVAL '1 month')
        AND l.status = 'sold'
        AND l.order_id NOT LIKE 'RE%'
        AND l.order_id IS NOT NULL)
    /*
    This subquery is used to eliminate any EPCs that were spoiled in W2
    (View first comment above to get details on W2)
    */
    AND EPC NOT IN (SELECT epc
        FROM pantry.label l
        JOIN pantry.kiosk k
        ON k.id = l.kiosk_id
        JOIN pantry.product p
        ON p.id = l.product_id
        JOIN pantry.order o
        ON o.order_id = l.order_id
        WHERE to_timestamp(created)::date >= (SELECT beginning_date::date - INTERVAL '1 month')
        AND to_timestamp(created)::date <= (SELECT ending_date::date + INTERVAL '1 month')
        AND l.status = 'out'
        AND l.order_id LIKE 'RE%')
    /*
    This subquery is used to eliminate any EPCs that are currently in the kiosk
    */
    AND EPC NOT IN (SELECT epc
        FROM pantry.label l
        JOIN pantry.kiosk k
        ON k.id = l.kiosk_id
        JOIN pantry.product p
        ON p.id = l.product_id
        AND l.status = 'ok'
        AND l.order_id IS NULL);
 END;
$$;


ALTER FUNCTION rptg.losses(beginning_date date, ending_date date) OWNER TO dbservice;

--
-- Name: non_byte_losses(date, date); Type: FUNCTION; Schema: rptg; Owner: dbservice
--

CREATE FUNCTION rptg.non_byte_losses(beginning_date date, ending_date date) RETURNS TABLE(epc character varying, kiosk_id bigint, product_id bigint, time_updated timestamp with time zone, cost numeric, price numeric)
    LANGUAGE plpgsql
    AS $$
    BEGIN
        RETURN QUERY
/*
The following query is used to get non byte kiosks losses.SEE ENG-1272. Unlike byte looses that
is = free kiosk losses, non byte kiosks losses = all non byte kiosks losses.
*/
SELECT epc_ as epc,
    kiosk_id_ as kiosk_id,
    product_id_ as product_id,
    time_updated_ as time_updated,
    cost_ as cost,
    price_ as price
    FROM rptg.losses(beginning_date, ending_date) gl
    WHERE kiosk_campus_id_ != 87
    AND product_campus_id_ != 87;
 END;
$$;


ALTER FUNCTION rptg.non_byte_losses(beginning_date date, ending_date date) OWNER TO dbservice;

--
-- Name: non_byte_sales(date, date); Type: FUNCTION; Schema: rptg; Owner: dbservice
--

CREATE FUNCTION rptg.non_byte_sales(beginning_date date, ending_date date) RETURNS TABLE(epc character varying, order_id character varying, kiosk_id bigint, product_id bigint, time_bought timestamp with time zone, cost numeric, price numeric)
    LANGUAGE plpgsql
    AS $$
    BEGIN
        RETURN QUERY
/*
The following query is used to get all non byte kiosks. Unlike byte sales that is =
non free kiosks sale + free kiosk sales + free kiosk losses, non byte kiosks = all non byte kiosk
sales.
*/
SELECT  epc_ as epc,
    order_id_ as order_id,
    kiosk_id_ as kiosk_id,
    product_id_ as product_id,
    time_bought_ as time_bought,
    cost_ as cost,
    price_ as price
    FROM rptg.sales(beginning_date, ending_date)  gl
    WHERE kiosk_campus_id_ != 87
    AND product_campus_id_ != 87;
END;
$$;


ALTER FUNCTION rptg.non_byte_sales(beginning_date date, ending_date date) OWNER TO dbservice;

--
-- Name: pick_audit(date, date); Type: FUNCTION; Schema: rptg; Owner: dbservice
--

CREATE FUNCTION rptg.pick_audit(start_date date, end_date date DEFAULT NULL::date) RETURNS TABLE(kiosk_id integer, route_date date, restocker text, product_id integer, pick_qty integer, restock_qty integer, discrepancy integer)
    LANGUAGE plpgsql
    AS $$

/*
Purpose - compare pick to restock
Input - 
	start_date: first pick date to consider
	end_date: last pick date to consider. 
	Note: add feature: if end_date not given, compute the result for only start_date
Output - 
	kiosk_id: id for kiosk
	route_date: delivery date
	kiosk_title: kiosk name
	product_id: what picked/allocated
	pick_qty: quantity above product_id picked
	restock_qty: quantity of above product_id for the same route_date
	discrepancy: restock_qty - pick_quantity for target_date  
*/
begin
	if end_date is null
		then end_date = start_date;
	end if;
	
	return query
		select a.kiosk_id, a.route_date, r.restocker, a.sku_id, cast(sum(a.qty) as integer), 
			coalesce(cast(sum(l.total) as integer), 0), cast(coalesce(sum(l.total), 0) - sum(a.qty) as integer)
			from inm.pick_allocation a 
			left join 
				(select to_timestamp(time_created)::date restock_date, pantry.label.kiosk_id, pantry.label.product_id, count(*) total
					from pantry.label group by 1,2,3) l
					on a.route_date = l.restock_date and a.kiosk_id=l.kiosk_id and a.sku_id = l.product_id
			left join 
					-- restocker
					(select distinct to_timestamp(created)::date route_date, o.kiosk_id, first_name || ' ' || last_name restocker from pantry.order o
						where order_id like 'RE%' and to_timestamp(created)::date between start_date and end_date + 1 order by 1,2) r
					on r.route_date = a.route_date and r.kiosk_id = a.kiosk_id
			where a.route_date between start_date and end_date
		group by 1, 2, 3, 4;
end;

$$;


ALTER FUNCTION rptg.pick_audit(start_date date, end_date date) OWNER TO dbservice;

--
-- Name: restocks(date, date); Type: FUNCTION; Schema: rptg; Owner: dbservice
--

CREATE FUNCTION rptg.restocks(beginning_date date, ending_date date) RETURNS TABLE(epc_ character varying, kiosk_id_ bigint, product_id_ bigint, time_added_ timestamp with time zone, cost_ numeric, price_ numeric, kiosk_campus_id_ bigint, product_campus_id_ bigint, enable_reporting_ bigint)
    LANGUAGE plpgsql
    AS $$
    BEGIN
        RETURN QUERY
/* Restock is a count of unique epcs based on time_created*/
SELECT epc as epc_,
    kiosk_id as kiosk_id_,
    product_id as product_id_,
    time_added as time_added_ ,
    cost as cost_,
    price as price_,
    kiosk_campus_id as kiosk_campus_id_,
    product_campus_id as product_campus_id_,
    enable_reporting as enable_reporting_
    FROM (SELECT unique_epcs.epc,
        kiosk_id,
        product_id,
        to_timestamp(all_epc_data.time_created) as time_added,
        cost,
        price,
        kiosk_campus_id,
        product_campus_id,
        enable_reporting
        --- There are duplicated EPCs. This subquery selects the most recent distinct EPC
        FROM(SELECT epc,
            max(time_created) as time_created
            FROM pantry.label l
            JOIN pantry.kiosk k
            ON k.id = l.kiosk_id
            JOIN pantry.product p
            ON p.id = l.product_id
            WHERE to_timestamp(time_created)::date >= beginning_date
            AND to_timestamp(time_created)::date <= ending_date
            GROUP BY epc
        ) as unique_epcs
        /*
        This subquery is used to get the price and cost values for the distinct EPCs we selected
        in the subquery above.
        */
        LEFT JOIN (SELECT epc,
            l.product_id,
            l.time_created as time_created,
            p.cost,
            p.price,
            l.kiosk_id,
            k.campus_id as kiosk_campus_id,
            p.campus_id as product_campus_id,
            k.enable_reporting
            FROM pantry.label l
            JOIN pantry.kiosk k
            ON k.id = l.kiosk_id
            JOIN pantry.product p
            ON p.id = l.product_id
        ) as all_epc_data
        ON unique_epcs.epc = all_epc_data.epc
        AND unique_epcs. time_created = all_epc_data.time_created
    ) as restocks;
 END;
$$;


ALTER FUNCTION rptg.restocks(beginning_date date, ending_date date) OWNER TO dbservice;

--
-- Name: sales(date, date); Type: FUNCTION; Schema: rptg; Owner: dbservice
--

CREATE FUNCTION rptg.sales(beginning_date date, ending_date date) RETURNS TABLE(epc_ character varying, order_id_ character varying, kiosk_id_ bigint, product_id_ bigint, time_bought_ timestamp with time zone, cost_ numeric, price_ numeric, kiosk_campus_id_ bigint, product_campus_id_ bigint, enable_reporting_ bigint)
    LANGUAGE plpgsql
    AS $$
    BEGIN
        RETURN QUERY
/*
SALE QUERY From Art's logic: see ENG-834
For a given time window W1 (e.g. from beginning_date through ending_date) and an extended time
window W2, with W1 being a subset of W2 (e.g. W1 +1 and -1 month from beginning_date through
ending_date)
Sale: count of unique epc’s which have at least one sale label record within W1.
A sale label record has an order id which does not start with RE and has a sold status.
For a sale label record to be within time window W1, the order creation time needs to be within W1.
*/
    SELECT unique_epcs.epc as epc_,
        order_id as order_id_,
        kiosk_id as kiosk_id_,
        product_id as product_id_,
        to_timestamp(all_epc_data.time_bought) as time_bought_,
        cost as cost_,
        price as price_,
        kiosk_campus_id as kiosk_campus_id_,
        product_campus_id as product_campus_id_,
        enable_reporting as enable_reporting_
        --- There are duplicated EPCs. This subquery selects the most recent distinct sold EPC
        FROM(SELECT epc,
            max(created) as time_bought
            FROM pantry.label l
            JOIN pantry.kiosk k
            ON k.id = l.kiosk_id
            JOIN pantry.product p
            ON p.id = l.product_id
            JOIN pantry.order o
            ON o.order_id = l.order_id
            AND to_timestamp(created)::date >= beginning_date
            AND to_timestamp(created)::date <= ending_date
            AND l.status = 'sold'
            AND l.order_id NOT LIKE 'RE%'
            AND l.order_id IS NOT NULL
            GROUP BY epc
        ) as unique_epcs
        /*
        This subquery is used to get the order_id, time the order was created, price and cost
        values for the distinct EPCs we selected in the subquery above.
        */
        LEFT JOIN (SELECT epc,
            l.product_id,
            l.order_id,
            o.created as time_bought,
            --- Get the cost from label, if NULL, get cost from product_history, if NULL get cost
            --- from product, if NULL get 0. label has the most accurate cost info for
            --- the specific epc, then product_history, then product.
            COALESCE(l.cost, ph.cost, p.cost,0) as cost,
            --- Get the price from product_history, if NULL, get price from label, if NULL get price
            --- from product, if NULL get 0. product_history has the most accurate price info for
            --- that time, then label, then product.
            COALESCE(ph.price, l.price, p.price,0) as price,
            l.kiosk_id,
            k.campus_id as kiosk_campus_id,
            p.campus_id as product_campus_id,
            k.enable_reporting
            FROM pantry.label l
            JOIN pantry.kiosk k
            ON k.id = l.kiosk_id
            JOIN pantry.product p
            ON p.id = l.product_id
            JOIN pantry.order o
            ON o.order_id = l.order_id
            AND to_timestamp(created)::date >= beginning_date
            AND to_timestamp(created)::date <= ending_date
            LEFT JOIN pantry.product_history ph ON ph.product_id = p.id
            AND o.created >= ph.start_time AND (ph.end_time IS NULL OR o.created <
            ph.end_time)
            AND l.status = 'sold'
            AND l.order_id NOT LIKE 'RE%'
            AND l.order_id IS NOT NULL
        ) as all_epc_data
        ON unique_epcs.epc = all_epc_data.epc
        AND unique_epcs.time_bought = all_epc_data.time_bought;

 END;
$$;


ALTER FUNCTION rptg.sales(beginning_date date, ending_date date) OWNER TO dbservice;

--
-- Name: spoils(date, date); Type: FUNCTION; Schema: rptg; Owner: dbservice
--

CREATE FUNCTION rptg.spoils(beginning_date date, ending_date date) RETURNS TABLE(epc_ character varying, order_id_ character varying, kiosk_id_ bigint, product_id_ bigint, time_updated_ timestamp with time zone, cost_ numeric, price_ numeric, kiosk_campus_id_ bigint, product_campus_id_ bigint, enable_reporting_ bigint)
    LANGUAGE plpgsql
    AS $$
    BEGIN
        RETURN QUERY
/*
SPOIL QUERY From Art's logic: see ENG-834
For a given time window W1 (e.g. from beginning_date through ending_date) and an extended time
window W2, with W1 being a subset of W2 (e.g. W1 +1 and -1 month from beginning_date through
ending_date)
Spoil: count of unique epc’s which have at least one spoil label record within W1 and have no
sale record within W2.
A spoil label record has an order id which starts with RE and has an out status.
For a spoil label record to be within time window W1, the order creation time needs to be within W1.
*/

SELECT epc as epc_,
    order_id as order_id_,
    kiosk_id as kiosk_id_,
    product_id as product_id_,
    time_updated as time_updated_,
    cost as cost_,
    price as pice_,
    kiosk_campus_id as kiosk_campus_id_,
    product_campus_id as product_campus_id_,
    enable_reporting as enable_reporting_
    FROM (SELECT unique_epcs.epc as epc,
        order_id,
        kiosk_id,
        product_id,
        to_timestamp(all_epc_data. time_updated) as time_updated,
        cost,
        price,
        kiosk_campus_id,
        product_campus_id,
        enable_reporting
        --- There are duplicated EPCs. This subquery selects the most recent distinct spoiled EPC
        FROM(SELECT epc,
            max(created) as time_updated
            FROM pantry.label l
            JOIN pantry.kiosk k
            ON k.id = l.kiosk_id
            JOIN pantry.product p
            ON p.id = l.product_id
            JOIN pantry.order o
            ON o.order_id = l.order_id
            WHERE to_timestamp(created)::date >= beginning_date
            AND to_timestamp(created)::date <= ending_date
            AND l.status = 'out'
            AND l.order_id LIKE 'RE%'
            GROUP BY epc
        ) as unique_epcs
        /*
        This subquery is used to get the order_id, time the order was created, price and cost
        values for the distinct EPCs we selected in the subquery above.
        */
        LEFT JOIN (SELECT epc,
            l.product_id,
            l.order_id,
            o.created as time_updated,
            --- Get the cost from label, if NULL, get cost from product_history, if NULL get cost
            --- from product, if NULL get 0. label has the most accurate cost info for
            --- the specific epc, then product_history, then product.
            COALESCE(l.cost, ph.cost, p.cost,0) as cost,
            --- Get the price from product_history, if NULL, get price from label, if NULL get price
            --- from product, if NULL get 0. product_history has the most accurate price info for
            --- that time, then label, then product.
            COALESCE(ph.price, l.price, p.price,0) as price,
            l.kiosk_id,
            k.campus_id as kiosk_campus_id,
            p.campus_id as product_campus_id,
            k.enable_reporting
            FROM pantry.label l
            JOIN pantry.kiosk k
            ON k.id = l.kiosk_id
            JOIN pantry.product p
            ON p.id = l.product_id
            JOIN pantry.order o
            ON o.order_id = l.order_id
            AND to_timestamp(created)::date >= beginning_date
            AND to_timestamp(created)::date <= ending_date
            LEFT JOIN pantry.product_history ph ON ph.product_id = p.id
            AND o.created >= ph.start_time AND (ph.end_time IS NULL OR o.created <
            ph.end_time)
            AND l.status = 'out'
            AND l.order_id LIKE 'RE%'
        ) as all_epc_data
        ON unique_epcs.epc = all_epc_data.epc
        AND unique_epcs. time_updated = all_epc_data. time_updated
    ) as spoiled_data
    /*
    This subquery is used to eliminate any EPCs that were sold in W2
    (View first comment above to get details on W2)
    */
    WHERE epc NOT IN (SELECT epc
        FROM pantry.label l
        JOIN pantry.kiosk k
        ON k.id = l.kiosk_id
        JOIN pantry.product p
        ON p.id = l.product_id
        JOIN pantry.order o
        ON o.order_id = l.order_id
        WHERE to_timestamp(created)::date >= (SELECT beginning_date::date - INTERVAL '1 month')
        AND to_timestamp(created)::date <= (SELECT ending_date::date + INTERVAL '1 month')
        AND l.status = 'sold'
        AND l.order_id NOT LIKE 'RE%'
        AND l.order_id IS NOT NULL);
 END;
$$;


ALTER FUNCTION rptg.spoils(beginning_date date, ending_date date) OWNER TO dbservice;

--
-- Name: deps_restore_dependencies(character varying, character varying); Type: FUNCTION; Schema: util; Owner: dbservice
--

CREATE FUNCTION util.deps_restore_dependencies(p_view_schema character varying, p_view_name character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
declare
  v_curr record;
begin
  for v_curr in
    (
      select deps_ddl_to_run
      from util.deps_saved_ddl
      where deps_view_schema = p_view_schema and deps_view_name = p_view_name
      order by deps_id desc
    ) loop
    execute v_curr.deps_ddl_to_run;
  end loop;
  delete from util.deps_saved_ddl
  where deps_view_schema = p_view_schema and deps_view_name = p_view_name;
end;
$$;


ALTER FUNCTION util.deps_restore_dependencies(p_view_schema character varying, p_view_name character varying) OWNER TO dbservice;

--
-- Name: FUNCTION deps_restore_dependencies(p_view_schema character varying, p_view_name character varying); Type: COMMENT; Schema: util; Owner: dbservice
--

COMMENT ON FUNCTION util.deps_restore_dependencies(p_view_schema character varying, p_view_name character varying) IS 'part of save/drop/restore dependent views suite: restore previously saved dependent views';


--
-- Name: deps_save_and_drop_dependencies(character varying, character varying); Type: FUNCTION; Schema: util; Owner: dbservice
--

CREATE FUNCTION util.deps_save_and_drop_dependencies(p_view_schema character varying, p_view_name character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
declare
  v_curr record;
begin
  for v_curr in
    -- return a set of records of schema name, view name, view type (normal or materialized view)
    (
      select obj_schema, obj_name, obj_type from
        (
          with recursive recursive_deps(obj_schema, obj_name, obj_type, depth) as
            (
              select p_view_schema, p_view_name, null::varchar, 0
              union
              select dep_schema::varchar, dep_name::varchar, dep_type::varchar,
                     recursive_deps.depth + 1 from
                (
                  select ref_nsp.nspname ref_schema, ref_cl.relname ref_name,
                    rwr_cl.relkind dep_type,
                    rwr_nsp.nspname dep_schema,
                    rwr_cl.relname dep_name
                  from pg_depend dep
                         join pg_class ref_cl on dep.refobjid = ref_cl.oid
                         join pg_namespace ref_nsp on ref_cl.relnamespace = ref_nsp.oid
                         join pg_rewrite rwr on dep.objid = rwr.oid
                         join pg_class rwr_cl on rwr.ev_class = rwr_cl.oid
                         join pg_namespace rwr_nsp on rwr_cl.relnamespace = rwr_nsp.oid
                  where dep.deptype = 'n'
                  and dep.classid = 'pg_rewrite'::regclass
                ) deps
                  join recursive_deps on deps.ref_schema = recursive_deps.obj_schema
                                           and deps.ref_name = recursive_deps.obj_name
              where (deps.ref_schema != deps.dep_schema or deps.ref_name != deps.dep_name)
            )
          select obj_schema, obj_name, obj_type, depth
          from recursive_deps
          where depth > 0
        ) t
      group by obj_schema, obj_name, obj_type
      order by max(depth) desc
    ) loop

    insert into util.deps_saved_ddl(deps_view_schema, deps_view_name, deps_ddl_to_run)
      select p_view_schema, p_view_name, 'COMMENT ON '
        ||  case
             when c.relkind = 'v' then 'VIEW'
             when c.relkind = 'm' then 'MATERIALIZED VIEW'
             else ''
             end
        || ' ' || n.nspname || '.' || c.relname || ' IS '''
        || replace(d.description, '''', '''''') || ''';'
      from pg_class c
             join pg_namespace n on n.oid = c.relnamespace
             join pg_description d on d.objoid = c.oid and d.objsubid = 0
      where n.nspname = v_curr.obj_schema
        and c.relname = v_curr.obj_name and d.description is not null;

    insert into util.deps_saved_ddl(deps_view_schema, deps_view_name, deps_ddl_to_run)
      select p_view_schema, p_view_name, 'COMMENT ON COLUMN ' || n.nspname || '.' || c.relname
         || '.' || a.attname || ' IS ''' || replace(d.description, '''', '''''') || ''';'
      from pg_class c
             join pg_attribute a on c.oid = a.attrelid
             join pg_namespace n on n.oid = c.relnamespace
             join pg_description d on d.objoid = c.oid and d.objsubid = a.attnum
      where n.nspname = v_curr.obj_schema
        and c.relname = v_curr.obj_name and d.description is not null;

    insert into util.deps_saved_ddl(deps_view_schema, deps_view_name, deps_ddl_to_run)
      select p_view_schema, p_view_name, 'GRANT ' || privilege_type || ' ON ' || table_schema || '.'
         || table_name || ' TO ' || grantee
      from information_schema.role_table_grants
      where table_schema = v_curr.obj_schema and table_name = v_curr.obj_name;

    -- generate statement to create normal view
    if v_curr.obj_type = 'v' then
      insert into util.deps_saved_ddl(deps_view_schema, deps_view_name, deps_ddl_to_run)
        select p_view_schema, p_view_name, 'CREATE VIEW ' || v_curr.obj_schema || '.'
           || v_curr.obj_name || ' AS ' || view_definition
        from information_schema.views
        where table_schema = v_curr.obj_schema and table_name = v_curr.obj_name;

    -- generate statement to create materialized view
    elsif v_curr.obj_type = 'm' then
      insert into util.deps_saved_ddl(deps_view_schema, deps_view_name, deps_ddl_to_run)
        select p_view_schema, p_view_name, 'CREATE MATERIALIZED VIEW ' || v_curr.obj_schema
           || '.' || v_curr.obj_name || ' AS ' || definition
        from pg_matviews
        where schemaname = v_curr.obj_schema and matviewname = v_curr.obj_name;
    end if;

    execute 'DROP ' ||
            case
              when v_curr.obj_type = 'v' then 'VIEW'
              when v_curr.obj_type = 'm' then 'MATERIALIZED VIEW'
              end
      || ' ' || v_curr.obj_schema || '.' || v_curr.obj_name;

  end loop;
end;
$$;


ALTER FUNCTION util.deps_save_and_drop_dependencies(p_view_schema character varying, p_view_name character varying) OWNER TO dbservice;

--
-- Name: FUNCTION deps_save_and_drop_dependencies(p_view_schema character varying, p_view_name character varying); Type: COMMENT; Schema: util; Owner: dbservice
--

COMMENT ON FUNCTION util.deps_save_and_drop_dependencies(p_view_schema character varying, p_view_name character varying) IS 'part of save/drop/restore dependent views suite: store DDL of dependent views then drop the views';


--
-- Name: extract_request_log_epc_order(integer, timestamp without time zone, timestamp without time zone); Type: FUNCTION; Schema: util; Owner: dbservice
--

CREATE FUNCTION util.extract_request_log_epc_order(target_kiosk_id integer, report_start timestamp without time zone, report_end timestamp without time zone) RETURNS TABLE(epc character varying, order_id text, ts timestamp without time zone)
    LANGUAGE plpgsql
    AS $$

/*
Extract epc, order_id from mixalot.request_log for a kiosk for a period and store the result in
table request_log_sold_epc to be used by function fix_orders_using_request_log
to fix incorrectly voided orders due to kiosk sync issue.
*/

begin
  -- create table to hold sold epc's
  create table if not exists test.request_log_sold_epc(
    id serial,
    epc varchar(24) not null,
    order_id text,
    kiosk_id bigint,
    direction varchar(16) not null,
    reason text,
    ts timestamp not null
  );

  -- create table to store final result
  create table if not exists test.request_log_epc_order(
    epc varchar(24) not null,
    order_id text,
    ts timestamp not null
  );

  truncate test.request_log_sold_epc;

  -- Parse mixalot.request_log for sold epc and store them in request_log_sold_epc for target kiosk and date range
  -- When there are duplicate order_id, epc, pick the latest.
  insert into test.request_log_sold_epc(epc, order_id, kiosk_id, direction, reason, ts)
    select out_epc.epc, out_epc.order_id, out_epc.kiosk_id, out_epc.direction, out_epc.reason, out_epc.ts
    from (
           select request_body_json::json ->> 'epc' as epc,
                  request_body_json::json ->> 'order_id' as order_id,
                  nullif(regexp_replace(request_body_json::json ->> 'order_id', '[A-Za-z]+[0-9]*', '', 'g'),
                         '')::int kiosk_id,
                  request_body_json::json ->> 'direction' as direction,
                  request_body_json::json ->> 'reason' as reason,
                  start_ts ts,
                  rank() over (partition by request_body_json::json ->> 'order_id',
                        request_body_json::json ->> 'epc' order by start_ts desc) as r
           from mixalot.request_log
           where start_ts between report_start and report_end
             and endpoint in ('/item')
             and request_body_json::json ->> 'direction' = 'out'
             and request_body_json::json ->> 'order_id' is not null
             and request_body_json::json ->> 'order_id' like target_kiosk_id || '%'
         ) out_epc
    where out_epc.r = 1;

  truncate test.request_log_epc_order;

  -- insert correcting data for labels and orders
  insert into test.request_log_epc_order
    select tsp.epc, tsp.order_id, tsp.ts
      from (
             select distinct on(epc) test.request_log_sold_epc.*
             from test.request_log_sold_epc
             order by epc, ts desc
           ) tsp
      where reason = 'add_to_order';

  -- parsed epc orders from mixalot.request_log
  return query
    select * from test.request_log_epc_order;

end;

$$;


ALTER FUNCTION util.extract_request_log_epc_order(target_kiosk_id integer, report_start timestamp without time zone, report_end timestamp without time zone) OWNER TO dbservice;

--
-- Name: fix_orders_using_request_log(); Type: FUNCTION; Schema: util; Owner: dbservice
--

CREATE FUNCTION util.fix_orders_using_request_log() RETURNS TABLE(count_orders_affected integer)
    LANGUAGE plpgsql
    AS $$

/*
Address issues of specific kiosk not sending /item requests to our backend, thus voiding orders.

To fix these orders, first use function extract_request_log_epc_order to extract epc orders and save
them to request_log_epc_order.

Then run this function to fix those orders.
*/

declare count_orders_affected integer;

begin
  -- update label with curated data from mixalot.request_log
  update pantry.label l
     set order_id = p.order_id
     from test.request_log_epc_order p
     where p.epc = l.epc;

  -- count affected orders
  select count(*)
    from pantry.order o
      join test.request_log_epc_order rleo on o.order_id = rleo.order_id
      where o.state = 'Voided'
      into count_orders_affected;

  -- updated potentially affected orders
  update pantry.order o
    set state = 'PriceFinalized'
    from test.request_log_epc_order rleo
    where o.order_id = rleo.order_id and o.state = 'Voided';

  -- return number of orders affected
  return query
    select count_orders_affected;

end;

$$;


ALTER FUNCTION util.fix_orders_using_request_log() OWNER TO dbservice;

SET default_tablespace = '';

SET default_with_oids = false;

--
-- Name: awsdms_apply_exceptions; Type: TABLE; Schema: aws_dms; Owner: dbservice
--

CREATE TABLE aws_dms.awsdms_apply_exceptions (
    "TASK_NAME" character varying(384) NOT NULL,
    "TABLE_OWNER" character varying(384) NOT NULL,
    "TABLE_NAME" character varying(384) NOT NULL,
    "ERROR_TIME" timestamp without time zone NOT NULL,
    "STATEMENT" text NOT NULL,
    "ERROR" text NOT NULL
);


ALTER TABLE aws_dms.awsdms_apply_exceptions OWNER TO dbservice;

--
-- Name: awsdms_history; Type: TABLE; Schema: aws_dms; Owner: dbservice
--

CREATE TABLE aws_dms.awsdms_history (
    server_name character varying(384) NOT NULL,
    task_name character varying(384) NOT NULL,
    timeslot_type character varying(96) NOT NULL,
    timeslot timestamp without time zone NOT NULL,
    timeslot_duration bigint,
    timeslot_latency bigint,
    timeslot_records bigint,
    timeslot_volume bigint
);


ALTER TABLE aws_dms.awsdms_history OWNER TO dbservice;

--
-- Name: awsdms_status; Type: TABLE; Schema: aws_dms; Owner: dbservice
--

CREATE TABLE aws_dms.awsdms_status (
    server_name character varying(384) NOT NULL,
    task_name character varying(384) NOT NULL,
    task_status character varying(96),
    status_time timestamp without time zone,
    pending_changes bigint,
    disk_swap_size bigint,
    task_memory bigint,
    source_current_position character varying(384),
    source_current_timestamp timestamp without time zone,
    source_tail_position character varying(384),
    source_tail_timestamp timestamp without time zone,
    source_timestamp_applied timestamp without time zone
);


ALTER TABLE aws_dms.awsdms_status OWNER TO dbservice;

--
-- Name: awsdms_suspended_tables; Type: TABLE; Schema: aws_dms; Owner: dbservice
--

CREATE TABLE aws_dms.awsdms_suspended_tables (
    server_name character varying(384) NOT NULL,
    task_name character varying(384) NOT NULL,
    table_owner character varying(384) NOT NULL,
    table_name character varying(384) NOT NULL,
    suspend_reason character varying(96),
    suspend_timestamp timestamp without time zone
);


ALTER TABLE aws_dms.awsdms_suspended_tables OWNER TO dbservice;

--
-- Name: card; Type: TABLE; Schema: beta; Owner: dbservice
--

CREATE TABLE beta.card (
    id bigint,
    hash character varying(264),
    first_name character varying(135),
    last_name character varying(135),
    type character varying(45),
    number character varying(93),
    email character varying(381),
    notes text,
    created bigint,
    last_update bigint
);


ALTER TABLE beta.card OWNER TO dbservice;

--
-- Name: kiosk_projected_stock; Type: TABLE; Schema: beta; Owner: dbservice
--

CREATE TABLE beta.kiosk_projected_stock (
    kiosk_id bigint,
    kiosk_title character varying,
    fc_title character varying(765),
    count numeric
);


ALTER TABLE beta.kiosk_projected_stock OWNER TO dbservice;

--
-- Name: kiosk_sku_group_manual_scale; Type: TABLE; Schema: beta; Owner: dbservice
--

CREATE TABLE beta.kiosk_sku_group_manual_scale (
    kiosk_id integer NOT NULL,
    fc_title character varying(70) NOT NULL,
    scale numeric(4,2) NOT NULL
);


ALTER TABLE beta.kiosk_sku_group_manual_scale OWNER TO dbservice;

--
-- Name: kiosks; Type: TABLE; Schema: beta; Owner: dbservice
--

CREATE TABLE beta.kiosks (
    id integer NOT NULL
);


ALTER TABLE beta.kiosks OWNER TO dbservice;

--
-- Name: missing_hash; Type: TABLE; Schema: beta; Owner: dbservice
--

CREATE TABLE beta.missing_hash (
    order_id character varying(16) NOT NULL,
    transaction_id character varying(10),
    approval_code character varying(6),
    card_hash character varying(264),
    first_name character varying(135),
    last_name character varying(135),
    card_type character varying(45),
    card_number character varying(93),
    email character varying(381),
    created bigint,
    status_message character varying(25)
);


ALTER TABLE beta.missing_hash OWNER TO dbservice;

--
-- Name: pick_demand; Type: TABLE; Schema: beta; Owner: dbservice
--

CREATE TABLE beta.pick_demand (
    id integer NOT NULL,
    pick_date date NOT NULL,
    route_date date NOT NULL,
    kiosk_id integer NOT NULL,
    sku_group_id integer NOT NULL,
    qty integer NOT NULL
);


ALTER TABLE beta.pick_demand OWNER TO dbservice;

--
-- Name: pick_demand_id_seq; Type: SEQUENCE; Schema: beta; Owner: dbservice
--

CREATE SEQUENCE beta.pick_demand_id_seq
CREATE SEQUENCE beta.pick_demand_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE beta.pick_demand_id_seq OWNER TO dbservice;

--
-- Name: pick_demand_id_seq; Type: SEQUENCE OWNED BY; Schema: beta; Owner: dbservice
--

ALTER SEQUENCE beta.pick_demand_id_seq OWNED BY beta.pick_demand.id;


--
-- Name: route; Type: TABLE; Schema: beta; Owner: dbservice
--

CREATE TABLE beta.route (
    route_date_time timestamp(6) with time zone,
    duration integer,
    vehicle_label character varying(200),
    vehicle_registration character varying(200),
    driver_serial character varying(200),
    distance numeric(28,6),
    driver_name character varying(200)
);


ALTER TABLE beta.route OWNER TO dbservice;

--
-- Name: route_stop; Type: TABLE; Schema: beta; Owner: dbservice
--

CREATE TABLE beta.route_stop (
    route_date_time timestamp(6) with time zone,
    driver_name character varying(200),
    location_name character varying(200),
    schedule_at timestamp(6) with time zone,
    longitude numeric(28,6),
    address character varying(200),
    latitude numeric(28,6),
    stop_number integer,
    order_number character varying(200),
    location_number integer
);


ALTER TABLE beta.route_stop OWNER TO dbservice;

--
-- Name: sku_group_attribute; Type: TABLE; Schema: beta; Owner: dbservice
--

CREATE TABLE beta.sku_group_attribute (
    id integer,
    title character varying(512),
    relative_size numeric(4,2),
    minimum_kiosk_qty smallint
);


ALTER TABLE beta.sku_group_attribute OWNER TO dbservice;

--
-- Name: sku_group_control; Type: TABLE; Schema: beta; Owner: dbservice
--

CREATE TABLE beta.sku_group_control (
    fc_title character varying(64) NOT NULL,
    start_level numeric(4,2) DEFAULT '-1'::integer NOT NULL,
    scale numeric(4,2) DEFAULT 1.0 NOT NULL,
    min_qty smallint DEFAULT 0 NOT NULL,
    max_qty smallint DEFAULT 0 NOT NULL
);


ALTER TABLE beta.sku_group_control OWNER TO dbservice;

--
-- Name: temp_fc_default_level; Type: TABLE; Schema: beta; Owner: dbservice
--

CREATE TABLE beta.temp_fc_default_level (
    fc_title character varying(60),
    default_level smallint
);


ALTER TABLE beta.temp_fc_default_level OWNER TO dbservice;

--
-- Name: temp_inv; Type: TABLE; Schema: beta; Owner: dbservice
--

CREATE TABLE beta.temp_inv (
    kiosk_id integer,
    fc_title character varying(100),
    qty integer,
    kiosk_title character varying(60)
);


ALTER TABLE beta.temp_inv OWNER TO dbservice;

--
-- Name: temp_nutrition_filter; Type: TABLE; Schema: beta; Owner: dbservice
--

CREATE TABLE beta.temp_nutrition_filter (
    id bigint NOT NULL,
    tag_id bigint,
    label character varying(150),
    icon character varying(381)
);


ALTER TABLE beta.temp_nutrition_filter OWNER TO dbservice;

--
-- Name: temp_pick_preference_kiosk_sku; Type: TABLE; Schema: beta; Owner: dbservice
--

CREATE TABLE beta.temp_pick_preference_kiosk_sku (
    kiosk_id integer,
    sku_id integer,
    preference smallint
);


ALTER TABLE beta.temp_pick_preference_kiosk_sku OWNER TO dbservice;

--
-- Name: temp_product; Type: TABLE; Schema: beta; Owner: dbservice
--

CREATE TABLE beta.temp_product (
    id bigint NOT NULL,
    title character varying(381) NOT NULL,
    description character varying(12285),
    tiny_description character varying(120),
    short_description character varying(300),
    medium_description character varying(1200),
    long_description character varying(3600),
    price numeric(5,2) NOT NULL,
    cost numeric(5,2) NOT NULL,
    shelf_time integer NOT NULL,
    campus_id bigint NOT NULL,
    image smallint NOT NULL,
    image_time bigint,
    last_update bigint NOT NULL,
    archived bigint,
    taxable smallint,
    allergens character varying(765),
    attribute_names character varying(1533),
    categories character varying(765),
    category_names character varying(1533),
    vendor character varying(405),
    source character varying(405),
    notes character varying(6000),
    total_cal bigint,
    num_servings real,
    ingredients character varying(6000),
    calories real,
    proteins real,
    sugar real,
    carbohydrates real,
    fat real,
    consumer_category character varying(6000),
    ws_case_size bigint,
    kiosk_ship_qty bigint,
    ws_case_cost numeric(5,2),
    pick_station bigint,
    fc_title character varying(765),
    pricing_tier character varying(765),
    width_space real,
    height_space real,
    depth_space real,
    slotted_width real,
    tag_volume bigint,
    delivery_option character varying(765),
    tag_applied_by character varying(765)
);


ALTER TABLE beta.temp_product OWNER TO dbservice;

--
-- Name: temp_sku_group_attribute; Type: TABLE; Schema: beta; Owner: dbservice
--

CREATE TABLE beta.temp_sku_group_attribute (
    title character varying(512) NOT NULL,
    relative_size numeric(4,2) NOT NULL,
    minimum_kiosk_qty smallint NOT NULL,
    maximum_kiosk_qty smallint NOT NULL
);


ALTER TABLE beta.temp_sku_group_attribute OWNER TO dbservice;

--
-- Name: temp_sync_label_2018_12_13; Type: TABLE; Schema: beta; Owner: dbservice
--

CREATE TABLE beta.temp_sync_label_2018_12_13 (
    id bigint,
    product_id bigint,
    epc character varying(72),
    is_generic_sku smallint,
    kiosk_id bigint,
    order_id character varying(135),
    status character varying(12),
    price numeric(6,2),
    cost numeric(6,2),
    time_created bigint,
    time_added bigint,
    time_updated bigint,
    notes text
);


ALTER TABLE beta.temp_sync_label_2018_12_13 OWNER TO dbservice;

--
-- Name: temp_sync_order_2018_12_13; Type: TABLE; Schema: beta; Owner: dbservice
--

CREATE TABLE beta.temp_sync_order_2018_12_13 (
    order_id character varying(135),
    first_name character varying(135),
    last_name character varying(135),
    kiosk_id bigint,
    kiosk_title character varying(138),
    email character varying(381),
    amount_paid numeric(6,2),
    payment_system character varying(135),
    transaction_id character varying(135),
    approval_code character varying(135),
    status_code character varying(135),
    status_message character varying(135),
    status character varying(135),
    batch_id character varying(45),
    created bigint,
    auth_amount character varying(21),
    data_token character varying(6141),
    time_opened bigint,
    time_closed bigint,
    card_hash character varying(264),
    state character varying(45),
    archived bigint,
    stamp bigint,
    last_update bigint,
    balance numeric(7,2),
    delta character varying(12),
    coupon_id bigint,
    coupon character varying(135),
    refund numeric(6,2),
    receipt bigint,
    campus_id bigint,
    amount_list_price numeric(6,2),
    notes text,
    time_door_opened bigint,
    time_door_closed bigint
);


ALTER TABLE beta.temp_sync_order_2018_12_13 OWNER TO dbservice;

--
-- Name: temp_test; Type: TABLE; Schema: beta; Owner: dbservice
--

CREATE TABLE beta.temp_test (
    id integer NOT NULL,
    name text
);


ALTER TABLE beta.temp_test OWNER TO dbservice;

--
-- Name: temp_test2; Type: TABLE; Schema: beta; Owner: dbservice
--

CREATE TABLE beta.temp_test2 (
    id integer NOT NULL,
    value integer
);


ALTER TABLE beta.temp_test2 OWNER TO dbservice;

--
-- Name: temp_test2_id_seq; Type: SEQUENCE; Schema: beta; Owner: dbservice
--

CREATE SEQUENCE beta.temp_test2_id_seq
CREATE SEQUENCE beta.temp_test2_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE beta.temp_test2_id_seq OWNER TO dbservice;

--
-- Name: temp_test2_id_seq; Type: SEQUENCE OWNED BY; Schema: beta; Owner: dbservice
--

ALTER SEQUENCE beta.temp_test2_id_seq OWNED BY beta.temp_test2.id;


--
-- Name: temp_test3; Type: VIEW; Schema: beta; Owner: dbservice
--

CREATE VIEW beta.temp_test3 AS
 SELECT t1.id,
    t1.name,
    t2.value
   FROM (beta.temp_test t1
     JOIN beta.temp_test2 t2 ON ((t1.id = t2.id)));


ALTER TABLE beta.temp_test3 OWNER TO dbservice;

--
-- Name: temp_test_id_seq; Type: SEQUENCE; Schema: beta; Owner: dbservice
--

CREATE SEQUENCE beta.temp_test_id_seq
CREATE SEQUENCE beta.temp_test_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE beta.temp_test_id_seq OWNER TO dbservice;

--
-- Name: temp_test_id_seq; Type: SEQUENCE OWNED BY; Schema: beta; Owner: dbservice
--

ALTER SEQUENCE beta.temp_test_id_seq OWNED BY beta.temp_test.id;


--
-- Name: test; Type: TABLE; Schema: beta; Owner: dbservice
--

CREATE TABLE beta.test (
    n integer
);


ALTER TABLE beta.test OWNER TO dbservice;

--
-- Name: warehouse_inventory_history; Type: TABLE; Schema: beta; Owner: dbservice
--

CREATE TABLE beta.warehouse_inventory_history (
    date_time timestamp(6) with time zone DEFAULT now(),
    sku integer NOT NULL,
    stickered_cases integer,
    stickered_units integer,
    unstickered_cases integer,
    unstickered_units integer,
    spoils integer,
    date_ date NOT NULL
);


ALTER TABLE beta.warehouse_inventory_history OWNER TO dbservice;

--
-- Name: pgdudetail; Type: VIEW; Schema: byt_devops; Owner: dbservice
--

CREATE VIEW byt_devops.pgdudetail AS
 SELECT 0 AS union_sort_order,
    all_tables.table_name,
    pg_table_size((all_tables.table_name)::regclass) AS table_size,
    to_char((((pg_table_size((all_tables.table_name)::regclass))::double precision / (pg_total_relation_size((all_tables.table_name)::regclass))::double precision) * (100)::double precision), '999D9%'::text) AS percent_table,
    pg_indexes_size((all_tables.table_name)::regclass) AS indexes_size,
    to_char((((pg_indexes_size((all_tables.table_name)::regclass))::double precision / (pg_total_relation_size((all_tables.table_name)::regclass))::double precision) * (100)::double precision), '999D9%'::text) AS percent_index,
    pg_total_relation_size((all_tables.table_name)::regclass) AS total_size
   FROM ( SELECT (((('"'::text || (tables.table_schema)::text) || '"."'::text) || (tables.table_name)::text) || '"'::text) AS table_name
           FROM information_schema.tables) all_tables
  WHERE (pg_total_relation_size((all_tables.table_name)::regclass) > 0)
  ORDER BY (pg_total_relation_size((all_tables.table_name)::regclass)) DESC;


ALTER TABLE byt_devops.pgdudetail OWNER TO dbservice;

--
-- Name: pgdutotal; Type: VIEW; Schema: byt_devops; Owner: dbservice
--

CREATE VIEW byt_devops.pgdutotal AS
 SELECT 1 AS union_sort_order,
    'All db objects'::text AS table_name,
    sum(pgdudetail.table_size) AS table_size,
    to_char(((sum(pgdudetail.table_size) / sum(pgdudetail.total_size)) * (100)::numeric), '999D9%'::text) AS percent_table,
    sum(pgdudetail.indexes_size) AS indexes_size,
    to_char(((sum(pgdudetail.indexes_size) / sum(pgdudetail.total_size)) * (100)::numeric), '999D9%'::text) AS percent_index,
    sum(pgdudetail.total_size) AS total_size
   FROM byt_devops.pgdudetail;


ALTER TABLE byt_devops.pgdutotal OWNER TO dbservice;

--
-- Name: pgdu_union; Type: VIEW; Schema: byt_devops; Owner: dbservice
--

CREATE VIEW byt_devops.pgdu_union AS
 SELECT pgdudetail.union_sort_order,
    pgdudetail.table_name,
    pgdudetail.table_size,
    pgdudetail.percent_table,
    pgdudetail.indexes_size,
    pgdudetail.percent_index,
    pgdudetail.total_size
   FROM byt_devops.pgdudetail
UNION
 SELECT pgdutotal.union_sort_order,
    pgdutotal.table_name,
    pgdutotal.table_size,
    pgdutotal.percent_table,
    pgdutotal.indexes_size,
    pgdutotal.percent_index,
    pgdutotal.total_size
   FROM byt_devops.pgdutotal
  ORDER BY 1, 7 DESC;


ALTER TABLE byt_devops.pgdu_union OWNER TO dbservice;

--
-- Name: pgdu; Type: VIEW; Schema: byt_devops; Owner: dbservice
--

CREATE VIEW byt_devops.pgdu AS
 SELECT pgdu_union.table_name,
    pgdu_union.table_size,
    pgdu_union.percent_table,
    pgdu_union.indexes_size,
    pgdu_union.percent_index,
    pgdu_union.total_size
   FROM byt_devops.pgdu_union;


ALTER TABLE byt_devops.pgdu OWNER TO dbservice;

--
-- Name: pgdudetail_pretty; Type: VIEW; Schema: byt_devops; Owner: dbservice
--

CREATE VIEW byt_devops.pgdudetail_pretty AS
 SELECT 0 AS union_sort_order,
    pgdudetail.total_size AS total_size_sort_order,
    pgdudetail.table_name,
    pg_size_pretty(pgdudetail.table_size) AS table_size,
    pgdudetail.percent_table,
    pg_size_pretty(pgdudetail.indexes_size) AS indexes_size,
    pgdudetail.percent_index,
    pg_size_pretty(pgdudetail.total_size) AS total_size
   FROM byt_devops.pgdudetail
  ORDER BY pgdudetail.total_size DESC
 LIMIT 15;


ALTER TABLE byt_devops.pgdudetail_pretty OWNER TO dbservice;

--
-- Name: pgdutotal_pretty; Type: VIEW; Schema: byt_devops; Owner: dbservice
--

CREATE VIEW byt_devops.pgdutotal_pretty AS
 SELECT 1 AS union_sort_order,
    sum(pgdudetail.total_size) AS total_size_sort_order,
    'All db objects'::text AS table_name,
    pg_size_pretty(sum(pgdudetail.table_size)) AS table_size,
    to_char(((sum(pgdudetail.table_size) / sum(pgdudetail.total_size)) * (100)::numeric), '999D9%'::text) AS percent_table,
    pg_size_pretty(sum(pgdudetail.indexes_size)) AS indexes_size,
    to_char(((sum(pgdudetail.indexes_size) / sum(pgdudetail.total_size)) * (100)::numeric), '999D9%'::text) AS percent_index,
    pg_size_pretty(sum(pgdudetail.total_size)) AS total_size
   FROM byt_devops.pgdudetail;


ALTER TABLE byt_devops.pgdutotal_pretty OWNER TO dbservice;

--
-- Name: pgdu_union_pretty; Type: VIEW; Schema: byt_devops; Owner: dbservice
--

CREATE VIEW byt_devops.pgdu_union_pretty AS
 SELECT pgdudetail_pretty.union_sort_order,
    pgdudetail_pretty.total_size_sort_order,
    pgdudetail_pretty.table_name,
    pgdudetail_pretty.table_size,
    pgdudetail_pretty.percent_table,
    pgdudetail_pretty.indexes_size,
    pgdudetail_pretty.percent_index,
    pgdudetail_pretty.total_size
   FROM byt_devops.pgdudetail_pretty
UNION
 SELECT pgdutotal_pretty.union_sort_order,
    pgdutotal_pretty.total_size_sort_order,
    pgdutotal_pretty.table_name,
    pgdutotal_pretty.table_size,
    pgdutotal_pretty.percent_table,
    pgdutotal_pretty.indexes_size,
    pgdutotal_pretty.percent_index,
    pgdutotal_pretty.total_size
   FROM byt_devops.pgdutotal_pretty
  ORDER BY 1, 2 DESC;


ALTER TABLE byt_devops.pgdu_union_pretty OWNER TO dbservice;

--
-- Name: pgdu_pretty; Type: VIEW; Schema: byt_devops; Owner: dbservice
--

CREATE VIEW byt_devops.pgdu_pretty AS
 SELECT pgdu_union_pretty.table_name,
    pgdu_union_pretty.table_size,
    pgdu_union_pretty.percent_table,
    pgdu_union_pretty.indexes_size,
    pgdu_union_pretty.percent_index,
    pgdu_union_pretty.total_size
   FROM byt_devops.pgdu_union_pretty;


ALTER TABLE byt_devops.pgdu_pretty OWNER TO dbservice;

--
-- Name: pgdudetail; Type: VIEW; Schema: byte_pgdu; Owner: dbservice
--

CREATE VIEW byte_pgdu.pgdudetail AS
 SELECT 0 AS union_sort_order,
    all_tables.table_schema,
    all_tables.table_name,
    pg_table_size((all_tables.full_table_name)::regclass) AS table_size,
    to_char((((pg_table_size((all_tables.full_table_name)::regclass))::double precision / (pg_total_relation_size((all_tables.full_table_name)::regclass))::double precision) * (100)::double precision), '999D9%'::text) AS percent_table,
    pg_indexes_size((all_tables.full_table_name)::regclass) AS indexes_size,
    to_char((((pg_indexes_size((all_tables.full_table_name)::regclass))::double precision / (pg_total_relation_size((all_tables.full_table_name)::regclass))::double precision) * (100)::double precision), '999D9%'::text) AS percent_index,
    pg_total_relation_size((all_tables.full_table_name)::regclass) AS total_size
   FROM ( SELECT tables.table_schema,
            tables.table_name,
            (((('"'::text || (tables.table_schema)::text) || '"."'::text) || (tables.table_name)::text) || '"'::text) AS full_table_name
           FROM information_schema.tables
          WHERE (((tables.table_schema)::text !~~ 'pg_%'::text) AND ((tables.table_schema)::text <> 'information_schema'::text))) all_tables
  WHERE (pg_total_relation_size((all_tables.full_table_name)::regclass) > 0)
  ORDER BY (pg_total_relation_size((all_tables.full_table_name)::regclass)) DESC;


ALTER TABLE byte_pgdu.pgdudetail OWNER TO dbservice;

--
-- Name: accounting; Type: TABLE; Schema: develop; Owner: dbservice
--

CREATE TABLE develop.accounting (
    id bigint NOT NULL,
    date character varying(135) NOT NULL,
    kiosk_id bigint NOT NULL,
    campus_id bigint NOT NULL,
    sales_ipc numeric(6,2) NOT NULL,
    sales_fp numeric(6,2) NOT NULL,
    sales_cs numeric(6,2) NOT NULL,
    sales_cp numeric(6,2) NOT NULL,
    tags_got bigint NOT NULL,
    tags_spent bigint NOT NULL,
    timezone smallint NOT NULL,
    sales_tax numeric(4,2) NOT NULL,
    sales_tax_ipc numeric(6,2) NOT NULL,
    sales_tax_fp numeric(6,2) NOT NULL,
    sales_tax_cs numeric(6,2) NOT NULL,
    sales_tax_cp numeric(6,2) NOT NULL,
    prepaid bigint NOT NULL,
    current_fee bigint NOT NULL,
    next_fee bigint NOT NULL,
    recalculated_fee numeric(6,2),
    prepaid_day bigint NOT NULL,
    next_fee_from character varying(135),
    fee_connectivity numeric(5,2) NOT NULL
);


ALTER TABLE develop.accounting OWNER TO dbservice;

--
-- Name: campus; Type: TABLE; Schema: develop; Owner: dbservice
--

CREATE TABLE develop.campus (
    id bigint NOT NULL,
    title character varying(135) NOT NULL,
    timezone character varying(150),
    archived smallint
);


ALTER TABLE develop.campus OWNER TO dbservice;

--
-- Name: card; Type: TABLE; Schema: develop; Owner: dbservice
--

CREATE TABLE develop.card (
    id bigint NOT NULL,
    hash character varying(264) NOT NULL,
    first_name character varying(135),
    last_name character varying(135),
    type character varying(45),
    number character varying(93),
    email character varying(381) NOT NULL
);


ALTER TABLE develop.card OWNER TO dbservice;

--
-- Name: contract; Type: TABLE; Schema: develop; Owner: dbservice
--

CREATE TABLE develop.contract (
    id bigint NOT NULL,
    url character varying(765) NOT NULL,
    user_id integer,
    name character varying(381),
    email character varying(381),
    payment_type character varying(150),
    pantry_quantity bigint,
    step smallint,
    paid smallint,
    archived smallint,
    initials character varying(150),
    total bigint,
    pricing_structure smallint,
    payment_transaction_id character varying(765),
    fee_monthly numeric(8,2),
    fee_6_month_pre_payment numeric(8,2),
    fee_12_month_pre_payment numeric(8,2),
    fee_label numeric(3,2),
    fee_transact numeric(5,4),
    fee_deposit numeric(8,2),
    logo character varying(765),
    terms character varying(765),
    requester_id bigint,
    monthly_allowed smallint NOT NULL
);


ALTER TABLE develop.contract OWNER TO dbservice;

--
-- Name: coupon; Type: TABLE; Schema: develop; Owner: dbservice
--

CREATE TABLE develop.coupon (
    id bigint NOT NULL,
    code character varying(135) NOT NULL,
    flat_discount numeric(5,2) NOT NULL,
    real_discount numeric(5,2) NOT NULL,
    used smallint NOT NULL,
    kiosk_list character varying(765)
);


ALTER TABLE develop.coupon OWNER TO dbservice;

--
-- Name: cron; Type: TABLE; Schema: develop; Owner: dbservice
--

CREATE TABLE develop.cron (
    id integer NOT NULL,
    "time" character varying(300),
    kiosks character varying(1500),
    command character varying(300),
    payload text,
    trigger_id integer,
    dependencies character varying(300),
    user_id integer,
    raw_task text,
    active integer,
    group_id integer,
    timezone character varying(210)
);


ALTER TABLE develop.cron OWNER TO dbservice;

--
-- Name: current_label_status_365days; Type: TABLE; Schema: develop; Owner: dbservice
--

CREATE TABLE develop.current_label_status_365days (
    epc character varying(72) NOT NULL,
    campus_id bigint NOT NULL,
    product_id bigint NOT NULL,
    product_title character varying(381) NOT NULL,
    price numeric(5,2) NOT NULL,
    status character varying(12) NOT NULL,
    kiosk_id bigint NOT NULL,
    order_id character varying(150) NOT NULL,
    first_timestamp bigint NOT NULL,
    last_timestamp bigint NOT NULL,
    cost numeric(5,2)
);


ALTER TABLE develop.current_label_status_365days OWNER TO dbservice;

--
-- Name: discount; Type: TABLE; Schema: develop; Owner: dbservice
--

CREATE TABLE develop.discount (
    id bigint NOT NULL,
    kiosk_id bigint,
    product_id bigint,
    value integer NOT NULL
);


ALTER TABLE develop.discount OWNER TO dbservice;

--
-- Name: discount_history; Type: TABLE; Schema: develop; Owner: dbservice
--

CREATE TABLE develop.discount_history (
    id integer NOT NULL,
    kiosk_id integer,
    product_id integer,
    value integer,
    start_time integer,
    end_time integer,
    discount_id integer
);


ALTER TABLE develop.discount_history OWNER TO dbservice;

--
-- Name: event; Type: TABLE; Schema: develop; Owner: dbservice
--

CREATE TABLE develop.event (
    id bigint NOT NULL,
    user_id bigint NOT NULL,
    params character varying(6141) NOT NULL,
    action character varying(45) NOT NULL,
    options character varying(6141) NOT NULL,
    archived smallint NOT NULL
);


ALTER TABLE develop.event OWNER TO dbservice;

--
-- Name: fee_rates; Type: TABLE; Schema: develop; Owner: dbservice
--

CREATE TABLE develop.fee_rates (
    id bigint NOT NULL,
    fee_lease numeric(6,2) NOT NULL,
    fee_tags numeric(3,2) NOT NULL,
    fee_ipc numeric(5,4) NOT NULL,
    bi_monthly smallint NOT NULL,
    archived smallint NOT NULL,
    custom smallint NOT NULL,
    prepaid_amount bigint NOT NULL,
    name character varying(384) NOT NULL
);


ALTER TABLE develop.fee_rates OWNER TO dbservice;

--
-- Name: feedback; Type: TABLE; Schema: develop; Owner: dbservice
--

CREATE TABLE develop.feedback (
    id bigint NOT NULL,
    rate smallint NOT NULL,
    order_id character varying(135) NOT NULL,
    message character varying(1536),
    taste smallint,
    freshness smallint,
    variety smallint,
    value smallint,
    ticket_created smallint
);


ALTER TABLE develop.feedback OWNER TO dbservice;

--
-- Name: group; Type: TABLE; Schema: develop; Owner: dbservice
--

CREATE TABLE develop."group" (
    id bigint NOT NULL,
    name character varying(135) NOT NULL,
    title character varying(135) NOT NULL,
    notes character varying(6000) NOT NULL,
    archived smallint
);


ALTER TABLE develop."group" OWNER TO dbservice;

--
-- Name: group_campus; Type: TABLE; Schema: develop; Owner: dbservice
--

CREATE TABLE develop.group_campus (
    group_id bigint NOT NULL,
    campus_id bigint NOT NULL,
    owner smallint NOT NULL,
    archived smallint
);


ALTER TABLE develop.group_campus OWNER TO dbservice;

--
-- Name: history; Type: TABLE; Schema: develop; Owner: dbservice
--

CREATE TABLE develop.history (
    id bigint NOT NULL,
    epc character varying(72) NOT NULL,
    kiosk_id bigint NOT NULL,
    user_id bigint,
    order_id character varying(135),
    direction character varying(9) NOT NULL,
    "time" bigint NOT NULL
);


ALTER TABLE develop.history OWNER TO dbservice;

--
-- Name: history_epc_order; Type: TABLE; Schema: develop; Owner: dbservice
--

CREATE TABLE develop.history_epc_order (
    id bigint NOT NULL,
    epc character varying(72) NOT NULL,
    kiosk_id bigint NOT NULL,
    order_id character varying(135),
    "time" bigint NOT NULL,
    product_id integer
);


ALTER TABLE develop.history_epc_order OWNER TO dbservice;

--
-- Name: inventory_history; Type: TABLE; Schema: develop; Owner: dbservice
--

CREATE TABLE develop.inventory_history (
    id integer NOT NULL,
    "time" integer NOT NULL,
    kiosk_id integer NOT NULL,
    product_id integer NOT NULL,
    qty integer NOT NULL
);


ALTER TABLE develop.inventory_history OWNER TO dbservice;

--
-- Name: kiosk; Type: TABLE; Schema: develop; Owner: dbservice
--

CREATE TABLE develop.kiosk (
    id bigint NOT NULL,
    campus_id bigint NOT NULL,
    serial character varying(135) NOT NULL,
    title character varying(138),
    address character varying(381),
    location_x numeric(9,6) NOT NULL,
    location_y numeric(9,6) NOT NULL,
    gcm_id character varying(765),
    app_vname character varying(75),
    app_vcode smallint,
    archived smallint,
    creation_time bigint,
    deployment_time bigint,
    last_update bigint,
    client_name character varying(765),
    last_status bigint,
    last_inventory bigint NOT NULL,
    kiosk_name character varying(765) NOT NULL,
    payment_start bigint,
    payment_stop bigint,
    features character varying(765) NOT NULL,
    sales_tax smallint NOT NULL,
    default_fee_plan bigint NOT NULL,
    timezone character varying(150)
);


ALTER TABLE develop.kiosk OWNER TO dbservice;

--
-- Name: kiosk_par_level; Type: TABLE; Schema: develop; Owner: dbservice
--

CREATE TABLE develop.kiosk_par_level (
    kiosk_id bigint NOT NULL,
    product_id bigint NOT NULL,
    amount bigint
);


ALTER TABLE develop.kiosk_par_level OWNER TO dbservice;

--
-- Name: kiosk_status; Type: TABLE; Schema: develop; Owner: dbservice
--

CREATE TABLE develop.kiosk_status (
    id bigint NOT NULL,
    kiosk_id bigint NOT NULL,
    kiosk_temperature numeric(6,3),
    kit_temperature numeric(6,3),
    power integer,
    battery_level smallint,
    rfid_0 integer,
    rfid_1 integer,
    rfid_2 integer,
    rfid_3 bigint NOT NULL,
    "time" bigint,
    modem_signal_percentage smallint,
    modem_signal_type character varying(81),
    ip character varying(135)
);


ALTER TABLE develop.kiosk_status OWNER TO dbservice;

--
-- Name: label; Type: TABLE; Schema: develop; Owner: dbservice
--

CREATE TABLE develop.label (
    id bigint NOT NULL,
    product_id bigint NOT NULL,
    epc character varying(72) NOT NULL,
    is_generic_sku smallint,
    kiosk_id bigint,
    order_id character varying(135),
    status character varying(12),
    price numeric(6,2),
    time_created bigint,
    time_added bigint,
    time_updated bigint
);


ALTER TABLE develop.label OWNER TO dbservice;

--
-- Name: label_order; Type: TABLE; Schema: develop; Owner: dbservice
--

CREATE TABLE develop.label_order (
    id bigint NOT NULL,
    product_id bigint,
    group_id bigint,
    box_id character varying(48),
    amount bigint NOT NULL,
    time_order bigint NOT NULL,
    time_encoded bigint,
    time_delivery bigint,
    time_updated bigint,
    status character varying(45)
);


ALTER TABLE develop.label_order OWNER TO dbservice;

--
-- Name: last_kiosk_status; Type: TABLE; Schema: develop; Owner: dbservice
--

CREATE TABLE develop.last_kiosk_status (
    id bigint NOT NULL,
    kiosk_id bigint NOT NULL,
    kiosk_temperature numeric(6,3),
    kit_temperature numeric(6,3),
    power integer,
    battery_level smallint,
    rfid_0 integer,
    rfid_1 integer,
    rfid_2 integer,
    rfid_3 bigint NOT NULL,
    "time" bigint,
    modem_signal_percentage smallint,
    modem_signal_type character varying(81),
    ip character varying(135)
);


ALTER TABLE develop.last_kiosk_status OWNER TO dbservice;

--
-- Name: manual_adjustment; Type: TABLE; Schema: develop; Owner: dbservice
--

CREATE TABLE develop.manual_adjustment (
    id bigint NOT NULL,
    kiosk_id bigint NOT NULL,
    date character varying(135) NOT NULL,
    sum numeric(6,2) NOT NULL,
    reason character varying(384) NOT NULL,
    auto_generated smallint NOT NULL,
    archived smallint NOT NULL
);


ALTER TABLE develop.manual_adjustment OWNER TO dbservice;

--
-- Name: order; Type: TABLE; Schema: develop; Owner: dbservice
--

CREATE TABLE develop."order" (
    order_id character varying(135) NOT NULL,
    kiosk_id bigint NOT NULL,
    kiosk_title character varying(138),
    email character varying(381) NOT NULL,
    amount_paid numeric(6,2),
    payment_system character varying(135) NOT NULL,
    transaction_id character varying(135) NOT NULL,
    approval_code character varying(135) NOT NULL,
    status_code character varying(135),
    status_message character varying(135),
    status character varying(135),
    batch_id character varying(45),
    created bigint,
    auth_amount character varying(21),
    data_token character varying(6141),
    time_opened bigint,
    time_closed bigint,
    card_hash character varying(264) NOT NULL,
    state character varying(45) NOT NULL,
    archived smallint,
    stamp bigint NOT NULL,
    last_update bigint,
    balance numeric(7,2),
    delta character varying(12),
    coupon_id bigint,
    coupon character varying(135),
    refund numeric(6,2) NOT NULL,
    receipt smallint NOT NULL,
    campus_id integer
);


ALTER TABLE develop."order" OWNER TO dbservice;

--
-- Name: par_history; Type: TABLE; Schema: develop; Owner: dbservice
--

CREATE TABLE develop.par_history (
    id integer NOT NULL,
    kiosk_id integer,
    par_level character varying(3069),
    end_time integer
);


ALTER TABLE develop.par_history OWNER TO dbservice;

--
-- Name: permission; Type: TABLE; Schema: develop; Owner: dbservice
--

CREATE TABLE develop.permission (
    id integer NOT NULL,
    permission character varying(765),
    api character varying(765),
    "isFrontend" integer NOT NULL
);


ALTER TABLE develop.permission OWNER TO dbservice;

--
-- Name: permission_mapping; Type: TABLE; Schema: develop; Owner: dbservice
--

CREATE TABLE develop.permission_mapping (
    role_id integer NOT NULL,
    permission_id integer NOT NULL
);


ALTER TABLE develop.permission_mapping OWNER TO dbservice;

--
-- Name: product; Type: TABLE; Schema: develop; Owner: dbservice
--

CREATE TABLE develop.product (
    id bigint NOT NULL,
    title character varying(381) NOT NULL,
    description character varying(12285),
    price numeric(5,2) NOT NULL,
    cost numeric(5,2) NOT NULL,
    shelf_time integer NOT NULL,
    campus_id bigint NOT NULL,
    image smallint NOT NULL,
    last_update bigint NOT NULL,
    archived smallint,
    taxable smallint,
    allergens character varying(765),
    categories character varying(765),
    vendor character varying(6000)
);


ALTER TABLE develop.product OWNER TO dbservice;

--
-- Name: product_history; Type: TABLE; Schema: develop; Owner: dbservice
--

CREATE TABLE develop.product_history (
    id integer NOT NULL,
    price numeric(5,2),
    cost numeric(5,2),
    start_time integer,
    end_time integer,
    product_id integer,
    campus_id integer
);


ALTER TABLE develop.product_history OWNER TO dbservice;

--
-- Name: refunds; Type: TABLE; Schema: develop; Owner: dbservice
--

CREATE TABLE develop.refunds (
    order_id character varying(135) NOT NULL,
    product_id integer NOT NULL,
    price numeric(6,2) NOT NULL
);


ALTER TABLE develop.refunds OWNER TO dbservice;

--
-- Name: ro_order; Type: TABLE; Schema: develop; Owner: dbservice
--

CREATE TABLE develop.ro_order (
    order_id character varying(135) NOT NULL,
    campus_id bigint NOT NULL,
    kiosk_id bigint NOT NULL,
    kiosk_title character varying(138),
    created bigint,
    state character varying(45) NOT NULL,
    customer_full_name character varying(300),
    full_price numeric(6,2),
    real_full_price numeric(6,2),
    archived smallint,
    time_updated bigint
);


ALTER TABLE develop.ro_order OWNER TO dbservice;

--
-- Name: role; Type: TABLE; Schema: develop; Owner: dbservice
--

CREATE TABLE develop.role (
    id integer NOT NULL,
    role character varying(765)
);


ALTER TABLE develop.role OWNER TO dbservice;

--
-- Name: role_mapping; Type: TABLE; Schema: develop; Owner: dbservice
--

CREATE TABLE develop.role_mapping (
    role_id integer NOT NULL,
    parent_id integer NOT NULL
);


ALTER TABLE develop.role_mapping OWNER TO dbservice;

--
-- Name: sessions; Type: TABLE; Schema: develop; Owner: dbservice
--

CREATE TABLE develop.sessions (
    sid character varying(765) NOT NULL,
    session character varying(65535) NOT NULL,
    expires integer
);


ALTER TABLE develop.sessions OWNER TO dbservice;

--
-- Name: spoilage; Type: TABLE; Schema: develop; Owner: dbservice
--

CREATE TABLE develop.spoilage (
    id integer NOT NULL,
    epc character varying(72) NOT NULL,
    kiosk_id integer NOT NULL,
    order_id character varying(135),
    time_removed integer,
    time_added integer,
    product_id integer
);


ALTER TABLE develop.spoilage OWNER TO dbservice;

--
-- Name: tag; Type: TABLE; Schema: develop; Owner: dbservice
--

CREATE TABLE develop.tag (
    id bigint NOT NULL,
    tag character varying(93) NOT NULL
);


ALTER TABLE develop.tag OWNER TO dbservice;

--
-- Name: temp; Type: TABLE; Schema: develop; Owner: dbservice
--

CREATE TABLE develop.temp (
    id bigint NOT NULL,
    date_processed character varying(135),
    date_auth character varying(135),
    type character varying(135),
    card character varying(135),
    num character varying(135),
    appcode character varying(135),
    amount character varying(135)
);


ALTER TABLE develop.temp OWNER TO dbservice;

--
-- Name: timezone_mapping; Type: TABLE; Schema: develop; Owner: dbservice
--

CREATE TABLE develop.timezone_mapping (
    id bigint NOT NULL,
    value smallint NOT NULL,
    name character varying(135) NOT NULL
);


ALTER TABLE develop.timezone_mapping OWNER TO dbservice;

--
-- Name: tmp_watcher; Type: TABLE; Schema: develop; Owner: dbservice
--

CREATE TABLE develop.tmp_watcher (
    label_id bigint,
    order_id character varying(135) NOT NULL,
    created bigint
);


ALTER TABLE develop.tmp_watcher OWNER TO dbservice;

--
-- Name: transact_comp; Type: TABLE; Schema: develop; Owner: dbservice
--

CREATE TABLE develop.transact_comp (
    id bigint NOT NULL,
    order_id character varying(93),
    result character varying(3069),
    "time" bigint
);


ALTER TABLE develop.transact_comp OWNER TO dbservice;

--
-- Name: transact_cs; Type: TABLE; Schema: develop; Owner: dbservice
--

CREATE TABLE develop.transact_cs (
    id bigint NOT NULL,
    order_id character varying(93),
    result character varying(3069),
    "time" bigint
);


ALTER TABLE develop.transact_cs OWNER TO dbservice;

--
-- Name: transact_fp; Type: TABLE; Schema: develop; Owner: dbservice
--

CREATE TABLE develop.transact_fp (
    id bigint NOT NULL,
    order_id character varying(93),
    result character varying(3069),
    "time" bigint
);


ALTER TABLE develop.transact_fp OWNER TO dbservice;

--
-- Name: transact_ipc; Type: TABLE; Schema: develop; Owner: dbservice
--

CREATE TABLE develop.transact_ipc (
    id bigint NOT NULL,
    order_id character varying(93),
    result character varying(12285),
    "time" bigint
);


ALTER TABLE develop.transact_ipc OWNER TO dbservice;

--
-- Name: unused_user_mapping; Type: TABLE; Schema: develop; Owner: dbservice
--

CREATE TABLE develop.unused_user_mapping (
    user_id integer NOT NULL,
    role_id integer NOT NULL
);


ALTER TABLE develop.unused_user_mapping OWNER TO dbservice;

--
-- Name: user; Type: TABLE; Schema: develop; Owner: dbservice
--

CREATE TABLE develop."user" (
    id bigint NOT NULL,
    login character varying(135) NOT NULL,
    first_name character varying(381),
    last_name character varying(381),
    password character varying(264) NOT NULL,
    email character varying(381),
    role_id bigint NOT NULL,
    group_id bigint NOT NULL,
    archived smallint NOT NULL,
    date_registered bigint NOT NULL,
    timezone character varying(150),
    email_params character varying(65535),
    token character varying(120)
);


ALTER TABLE develop."user" OWNER TO dbservice;

--
-- Name: awsdms_apply_exceptions; Type: TABLE; Schema: dms7; Owner: dbservice
--

CREATE TABLE dms7.awsdms_apply_exceptions (
    "TASK_NAME" character varying(384) NOT NULL,
    "TABLE_OWNER" character varying(384) NOT NULL,
    "TABLE_NAME" character varying(384) NOT NULL,
    "ERROR_TIME" timestamp without time zone NOT NULL,
    "STATEMENT" text NOT NULL,
    "ERROR" text NOT NULL
);


ALTER TABLE dms7.awsdms_apply_exceptions OWNER TO dbservice;

--
-- Name: awsdms_history; Type: TABLE; Schema: dms7; Owner: dbservice
--

CREATE TABLE dms7.awsdms_history (
    server_name character varying(384) NOT NULL,
    task_name character varying(384) NOT NULL,
    timeslot_type character varying(96) NOT NULL,
    timeslot timestamp without time zone NOT NULL,
    timeslot_duration bigint,
    timeslot_latency bigint,
    timeslot_records bigint,
    timeslot_volume bigint
);


ALTER TABLE dms7.awsdms_history OWNER TO dbservice;

--
-- Name: awsdms_status; Type: TABLE; Schema: dms7; Owner: dbservice
--

CREATE TABLE dms7.awsdms_status (
    server_name character varying(384) NOT NULL,
    task_name character varying(384) NOT NULL,
    task_status character varying(96),
    status_time timestamp without time zone,
    pending_changes bigint,
    disk_swap_size bigint,
    task_memory bigint,
    source_current_position character varying(384),
    source_current_timestamp timestamp without time zone,
    source_tail_position character varying(384),
    source_tail_timestamp timestamp without time zone,
    source_timestamp_applied timestamp without time zone
);


ALTER TABLE dms7.awsdms_status OWNER TO dbservice;

--
-- Name: awsdms_suspended_tables; Type: TABLE; Schema: dms7; Owner: dbservice
--

CREATE TABLE dms7.awsdms_suspended_tables (
    server_name character varying(384) NOT NULL,
    task_name character varying(384) NOT NULL,
    table_owner character varying(384) NOT NULL,
    table_name character varying(384) NOT NULL,
    suspend_reason character varying(96),
    suspend_timestamp timestamp without time zone
);


ALTER TABLE dms7.awsdms_suspended_tables OWNER TO dbservice;

--
-- Name: a; Type: TABLE; Schema: fnrenames; Owner: dbservice
--

CREATE TABLE fnrenames.a (
    "?column?" integer
);


ALTER TABLE fnrenames.a OWNER TO dbservice;

--
-- Name: card_id_seq; Type: SEQUENCE; Schema: fnrenames; Owner: dbservice
--

CREATE SEQUENCE fnrenames.card_id_seq
CREATE SEQUENCE fnrenames.card_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE fnrenames.card_id_seq OWNER TO dbservice;

--
-- Name: discount_history_id_seq; Type: SEQUENCE; Schema: fnrenames; Owner: dbservice
--

CREATE SEQUENCE fnrenames.discount_history_id_seq
CREATE SEQUENCE fnrenames.discount_history_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE fnrenames.discount_history_id_seq OWNER TO dbservice;

--
-- Name: history_id_seq; Type: SEQUENCE; Schema: fnrenames; Owner: dbservice
--

CREATE SEQUENCE fnrenames.history_id_seq
CREATE SEQUENCE fnrenames.history_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE fnrenames.history_id_seq OWNER TO dbservice;

--
-- Name: kiosk_id_seq; Type: SEQUENCE; Schema: fnrenames; Owner: dbservice
--

CREATE SEQUENCE fnrenames.kiosk_id_seq
CREATE SEQUENCE fnrenames.kiosk_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE fnrenames.kiosk_id_seq OWNER TO dbservice;

--
-- Name: kiosk_status_id_seq; Type: SEQUENCE; Schema: fnrenames; Owner: dbservice
--

CREATE SEQUENCE fnrenames.kiosk_status_id_seq
CREATE SEQUENCE fnrenames.kiosk_status_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE fnrenames.kiosk_status_id_seq OWNER TO dbservice;

--
-- Name: label_id_seq; Type: SEQUENCE; Schema: fnrenames; Owner: dbservice
--

CREATE SEQUENCE fnrenames.label_id_seq
CREATE SEQUENCE fnrenames.label_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE fnrenames.label_id_seq OWNER TO dbservice;

--
-- Name: nutrition_filter_id_seq; Type: SEQUENCE; Schema: fnrenames; Owner: dbservice
--

CREATE SEQUENCE fnrenames.nutrition_filter_id_seq
CREATE SEQUENCE fnrenames.nutrition_filter_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE fnrenames.nutrition_filter_id_seq OWNER TO dbservice;

--
-- Name: overstock_multiplier; Type: TABLE; Schema: fnrenames; Owner: dbservice
--

CREATE TABLE fnrenames.overstock_multiplier (
    setting character varying(100)
);


ALTER TABLE fnrenames.overstock_multiplier OWNER TO dbservice;

--
-- Name: overstock_multiplier2; Type: TABLE; Schema: fnrenames; Owner: dbservice
--

CREATE TABLE fnrenames.overstock_multiplier2 (
    value character varying(100)
);


ALTER TABLE fnrenames.overstock_multiplier2 OWNER TO dbservice;

--
-- Name: product_id_seq; Type: SEQUENCE; Schema: fnrenames; Owner: dbservice
--

CREATE SEQUENCE fnrenames.product_id_seq
CREATE SEQUENCE fnrenames.product_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE fnrenames.product_id_seq OWNER TO dbservice;

--
-- Name: tag_id_seq; Type: SEQUENCE; Schema: fnrenames; Owner: dbservice
--

CREATE SEQUENCE fnrenames.tag_id_seq
CREATE SEQUENCE fnrenames.tag_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE fnrenames.tag_id_seq OWNER TO dbservice;

--
-- Name: temp_sync_order_2018_12_13; Type: TABLE; Schema: fnrenames; Owner: dbservice
--

CREATE TABLE fnrenames.temp_sync_order_2018_12_13 (
    order_id character varying(135),
    first_name character varying(135),
    last_name character varying(135),
    kiosk_id bigint,
    kiosk_title character varying(138),
    email character varying(381),
    amount_paid numeric(6,2),
    payment_system character varying(135),
    transaction_id character varying(135),
    approval_code character varying(135),
    status_code character varying(135),
    status_message character varying(135),
    status character varying(135),
    batch_id character varying(45),
    created bigint,
    auth_amount character varying(21),
    data_token character varying(6141),
    time_opened bigint,
    time_closed bigint,
    card_hash character varying(264),
    state character varying(45),
    archived bigint,
    stamp bigint,
    last_update bigint,
    balance numeric(7,2),
    delta character varying(12),
    coupon_id bigint,
    coupon character varying(135),
    refund numeric(6,2),
    receipt bigint,
    campus_id bigint,
    amount_list_price numeric(6,2),
    notes text,
    time_door_opened bigint,
    time_door_closed bigint
);


ALTER TABLE fnrenames.temp_sync_order_2018_12_13 OWNER TO dbservice;

--
-- Name: tmp_payment_information; Type: TABLE; Schema: fnrenames; Owner: dbservice
--

CREATE TABLE fnrenames.tmp_payment_information (
    order_id character varying(20) NOT NULL,
    magne_print character varying(112),
    ksn character varying(20),
    magne_print_status character varying(8),
    track2 character varying(80)
);


ALTER TABLE fnrenames.tmp_payment_information OWNER TO dbservice;

--
-- Name: warehouse_inventory; Type: TABLE; Schema: inm; Owner: dbservice
--

CREATE TABLE inm.warehouse_inventory (
    inventory_date date NOT NULL,
    product_id integer NOT NULL,
    stickered_units integer DEFAULT 0 NOT NULL,
    unstickered_units integer DEFAULT 0 NOT NULL,
    stickered_cases integer DEFAULT 0 NOT NULL,
    unstickered_cases integer DEFAULT 0 NOT NULL,
    spoiled_units integer DEFAULT 0 NOT NULL,
    units_per_case integer NOT NULL,
    sort_order smallint NOT NULL
);


ALTER TABLE inm.warehouse_inventory OWNER TO dbservice;

--
-- Name: product; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.product (
    id bigint NOT NULL,
    title character varying(127) NOT NULL,
    description character varying(4095) DEFAULT 'No description yet'::character varying,
    tiny_description character varying(40),
    short_description character varying(100),
    medium_description character varying(400),
    long_description character varying(1200),
    price numeric(5,2) DEFAULT 0.00 NOT NULL,
    cost numeric(5,2) DEFAULT 0.00 NOT NULL,
    shelf_time integer DEFAULT 1 NOT NULL,
    campus_id bigint NOT NULL,
    image smallint DEFAULT 0 NOT NULL,
    image_time bigint,
    last_update bigint DEFAULT 0 NOT NULL,
    archived bigint DEFAULT 0,
    taxable smallint DEFAULT 0,
    allergens character varying(255),
    attribute_names character varying(511),
    categories character varying(255),
    category_names character varying(511),
    vendor character varying(135),
    source character varying(135),
    notes character varying(2000),
    total_cal bigint,
    num_servings real,
    ingredients character varying(2000),
    calories real,
    proteins real,
    sugar real,
    carbohydrates real,
    fat real,
    consumer_category character varying(2000),
    ws_case_size bigint,
    kiosk_ship_qty bigint,
    ws_case_cost numeric(5,2),
    pick_station bigint,
    fc_title character varying(255),
    pricing_tier character varying(255),
    width_space real,
    height_space real,
    depth_space real,
    slotted_width real,
    tag_volume bigint,
    delivery_option character varying(255) DEFAULT 'M'::character varying,
    tag_applied_by character varying(255) DEFAULT 'W'::character varying,
    internal_id text,
    CONSTRAINT product_internal_id_check CHECK ((length(internal_id) <= 400))
);


ALTER TABLE pantry.product OWNER TO dbservice;

--
-- Name: allocable_inventory; Type: VIEW; Schema: inm; Owner: dbservice
--

CREATE VIEW inm.allocable_inventory AS
 SELECT i.inventory_date,
    i.product_id,
    ((i.stickered_units + (i.stickered_cases * i.units_per_case)) - i.spoiled_units) AS qty,
    p.pick_station,
    p.title,
    p.fc_title,
    p.vendor
   FROM (inm.warehouse_inventory i
     JOIN pantry.product p ON ((i.product_id = p.id)))
  WHERE (((i.stickered_units + (i.stickered_cases * i.units_per_case)) - i.spoiled_units) > 0);


ALTER TABLE inm.allocable_inventory OWNER TO dbservice;

--
-- Name: bringg_delivery; Type: TABLE; Schema: inm; Owner: dbservice
--

CREATE TABLE inm.bringg_delivery (
    task_id integer NOT NULL,
    route_date_time timestamp(6) with time zone NOT NULL,
    driver_name character varying(200) NOT NULL,
    kid integer NOT NULL,
    stop_number integer,
    status character varying(200),
    ready_to_execute character varying(200)
);


ALTER TABLE inm.bringg_delivery OWNER TO dbservice;

--
-- Name: configuration; Type: TABLE; Schema: inm; Owner: dbservice
--

CREATE TABLE inm.configuration (
    setting character varying(100) NOT NULL,
    value character varying(100) NOT NULL
);


ALTER TABLE inm.configuration OWNER TO dbservice;

--
-- Name: kiosk_attribute; Type: TABLE; Schema: inm; Owner: dbservice
--

CREATE TABLE inm.kiosk_attribute (
    id integer NOT NULL,
    start_level numeric(4,2) NOT NULL,
    min_level numeric(4,2) NOT NULL,
    manual_multiplier numeric(4,2) NOT NULL
);


ALTER TABLE inm.kiosk_attribute OWNER TO dbservice;

--
-- Name: kiosk_control; Type: TABLE; Schema: inm; Owner: dbservice
--

CREATE TABLE inm.kiosk_control (
    kiosk_id integer NOT NULL,
    start_level numeric(4,2) NOT NULL,
    min_level numeric(4,2) NOT NULL,
    scale numeric(4,2) DEFAULT 1.0 NOT NULL,
    manual_multiplier numeric(4,2) DEFAULT 1.0 NOT NULL
);


ALTER TABLE inm.kiosk_control OWNER TO dbservice;

--
-- Name: kiosk_product_disabled; Type: TABLE; Schema: inm; Owner: dbservice
--

CREATE TABLE inm.kiosk_product_disabled (
    kiosk_id bigint NOT NULL,
    product_id integer NOT NULL
);


ALTER TABLE inm.kiosk_product_disabled OWNER TO dbservice;

--
-- Name: pick_allocation; Type: TABLE; Schema: inm; Owner: dbservice
--

CREATE TABLE inm.pick_allocation (
    pick_date date NOT NULL,
    route_date date NOT NULL,
    kiosk_id integer NOT NULL,
    sku_id integer NOT NULL,
    qty integer NOT NULL
);


ALTER TABLE inm.pick_allocation OWNER TO dbservice;

--
-- Name: sku_group_attribute; Type: TABLE; Schema: inm; Owner: dbservice
--

CREATE TABLE inm.sku_group_attribute (
    id integer NOT NULL,
    title character varying(512) NOT NULL,
    relative_size numeric(4,2) NOT NULL,
    minimum_kiosk_qty smallint NOT NULL,
    maximum_kiosk_qty smallint
);


ALTER TABLE inm.sku_group_attribute OWNER TO dbservice;

--
-- Name: kiosk; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.kiosk (
    id bigint NOT NULL,
    campus_id bigint NOT NULL,
    serial character varying(45) DEFAULT '000000000000000'::character varying NOT NULL,
    title character varying(46),
    address character varying(127),
    location_x numeric(9,6) DEFAULT 0.000000 NOT NULL,
    location_y numeric(9,6) DEFAULT 0.000000 NOT NULL,
    gcm_id character varying(255),
    app_vname character varying(63),
    app_vcode integer,
    archived bigint DEFAULT 0,
    creation_time bigint,
    deployment_time bigint,
    last_update bigint DEFAULT 0,
    client_name character varying(255),
    last_status bigint,
    last_inventory bigint DEFAULT 0 NOT NULL,
    kiosk_name character varying(200) NOT NULL,
    payment_start bigint,
    payment_stop bigint,
    features character varying(255) NOT NULL,
    sales_tax smallint DEFAULT 0 NOT NULL,
    default_fee_plan bigint DEFAULT 1 NOT NULL,
    timezone character varying(50),
    estd_num_users bigint DEFAULT 0,
    tags character varying(255),
    publicly_accessible bigint DEFAULT 0,
    cardkey_required bigint DEFAULT 0,
    delivery_insns character varying(65535),
    fridge_loc_info character varying(65535),
    contact_first_name character varying(65535),
    contact_last_name character varying(65535),
    contact_email character varying(65535),
    contact_phone character varying(65535),
    accounting_email character varying(65535),
    byte_discount character varying(255),
    subsidy_info character varying(50),
    subsidy_notes character varying(65535),
    max_subscription character varying(50),
    delivery_window_mon character varying(50),
    delivery_window_tue character varying(50),
    delivery_window_wed character varying(50),
    delivery_window_thu character varying(50),
    delivery_window_fri character varying(50),
    delivery_window_sat character varying(50),
    delivery_window_sun character varying(50),
    notes character varying(2000),
    components text,
    email_receipt_subject character varying(200),
    ops_team_notes character varying(65535),
    geo character varying(3),
    server_url character varying(127) DEFAULT 'https://kiosk-prod.bytefoods.com'::character varying,
    subscription_amount numeric(8,2) DEFAULT 0.00 NOT NULL,
    enable_reporting bigint,
    enable_monitoring bigint,
    employees_num bigint,
    kiosk_restrictions character varying(2000),
    CONSTRAINT check_features CHECK (((((features)::text ~~ '%nursing%'::text) AND ((features)::text !~~ '%no_vending%'::text)) OR (((features)::text ~~ '%no_vending%'::text) AND ((features)::text !~~ '%nursing%'::text)) OR (((features)::text !~~ '%no_vending%'::text) AND ((features)::text !~~ '%nursing%'::text))))
);


ALTER TABLE pantry.kiosk OWNER TO dbservice;

--
-- Name: label; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.label (
    id bigint NOT NULL,
    product_id bigint NOT NULL,
    epc character varying(24) NOT NULL,
    is_generic_sku smallint,
    kiosk_id bigint,
    order_id character varying(45),
    status character varying(4),
    price numeric(6,2),
    cost numeric(6,2),
    time_created bigint,
    time_added bigint,
    time_updated bigint,
    notes text
);


ALTER TABLE pantry.label OWNER TO dbservice;

--
-- Name: order; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry."order" (
    order_id character varying(45) NOT NULL,
    first_name character varying(45),
    last_name character varying(45),
    kiosk_id bigint NOT NULL,
    kiosk_title character varying(46),
    email character varying(127) NOT NULL,
    amount_paid numeric(6,2) DEFAULT 0.00,
    payment_system character varying(45) NOT NULL,
    transaction_id character varying(45) NOT NULL,
    approval_code character varying(45) NOT NULL,
    status_code character varying(45),
    status_message character varying(45),
    status character varying(45),
    batch_id character varying(15),
    created bigint,
    auth_amount character varying(7),
    data_token character varying(2047),
    time_opened bigint,
    time_closed bigint,
    card_hash character varying(88) NOT NULL,
    state character varying(15) NOT NULL,
    archived bigint DEFAULT 0,
    stamp bigint DEFAULT 0 NOT NULL,
    last_update bigint,
    balance numeric(7,2),
    delta character varying(4),
    coupon_id bigint,
    coupon character varying(45),
    refund numeric(6,2) DEFAULT 0.00 NOT NULL,
    receipt bigint DEFAULT 0 NOT NULL,
    campus_id bigint NOT NULL,
    amount_list_price numeric(6,2),
    time_door_opened bigint,
    time_door_closed bigint,
    notes text
);


ALTER TABLE pantry."order" OWNER TO dbservice;

--
-- Name: kiosk_projected_minimum; Type: VIEW; Schema: inm; Owner: dbservice
--

CREATE VIEW inm.kiosk_projected_minimum AS
 SELECT combined_stock.kiosk_id,
    combined_stock.kiosk_title,
    combined_stock.fc_title,
    sga.minimum_kiosk_qty AS min_qty,
    sum(combined_stock.qty) AS stock_qty,
    ((sga.minimum_kiosk_qty)::numeric - sum(combined_stock.qty)) AS min_need
   FROM (( SELECT l.kiosk_id,
            k.title AS kiosk_title,
            p.fc_title,
            count(l.epc) AS qty
           FROM ((pantry.label l
             JOIN pantry.product p ON ((l.product_id = p.id)))
             JOIN pantry.kiosk k ON ((l.kiosk_id = k.id)))
          WHERE (((l.status)::text ~~ 'ok'::text) AND (k.campus_id = 87) AND (k.enable_reporting = 1) AND (k.archived <> 1) AND (l.kiosk_id <> 737))
          GROUP BY l.kiosk_id, k.title, p.fc_title
        UNION ALL
         SELECT a.kiosk_id,
            k.title AS kiosk_title,
            p.fc_title,
            a.qty
           FROM (((inm.pick_allocation a
             LEFT JOIN pantry."order" o ON (((a.route_date = (to_timestamp((o.created)::double precision))::date) AND (a.kiosk_id = o.kiosk_id) AND ((o.payment_system)::text = 'Restocking'::text))))
             JOIN pantry.product p ON ((a.sku_id = p.id)))
             JOIN pantry.kiosk k ON ((a.kiosk_id = k.id)))
          WHERE ((a.route_date >= ('now'::text)::date) AND (a.pick_date > (('now'::text)::date - 1)) AND (o.kiosk_id IS NULL))) combined_stock
     JOIN inm.sku_group_attribute sga ON (((combined_stock.fc_title)::text = (sga.title)::text)))
  GROUP BY combined_stock.kiosk_id, combined_stock.kiosk_title, combined_stock.fc_title, sga.minimum_kiosk_qty;


ALTER TABLE inm.kiosk_projected_minimum OWNER TO dbservice;

--
-- Name: VIEW kiosk_projected_minimum; Type: COMMENT; Schema: inm; Owner: dbservice
--

COMMENT ON VIEW inm.kiosk_projected_minimum IS 'Anbalysis of minimum using current and expect inventory from pick';


--
-- Name: kiosk_projected_stock; Type: VIEW; Schema: inm; Owner: dbservice
--

CREATE VIEW inm.kiosk_projected_stock AS
 SELECT combined_stock.kiosk_id,
    combined_stock.kiosk_title,
    combined_stock.fc_title,
    sum(combined_stock.qty) AS count
   FROM ( SELECT l.kiosk_id,
            k.title AS kiosk_title,
            p.fc_title,
            count(l.epc) AS qty
           FROM ((pantry.label l
             JOIN pantry.product p ON ((l.product_id = p.id)))
             JOIN pantry.kiosk k ON ((l.kiosk_id = k.id)))
          WHERE (((l.status)::text ~~ 'ok'::text) AND (k.campus_id = 87) AND (k.enable_reporting = 1) AND (k.archived <> 1))
          GROUP BY l.kiosk_id, k.title, p.fc_title
        UNION ALL
         SELECT a.kiosk_id,
            k.title AS kiosk_title,
            p.fc_title,
            a.qty
           FROM (((inm.pick_allocation a
             LEFT JOIN pantry."order" o ON (((a.route_date = (to_timestamp((o.created)::double precision))::date) AND (a.kiosk_id = o.kiosk_id) AND ((o.payment_system)::text = 'Restocking'::text))))
             JOIN pantry.product p ON ((a.sku_id = p.id)))
             JOIN pantry.kiosk k ON ((a.kiosk_id = k.id)))
          WHERE ((a.route_date >= ('now'::text)::date) AND (a.pick_date = (('now'::text)::date - 1)) AND (o.kiosk_id IS NULL))
        UNION ALL
         SELECT pl.kiosk_id,
            pl.kiosk_title,
            p.fc_title,
            count(*) AS qty
           FROM (inm.get_spoilage_pull_list() pl(category, kiosk_id, kiosk_title, product_id, product_tile, epc)
             JOIN pantry.product p ON ((pl.product_id = p.id)))
          GROUP BY pl.kiosk_id, pl.kiosk_title, p.fc_title) combined_stock
  WHERE (combined_stock.fc_title IS NOT NULL)
  GROUP BY combined_stock.kiosk_id, combined_stock.kiosk_title, combined_stock.fc_title;


ALTER TABLE inm.kiosk_projected_stock OWNER TO dbservice;

--
-- Name: kiosk_projected_stock_sku_level; Type: VIEW; Schema: inm; Owner: dbservice
--

CREATE VIEW inm.kiosk_projected_stock_sku_level AS
 SELECT NULL::bigint AS kiosk_id,
    NULL::character varying(138) AS kiosk_title,
    NULL::character varying(255) AS fc_title,
    NULL::bigint AS id,
    NULL::character varying(127) AS title,
    NULL::numeric AS count;


ALTER TABLE inm.kiosk_projected_stock_sku_level OWNER TO dbservice;

--
-- Name: VIEW kiosk_projected_stock_sku_level; Type: COMMENT; Schema: inm; Owner: dbservice
--

COMMENT ON VIEW inm.kiosk_projected_stock_sku_level IS 'Projected skus in a kiosk which includes items on delivery';


--
-- Name: kiosk_restriction_by_product; Type: TABLE; Schema: inm; Owner: dbservice
--

CREATE TABLE inm.kiosk_restriction_by_product (
    kiosk_id bigint NOT NULL,
    product_id integer NOT NULL
);


ALTER TABLE inm.kiosk_restriction_by_product OWNER TO dbservice;

--
-- Name: kiosk_restriction_by_property; Type: TABLE; Schema: inm; Owner: dbservice
--

CREATE TABLE inm.kiosk_restriction_by_property (
    kiosk_id integer NOT NULL,
    property_id integer NOT NULL
);


ALTER TABLE inm.kiosk_restriction_by_property OWNER TO dbservice;

--
-- Name: kiosk_restriction_by_sku; Type: TABLE; Schema: inm; Owner: dbservice
--

CREATE TABLE inm.kiosk_restriction_by_sku (
    kiosk_id integer NOT NULL,
    sku_id integer NOT NULL
);


ALTER TABLE inm.kiosk_restriction_by_sku OWNER TO dbservice;

--
-- Name: product_property_def; Type: TABLE; Schema: inm; Owner: dbservice
--

CREATE TABLE inm.product_property_def (
    id integer NOT NULL,
    name text NOT NULL,
    value text
);


ALTER TABLE inm.product_property_def OWNER TO dbservice;

--
-- Name: kiosk_restriction_list; Type: VIEW; Schema: inm; Owner: dbservice
--

CREATE VIEW inm.kiosk_restriction_list AS
 SELECT kr.kiosk_id,
    string_agg(pp.value, ','::text) AS restrictions
   FROM (inm.kiosk_restriction_by_property kr
     JOIN inm.product_property_def pp ON ((pp.id = kr.property_id)))
  GROUP BY kr.kiosk_id;


ALTER TABLE inm.kiosk_restriction_list OWNER TO dbservice;

--
-- Name: kiosk_sku_group_manual_scale; Type: TABLE; Schema: inm; Owner: dbservice
--

CREATE TABLE inm.kiosk_sku_group_manual_scale (
    kiosk_id integer NOT NULL,
    sku_group_id integer NOT NULL,
    scale numeric(4,2) NOT NULL
);


ALTER TABLE inm.kiosk_sku_group_manual_scale OWNER TO dbservice;

--
-- Name: pick_demand; Type: TABLE; Schema: inm; Owner: dbservice
--

CREATE TABLE inm.pick_demand (
    pick_date date NOT NULL,
    route_date date NOT NULL,
    kiosk_id integer NOT NULL,
    sku_group_id integer NOT NULL,
    qty integer NOT NULL
);


ALTER TABLE inm.pick_demand OWNER TO dbservice;

--
-- Name: pick_inventory; Type: TABLE; Schema: inm; Owner: dbservice
--

CREATE TABLE inm.pick_inventory (
    pick_date date NOT NULL,
    route_date date NOT NULL,
    kiosk_id integer NOT NULL,
    sku_group_id integer NOT NULL,
    qty integer NOT NULL
);


ALTER TABLE inm.pick_inventory OWNER TO dbservice;

--
-- Name: pick_list; Type: TABLE; Schema: inm; Owner: dbservice
--

CREATE TABLE inm.pick_list (
    pick_date date NOT NULL,
    create_ts timestamp with time zone DEFAULT CURRENT_TIMESTAMP NOT NULL,
    timeout_seconds smallint DEFAULT 360,
    finish_ts timestamp with time zone,
    status text DEFAULT 'started'::text,
    log text,
    url text,
    CONSTRAINT pick_list_status_check CHECK ((status = ANY (ARRAY['started'::text, 'ready'::text, 'failed'::text])))
);


ALTER TABLE inm.pick_list OWNER TO dbservice;

--
-- Name: pick_preference_kiosk_sku; Type: TABLE; Schema: inm; Owner: dbservice
--

CREATE TABLE inm.pick_preference_kiosk_sku (
    kiosk_id integer NOT NULL,
    sku_id integer NOT NULL,
    preference smallint NOT NULL
);


ALTER TABLE inm.pick_preference_kiosk_sku OWNER TO dbservice;

--
-- Name: pick_priority_kiosk; Type: TABLE; Schema: inm; Owner: dbservice
--

CREATE TABLE inm.pick_priority_kiosk (
    kiosk_id integer NOT NULL,
    priority integer,
    comment text,
    end_date date
);


ALTER TABLE inm.pick_priority_kiosk OWNER TO dbservice;

--
-- Name: pick_priority_sku; Type: TABLE; Schema: inm; Owner: dbservice
--

CREATE TABLE inm.pick_priority_sku (
    sku_id integer NOT NULL,
    priority integer
);


ALTER TABLE inm.pick_priority_sku OWNER TO dbservice;

--
-- Name: pick_rejection; Type: TABLE; Schema: inm; Owner: dbservice
--

CREATE TABLE inm.pick_rejection (
    pick_date date NOT NULL,
    route_date date NOT NULL,
    kiosk_id integer NOT NULL,
    item_id integer NOT NULL,
    item_type character varying(32) NOT NULL,
    reason character varying(64) NOT NULL
);


ALTER TABLE inm.pick_rejection OWNER TO dbservice;

--
-- Name: pick_route; Type: TABLE; Schema: inm; Owner: dbservice
--

CREATE TABLE inm.pick_route (
    pick_date date NOT NULL,
    kiosk_id integer NOT NULL,
    route_number character varying(256),
    driver_name character varying(64) NOT NULL,
    route_time time(6) without time zone NOT NULL,
    route_date date NOT NULL,
    delivery_order smallint NOT NULL
);


ALTER TABLE inm.pick_route OWNER TO dbservice;

--
-- Name: pick_substitution; Type: TABLE; Schema: inm; Owner: dbservice
--

CREATE TABLE inm.pick_substitution (
    substituting_sku_group_id integer NOT NULL,
    substituted_sku_group_id integer NOT NULL,
    qty integer NOT NULL,
    pick_date date NOT NULL
);


ALTER TABLE inm.pick_substitution OWNER TO dbservice;

--
-- Name: product_property; Type: TABLE; Schema: inm; Owner: dbservice
--

CREATE TABLE inm.product_property (
    product_id bigint NOT NULL,
    property_id integer NOT NULL
);


ALTER TABLE inm.product_property OWNER TO dbservice;

--
-- Name: product_property_def_id_seq; Type: SEQUENCE; Schema: inm; Owner: dbservice
--

CREATE SEQUENCE inm.product_property_def_id_seq
CREATE SEQUENCE inm.product_property_def_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE inm.product_property_def_id_seq OWNER TO dbservice;

--
-- Name: product_property_def_id_seq; Type: SEQUENCE OWNED BY; Schema: inm; Owner: dbservice
--

ALTER SEQUENCE inm.product_property_def_id_seq OWNED BY inm.product_property_def.id;


--
-- Name: sku_def; Type: TABLE; Schema: inm; Owner: dbservice
--

CREATE TABLE inm.sku_def (
    id integer NOT NULL,
    title character varying(512) NOT NULL
);


ALTER TABLE inm.sku_def OWNER TO dbservice;

--
-- Name: sku_group; Type: TABLE; Schema: inm; Owner: dbservice
--

CREATE TABLE inm.sku_group (
    id integer NOT NULL,
    fc_title inm_beta.text_name NOT NULL,
    unit_size numeric(4,2) NOT NULL
);


ALTER TABLE inm.sku_group OWNER TO dbservice;

--
-- Name: sku_group_control; Type: TABLE; Schema: inm; Owner: dbservice
--

CREATE TABLE inm.sku_group_control (
    sku_group_id integer NOT NULL,
    default_level numeric(4,2) DEFAULT '-1'::integer NOT NULL,
    scale numeric(4,2) DEFAULT 1.0 NOT NULL,
    min_qty smallint,
    max_qty smallint
);


ALTER TABLE inm.sku_group_control OWNER TO dbservice;

--
-- Name: sku_property; Type: TABLE; Schema: inm; Owner: dbservice
--

CREATE TABLE inm.sku_property (
    sku_id integer NOT NULL,
    property_id integer NOT NULL
);


ALTER TABLE inm.sku_property OWNER TO dbservice;

--
-- Name: sku_property_def; Type: TABLE; Schema: inm; Owner: dbservice
--

CREATE TABLE inm.sku_property_def (
    id integer NOT NULL,
    attribute character varying(256),
    title character varying(512) NOT NULL
);


ALTER TABLE inm.sku_property_def OWNER TO dbservice;

--
-- Name: temp_pick_order; Type: TABLE; Schema: inm; Owner: dbservice
--

CREATE TABLE inm.temp_pick_order (
    kiosk_id integer,
    route_date_time timestamp with time zone,
    sku_group_id integer,
    fc_title text,
    week_qty integer,
    plan_qty integer
);


ALTER TABLE inm.temp_pick_order OWNER TO dbservice;

--
-- Name: temp_velocity; Type: TABLE; Schema: inm; Owner: dbservice
--

CREATE TABLE inm.temp_velocity (
    kiosk_id bigint,
    sku_group character varying(765),
    sample_size bigint,
    dt_avg numeric,
    dt_std numeric,
    w_departure_time numeric,
    preference numeric,
    pref_total numeric,
    ws_avg numeric,
    ws_std numeric,
    ws_live bigint,
    demand_weekly_wo_min numeric
);


ALTER TABLE inm.temp_velocity OWNER TO dbservice;

--
-- Name: all_raw_orders; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.all_raw_orders AS
 SELECT o.order_id,
    o.first_name,
    o.last_name,
    o.kiosk_id,
    o.kiosk_title,
    o.email,
    o.amount_paid,
    o.payment_system,
    o.transaction_id,
    o.approval_code,
    o.status_code,
    o.status_message,
    o.status,
    o.batch_id,
    o.created,
    o.auth_amount,
    o.data_token,
    o.time_opened,
    o.time_closed,
    o.card_hash,
    o.state,
    o.archived,
    o.stamp,
    o.last_update,
    o.balance,
    o.delta,
    o.coupon_id,
    o.coupon,
    o.refund,
    o.receipt,
    o.campus_id,
    o.amount_list_price,
    o.notes,
    o.time_door_opened,
    o.time_door_closed,
    k.client_name,
    k.estd_num_users,
    to_timestamp((o.created)::double precision) AS ts,
    concat(btrim((o.first_name)::text), ' ', btrim((o.last_name)::text)) AS full_name,
    (o.time_closed - o.time_opened) AS door_opened_secs
   FROM (pantry."order" o
     JOIN pantry.kiosk k ON ((o.kiosk_id = k.id)));


ALTER TABLE public.all_raw_orders OWNER TO dbservice;

--
-- Name: _all_orders; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public._all_orders AS
 SELECT all_raw_orders.order_id,
    all_raw_orders.first_name,
    all_raw_orders.last_name,
    all_raw_orders.kiosk_id,
    all_raw_orders.kiosk_title,
    all_raw_orders.email,
    all_raw_orders.amount_paid,
    all_raw_orders.payment_system,
    all_raw_orders.transaction_id,
    all_raw_orders.approval_code,
    all_raw_orders.status_code,
    all_raw_orders.status_message,
    all_raw_orders.status,
    all_raw_orders.batch_id,
    all_raw_orders.created,
    all_raw_orders.auth_amount,
    all_raw_orders.data_token,
    all_raw_orders.time_opened,
    all_raw_orders.time_closed,
    all_raw_orders.card_hash,
    all_raw_orders.state,
    all_raw_orders.archived,
    all_raw_orders.stamp,
    all_raw_orders.last_update,
    all_raw_orders.balance,
    all_raw_orders.delta,
    all_raw_orders.coupon_id,
    all_raw_orders.coupon,
    all_raw_orders.refund,
    all_raw_orders.receipt,
    all_raw_orders.campus_id,
    all_raw_orders.amount_list_price,
    all_raw_orders.notes,
    all_raw_orders.time_door_opened,
    all_raw_orders.time_door_closed,
    all_raw_orders.client_name,
    all_raw_orders.estd_num_users,
    all_raw_orders.ts,
    all_raw_orders.full_name,
    all_raw_orders.door_opened_secs,
    date_trunc('month'::text, all_raw_orders.ts) AS month,
    date_trunc('week'::text, all_raw_orders.ts) AS week,
    date_trunc('day'::text, all_raw_orders.ts) AS date,
    date_part('dow'::text, all_raw_orders.ts) AS dayofweek,
    date_trunc('hour'::text, all_raw_orders.ts) AS hour
   FROM public.all_raw_orders;


ALTER TABLE public._all_orders OWNER TO dbservice;

--
-- Name: all_orders; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.all_orders AS
 SELECT _all_orders.order_id,
    _all_orders.first_name,
    _all_orders.last_name,
    _all_orders.kiosk_id,
    _all_orders.kiosk_title,
    _all_orders.email,
    _all_orders.amount_paid,
    _all_orders.payment_system,
    _all_orders.transaction_id,
    _all_orders.approval_code,
    _all_orders.status_code,
    _all_orders.status_message,
    _all_orders.status,
    _all_orders.batch_id,
    _all_orders.created,
    _all_orders.auth_amount,
    _all_orders.data_token,
    _all_orders.time_opened,
    _all_orders.time_closed,
    _all_orders.card_hash,
    _all_orders.state,
    _all_orders.archived,
    _all_orders.stamp,
    _all_orders.last_update,
    _all_orders.balance,
    _all_orders.delta,
    _all_orders.coupon_id,
    _all_orders.coupon,
    _all_orders.refund,
    _all_orders.receipt,
    _all_orders.campus_id,
    _all_orders.amount_list_price,
    _all_orders.notes,
    _all_orders.time_door_opened,
    _all_orders.time_door_closed,
    _all_orders.client_name,
    _all_orders.estd_num_users,
    _all_orders.ts,
    _all_orders.full_name,
    _all_orders.door_opened_secs,
    _all_orders.month,
    _all_orders.week,
    _all_orders.date,
    _all_orders.dayofweek,
    _all_orders.hour,
    public.dowhour(_all_orders.hour) AS dowhour
   FROM public._all_orders;


ALTER TABLE public.all_orders OWNER TO dbservice;

--
-- Name: byte_products_fast; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_products_fast AS
 SELECT product.id,
    product.title,
    product.description,
    product.tiny_description,
    product.short_description,
    product.medium_description,
    product.long_description,
    product.price,
    product.cost,
    product.shelf_time,
    product.campus_id,
    product.image,
    product.image_time,
    product.last_update,
    product.archived,
    product.taxable,
    product.allergens,
    product.attribute_names,
    product.categories,
    product.category_names,
    product.vendor,
    product.source,
    product.notes,
    product.total_cal,
    product.num_servings,
    product.ingredients,
    product.calories,
    product.proteins,
    product.sugar,
    product.carbohydrates,
    product.fat,
    product.consumer_category,
    product.ws_case_size,
    product.kiosk_ship_qty,
    product.ws_case_cost,
    product.pick_station,
    product.fc_title,
    product.pricing_tier,
    product.width_space,
    product.height_space,
    product.depth_space,
    product.slotted_width,
    product.tag_volume,
    product.delivery_option,
    product.shelf_time AS shelf_life_days
   FROM pantry.product
  WHERE (product.campus_id = 87);


ALTER TABLE public.byte_products_fast OWNER TO dbservice;

--
-- Name: byte_products; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_products WITH (security_barrier='false') AS
 SELECT byte_products_fast.id,
    byte_products_fast.title,
    byte_products_fast.vendor,
    byte_products_fast.price,
    byte_products_fast.cost,
    byte_products_fast.shelf_time AS shelf_life_days,
    byte_products_fast.archived,
    byte_products_fast.attribute_names AS attributes,
    byte_products_fast.category_names AS categories,
    byte_products_fast.consumer_category,
    byte_products_fast.source,
    byte_products_fast.ws_case_size,
    byte_products_fast.kiosk_ship_qty,
    byte_products_fast.ws_case_cost,
    byte_products_fast.pick_station,
    byte_products_fast.allergens AS pantry_allergens,
    byte_products_fast.categories AS pantry_categories,
    byte_products_fast.fc_title
   FROM public.byte_products_fast;


ALTER TABLE public.byte_products OWNER TO dbservice;

--
-- Name: byte_label_product; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_label_product WITH (security_barrier='false') AS
 SELECT l.epc,
    l.order_id AS label_order_id,
    l.status AS label_status,
    l.price AS label_price,
    l.time_created,
    l.time_added,
    l.time_updated,
    to_timestamp((l.time_created)::double precision) AS ts_created,
    to_timestamp((l.time_added)::double precision) AS ts_added,
    to_timestamp((l.time_updated)::double precision) AS ts_updated,
    l.kiosk_id AS label_kiosk_id,
    p.id AS product_id,
    p.title AS product_title,
    p.archived AS product_archived,
    p.vendor AS product_vendor,
    p.price AS product_price,
    p.cost AS product_cost,
    p.shelf_life_days AS product_shelf_life_days,
    p.attributes AS product_attributes,
    p.categories AS product_categories,
    p.consumer_category,
    p.source AS product_source,
    p.fc_title
   FROM (pantry.label l
     JOIN public.byte_products p ON ((l.product_id = p.id)));


ALTER TABLE public.byte_label_product OWNER TO dbservice;

--
-- Name: byte_orders; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_orders AS
 SELECT all_orders.order_id,
    all_orders.first_name,
    all_orders.last_name,
    all_orders.kiosk_id,
    all_orders.kiosk_title,
    all_orders.email,
    all_orders.amount_paid,
    all_orders.payment_system,
    all_orders.transaction_id,
    all_orders.approval_code,
    all_orders.status_code,
    all_orders.status_message,
    all_orders.status,
    all_orders.batch_id,
    all_orders.created,
    all_orders.auth_amount,
    all_orders.data_token,
    all_orders.time_opened,
    all_orders.time_closed,
    all_orders.card_hash,
    all_orders.state,
    all_orders.archived,
    all_orders.stamp,
    all_orders.last_update,
    all_orders.balance,
    all_orders.delta,
    all_orders.coupon_id,
    all_orders.coupon,
    all_orders.refund,
    all_orders.receipt,
    all_orders.campus_id,
    all_orders.amount_list_price,
    all_orders.notes,
    all_orders.time_door_opened,
    all_orders.time_door_closed,
    all_orders.client_name,
    all_orders.estd_num_users,
    all_orders.ts,
    all_orders.full_name,
    all_orders.door_opened_secs,
    all_orders.month,
    all_orders.week,
    all_orders.date,
    all_orders.dayofweek,
    all_orders.hour,
    all_orders.dowhour
   FROM (public.all_orders all_orders
     JOIN pantry.kiosk kiosk ON ((all_orders.kiosk_id = kiosk.id)))
  WHERE ((all_orders.campus_id = 87) AND (kiosk.enable_reporting = 1));


ALTER TABLE public.byte_orders OWNER TO dbservice;

--
-- Name: byte_tickets; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_tickets AS
 SELECT byte_orders.order_id,
    byte_orders.first_name,
    byte_orders.last_name,
    byte_orders.kiosk_id,
    byte_orders.kiosk_title,
    byte_orders.email,
    byte_orders.amount_paid,
    byte_orders.payment_system,
    byte_orders.transaction_id,
    byte_orders.approval_code,
    byte_orders.status_code,
    byte_orders.status_message,
    byte_orders.status,
    byte_orders.batch_id,
    byte_orders.created,
    byte_orders.auth_amount,
    byte_orders.data_token,
    byte_orders.time_opened,
    byte_orders.time_closed,
    byte_orders.card_hash,
    byte_orders.state,
    byte_orders.archived,
    byte_orders.stamp,
    byte_orders.last_update,
    byte_orders.balance,
    byte_orders.delta,
    byte_orders.coupon_id,
    byte_orders.coupon,
    byte_orders.refund,
    byte_orders.receipt,
    byte_orders.campus_id,
    byte_orders.amount_list_price,
    byte_orders.notes,
    byte_orders.time_door_opened,
    byte_orders.time_door_closed,
    byte_orders.client_name,
    byte_orders.estd_num_users,
    byte_orders.ts,
    byte_orders.full_name,
    byte_orders.door_opened_secs,
    byte_orders.month,
    byte_orders.week,
    byte_orders.date,
    byte_orders.dayofweek,
    byte_orders.hour,
    byte_orders.dowhour,
    btrim(concat("left"(btrim((byte_orders.first_name)::text), 1), '.', btrim((byte_orders.last_name)::text))) AS uniq_user
   FROM public.byte_orders
  WHERE ((byte_orders.state)::text <> 'NonTrans'::text);


ALTER TABLE public.byte_tickets OWNER TO dbservice;

--
-- Name: byte_tickets_12weeks; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_tickets_12weeks AS
 SELECT byte_tickets.order_id,
    byte_tickets.first_name,
    byte_tickets.last_name,
    byte_tickets.kiosk_id,
    byte_tickets.kiosk_title,
    byte_tickets.email,
    byte_tickets.amount_paid,
    byte_tickets.payment_system,
    byte_tickets.transaction_id,
    byte_tickets.approval_code,
    byte_tickets.status_code,
    byte_tickets.status_message,
    byte_tickets.status,
    byte_tickets.batch_id,
    byte_tickets.created,
    byte_tickets.auth_amount,
    byte_tickets.data_token,
    byte_tickets.time_opened,
    byte_tickets.time_closed,
    byte_tickets.card_hash,
    byte_tickets.state,
    byte_tickets.archived,
    byte_tickets.stamp,
    byte_tickets.last_update,
    byte_tickets.balance,
    byte_tickets.delta,
    byte_tickets.coupon_id,
    byte_tickets.coupon,
    byte_tickets.refund,
    byte_tickets.receipt,
    byte_tickets.campus_id,
    byte_tickets.amount_list_price,
    byte_tickets.notes,
    byte_tickets.time_door_opened,
    byte_tickets.time_door_closed,
    byte_tickets.client_name,
    byte_tickets.estd_num_users,
    byte_tickets.ts,
    byte_tickets.full_name,
    byte_tickets.door_opened_secs,
    byte_tickets.month,
    byte_tickets.week,
    byte_tickets.date,
    byte_tickets.dayofweek,
    byte_tickets.hour,
    byte_tickets.dowhour,
    byte_tickets.uniq_user
   FROM public.byte_tickets
  WHERE (byte_tickets.ts > (now() - '84 days'::interval day));


ALTER TABLE public.byte_tickets_12weeks OWNER TO dbservice;

--
-- Name: byte_epcssold_12weeks; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_epcssold_12weeks AS
 SELECT o.order_id,
    o.first_name,
    o.last_name,
    o.kiosk_id,
    o.kiosk_title,
    o.email,
    o.amount_paid,
    o.payment_system,
    o.transaction_id,
    o.approval_code,
    o.status_code,
    o.status_message,
    o.status,
    o.batch_id,
    o.created,
    o.auth_amount,
    o.data_token,
    o.time_opened,
    o.time_closed,
    o.card_hash,
    o.state,
    o.archived,
    o.stamp,
    o.last_update,
    o.balance,
    o.delta,
    o.coupon_id,
    o.coupon,
    o.refund,
    o.receipt,
    o.campus_id,
    o.amount_list_price,
    o.notes,
    o.time_door_opened,
    o.time_door_closed,
    o.client_name,
    o.estd_num_users,
    o.ts,
    o.full_name,
    o.door_opened_secs,
    o.month,
    o.week,
    o.date,
    o.dayofweek,
    o.hour,
    o.dowhour,
    o.uniq_user,
    lp.epc,
    lp.label_order_id,
    lp.label_status,
    lp.label_price,
    lp.time_created,
    lp.time_added,
    lp.time_updated,
    lp.ts_created,
    lp.ts_added,
    lp.ts_updated,
    lp.label_kiosk_id,
    lp.product_id,
    lp.product_title,
    lp.product_archived,
    lp.product_vendor,
    lp.product_price,
    lp.product_cost,
    lp.product_shelf_life_days,
    lp.product_attributes,
    lp.product_categories,
    lp.consumer_category,
    lp.product_source,
    lp.fc_title
   FROM (public.byte_tickets_12weeks o
     JOIN public.byte_label_product lp ON (((lp.label_order_id)::text = (o.order_id)::text)))
  WHERE ((lp.label_status)::text = 'sold'::text);


ALTER TABLE public.byte_epcssold_12weeks OWNER TO dbservice;

--
-- Name: v_kiosk_sale_hourly; Type: VIEW; Schema: inm; Owner: dbservice
--

CREATE VIEW inm.v_kiosk_sale_hourly AS
 SELECT units_sold.kiosk_id,
    units_sold.dow,
    units_sold.hod,
    units_sold.units_sold,
    round((units_sold.units_sold / GREATEST(1.00, sum(units_sold.units_sold) OVER (PARTITION BY units_sold.kiosk_id))), 4) AS units_sold_normalized
   FROM ( SELECT k.kiosk_id,
            dow.dow,
            hod.hod,
            round(COALESCE(((s.units_sold)::numeric / 12.0), 0.00), 2) AS units_sold
           FROM (((( SELECT k_1.id AS kiosk_id
                   FROM pantry.kiosk k_1
                  WHERE ((k_1.campus_id = 87) AND (k_1.archived = 0) AND (k_1.enable_reporting = 1))) k
             CROSS JOIN ( SELECT generate_series.generate_series AS dow
                   FROM generate_series(0, 6) generate_series(generate_series)) dow)
             CROSS JOIN ( SELECT generate_series.generate_series AS hod
                   FROM generate_series(0, 23) generate_series(generate_series)) hod)
             LEFT JOIN ( SELECT byte_epcssold_12weeks.kiosk_id,
                    date_part('dow'::text, timezone('US/Pacific'::text, byte_epcssold_12weeks.ts)) AS dow,
                    date_part('hour'::text, timezone('US/Pacific'::text, byte_epcssold_12weeks.ts)) AS hod,
                    count(*) AS units_sold
                   FROM public.byte_epcssold_12weeks
                  GROUP BY byte_epcssold_12weeks.kiosk_id, (date_part('dow'::text, timezone('US/Pacific'::text, byte_epcssold_12weeks.ts))), (date_part('hour'::text, timezone('US/Pacific'::text, byte_epcssold_12weeks.ts)))
                  ORDER BY byte_epcssold_12weeks.kiosk_id, (date_part('dow'::text, timezone('US/Pacific'::text, byte_epcssold_12weeks.ts))), (date_part('hour'::text, timezone('US/Pacific'::text, byte_epcssold_12weeks.ts)))) s ON (((k.kiosk_id = s.kiosk_id) AND ((dow.dow)::double precision = s.dow) AND ((hod.hod)::double precision = s.hod))))
          ORDER BY k.kiosk_id, dow.dow, hod.hod) units_sold;


ALTER TABLE inm.v_kiosk_sale_hourly OWNER TO dbservice;

--
-- Name: route_stop; Type: TABLE; Schema: mixalot; Owner: dbservice
--

CREATE TABLE mixalot.route_stop (
    route_date_time timestamp(6) with time zone NOT NULL,
    driver_name character varying(200) NOT NULL,
    location_name character varying(200) NOT NULL,
    schedule_at timestamp(6) with time zone NOT NULL,
    longitude numeric(28,6),
    address character varying(200),
    latitude numeric(28,6),
    stop_number integer,
    order_number character varying(200),
    location_number integer
);


ALTER TABLE mixalot.route_stop OWNER TO dbservice;

--
-- Name: v_kiosk_demand_plan_ratio; Type: VIEW; Schema: inm; Owner: dbservice
--

CREATE VIEW inm.v_kiosk_demand_plan_ratio AS
 SELECT ksh.kiosk_id,
        CASE
            WHEN (rdt.d0_delivery = 1) THEN (ksh.d0_demand +
            CASE
                WHEN (rdt.d1_delivery = 0) THEN (ksh.d1_demand +
                CASE
                    WHEN (rdt.d2_delivery = 0) THEN (ksh.d2_demand +
                    CASE
                        WHEN (rdt.d3_delivery = 0) THEN (ksh.d3_demand +
                        CASE
                            WHEN (rdt.d4_delivery = 0) THEN ksh.d4_demand
                            ELSE (0)::numeric
                        END)
                        ELSE (0)::numeric
                    END)
                    ELSE (0)::numeric
                END)
                ELSE (0)::numeric
            END)
            ELSE (0)::numeric
        END AS d0_plan_demand_ratio,
        CASE
            WHEN (rdt.d1_delivery = 1) THEN (ksh.d1_demand +
            CASE
                WHEN (rdt.d2_delivery = 0) THEN (ksh.d2_demand +
                CASE
                    WHEN (rdt.d3_delivery = 0) THEN (ksh.d3_demand +
                    CASE
                        WHEN (rdt.d4_delivery = 0) THEN (ksh.d4_demand +
                        CASE
                            WHEN (rdt.d0_delivery = 0) THEN ksh.d0_demand
                            ELSE (0)::numeric
                        END)
                        ELSE (0)::numeric
                    END)
                    ELSE (0)::numeric
                END)
                ELSE (0)::numeric
            END)
            ELSE (0)::numeric
        END AS d1_plan_demand_ratio,
        CASE
            WHEN (rdt.d2_delivery = 1) THEN (ksh.d2_demand +
            CASE
                WHEN (rdt.d3_delivery = 0) THEN (ksh.d3_demand +
                CASE
                    WHEN (rdt.d4_delivery = 0) THEN (ksh.d4_demand +
                    CASE
                        WHEN (rdt.d1_delivery = 0) THEN (ksh.d1_demand +
                        CASE
                            WHEN (rdt.d2_delivery = 0) THEN ksh.d2_demand
                            ELSE (0)::numeric
                        END)
                        ELSE (0)::numeric
                    END)
                    ELSE (0)::numeric
                END)
                ELSE (0)::numeric
            END)
            ELSE (0)::numeric
        END AS d2_plan_demand_ratio,
        CASE
            WHEN (rdt.d3_delivery = 1) THEN (ksh.d3_demand +
            CASE
                WHEN (rdt.d4_delivery = 0) THEN (ksh.d4_demand +
                CASE
                    WHEN (rdt.d0_delivery = 0) THEN (ksh.d0_demand +
                    CASE
                        WHEN (rdt.d1_delivery = 0) THEN (ksh.d1_demand +
                        CASE
                            WHEN (rdt.d2_delivery = 0) THEN ksh.d2_demand
                            ELSE (0)::numeric
                        END)
                        ELSE (0)::numeric
                    END)
                    ELSE (0)::numeric
                END)
                ELSE (0)::numeric
            END)
            ELSE (0)::numeric
        END AS d3_plan_demand_ratio,
        CASE
            WHEN (rdt.d4_delivery = 1) THEN (ksh.d4_demand +
            CASE
                WHEN (rdt.d0_delivery = 0) THEN (ksh.d0_demand +
                CASE
                    WHEN (rdt.d1_delivery = 0) THEN (ksh.d1_demand +
                    CASE
                        WHEN (rdt.d2_delivery = 0) THEN (ksh.d2_demand +
                        CASE
                            WHEN (rdt.d3_delivery = 0) THEN ksh.d3_demand
                            ELSE (0)::numeric
                        END)
                        ELSE (0)::numeric
                    END)
                    ELSE (0)::numeric
                END)
                ELSE (0)::numeric
            END)
            ELSE (0)::numeric
        END AS d4_plan_demand_ratio
   FROM (( SELECT ksh_1.kiosk_id,
            sum(ksh_1.units_sold_normalized) FILTER (WHERE ((ksh_1.how >= 34) AND (ksh_1.how < 58))) AS d0_demand,
            sum(ksh_1.units_sold_normalized) FILTER (WHERE ((ksh_1.how >= 58) AND (ksh_1.how < 82))) AS d1_demand,
            sum(ksh_1.units_sold_normalized) FILTER (WHERE ((ksh_1.how >= 82) AND (ksh_1.how < 106))) AS d2_demand,
            sum(ksh_1.units_sold_normalized) FILTER (WHERE ((ksh_1.how >= 106) AND (ksh_1.how < 130))) AS d3_demand,
            sum(ksh_1.units_sold_normalized) FILTER (WHERE ((ksh_1.how >= 130) OR (ksh_1.how < 34))) AS d4_demand
           FROM ( SELECT ksh_2.kiosk_id,
                    ksh_2.dow,
                    ksh_2.hod,
                    ksh_2.units_sold,
                    ksh_2.units_sold_normalized,
                    ((24 * ksh_2.dow) + ksh_2.hod) AS how
                   FROM inm.v_kiosk_sale_hourly ksh_2) ksh_1
          GROUP BY ksh_1.kiosk_id) ksh
     LEFT JOIN ( SELECT rdt_1.kiosk_id,
            count(rdt_1.d) FILTER (WHERE (rdt_1.d = (0)::double precision)) AS d0_delivery,
            count(rdt_1.d) FILTER (WHERE (rdt_1.d = (1)::double precision)) AS d1_delivery,
            count(rdt_1.d) FILTER (WHERE (rdt_1.d = (2)::double precision)) AS d2_delivery,
            count(rdt_1.d) FILTER (WHERE (rdt_1.d = (3)::double precision)) AS d3_delivery,
            count(rdt_1.d) FILTER (WHERE (rdt_1.d = (4)::double precision)) AS d4_delivery
           FROM ( SELECT route_stop.location_number AS kiosk_id,
                    date_part('dow'::text, (timezone('US/Pacific'::text, route_stop.route_date_time) - ('11:00:00'::time without time zone)::interval)) AS d
                   FROM mixalot.route_stop
                  WHERE (date_trunc('week'::text, route_stop.route_date_time) = date_trunc('week'::text, now()))
                  ORDER BY route_stop.route_date_time, route_stop.schedule_at) rdt_1
          GROUP BY rdt_1.kiosk_id) rdt ON ((ksh.kiosk_id = rdt.kiosk_id)))
  ORDER BY ksh.kiosk_id;


ALTER TABLE inm.v_kiosk_demand_plan_ratio OWNER TO dbservice;

--
-- Name: v_kiosk_sku_enabled; Type: VIEW; Schema: inm; Owner: dbservice
--

CREATE VIEW inm.v_kiosk_sku_enabled AS
 SELECT k.kiosk_id,
    p.sku_group,
    p.sku,
    public.if((kpd.product_id IS NOT NULL), 0, 1) AS enabled
   FROM ((( SELECT k_1.id AS kiosk_id
           FROM pantry.kiosk k_1
          WHERE ((k_1.campus_id = 87) AND (k_1.archived = 0) AND (k_1.enable_reporting = 1))) k
     CROSS JOIN ( SELECT p_1.id AS sku,
            p_1.fc_title AS sku_group
           FROM pantry.product p_1
          WHERE ((p_1.campus_id = 87) AND (p_1.archived = 0) AND (p_1.fc_title IS NOT NULL) AND ((p_1.fc_title)::text <> 'N/A'::text))
          ORDER BY p_1.fc_title) p)
     LEFT JOIN inm.kiosk_product_disabled kpd ON (((k.kiosk_id = kpd.kiosk_id) AND (p.sku = kpd.product_id))))
  ORDER BY k.kiosk_id, p.sku_group, p.sku;


ALTER TABLE inm.v_kiosk_sku_enabled OWNER TO dbservice;

--
-- Name: v_kiosk_sku_group_stock_sale_spoil_history; Type: VIEW; Schema: inm; Owner: dbservice
--

CREATE VIEW inm.v_kiosk_sku_group_stock_sale_spoil_history AS
 SELECT t3.kiosk_id,
    t3.sku_group,
    round(avg(t3.stock_count), 2) AS stock_avg,
    round(stddev(t3.stock_count), 2) AS stock_std,
    round(avg(t3.sale_count), 2) AS sale_avg,
    round(stddev(t3.sale_count), 2) AS sale_std,
    round(avg(t3.spoil_count), 2) AS spoil_avg,
    round(stddev(t3.spoil_count), 2) AS spoil_std,
    round(avg(t3.week_stock), 2) AS week_stock_avg,
    round(stddev(t3.week_stock), 2) AS week_stock_std,
    round(avg(t3.week_sale), 2) AS week_sale_avg,
    round(stddev(t3.week_sale), 2) AS week_sale_std,
    round(avg(t3.week_spoil), 2) AS week_spoil_avg,
    round(stddev(t3.week_spoil), 2) AS week_spoil_std
   FROM ( SELECT t2.kiosk_id,
            t2.week,
            t2.sku_group,
            t2.stock_count,
            t2.sale_count,
            t2.spoil_count,
            sum(t2.stock_count) OVER (PARTITION BY t2.kiosk_id, t2.week) AS week_stock,
            sum(t2.sale_count) OVER (PARTITION BY t2.kiosk_id, t2.week) AS week_sale,
            sum(t2.spoil_count) OVER (PARTITION BY t2.kiosk_id, t2.week) AS week_spoil
           FROM ( SELECT t1.kiosk_id,
                    t1.week,
                    t1.sku_group,
                    sum(t1.stock_count) AS stock_count,
                    sum(t1.sale_count) AS sale_count,
                    sum(t1.spoil_count) AS spoil_count
                   FROM ( SELECT kk.kiosk_id,
                            kk.week,
                            pp.sku_group,
                            sss.product_id,
                            COALESCE(sss.stock_count, (0)::bigint) AS stock_count,
                            COALESCE(sss.sale_count, (0)::bigint) AS sale_count,
                            COALESCE(sss.spoil_count, (0)::bigint) AS spoil_count
                           FROM ((( SELECT k.id AS kiosk_id,
                                    (date_trunc('week'::text, generate_series((now() - '3 mons'::interval month), now(), '7 days'::interval)))::date AS week
                                   FROM pantry.kiosk k
                                  WHERE ((k.campus_id = 87) AND (k.archived = 0) AND (k.enable_reporting = 1) AND (k.enable_monitoring = 1))) kk
                             CROSS JOIN ( SELECT DISTINCT p.fc_title AS sku_group
                                   FROM pantry.product p
                                  WHERE ((p.campus_id = 87) AND (p.archived = 0) AND (p.fc_title IS NOT NULL) AND ((p.fc_title)::text <> 'N/A'::text))) pp)
                             LEFT JOIN ( SELECT COALESCE(stock.kiosk_id, sale.kiosk_id, spoil.kiosk_id) AS kiosk_id,
                                    COALESCE(stock.week, sale.week, spoil.week) AS week,
                                    COALESCE(stock.sku_group, sale.sku_group, spoil.sku_group) AS sku_group,
                                    COALESCE(stock.product_id, sale.product_id, spoil.product_id) AS product_id,
                                    COALESCE(stock.stock_count, (0)::bigint) AS stock_count,
                                    COALESCE(sale.sale_count, (0)::bigint) AS sale_count,
                                    COALESCE(spoil.spoil_count, (0)::bigint) AS spoil_count
                                   FROM ((( SELECT l.kiosk_id,
    p.fc_title AS sku_group,
    l.product_id,
    (date_trunc('week'::text, to_timestamp((l.time_updated)::double precision)))::date AS week,
    count(*) AS stock_count
   FROM (pantry.label l
     LEFT JOIN pantry.product p ON ((l.product_id = p.id)))
  WHERE ((to_timestamp((l.time_added)::double precision) > (now() - '3 mons'::interval month)) AND (p.campus_id = 87) AND (p.archived = 0) AND (p.fc_title IS NOT NULL) AND ((p.fc_title)::text <> 'N/A'::text))
  GROUP BY l.kiosk_id, p.fc_title, l.product_id, ((date_trunc('week'::text, to_timestamp((l.time_updated)::double precision)))::date)) stock
                                     FULL JOIN ( SELECT l.kiosk_id,
    p.fc_title AS sku_group,
    l.product_id,
    (date_trunc('week'::text, to_timestamp((l.time_updated)::double precision)))::date AS week,
    count(*) AS sale_count
   FROM (pantry.label l
     LEFT JOIN pantry.product p ON ((l.product_id = p.id)))
  WHERE ((to_timestamp((l.time_updated)::double precision) > (now() - '3 mons'::interval month)) AND ((l.status)::text = 'sold'::text) AND (l.order_id IS NOT NULL) AND (p.campus_id = 87) AND (p.archived = 0) AND (p.fc_title IS NOT NULL) AND ((p.fc_title)::text <> 'N/A'::text))
  GROUP BY l.kiosk_id, p.fc_title, l.product_id, ((date_trunc('week'::text, to_timestamp((l.time_updated)::double precision)))::date)) sale ON (((stock.kiosk_id = sale.kiosk_id) AND (stock.week = sale.week) AND ((stock.sku_group)::text = (sale.sku_group)::text) AND (stock.product_id = sale.product_id))))
                                     FULL JOIN ( SELECT l.kiosk_id,
    p.fc_title AS sku_group,
    l.product_id,
    (date_trunc('week'::text, to_timestamp((l.time_updated)::double precision)))::date AS week,
    count(*) AS spoil_count
   FROM (pantry.label l
     LEFT JOIN pantry.product p ON ((l.product_id = p.id)))
  WHERE ((to_timestamp((l.time_updated)::double precision) > (now() - '3 mons'::interval month)) AND ((l.status)::text = 'out'::text) AND ((l.order_id)::text ~~ 'RE%'::text) AND (p.campus_id = 87) AND (p.archived = 0) AND (p.fc_title IS NOT NULL) AND ((p.fc_title)::text <> 'N/A'::text))
  GROUP BY l.kiosk_id, p.fc_title, l.product_id, ((date_trunc('week'::text, to_timestamp((l.time_updated)::double precision)))::date)) spoil ON (((stock.kiosk_id = spoil.kiosk_id) AND (stock.week = spoil.week) AND ((stock.sku_group)::text = (spoil.sku_group)::text) AND (stock.product_id = spoil.product_id))))) sss ON (((kk.kiosk_id = sss.kiosk_id) AND (kk.week = sss.week) AND ((pp.sku_group)::text = (sss.sku_group)::text))))
                          ORDER BY kk.kiosk_id, kk.week, pp.sku_group) t1
                  GROUP BY t1.kiosk_id, t1.week, t1.sku_group) t2) t3
  GROUP BY t3.kiosk_id, t3.sku_group
  ORDER BY t3.kiosk_id, t3.sku_group;


ALTER TABLE inm.v_kiosk_sku_group_stock_sale_spoil_history OWNER TO dbservice;

--
-- Name: byte_tickets_3months; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_tickets_3months AS
 SELECT byte_tickets.order_id,
    byte_tickets.first_name,
    byte_tickets.last_name,
    byte_tickets.kiosk_id,
    byte_tickets.kiosk_title,
    byte_tickets.email,
    byte_tickets.amount_paid,
    byte_tickets.payment_system,
    byte_tickets.transaction_id,
    byte_tickets.approval_code,
    byte_tickets.status_code,
    byte_tickets.status_message,
    byte_tickets.status,
    byte_tickets.batch_id,
    byte_tickets.created,
    byte_tickets.auth_amount,
    byte_tickets.data_token,
    byte_tickets.time_opened,
    byte_tickets.time_closed,
    byte_tickets.card_hash,
    byte_tickets.state,
    byte_tickets.archived,
    byte_tickets.stamp,
    byte_tickets.last_update,
    byte_tickets.balance,
    byte_tickets.delta,
    byte_tickets.coupon_id,
    byte_tickets.coupon,
    byte_tickets.refund,
    byte_tickets.receipt,
    byte_tickets.campus_id,
    byte_tickets.amount_list_price,
    byte_tickets.notes,
    byte_tickets.time_door_opened,
    byte_tickets.time_door_closed,
    byte_tickets.client_name,
    byte_tickets.estd_num_users,
    byte_tickets.ts,
    byte_tickets.full_name,
    byte_tickets.door_opened_secs,
    byte_tickets.month,
    byte_tickets.week,
    byte_tickets.date,
    byte_tickets.dayofweek,
    byte_tickets.hour,
    byte_tickets.dowhour,
    byte_tickets.uniq_user
   FROM public.byte_tickets
  WHERE (byte_tickets.ts > (now() - '3 mons'::interval month));


ALTER TABLE public.byte_tickets_3months OWNER TO dbservice;

--
-- Name: byte_epcssold_3months; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_epcssold_3months AS
 SELECT o.order_id,
    o.first_name,
    o.last_name,
    o.kiosk_id,
    o.kiosk_title,
    o.email,
    o.amount_paid,
    o.payment_system,
    o.transaction_id,
    o.approval_code,
    o.status_code,
    o.status_message,
    o.status,
    o.batch_id,
    o.created,
    o.auth_amount,
    o.data_token,
    o.time_opened,
    o.time_closed,
    o.card_hash,
    o.state,
    o.archived,
    o.stamp,
    o.last_update,
    o.balance,
    o.delta,
    o.coupon_id,
    o.coupon,
    o.refund,
    o.receipt,
    o.campus_id,
    o.amount_list_price,
    o.notes,
    o.time_door_opened,
    o.time_door_closed,
    o.client_name,
    o.estd_num_users,
    o.ts,
    o.full_name,
    o.door_opened_secs,
    o.month,
    o.week,
    o.date,
    o.dayofweek,
    o.hour,
    o.dowhour,
    o.uniq_user,
    lp.epc,
    lp.label_order_id,
    lp.label_status,
    lp.label_price,
    lp.time_created,
    lp.time_added,
    lp.time_updated,
    lp.ts_created,
    lp.ts_added,
    lp.ts_updated,
    lp.label_kiosk_id,
    lp.product_id,
    lp.product_title,
    lp.product_archived,
    lp.product_vendor,
    lp.product_price,
    lp.product_cost,
    lp.product_shelf_life_days,
    lp.product_attributes,
    lp.product_categories,
    lp.consumer_category,
    lp.product_source
   FROM (public.byte_tickets_3months o
     JOIN public.byte_label_product lp ON (((lp.label_order_id)::text = (o.order_id)::text)))
  WHERE ((lp.label_status)::text = 'sold'::text);


ALTER TABLE public.byte_epcssold_3months OWNER TO dbservice;

--
-- Name: v_kiosk_sku_group_velocity_demand_week; Type: VIEW; Schema: inm; Owner: dbservice
--

CREATE VIEW inm.v_kiosk_sku_group_velocity_demand_week AS
 SELECT kc.kiosk_id,
    sg.id AS sku_group_id,
    (sg.fc_title)::text AS sku_group,
    COALESCE(dwwom.sample_size, (0)::bigint) AS sample_size,
    COALESCE(dwwom.preference, 0.00) AS preference,
    max(COALESCE(dwwom.ws_avg, 0.00)) OVER (PARTITION BY kc.kiosk_id) AS ws_avg,
    max(COALESCE(dwwom.ws_std, 0.00)) OVER (PARTITION BY kc.kiosk_id) AS ws_std,
    max(COALESCE(dwwom.ws_max, 0.00)) OVER (PARTITION BY kc.kiosk_id) AS ws_max,
    max(COALESCE(dwwom.ws_live, (0)::bigint)) OVER (PARTITION BY kc.kiosk_id) AS ws_live,
    kc.start_level AS kc_start_level,
    kc.min_level AS kc_min_level,
    kc.manual_multiplier AS kc_manual_multiplier,
    sgc.default_level AS sgc_default_level,
    sgc.scale AS sgc_scale,
    COALESCE(ksms.scale, 1.00) AS ksms_scale,
    round((((((kc.start_level * kc.manual_multiplier) * sgc.scale) * COALESCE(ksms.scale, 1.00)) * sgc.scale) * sgc.default_level), 2) AS start_count,
    round((((((kc.min_level * kc.manual_multiplier) * sgc.scale) * COALESCE(ksms.scale, 1.00)) * sgc.scale) * sgc.default_level), 2) AS min_count,
    round((((COALESCE(dwwom.preference, 0.00) * kc.manual_multiplier) * sgc.scale) * COALESCE(ksms.scale, 1.00)), 2) AS scaled_preference,
    round(sum((((COALESCE(dwwom.preference, 0.00) * kc.manual_multiplier) * sgc.scale) * COALESCE(ksms.scale, 1.00))) OVER (PARTITION BY kc.kiosk_id), 2) AS scaled_preference_total,
    round((COALESCE(dwwom.ws_max, 0.00) * ((((COALESCE(dwwom.preference, 0.00) * kc.manual_multiplier) * sgc.scale) * COALESCE(ksms.scale, 1.00)) / GREATEST(0.01, sum((((COALESCE(dwwom.preference, 0.00) * kc.manual_multiplier) * sgc.scale) * COALESCE(ksms.scale, 1.00))) OVER (PARTITION BY kc.kiosk_id)))), 2) AS preference_count
   FROM ((((inm.sku_group sg
     CROSS JOIN inm.kiosk_control kc)
     LEFT JOIN inm.kiosk_sku_group_manual_scale ksms ON (((ksms.kiosk_id = kc.kiosk_id) AND (ksms.sku_group_id = sg.id))))
     LEFT JOIN inm.sku_group_control sgc ON ((sgc.sku_group_id = sg.id)))
     LEFT JOIN ( SELECT t4.kiosk_id,
            t4.sku_group,
            t4.sample_size,
            t4.dt_avg,
            t4.dt_std,
            t4.w_departure_time,
            t4.preference,
            t6.ws_avg,
            t6.ws_std,
            t6.ws_max,
            t6.ws_live
           FROM (( SELECT t3.kiosk_id,
                    t3.sku_group,
                    count(t3.purchase_index) AS sample_size,
                    round(avg(t3.departure_time), 2) AS dt_avg,
                    COALESCE(round(stddev(t3.departure_time), 2), (0)::numeric) AS dt_std,
                    round((sum((t3.departure_time * (t3.w)::numeric)) / (sum(t3.w))::numeric), 2) AS w_departure_time,
                    LEAST(round((1.00 / (sum((t3.departure_time * (t3.w)::numeric)) / (sum(t3.w))::numeric)), 2), 0.20) AS preference
                   FROM ( SELECT t2.kiosk_id,
                            t2.sku_group,
                            t2.time_stocked,
                            t2.time_sold,
                            t2.purchase_index,
                            t2.last_sale,
                            t2.last_purchase_index,
                            GREATEST(COALESCE(round((((t2.time_sold - GREATEST(t2.last_sale, t2.time_stocked)))::numeric / (3600)::numeric), 2), 50.00), 1.00) AS departure_time,
                            0 AS qty_sold,
                            1 AS w
                           FROM ( SELECT t1.kiosk_id,
                                    t1.sku_group,
                                    t1.time_stocked,
                                    t1.time_sold,
                                    t1.purchase_index,
                                    lag(t1.time_sold, 1) OVER (PARTITION BY t1.kiosk_id, t1.sku_group ORDER BY t1.time_sold) AS last_sale,
                                    lag(t1.purchase_index, 1) OVER (PARTITION BY t1.kiosk_id, t1.sku_group ORDER BY t1.time_sold) AS last_purchase_index
                                   FROM ( SELECT k.kiosk_id,
    p.sku_group,
    l.time_stocked,
    l.time_sold,
    l.purchase_index
   FROM ((( SELECT k_1.id AS kiosk_id
     FROM pantry.kiosk k_1
    WHERE ((k_1.campus_id = 87) AND (k_1.archived = 0) AND (k_1.enable_reporting = 1))) k
     CROSS JOIN ( SELECT DISTINCT p_1.fc_title AS sku_group
     FROM pantry.product p_1
    WHERE ((p_1.campus_id = 87) AND (p_1.archived = 0) AND (p_1.fc_title IS NOT NULL) AND ((p_1.fc_title)::text <> 'N/A'::text))
    ORDER BY p_1.fc_title) p)
     LEFT JOIN ( SELECT l_1.kiosk_id,
      p_1.fc_title AS sku_group,
      l_1.time_created AS time_stocked,
      l_1.time_updated AS time_sold,
      row_number() OVER (PARTITION BY l_1.kiosk_id ORDER BY l_1.time_updated) AS purchase_index
     FROM (pantry.label l_1
       JOIN pantry.product p_1 ON ((l_1.product_id = p_1.id)))
    WHERE ((l_1.kiosk_id IS NOT NULL) AND ((l_1.status)::text = 'sold'::text) AND (timezone('US/Pacific'::text, to_timestamp((l_1.time_updated)::double precision)) > (date_trunc('week'::text, CURRENT_TIMESTAMP) - '168 days'::interval)) AND (p_1.campus_id = 87) AND (p_1.archived = 0) AND (p_1.fc_title IS NOT NULL))) l ON (((k.kiosk_id = l.kiosk_id) AND ((p.sku_group)::text = (l.sku_group)::text))))
  ORDER BY k.kiosk_id, p.sku_group, l.purchase_index) t1) t2) t3
                  GROUP BY t3.kiosk_id, t3.sku_group) t4
             JOIN ( SELECT t5.kiosk_id,
                    round(avg(t5.units_sold), 2) AS ws_avg,
                    round(stddev(t5.units_sold), 2) AS ws_std,
                    round((max(t5.units_sold))::numeric, 2) AS ws_max,
                    count(t5.units_sold) AS ws_live
                   FROM ( SELECT concat((kk.kiosk_id)::character varying(4), ' ', kk.woy) AS key,
                            kk.kiosk_id,
                            kk.woy,
                            ss.units_sold
                           FROM (( SELECT k.id AS kiosk_id,
                                    generate_series(1, 52) AS woy
                                   FROM pantry.kiosk k
                                  WHERE ((k.campus_id = 87) AND (k.archived = 0) AND (k.enable_reporting = 1) AND (k.enable_monitoring = 1))) kk
                             LEFT JOIN ( SELECT s.kiosk_id,
                                    date_part('week'::text, s.ts) AS woy,
                                    count(*) AS units_sold
                                   FROM public.byte_epcssold_3months s
                                  GROUP BY s.kiosk_id, (date_part('week'::text, s.ts))) ss ON (((kk.kiosk_id = ss.kiosk_id) AND ((kk.woy)::double precision = ss.woy))))
                          ORDER BY ss.kiosk_id, ss.woy) t5
                  GROUP BY t5.kiosk_id
                  ORDER BY t5.kiosk_id) t6 ON ((t4.kiosk_id = t6.kiosk_id)))) dwwom ON (((dwwom.kiosk_id = kc.kiosk_id) AND ((dwwom.sku_group)::text = (sg.fc_title)::text))));


ALTER TABLE inm.v_kiosk_sku_group_velocity_demand_week OWNER TO dbservice;

--
-- Name: v_kiosk_sku_velocity; Type: VIEW; Schema: inm; Owner: dbservice
--

CREATE VIEW inm.v_kiosk_sku_velocity AS
 SELECT t3.kiosk_id,
    t3.sku_group,
    t3.sku,
    t3.name,
    count(t3.purchase_index) AS sample_size,
    round(avg(t3.departure_time), 2) AS dt_avg,
    COALESCE(round(stddev(t3.departure_time), 2), (0)::numeric) AS dt_std,
    round((sum((t3.departure_time * (t3.w)::numeric)) / (sum(t3.w))::numeric), 2) AS w_departure_time,
    LEAST(round((1.00 / (sum((t3.departure_time * (t3.w)::numeric)) / (sum(t3.w))::numeric)), 2), 0.20) AS preference
   FROM ( SELECT t2.kiosk_id,
            t2.sku_group,
            t2.sku,
            t2.name,
            t2.time_stocked,
            t2.time_sold,
            t2.purchase_index,
            t2.last_sale,
            t2.last_purchase_index,
            GREATEST(COALESCE(round((((t2.time_sold - GREATEST(t2.last_sale, t2.time_stocked)))::numeric / (3600)::numeric), 2), 50.00), 1.00) AS departure_time,
            0 AS qty_sold,
            1 AS w
           FROM ( SELECT t1.kiosk_id,
                    t1.sku_group,
                    t1.sku,
                    t1.name,
                    t1.time_stocked,
                    t1.time_sold,
                    t1.purchase_index,
                    lag(t1.time_sold, 1) OVER (PARTITION BY t1.kiosk_id, t1.sku ORDER BY t1.time_sold) AS last_sale,
                    lag(t1.purchase_index, 1) OVER (PARTITION BY t1.kiosk_id, t1.sku ORDER BY t1.time_sold) AS last_purchase_index
                   FROM ( SELECT k.kiosk_id,
                            p.sku_group,
                            p.sku,
                            p.name,
                            l.time_stocked,
                            l.time_sold,
                            l.purchase_index
                           FROM ((( SELECT k_1.id AS kiosk_id
                                   FROM pantry.kiosk k_1
                                  WHERE ((k_1.campus_id = 87) AND (k_1.archived = 0) AND (k_1.enable_reporting = 1))) k
                             CROSS JOIN ( SELECT p_1.fc_title AS sku_group,
                                    p_1.id AS sku,
                                    p_1.title AS name
                                   FROM pantry.product p_1
                                  WHERE ((p_1.campus_id = 87) AND (p_1.archived = 0) AND ((p_1.fc_title)::text <> 'N/A'::text) AND (p_1.fc_title IS NOT NULL))
                                  ORDER BY p_1.fc_title, p_1.id) p)
                             LEFT JOIN ( SELECT l_1.kiosk_id,
                                    p_1.fc_title AS sku_group,
                                    p_1.id AS sku,
                                    l_1.time_created AS time_stocked,
                                    l_1.time_updated AS time_sold,
                                    row_number() OVER (PARTITION BY l_1.kiosk_id ORDER BY l_1.time_updated) AS purchase_index
                                   FROM (pantry.label l_1
                                     JOIN pantry.product p_1 ON ((l_1.product_id = p_1.id)))
                                  WHERE ((l_1.kiosk_id IS NOT NULL) AND ((l_1.status)::text = 'sold'::text) AND (timezone('US/Pacific'::text, to_timestamp((l_1.time_updated)::double precision)) > (date_trunc('week'::text, CURRENT_TIMESTAMP) - '168 days'::interval)) AND (p_1.campus_id = 87) AND (p_1.archived = 0) AND ((p_1.fc_title)::text <> 'N/A'::text) AND (p_1.fc_title IS NOT NULL))) l ON (((k.kiosk_id = l.kiosk_id) AND (p.sku = l.sku))))
                          ORDER BY k.kiosk_id, p.sku_group, p.sku, l.purchase_index) t1) t2) t3
  GROUP BY t3.kiosk_id, t3.sku_group, t3.sku, t3.name
  ORDER BY t3.kiosk_id, t3.sku_group, t3.sku;


ALTER TABLE inm.v_kiosk_sku_velocity OWNER TO dbservice;

--
-- Name: v_kiosk_sku_group_sku_stats; Type: VIEW; Schema: inm; Owner: dbservice
--

CREATE VIEW inm.v_kiosk_sku_group_sku_stats AS
 SELECT enabled.kiosk_id,
    enabled.sku_group,
    demand.sku_group_id,
    enabled.sku,
    velocity.name,
    enabled.enabled,
    velocity.sample_size AS sku_sample_size,
    velocity.w_departure_time AS sku_departure_time,
    velocity.preference AS sku_preference,
    demand.sample_size AS sku_group_sample_size,
    demand.preference AS sku_group_preference,
    demand.kc_start_level AS kiosk_start_level,
    demand.kc_min_level AS kiosk_min_level,
    demand.kc_manual_multiplier AS kiosk_manual_multiplier,
    demand.sgc_default_level AS sku_group_default_level,
    demand.sgc_scale AS sku_group_scale,
    demand.ksms_scale AS kiosk_sku_group_scale,
    demand.start_count AS sku_group_start_count,
    demand.min_count AS sku_group_min_count,
    demand.preference_count AS sku_group_preference_count,
    history.stock_avg AS sku_group_stock_avg,
    history.stock_std AS sku_group_stock_std,
    history.sale_avg AS sku_group_sale_avg,
    history.sale_std AS sku_group_sale_std,
    history.spoil_avg AS sku_group_spoil_avg,
    history.spoil_std AS sku_group_spoil_std,
    demand.ws_live AS kiosk_weeks_live,
    demand.ws_max AS kiosk_sale_max,
    history.week_stock_avg AS kiosk_stock_avg,
    history.week_stock_std AS kiosk_stock_std,
    history.week_sale_avg AS kiosk_sale_avg,
    history.week_sale_std AS kiosk_sale_std,
    history.week_spoil_avg AS kiosk_spoil_avg,
    history.week_spoil_std AS kiosk_spoil_std,
    plan.d0_plan_demand_ratio,
    plan.d1_plan_demand_ratio,
    plan.d2_plan_demand_ratio,
    plan.d3_plan_demand_ratio,
    plan.d4_plan_demand_ratio
   FROM ((((inm.v_kiosk_sku_enabled enabled
     LEFT JOIN inm.v_kiosk_sku_velocity velocity ON (((enabled.kiosk_id = velocity.kiosk_id) AND (enabled.sku = velocity.sku))))
     LEFT JOIN inm.v_kiosk_sku_group_velocity_demand_week demand ON (((enabled.kiosk_id = demand.kiosk_id) AND ((enabled.sku_group)::text = demand.sku_group))))
     LEFT JOIN inm.v_kiosk_sku_group_stock_sale_spoil_history history ON (((enabled.kiosk_id = history.kiosk_id) AND ((enabled.sku_group)::text = (history.sku_group)::text))))
     LEFT JOIN inm.v_kiosk_demand_plan_ratio plan ON ((enabled.kiosk_id = plan.kiosk_id)))
  ORDER BY enabled.kiosk_id, enabled.sku_group, enabled.sku;


ALTER TABLE inm.v_kiosk_sku_group_sku_stats OWNER TO dbservice;

--
-- Name: v_warehouse_ordering_rec; Type: VIEW; Schema: inm; Owner: dbservice
--

CREATE VIEW inm.v_warehouse_ordering_rec AS
 SELECT stats.sku_group,
    stats.sku,
    stats.name,
    stats.vendor,
    ceiling(sum((stats.d0_plan_demand_ratio * (stats.sku_demand + stats.sku_overstock)))) AS su,
    ceiling(sum((stats.d1_plan_demand_ratio * (stats.sku_demand + stats.sku_overstock)))) AS mo,
    ceiling(sum((stats.d2_plan_demand_ratio * (stats.sku_demand + stats.sku_overstock)))) AS tu,
    ceiling(sum((stats.d3_plan_demand_ratio * (stats.sku_demand + stats.sku_overstock)))) AS we,
    ceiling(sum((stats.d4_plan_demand_ratio * (stats.sku_demand + stats.sku_overstock)))) AS th,
    ceiling(sum(stats.sku_demand)) AS demand_week,
    ceiling(sum(stats.sku_overstock)) AS overstock_week,
    max(stats.sku_shelf_time) AS shelf_time
   FROM ( SELECT stats_1.kiosk_id,
            stats_1.sku_group,
            stats_1.sku_group_id,
            stats_1.sku,
            stats_1.name,
            stats_1.enabled,
            stats_1.sku_sample_size,
            stats_1.sku_departure_time,
            stats_1.sku_preference,
            stats_1.sku_group_sample_size,
            stats_1.sku_group_preference,
            stats_1.kiosk_start_level,
            stats_1.kiosk_min_level,
            stats_1.kiosk_manual_multiplier,
            stats_1.sku_group_default_level,
            stats_1.sku_group_scale,
            stats_1.kiosk_sku_group_scale,
            stats_1.sku_group_start_count,
            stats_1.sku_group_min_count,
            stats_1.sku_group_preference_count,
            stats_1.sku_group_stock_avg,
            stats_1.sku_group_stock_std,
            stats_1.sku_group_sale_avg,
            stats_1.sku_group_sale_std,
            stats_1.sku_group_spoil_avg,
            stats_1.sku_group_spoil_std,
            stats_1.kiosk_weeks_live,
            stats_1.kiosk_sale_max,
            stats_1.kiosk_stock_avg,
            stats_1.kiosk_stock_std,
            stats_1.kiosk_sale_avg,
            stats_1.kiosk_sale_std,
            stats_1.kiosk_spoil_avg,
            stats_1.kiosk_spoil_std,
            stats_1.d0_plan_demand_ratio,
            stats_1.d1_plan_demand_ratio,
            stats_1.d2_plan_demand_ratio,
            stats_1.d3_plan_demand_ratio,
            stats_1.d4_plan_demand_ratio,
            stats_1.vendor,
            stats_1.sku_shelf_time,
            stats_1.sku_pref_total_kiosk_sku_group,
            stats_1.sku_group_demand,
            stats_1.sku_group_overstock,
            round(public.if((stats_1.sku_pref_total_kiosk_sku_group <> (0)::numeric), (((stats_1.sku_group_demand * (stats_1.enabled)::numeric) * stats_1.sku_preference) / stats_1.sku_pref_total_kiosk_sku_group), 0.00), 2) AS sku_demand,
            round(public.if((stats_1.sku_pref_total_kiosk_sku_group <> (0)::numeric), ((((LEAST(1.00, (7.00 / (stats_1.sku_shelf_time)::numeric)) * stats_1.sku_group_overstock) * (stats_1.enabled)::numeric) * stats_1.sku_preference) / stats_1.sku_pref_total_kiosk_sku_group), 0.00), 2) AS sku_overstock
           FROM ( SELECT stats_2.kiosk_id,
                    stats_2.sku_group,
                    stats_2.sku_group_id,
                    stats_2.sku,
                    stats_2.name,
                    stats_2.enabled,
                    stats_2.sku_sample_size,
                    stats_2.sku_departure_time,
                    stats_2.sku_preference,
                    stats_2.sku_group_sample_size,
                    stats_2.sku_group_preference,
                    stats_2.kiosk_start_level,
                    stats_2.kiosk_min_level,
                    stats_2.kiosk_manual_multiplier,
                    stats_2.sku_group_default_level,
                    stats_2.sku_group_scale,
                    stats_2.kiosk_sku_group_scale,
                    stats_2.sku_group_start_count,
                    stats_2.sku_group_min_count,
                    stats_2.sku_group_preference_count,
                    stats_2.sku_group_stock_avg,
                    stats_2.sku_group_stock_std,
                    stats_2.sku_group_sale_avg,
                    stats_2.sku_group_sale_std,
                    stats_2.sku_group_spoil_avg,
                    stats_2.sku_group_spoil_std,
                    stats_2.kiosk_weeks_live,
                    stats_2.kiosk_sale_max,
                    stats_2.kiosk_stock_avg,
                    stats_2.kiosk_stock_std,
                    stats_2.kiosk_sale_avg,
                    stats_2.kiosk_sale_std,
                    stats_2.kiosk_spoil_avg,
                    stats_2.kiosk_spoil_std,
                    stats_2.d0_plan_demand_ratio,
                    stats_2.d1_plan_demand_ratio,
                    stats_2.d2_plan_demand_ratio,
                    stats_2.d3_plan_demand_ratio,
                    stats_2.d4_plan_demand_ratio,
                    product.vendor,
                    product.shelf_time AS sku_shelf_time,
                    sum(((stats_2.enabled)::numeric * stats_2.sku_preference)) OVER (PARTITION BY stats_2.kiosk_id, stats_2.sku_group) AS sku_pref_total_kiosk_sku_group,
                    stats_2.sku_group_preference_count AS sku_group_demand,
                    GREATEST((public.if((stats_2.kiosk_weeks_live <= 4), GREATEST(stats_2.sku_group_start_count, stats_2.sku_group_preference_count), GREATEST(stats_2.sku_group_min_count, stats_2.sku_group_preference_count)) - stats_2.sku_group_preference_count), 0.00) AS sku_group_overstock
                   FROM (inm.v_kiosk_sku_group_sku_stats stats_2
                     LEFT JOIN pantry.product product ON ((stats_2.sku = product.id)))) stats_1) stats
  GROUP BY stats.sku_group, stats.sku, stats.name, stats.vendor
  ORDER BY stats.sku_group, stats.vendor;


ALTER TABLE inm.v_warehouse_ordering_rec OWNER TO dbservice;

--
-- Name: view_sku_sku_group; Type: VIEW; Schema: inm; Owner: dbservice
--

CREATE VIEW inm.view_sku_sku_group AS
 SELECT p.id AS product_id,
    p.title,
    sga.id AS sku_group_id,
    p.fc_title
   FROM (pantry.product p
     JOIN inm.sku_group_attribute sga ON (((p.fc_title)::text = (sga.title)::text)))
  WHERE ((p.campus_id = 87) AND (p.fc_title IS NOT NULL) AND (p.archived = 0));


ALTER TABLE inm.view_sku_sku_group OWNER TO dbservice;

--
-- Name: inm_sku_velocity; Type: VIEW; Schema: mixalot; Owner: dbservice
--

CREATE VIEW mixalot.inm_sku_velocity AS
 SELECT t3.kiosk_id,
    t3.sku_group,
    t3.sku,
    t3.name,
    count(t3.purchase_index) AS sample_size,
    round(avg(t3.departure_time), 2) AS dt_avg,
    COALESCE(round(stddev(t3.departure_time), 2), (0)::numeric) AS dt_std,
    round((sum((t3.departure_time * (t3.w)::numeric)) / (sum(t3.w))::numeric), 2) AS w_departure_time,
    LEAST(round((1.00 / (sum((t3.departure_time * (t3.w)::numeric)) / (sum(t3.w))::numeric)), 2), 0.20) AS preference
   FROM ( SELECT t2.kiosk_id,
            t2.sku_group,
            t2.sku,
            t2.name,
            t2.time_stocked,
            t2.time_sold,
            t2.purchase_index,
            t2.last_sale,
            t2.last_purchase_index,
            GREATEST(COALESCE(round((((t2.time_sold - GREATEST(t2.last_sale, t2.time_stocked)))::numeric / (3600)::numeric), 2), 50.00), 1.00) AS departure_time,
            0 AS qty_sold,
            1 AS w
           FROM ( SELECT t1.kiosk_id,
                    t1.sku_group,
                    t1.sku,
                    t1.name,
                    t1.time_stocked,
                    t1.time_sold,
                    t1.purchase_index,
                    lag(t1.time_sold, 1) OVER (PARTITION BY t1.kiosk_id, t1.sku ORDER BY t1.time_sold) AS last_sale,
                    lag(t1.purchase_index, 1) OVER (PARTITION BY t1.kiosk_id, t1.sku ORDER BY t1.time_sold) AS last_purchase_index
                   FROM ( SELECT k.kiosk_id,
                            p.sku_group,
                            p.sku,
                            p.name,
                            l.time_stocked,
                            l.time_sold,
                            l.purchase_index
                           FROM ((( SELECT k_1.id AS kiosk_id
                                   FROM pantry.kiosk k_1
                                  WHERE ((k_1.campus_id = 87) AND (k_1.archived = 0) AND (k_1.enable_reporting = 1))) k
                             CROSS JOIN ( SELECT p_1.fc_title AS sku_group,
                                    p_1.id AS sku,
                                    p_1.title AS name
                                   FROM pantry.product p_1
                                  WHERE ((p_1.campus_id = 87) AND (p_1.archived = 0) AND ((p_1.fc_title)::text <> 'N/A'::text) AND (p_1.fc_title IS NOT NULL))
                                  ORDER BY p_1.fc_title, p_1.id) p)
                             LEFT JOIN ( SELECT l_1.kiosk_id,
                                    p_1.fc_title AS sku_group,
                                    p_1.id AS sku,
                                    l_1.time_created AS time_stocked,
                                    l_1.time_updated AS time_sold,
                                    row_number() OVER (PARTITION BY l_1.kiosk_id ORDER BY l_1.time_updated) AS purchase_index
                                   FROM (pantry.label l_1
                                     JOIN pantry.product p_1 ON ((l_1.product_id = p_1.id)))
                                  WHERE ((l_1.kiosk_id IS NOT NULL) AND ((l_1.status)::text = 'sold'::text) AND (timezone('US/Pacific'::text, to_timestamp((l_1.time_updated)::double precision)) > (date_trunc('week'::text, CURRENT_TIMESTAMP) - '168 days'::interval)) AND (p_1.campus_id = 87) AND (p_1.archived = 0) AND ((p_1.fc_title)::text <> 'N/A'::text) AND (p_1.fc_title IS NOT NULL))) l ON (((k.kiosk_id = l.kiosk_id) AND (p.sku = l.sku))))
                          ORDER BY k.kiosk_id, p.sku_group, p.sku, l.purchase_index) t1) t2) t3
  GROUP BY t3.kiosk_id, t3.sku_group, t3.sku, t3.name
  ORDER BY t3.kiosk_id, t3.sku_group, t3.sku;


ALTER TABLE mixalot.inm_sku_velocity OWNER TO dbservice;

--
-- Name: inm_warehouse_sku_enabled; Type: VIEW; Schema: mixalot; Owner: dbservice
--

CREATE VIEW mixalot.inm_warehouse_sku_enabled AS
 SELECT p.sku,
    p.name,
    p.sku_group,
    1 AS scale
   FROM (( SELECT p_1.fc_title AS sku_group,
            p_1.id AS sku,
            p_1.title AS name
           FROM pantry.product p_1
          WHERE ((p_1.campus_id = 87) AND (p_1.archived = 0) AND ((p_1.fc_title)::text <> 'N/A'::text) AND (p_1.fc_title IS NOT NULL))
          ORDER BY p_1.fc_title, p_1.id) p
     LEFT JOIN ( SELECT p_1.id AS sku,
            count(*) AS units_sold
           FROM (pantry.label l_1
             JOIN pantry.product p_1 ON ((l_1.product_id = p_1.id)))
          WHERE ((l_1.kiosk_id IS NOT NULL) AND ((l_1.status)::text = 'sold'::text) AND (timezone('US/Pacific'::text, to_timestamp((l_1.time_updated)::double precision)) > (date_trunc('week'::text, CURRENT_TIMESTAMP) - '28 days'::interval)) AND (p_1.campus_id = 87) AND (p_1.archived = 0) AND ((p_1.fc_title)::text <> 'N/A'::text) AND (p_1.fc_title IS NOT NULL))
          GROUP BY p_1.id) l ON ((p.sku = l.sku)));


ALTER TABLE mixalot.inm_warehouse_sku_enabled OWNER TO dbservice;

--
-- Name: warehouse_ordering; Type: VIEW; Schema: inm; Owner: dbservice
--

CREATE VIEW inm.warehouse_ordering AS
 SELECT t9.sku_group,
    t9.sku,
    t9.name,
    sum(t9.su_plan_demand_qty) AS su,
    sum(t9.mo_plan_demand_qty) AS mo,
    sum(t9.tu_plan_demand_qty) AS tu,
    sum(t9.we_plan_demand_qty) AS we,
    sum(t9.th_plan_demand_qty) AS th
   FROM ( SELECT t8.kiosk_id,
            t8.sku_group,
            t8.sku,
            t8.name,
            COALESCE(round(
                CASE
                    WHEN (t8.preference_sum > (0)::numeric) THEN ((t8.preference_scale / t8.preference_sum) * t8.d1_plan_demand_qty)
                    ELSE 0.00
                END, 2), 0.00) AS su_plan_demand_qty,
            COALESCE(round(
                CASE
                    WHEN (t8.preference_sum > (0)::numeric) THEN ((t8.preference_scale / t8.preference_sum) * t8.d2_plan_demand_qty)
                    ELSE 0.00
                END, 2), 0.00) AS mo_plan_demand_qty,
            COALESCE(round(
                CASE
                    WHEN (t8.preference_sum > (0)::numeric) THEN ((t8.preference_scale / t8.preference_sum) * t8.d3_plan_demand_qty)
                    ELSE 0.00
                END, 2), 0.00) AS tu_plan_demand_qty,
            COALESCE(round(
                CASE
                    WHEN (t8.preference_sum > (0)::numeric) THEN ((t8.preference_scale / t8.preference_sum) * t8.d4_plan_demand_qty)
                    ELSE 0.00
                END, 2), 0.00) AS we_plan_demand_qty,
            COALESCE(round(
                CASE
                    WHEN (t8.preference_sum > (0)::numeric) THEN ((t8.preference_scale / t8.preference_sum) * t8.d5_plan_demand_qty)
                    ELSE 0.00
                END, 2), 0.00) AS th_plan_demand_qty
           FROM ( SELECT t7.kiosk_id,
                    t7.sku_group,
                    t7.sku,
                    t7.name,
                    t7.sample_size,
                    t7.dt_avg,
                    t7.dt_std,
                    t7.w_departure_time,
                    t7.preference,
                    t7.scale,
                    t7.week_demand_qty,
                    t7.d1_plan_demand_qty,
                    t7.d2_plan_demand_qty,
                    t7.d3_plan_demand_qty,
                    t7.d4_plan_demand_qty,
                    t7.d5_plan_demand_qty,
                    round((t7.preference * (t7.scale)::numeric), 2) AS preference_scale,
                    sum((t7.preference * (t7.scale)::numeric)) OVER (PARTITION BY t7.kiosk_id, t7.sku_group) AS preference_sum
                   FROM ( SELECT t4.kiosk_id,
                            t4.sku_group,
                            t4.sku,
                            t4.name,
                            t4.sample_size,
                            t4.dt_avg,
                            t4.dt_std,
                            t4.w_departure_time,
                            t4.preference,
                            t5.scale,
                            t6.week_demand_qty,
                            t6.d1_plan_demand_qty,
                            t6.d2_plan_demand_qty,
                            t6.d3_plan_demand_qty,
                            t6.d4_plan_demand_qty,
                            t6.d5_plan_demand_qty
                           FROM ((mixalot.inm_sku_velocity t4
                             LEFT JOIN mixalot.inm_warehouse_sku_enabled t5 ON ((t4.sku = t5.sku)))
                             LEFT JOIN ( SELECT t1.kiosk_id,
                                    t1.sku_group,
                                    t1.week_demand_qty,
                                    round(((t1.week_demand_qty * t1.d1_plan_demand_qty) / ((((t1.d1_plan_demand_qty + t1.d2_plan_demand_qty) + t1.d3_plan_demand_qty) + t1.d4_plan_demand_qty) + t1.d5_plan_demand_qty)), 2) AS d1_plan_demand_qty,
                                    round(((t1.week_demand_qty * t1.d2_plan_demand_qty) / ((((t1.d1_plan_demand_qty + t1.d2_plan_demand_qty) + t1.d3_plan_demand_qty) + t1.d4_plan_demand_qty) + t1.d5_plan_demand_qty)), 2) AS d2_plan_demand_qty,
                                    round(((t1.week_demand_qty * t1.d3_plan_demand_qty) / ((((t1.d1_plan_demand_qty + t1.d2_plan_demand_qty) + t1.d3_plan_demand_qty) + t1.d4_plan_demand_qty) + t1.d5_plan_demand_qty)), 2) AS d3_plan_demand_qty,
                                    round(((t1.week_demand_qty * t1.d4_plan_demand_qty) / ((((t1.d1_plan_demand_qty + t1.d2_plan_demand_qty) + t1.d3_plan_demand_qty) + t1.d4_plan_demand_qty) + t1.d5_plan_demand_qty)), 2) AS d4_plan_demand_qty,
                                    round(((t1.week_demand_qty * t1.d5_plan_demand_qty) / ((((t1.d1_plan_demand_qty + t1.d2_plan_demand_qty) + t1.d3_plan_demand_qty) + t1.d4_plan_demand_qty) + t1.d5_plan_demand_qty)), 2) AS d5_plan_demand_qty
                                   FROM ( SELECT k.kiosk_id,
    p.sku_group,
    COALESCE(d1.week_demand_qty, d2.week_demand_qty, d3.week_demand_qty, d4.week_demand_qty, d5.week_demand_qty) AS week_demand_qty,
    COALESCE(d1.plan_demand_qty, (0)::numeric) AS d1_plan_demand_qty,
    COALESCE(d2.plan_demand_qty, (0)::numeric) AS d2_plan_demand_qty,
    COALESCE(d3.plan_demand_qty, (0)::numeric) AS d3_plan_demand_qty,
    COALESCE(d4.plan_demand_qty, (0)::numeric) AS d4_plan_demand_qty,
    COALESCE(d5.plan_demand_qty, (0)::numeric) AS d5_plan_demand_qty
   FROM ((((((( SELECT k_1.id AS kiosk_id
     FROM pantry.kiosk k_1
    WHERE ((k_1.campus_id = 87) AND (k_1.archived = 0) AND (k_1.enable_reporting = 1))) k
     CROSS JOIN ( SELECT DISTINCT p_1.fc_title AS sku_group
     FROM pantry.product p_1
    WHERE ((p_1.campus_id = 87) AND (p_1.archived = 0) AND (p_1.fc_title IS NOT NULL) AND ((p_1.fc_title)::text <> 'N/A'::text))
    ORDER BY p_1.fc_title) p)
     FULL JOIN inm.pick_get_order_with_velocity('2018-12-16 20:00:00+00'::timestamp with time zone, '2018-12-17 18:00:00+00'::timestamp with time zone) d1(kiosk_id, route_date_time, sku_group_id, fc_title, week_demand_qty, plan_demand_qty, plan_order_qty) ON (((k.kiosk_id = d1.kiosk_id) AND ((p.sku_group)::text = d1.fc_title))))
     FULL JOIN inm.pick_get_order_with_velocity('2018-12-17 20:00:00+00'::timestamp with time zone, '2018-12-18 18:00:00+00'::timestamp with time zone) d2(kiosk_id, route_date_time, sku_group_id, fc_title, week_demand_qty, plan_demand_qty, plan_order_qty) ON (((k.kiosk_id = d2.kiosk_id) AND ((p.sku_group)::text = d2.fc_title))))
     FULL JOIN inm.pick_get_order_with_velocity('2018-12-18 20:00:00+00'::timestamp with time zone, '2018-12-19 18:00:00+00'::timestamp with time zone) d3(kiosk_id, route_date_time, sku_group_id, fc_title, week_demand_qty, plan_demand_qty, plan_order_qty) ON (((k.kiosk_id = d3.kiosk_id) AND ((p.sku_group)::text = d3.fc_title))))
     FULL JOIN inm.pick_get_order_with_velocity('2018-12-19 20:00:00+00'::timestamp with time zone, '2018-12-20 18:00:00+00'::timestamp with time zone) d4(kiosk_id, route_date_time, sku_group_id, fc_title, week_demand_qty, plan_demand_qty, plan_order_qty) ON (((k.kiosk_id = d4.kiosk_id) AND ((p.sku_group)::text = d4.fc_title))))
     FULL JOIN inm.pick_get_order_with_velocity('2018-12-20 20:00:00+00'::timestamp with time zone, '2018-12-21 18:00:00+00'::timestamp with time zone) d5(kiosk_id, route_date_time, sku_group_id, fc_title, week_demand_qty, plan_demand_qty, plan_order_qty) ON (((k.kiosk_id = d5.kiosk_id) AND ((p.sku_group)::text = d5.fc_title))))
  ORDER BY k.kiosk_id, p.sku_group) t1
                                  WHERE (((((t1.d1_plan_demand_qty + t1.d2_plan_demand_qty) + t1.d3_plan_demand_qty) + t1.d4_plan_demand_qty) + t1.d5_plan_demand_qty) > (0)::numeric)) t6 ON (((t4.kiosk_id = t6.kiosk_id) AND ((t4.sku_group)::text = (t6.sku_group)::text))))) t7) t8) t9
  GROUP BY t9.sku_group, t9.sku, t9.name
  ORDER BY t9.sku_group, t9.sku, t9.name;


ALTER TABLE inm.warehouse_ordering OWNER TO dbservice;

--
-- Name: kiosk_control; Type: TABLE; Schema: inm_backup; Owner: dbservice
--

CREATE TABLE inm_backup.kiosk_control (
    kiosk_id integer NOT NULL,
    start_level numeric(4,2) NOT NULL,
    min_level numeric(4,2) NOT NULL,
    scale numeric(4,2) NOT NULL,
    manual_multiplier numeric(4,2) NOT NULL
);


ALTER TABLE inm_backup.kiosk_control OWNER TO dbservice;

--
-- Name: kiosk_product_disabled; Type: TABLE; Schema: inm_backup; Owner: dbservice
--

CREATE TABLE inm_backup.kiosk_product_disabled (
    kiosk_id bigint,
    product_id integer
);


ALTER TABLE inm_backup.kiosk_product_disabled OWNER TO dbservice;

--
-- Name: kiosk_restriction_by_product; Type: TABLE; Schema: inm_backup; Owner: dbservice
--

CREATE TABLE inm_backup.kiosk_restriction_by_product (
    kiosk_id bigint,
    product_id integer
);


ALTER TABLE inm_backup.kiosk_restriction_by_product OWNER TO dbservice;

--
-- Name: kiosk_restriction_by_property; Type: TABLE; Schema: inm_backup; Owner: dbservice
--

CREATE TABLE inm_backup.kiosk_restriction_by_property (
    kiosk_id integer,
    property_id integer
);


ALTER TABLE inm_backup.kiosk_restriction_by_property OWNER TO dbservice;

--
-- Name: kiosk_sku_group_manual_scale; Type: TABLE; Schema: inm_backup; Owner: dbservice
--

CREATE TABLE inm_backup.kiosk_sku_group_manual_scale (
    kiosk_id integer,
    sku_group_id integer,
    scale numeric(4,2)
);


ALTER TABLE inm_backup.kiosk_sku_group_manual_scale OWNER TO dbservice;

--
-- Name: ku_group_attribute; Type: TABLE; Schema: inm_backup; Owner: dbservice
--

CREATE TABLE inm_backup.ku_group_attribute (
    id integer,
    title character varying(512),
    relative_size numeric(4,2),
    minimum_kiosk_qty smallint,
    maximum_kiosk_qty smallint
);


ALTER TABLE inm_backup.ku_group_attribute OWNER TO dbservice;

--
-- Name: pick_allocation; Type: TABLE; Schema: inm_backup; Owner: dbservice
--

CREATE TABLE inm_backup.pick_allocation (
    pick_date date,
    route_date date,
    kiosk_id integer,
    sku_id integer,
    qty integer
);


ALTER TABLE inm_backup.pick_allocation OWNER TO dbservice;

--
-- Name: pick_demand; Type: TABLE; Schema: inm_backup; Owner: dbservice
--

CREATE TABLE inm_backup.pick_demand (
    pick_date date,
    route_date date,
    kiosk_id integer,
    sku_group_id integer,
    qty integer
);


ALTER TABLE inm_backup.pick_demand OWNER TO dbservice;

--
-- Name: pick_inventory; Type: TABLE; Schema: inm_backup; Owner: dbservice
--

CREATE TABLE inm_backup.pick_inventory (
    pick_date date,
    route_date date,
    kiosk_id integer,
    sku_group_id integer,
    qty integer
);


ALTER TABLE inm_backup.pick_inventory OWNER TO dbservice;

--
-- Name: pick_preference_kiosk_sku_20190120; Type: TABLE; Schema: inm_backup; Owner: dbservice
--

CREATE TABLE inm_backup.pick_preference_kiosk_sku_20190120 (
    kiosk_id integer,
    sku_id integer,
    preference smallint
);


ALTER TABLE inm_backup.pick_preference_kiosk_sku_20190120 OWNER TO dbservice;

--
-- Name: pick_priority_kiosk; Type: TABLE; Schema: inm_backup; Owner: dbservice
--

CREATE TABLE inm_backup.pick_priority_kiosk (
    kiosk_id integer,
    priority integer,
    comment text,
    end_date date
);


ALTER TABLE inm_backup.pick_priority_kiosk OWNER TO dbservice;

--
-- Name: pick_route; Type: TABLE; Schema: inm_backup; Owner: dbservice
--

CREATE TABLE inm_backup.pick_route (
    pick_date date,
    kiosk_id integer,
    route_number character varying(256),
    driver_name character varying(64),
    route_time time(6) without time zone,
    route_date date,
    delivery_order smallint
);


ALTER TABLE inm_backup.pick_route OWNER TO dbservice;

--
-- Name: pick_substitution; Type: TABLE; Schema: inm_backup; Owner: dbservice
--

CREATE TABLE inm_backup.pick_substitution (
    substituting_sku_group_id integer,
    substituted_sku_group_id integer,
    qty integer,
    pick_date date
);


ALTER TABLE inm_backup.pick_substitution OWNER TO dbservice;

--
-- Name: product_property; Type: TABLE; Schema: inm_backup; Owner: dbservice
--

CREATE TABLE inm_backup.product_property (
    product_id bigint,
    property_id integer
);


ALTER TABLE inm_backup.product_property OWNER TO dbservice;

--
-- Name: sku_group_control; Type: TABLE; Schema: inm_backup; Owner: dbservice
--

CREATE TABLE inm_backup.sku_group_control (
    sku_group_id integer,
    default_level numeric(4,2),
    scale numeric(4,2),
    min_qty smallint,
    max_qty smallint
);


ALTER TABLE inm_backup.sku_group_control OWNER TO dbservice;

--
-- Name: sku_group_def; Type: TABLE; Schema: inm_backup; Owner: dbservice
--

CREATE TABLE inm_backup.sku_group_def (
    id integer,
    title character varying(512),
    volume numeric(4,2)
);


ALTER TABLE inm_backup.sku_group_def OWNER TO dbservice;

--
-- Name: sku_velocity_20190120; Type: TABLE; Schema: inm_backup; Owner: dbservice
--

CREATE TABLE inm_backup.sku_velocity_20190120 (
    kiosk_id bigint,
    sku_group character varying(765),
    sku bigint,
    name character varying(381),
    sample_size bigint,
    dt_avg numeric,
    dt_std numeric,
    w_departure_time numeric,
    preference numeric
);


ALTER TABLE inm_backup.sku_velocity_20190120 OWNER TO dbservice;

--
-- Name: allocable_inventory; Type: VIEW; Schema: inm_beta; Owner: dbservice
--

CREATE VIEW inm_beta.allocable_inventory AS
 SELECT warehouse_inventory.inventory_date,
    warehouse_inventory.product_id,
    ((warehouse_inventory.stickered_units + (warehouse_inventory.stickered_cases * warehouse_inventory.units_per_case)) - warehouse_inventory.spoiled_units) AS qty
   FROM inm.warehouse_inventory;


ALTER TABLE inm_beta.allocable_inventory OWNER TO dbservice;

--
-- Name: kiosk_control; Type: TABLE; Schema: inm_beta; Owner: dbservice
--

CREATE TABLE inm_beta.kiosk_control (
    kiosk_id integer NOT NULL,
    start_level numeric(4,2) NOT NULL,
    min_level numeric(4,2) NOT NULL,
    scale numeric(4,2) DEFAULT 1.0 NOT NULL,
    manual_multiplier numeric(4,2) DEFAULT 1.0 NOT NULL
);


ALTER TABLE inm_beta.kiosk_control OWNER TO dbservice;

--
-- Name: kiosk_product_disabled; Type: TABLE; Schema: inm_beta; Owner: dbservice
--

CREATE TABLE inm_beta.kiosk_product_disabled (
    kiosk_id bigint NOT NULL,
    product_id integer NOT NULL
);


ALTER TABLE inm_beta.kiosk_product_disabled OWNER TO dbservice;

--
-- Name: kiosk_restriction_by_product; Type: TABLE; Schema: inm_beta; Owner: dbservice
--

CREATE TABLE inm_beta.kiosk_restriction_by_product (
    kiosk_id bigint NOT NULL,
    product_id integer NOT NULL
);


ALTER TABLE inm_beta.kiosk_restriction_by_product OWNER TO dbservice;

--
-- Name: kiosk_restriction_by_property; Type: TABLE; Schema: inm_beta; Owner: dbservice
--

CREATE TABLE inm_beta.kiosk_restriction_by_property (
    kiosk_id integer NOT NULL,
    property_id integer NOT NULL
);


ALTER TABLE inm_beta.kiosk_restriction_by_property OWNER TO dbservice;

--
-- Name: kiosk_sku_group_manual_scale; Type: TABLE; Schema: inm_beta; Owner: dbservice
--

CREATE TABLE inm_beta.kiosk_sku_group_manual_scale (
    kiosk_id integer NOT NULL,
    sku_group_id integer NOT NULL,
    scale numeric(4,2) NOT NULL
);


ALTER TABLE inm_beta.kiosk_sku_group_manual_scale OWNER TO dbservice;

--
-- Name: pick_allocation; Type: TABLE; Schema: inm_beta; Owner: dbservice
--

CREATE TABLE inm_beta.pick_allocation (
    pick_date date NOT NULL,
    route_date date NOT NULL,
    kiosk_id integer NOT NULL,
    sku_id integer NOT NULL,
    qty integer NOT NULL
);


ALTER TABLE inm_beta.pick_allocation OWNER TO dbservice;

--
-- Name: pick_demand; Type: TABLE; Schema: inm_beta; Owner: dbservice
--

CREATE TABLE inm_beta.pick_demand (
    pick_date date NOT NULL,
    route_date date NOT NULL,
    kiosk_id integer NOT NULL,
    sku_group_id integer NOT NULL,
    qty integer NOT NULL
);


ALTER TABLE inm_beta.pick_demand OWNER TO dbservice;

--
-- Name: pick_inventory; Type: TABLE; Schema: inm_beta; Owner: dbservice
--

CREATE TABLE inm_beta.pick_inventory (
    pick_date date NOT NULL,
    route_date date NOT NULL,
    kiosk_id integer NOT NULL,
    sku_group_id integer NOT NULL,
    qty integer NOT NULL
);


ALTER TABLE inm_beta.pick_inventory OWNER TO dbservice;

--
-- Name: pick_list; Type: TABLE; Schema: inm_beta; Owner: dbservice
--

CREATE TABLE inm_beta.pick_list (
    pick_date date NOT NULL,
    create_ts timestamp with time zone,
    finish_ts timestamp with time zone,
    status text,
    log text,
    url text
);


ALTER TABLE inm_beta.pick_list OWNER TO dbservice;

--
-- Name: pick_preference_kiosk_sku; Type: TABLE; Schema: inm_beta; Owner: dbservice
--

CREATE TABLE inm_beta.pick_preference_kiosk_sku (
    kiosk_id integer NOT NULL,
    sku_id integer NOT NULL,
    preference smallint NOT NULL
);


ALTER TABLE inm_beta.pick_preference_kiosk_sku OWNER TO dbservice;

--
-- Name: pick_priority_kiosk; Type: TABLE; Schema: inm_beta; Owner: dbservice
--

CREATE TABLE inm_beta.pick_priority_kiosk (
    kiosk_id integer NOT NULL,
    priority integer,
    start_date date,
    end_date date,
    comment text
);


ALTER TABLE inm_beta.pick_priority_kiosk OWNER TO dbservice;

--
-- Name: pick_priority_sku; Type: TABLE; Schema: inm_beta; Owner: dbservice
--

CREATE TABLE inm_beta.pick_priority_sku (
    sku_id integer NOT NULL,
    priority integer,
    start_date date,
    end_date date,
    comment text
);


ALTER TABLE inm_beta.pick_priority_sku OWNER TO dbservice;

--
-- Name: pick_rejection; Type: TABLE; Schema: inm_beta; Owner: dbservice
--

CREATE TABLE inm_beta.pick_rejection (
    pick_date date NOT NULL,
    route_date date NOT NULL,
    kiosk_id integer NOT NULL,
    item_id integer NOT NULL,
    item_type character varying(32) NOT NULL,
    reason character varying(64) NOT NULL
);


ALTER TABLE inm_beta.pick_rejection OWNER TO dbservice;

--
-- Name: pick_route; Type: TABLE; Schema: inm_beta; Owner: dbservice
--

CREATE TABLE inm_beta.pick_route (
    pick_date date NOT NULL,
    kiosk_id integer NOT NULL,
    route_number character varying(256),
    driver_name character varying(64) NOT NULL,
    route_time time(6) without time zone NOT NULL,
    route_date date NOT NULL,
    delivery_order smallint NOT NULL
);


ALTER TABLE inm_beta.pick_route OWNER TO dbservice;

--
-- Name: pick_substitution; Type: TABLE; Schema: inm_beta; Owner: dbservice
--

CREATE TABLE inm_beta.pick_substitution (
    substituting_sku_group_id integer NOT NULL,
    substituted_sku_group_id integer NOT NULL,
    qty integer NOT NULL,
    pick_date date NOT NULL
);


ALTER TABLE inm_beta.pick_substitution OWNER TO dbservice;

--
-- Name: product_property; Type: TABLE; Schema: inm_beta; Owner: dbservice
--

CREATE TABLE inm_beta.product_property (
    product_id bigint,
    property_id integer
);


ALTER TABLE inm_beta.product_property OWNER TO dbservice;

--
-- Name: sku_group; Type: TABLE; Schema: inm_beta; Owner: dbservice
--

CREATE TABLE inm_beta.sku_group (
    id integer NOT NULL,
    fc_title inm_beta.text_name NOT NULL,
    unit_size numeric(4,2) NOT NULL
);


ALTER TABLE inm_beta.sku_group OWNER TO dbservice;

--
-- Name: sku_group_control; Type: TABLE; Schema: inm_beta; Owner: dbservice
--

CREATE TABLE inm_beta.sku_group_control (
    sku_group_id integer NOT NULL,
    default_level numeric(4,2) DEFAULT '-1'::integer NOT NULL,
    scale numeric(4,2) DEFAULT 1.0 NOT NULL,
    min_qty smallint,
    max_qty smallint
);


ALTER TABLE inm_beta.sku_group_control OWNER TO dbservice;

--
-- Name: warehouse_inventory; Type: TABLE; Schema: inm_beta; Owner: dbservice
--

CREATE TABLE inm_beta.warehouse_inventory (
    inventory_date date NOT NULL,
    product_id integer NOT NULL,
    stickered_units integer DEFAULT 0 NOT NULL,
    unstickered_units integer DEFAULT 0 NOT NULL,
    stickered_cases integer DEFAULT 0 NOT NULL,
    unstickered_cases integer DEFAULT 0 NOT NULL,
    spoiled_units integer DEFAULT 0 NOT NULL,
    units_per_case integer NOT NULL,
    sort_order smallint NOT NULL
);


ALTER TABLE inm_beta.warehouse_inventory OWNER TO dbservice;

--
-- Name: backup_inm_data_09_16; Type: TABLE; Schema: inm_test; Owner: dbservice
--

CREATE TABLE inm_test.backup_inm_data_09_16 (
    id integer,
    import_ts timestamp(6) with time zone,
    kiosk_id integer,
    product_id integer,
    fc_title text,
    qty integer,
    data_type text,
    route_date timestamp(6) with time zone,
    route_name text,
    route_time text,
    driver_name text,
    refrigerated smallint,
    sort_order integer
);


ALTER TABLE inm_test.backup_inm_data_09_16 OWNER TO dbservice;

--
-- Name: broken_product; Type: TABLE; Schema: inm_test; Owner: dbservice
--

CREATE TABLE inm_test.broken_product (
    id bigint,
    title character varying(127),
    description character varying(4095),
    tiny_description character varying(40),
    short_description character varying(100),
    medium_description character varying(400),
    long_description character varying(1200),
    price numeric(5,2),
    cost numeric(5,2),
    shelf_time integer,
    campus_id bigint,
    image smallint,
    image_time bigint,
    last_update bigint,
    archived bigint,
    taxable smallint,
    allergens character varying(255),
    attribute_names character varying(511),
    categories character varying(255),
    category_names character varying(511),
    vendor character varying(135),
    source character varying(135),
    notes character varying(2000),
    total_cal bigint,
    num_servings real,
    ingredients character varying(2000),
    calories real,
    proteins real,
    sugar real,
    carbohydrates real,
    fat real,
    consumer_category character varying(2000),
    ws_case_size bigint,
    kiosk_ship_qty bigint,
    ws_case_cost numeric(5,2),
    pick_station bigint,
    fc_title character varying(255),
    pricing_tier character varying(255),
    width_space real,
    height_space real,
    depth_space real,
    slotted_width real,
    tag_volume bigint,
    delivery_option character varying(255),
    tag_applied_by character varying(255)
);


ALTER TABLE inm_test.broken_product OWNER TO dbservice;

--
-- Name: inm_kiosk_hourly_sale; Type: TABLE; Schema: inm_test; Owner: dbservice
--

CREATE TABLE inm_test.inm_kiosk_hourly_sale (
    key text,
    kiosk_id bigint,
    dow integer,
    hod integer,
    units_sold numeric(28,6)
);


ALTER TABLE inm_test.inm_kiosk_hourly_sale OWNER TO dbservice;

--
-- Name: inm_kiosk_restock; Type: TABLE; Schema: inm_test; Owner: dbservice
--

CREATE TABLE inm_test.inm_kiosk_restock (
    key text,
    kiosk_id bigint,
    dow integer,
    hod integer,
    delivery bigint
);


ALTER TABLE inm_test.inm_kiosk_restock OWNER TO dbservice;

--
-- Name: inm_kiosk_skugroup_sale; Type: TABLE; Schema: inm_test; Owner: dbservice
--

CREATE TABLE inm_test.inm_kiosk_skugroup_sale (
    key text,
    kiosk_id bigint,
    sku_group character varying(765),
    sku_group_contribution numeric(28,6)
);


ALTER TABLE inm_test.inm_kiosk_skugroup_sale OWNER TO dbservice;

--
-- Name: inm_kiosk_weekly_sale; Type: TABLE; Schema: inm_test; Owner: dbservice
--

CREATE TABLE inm_test.inm_kiosk_weekly_sale (
    key text,
    kiosk_id bigint,
    woy integer,
    units_sold bigint
);


ALTER TABLE inm_test.inm_kiosk_weekly_sale OWNER TO dbservice;

--
-- Name: kiosk_20190508; Type: TABLE; Schema: inm_test; Owner: dbservice
--

CREATE TABLE inm_test.kiosk_20190508 (
    id bigint,
    campus_id bigint,
    serial character varying(45),
    title character varying(46),
    address character varying(127),
    location_x numeric(9,6),
    location_y numeric(9,6),
    gcm_id character varying(255),
    app_vname character varying(63),
    app_vcode integer,
    archived bigint,
    creation_time bigint,
    deployment_time bigint,
    last_update bigint,
    client_name character varying(255),
    last_status bigint,
    last_inventory bigint,
    kiosk_name character varying(255),
    payment_start bigint,
    payment_stop bigint,
    features character varying(255),
    sales_tax smallint,
    default_fee_plan bigint,
    timezone character varying(50),
    estd_num_users bigint,
    tags character varying(255),
    publicly_accessible bigint,
    cardkey_required bigint,
    delivery_insns character varying(65535),
    fridge_loc_info character varying(65535),
    contact_first_name character varying(65535),
    contact_last_name character varying(65535),
    contact_email character varying(65535),
    contact_phone character varying(65535),
    accounting_email character varying(65535),
    byte_discount character varying(255),
    subsidy_info character varying(50),
    subsidy_notes character varying(65535),
    max_subscription character varying(50),
    delivery_window_mon character varying(50),
    delivery_window_tue character varying(50),
    delivery_window_wed character varying(50),
    delivery_window_thu character varying(50),
    delivery_window_fri character varying(50),
    delivery_window_sat character varying(50),
    delivery_window_sun character varying(50),
    notes character varying(2000),
    components text,
    email_receipt_subject character varying(255),
    ops_team_notes character varying(65535),
    geo character varying(3),
    server_url character varying(127),
    subscription_amount numeric(8,2),
    enable_reporting bigint,
    enable_monitoring bigint,
    employees_num bigint,
    kiosk_restrictions character varying(2000)
);


ALTER TABLE inm_test.kiosk_20190508 OWNER TO dbservice;

--
-- Name: kiosk_20190531; Type: TABLE; Schema: inm_test; Owner: dbservice
--

CREATE TABLE inm_test.kiosk_20190531 (
    id bigint,
    campus_id bigint,
    serial character varying(45),
    title character varying(46),
    address character varying(127),
    location_x numeric(9,6),
    location_y numeric(9,6),
    gcm_id character varying(255),
    app_vname character varying(63),
    app_vcode integer,
    archived bigint,
    creation_time bigint,
    deployment_time bigint,
    last_update bigint,
    client_name character varying(255),
    last_status bigint,
    last_inventory bigint,
    kiosk_name character varying(255),
    payment_start bigint,
    payment_stop bigint,
    features character varying(255),
    sales_tax smallint,
    default_fee_plan bigint,
    timezone character varying(50),
    estd_num_users bigint,
    tags character varying(255),
    publicly_accessible bigint,
    cardkey_required bigint,
    delivery_insns character varying(65535),
    fridge_loc_info character varying(65535),
    contact_first_name character varying(65535),
    contact_last_name character varying(65535),
    contact_email character varying(65535),
    contact_phone character varying(65535),
    accounting_email character varying(65535),
    byte_discount character varying(255),
    subsidy_info character varying(50),
    subsidy_notes character varying(65535),
    max_subscription character varying(50),
    delivery_window_mon character varying(50),
    delivery_window_tue character varying(50),
    delivery_window_wed character varying(50),
    delivery_window_thu character varying(50),
    delivery_window_fri character varying(50),
    delivery_window_sat character varying(50),
    delivery_window_sun character varying(50),
    notes character varying(2000),
    components text,
    email_receipt_subject character varying(255),
    ops_team_notes character varying(65535),
    geo character varying(3),
    server_url character varying(127),
    subscription_amount numeric(8,2),
    enable_reporting bigint,
    enable_monitoring bigint,
    employees_num bigint,
    kiosk_restrictions character varying(2000)
);


ALTER TABLE inm_test.kiosk_20190531 OWNER TO dbservice;

--
-- Name: kiosk_20190531_test_update; Type: TABLE; Schema: inm_test; Owner: dbservice
--

CREATE TABLE inm_test.kiosk_20190531_test_update (
    id bigint,
    campus_id bigint,
    serial character varying(45),
    title character varying(46),
    address character varying(127),
    location_x numeric(9,6),
    location_y numeric(9,6),
    gcm_id character varying(255),
    app_vname character varying(63),
    app_vcode integer,
    archived bigint,
    creation_time bigint,
    deployment_time bigint,
    last_update bigint,
    client_name character varying(255),
    last_status bigint,
    last_inventory bigint,
    kiosk_name character varying(255),
    payment_start bigint,
    payment_stop bigint,
    features character varying(255),
    sales_tax smallint,
    default_fee_plan bigint,
    timezone character varying(50),
    estd_num_users bigint,
    tags character varying(255),
    publicly_accessible bigint,
    cardkey_required bigint,
    delivery_insns character varying(65535),
    fridge_loc_info character varying(65535),
    contact_first_name character varying(65535),
    contact_last_name character varying(65535),
    contact_email character varying(65535),
    contact_phone character varying(65535),
    accounting_email character varying(65535),
    byte_discount character varying(255),
    subsidy_info character varying(50),
    subsidy_notes character varying(65535),
    max_subscription character varying(50),
    delivery_window_mon character varying(50),
    delivery_window_tue character varying(50),
    delivery_window_wed character varying(50),
    delivery_window_thu character varying(50),
    delivery_window_fri character varying(50),
    delivery_window_sat character varying(50),
    delivery_window_sun character varying(50),
    notes character varying(2000),
    components text,
    email_receipt_subject character varying(255),
    ops_team_notes character varying(65535),
    geo character varying(3),
    server_url character varying(127),
    subscription_amount numeric(8,2),
    enable_reporting bigint,
    enable_monitoring bigint,
    employees_num bigint,
    kiosk_restrictions character varying(2000)
);


ALTER TABLE inm_test.kiosk_20190531_test_update OWNER TO dbservice;

--
-- Name: kiosk_20190810; Type: TABLE; Schema: inm_test; Owner: dbservice
--

CREATE TABLE inm_test.kiosk_20190810 (
    id bigint,
    campus_id bigint,
    serial character varying(45),
    title character varying(46),
    address character varying(127),
    location_x numeric(9,6),
    location_y numeric(9,6),
    gcm_id character varying(255),
    app_vname character varying(63),
    app_vcode integer,
    archived bigint,
    creation_time bigint,
    deployment_time bigint,
    last_update bigint,
    client_name character varying(255),
    last_status bigint,
    last_inventory bigint,
    kiosk_name character varying(255),
    payment_start bigint,
    payment_stop bigint,
    features character varying(255),
    sales_tax smallint,
    default_fee_plan bigint,
    timezone character varying(50),
    estd_num_users bigint,
    tags character varying(255),
    publicly_accessible bigint,
    cardkey_required bigint,
    delivery_insns character varying(65535),
    fridge_loc_info character varying(65535),
    contact_first_name character varying(65535),
    contact_last_name character varying(65535),
    contact_email character varying(65535),
    contact_phone character varying(65535),
    accounting_email character varying(65535),
    byte_discount character varying(255),
    subsidy_info character varying(50),
    subsidy_notes character varying(65535),
    max_subscription character varying(50),
    delivery_window_mon character varying(50),
    delivery_window_tue character varying(50),
    delivery_window_wed character varying(50),
    delivery_window_thu character varying(50),
    delivery_window_fri character varying(50),
    delivery_window_sat character varying(50),
    delivery_window_sun character varying(50),
    notes character varying(2000),
    components text,
    email_receipt_subject character varying(255),
    ops_team_notes character varying(65535),
    geo character varying(3),
    server_url character varying(127),
    subscription_amount numeric(8,2),
    enable_reporting bigint,
    enable_monitoring bigint,
    employees_num bigint,
    kiosk_restrictions character varying(2000)
);


ALTER TABLE inm_test.kiosk_20190810 OWNER TO dbservice;

--
-- Name: kiosk_audit; Type: TABLE; Schema: inm_test; Owner: dbservice
--

CREATE TABLE inm_test.kiosk_audit (
    a text,
    b text,
    kid integer NOT NULL,
    status text,
    e text,
    enable_reporting character(1),
    enable_monitoring character(1)
);


ALTER TABLE inm_test.kiosk_audit OWNER TO dbservice;

--
-- Name: kiosk_par_level; Type: TABLE; Schema: inm_test; Owner: dbservice
--

CREATE TABLE inm_test.kiosk_par_level (
    kiosk_id bigint NOT NULL,
    product_id bigint NOT NULL,
    amount bigint
);


ALTER TABLE inm_test.kiosk_par_level OWNER TO dbservice;

--
-- Name: kiosk_par_level_bkup; Type: TABLE; Schema: inm_test; Owner: dbservice
--

CREATE TABLE inm_test.kiosk_par_level_bkup (
    kiosk_id bigint,
    product_id bigint,
    amount bigint
);


ALTER TABLE inm_test.kiosk_par_level_bkup OWNER TO dbservice;

--
-- Name: kiosk_software; Type: TABLE; Schema: inm_test; Owner: dbservice
--

CREATE TABLE inm_test.kiosk_software (
    id integer NOT NULL,
    app_vname character varying(63),
    components text
);


ALTER TABLE inm_test.kiosk_software OWNER TO dbservice;

--
-- Name: pick_allocation; Type: TABLE; Schema: inm_test; Owner: dbservice
--

CREATE TABLE inm_test.pick_allocation (
    pick_date date NOT NULL,
    route_date date NOT NULL,
    kiosk_id integer NOT NULL,
    sku_id integer NOT NULL,
    qty integer NOT NULL
);


ALTER TABLE inm_test.pick_allocation OWNER TO dbservice;

--
-- Name: pick_demand; Type: TABLE; Schema: inm_test; Owner: dbservice
--

CREATE TABLE inm_test.pick_demand (
    pick_date date NOT NULL,
    route_date date NOT NULL,
    kiosk_id integer NOT NULL,
    sku_group_id integer NOT NULL,
    qty integer NOT NULL
);


ALTER TABLE inm_test.pick_demand OWNER TO dbservice;

--
-- Name: pick_inventory; Type: TABLE; Schema: inm_test; Owner: dbservice
--

CREATE TABLE inm_test.pick_inventory (
    pick_date date NOT NULL,
    route_date date NOT NULL,
    kiosk_id integer NOT NULL,
    sku_group_id integer NOT NULL,
    qty integer NOT NULL
);


ALTER TABLE inm_test.pick_inventory OWNER TO dbservice;

--
-- Name: pick_rejection; Type: TABLE; Schema: inm_test; Owner: dbservice
--

CREATE TABLE inm_test.pick_rejection (
    pick_date date NOT NULL,
    route_date date NOT NULL,
    kiosk_id integer NOT NULL,
    item_id integer NOT NULL,
    item_type character varying(32) NOT NULL,
    reason character varying(64) NOT NULL
);


ALTER TABLE inm_test.pick_rejection OWNER TO dbservice;

--
-- Name: pick_route; Type: TABLE; Schema: inm_test; Owner: dbservice
--

CREATE TABLE inm_test.pick_route (
    pick_date date NOT NULL,
    kiosk_id integer NOT NULL,
    route_number character varying(256),
    driver_name character varying(64) NOT NULL,
    route_time time(6) without time zone NOT NULL,
    route_date date NOT NULL,
    delivery_order smallint NOT NULL
);


ALTER TABLE inm_test.pick_route OWNER TO dbservice;

--
-- Name: pick_substitution; Type: TABLE; Schema: inm_test; Owner: dbservice
--

CREATE TABLE inm_test.pick_substitution (
    substituting_sku_group_id integer NOT NULL,
    substituted_sku_group_id integer NOT NULL,
    qty integer NOT NULL,
    pick_date date NOT NULL
);


ALTER TABLE inm_test.pick_substitution OWNER TO dbservice;

--
-- Name: plan_kiosks; Type: TABLE; Schema: inm_test; Owner: dbservice
--

CREATE TABLE inm_test.plan_kiosks (
    kiosk_id integer,
    route_date_time timestamp(6) with time zone,
    driver_name character varying(8000),
    location_name character varying(8000),
    next_delivery_ts timestamp(6) with time zone,
    time_to_next_delivery interval,
    days_to_next_delivery double precision,
    delivery_order bigint
);


ALTER TABLE inm_test.plan_kiosks OWNER TO dbservice;

--
-- Name: product_20190508; Type: TABLE; Schema: inm_test; Owner: dbservice
--

CREATE TABLE inm_test.product_20190508 (
    id bigint,
    title character varying(127),
    description character varying(4095),
    tiny_description character varying(40),
    short_description character varying(100),
    medium_description character varying(400),
    long_description character varying(1200),
    price numeric(5,2),
    cost numeric(5,2),
    shelf_time integer,
    campus_id bigint,
    image smallint,
    image_time bigint,
    last_update bigint,
    archived bigint,
    taxable smallint,
    allergens character varying(255),
    attribute_names character varying(511),
    categories character varying(255),
    category_names character varying(511),
    vendor character varying(135),
    source character varying(135),
    notes character varying(2000),
    total_cal bigint,
    num_servings real,
    ingredients character varying(2000),
    calories real,
    proteins real,
    sugar real,
    carbohydrates real,
    fat real,
    consumer_category character varying(2000),
    ws_case_size bigint,
    kiosk_ship_qty bigint,
    ws_case_cost numeric(5,2),
    pick_station bigint,
    fc_title character varying(255),
    pricing_tier character varying(255),
    width_space real,
    height_space real,
    depth_space real,
    slotted_width real,
    tag_volume bigint,
    delivery_option character varying(255),
    tag_applied_by character varying(255)
);


ALTER TABLE inm_test.product_20190508 OWNER TO dbservice;

--
-- Name: product_20190514; Type: TABLE; Schema: inm_test; Owner: dbservice
--

CREATE TABLE inm_test.product_20190514 (
    id bigint,
    title character varying(127),
    description character varying(4095),
    tiny_description character varying(40),
    short_description character varying(100),
    medium_description character varying(400),
    long_description character varying(1200),
    price numeric(5,2),
    cost numeric(5,2),
    shelf_time integer,
    campus_id bigint,
    image smallint,
    image_time bigint,
    last_update bigint,
    archived bigint,
    taxable smallint,
    allergens character varying(255),
    attribute_names character varying(511),
    categories character varying(255),
    category_names character varying(511),
    vendor character varying(135),
    source character varying(135),
    notes character varying(2000),
    total_cal bigint,
    num_servings real,
    ingredients character varying(2000),
    calories real,
    proteins real,
    sugar real,
    carbohydrates real,
    fat real,
    consumer_category character varying(2000),
    ws_case_size bigint,
    kiosk_ship_qty bigint,
    ws_case_cost numeric(5,2),
    pick_station bigint,
    fc_title character varying(255),
    pricing_tier character varying(255),
    width_space real,
    height_space real,
    depth_space real,
    slotted_width real,
    tag_volume bigint,
    delivery_option character varying(255),
    tag_applied_by character varying(255)
);


ALTER TABLE inm_test.product_20190514 OWNER TO dbservice;

--
-- Name: restricted; Type: TABLE; Schema: inm_test; Owner: dbservice
--

CREATE TABLE inm_test.restricted (
    kid integer NOT NULL,
    sku_id integer NOT NULL
);


ALTER TABLE inm_test.restricted OWNER TO dbservice;

--
-- Name: route_stop; Type: TABLE; Schema: inm_test; Owner: dbservice
--

CREATE TABLE inm_test.route_stop (
    route_date_time timestamp(6) with time zone,
    driver_name character varying(200),
    location_name character varying(200),
    schedule_at timestamp(6) with time zone,
    longitude numeric(28,6),
    address character varying(200),
    latitude numeric(28,6),
    stop_number integer,
    order_number character varying(200),
    location_number integer
);


ALTER TABLE inm_test.route_stop OWNER TO dbservice;

--
-- Name: tag_2019_05_15; Type: TABLE; Schema: inm_test; Owner: dbservice
--

CREATE TABLE inm_test.tag_2019_05_15 (
    id bigint,
    tag character varying(100)
);


ALTER TABLE inm_test.tag_2019_05_15 OWNER TO dbservice;

--
-- Name: temp_kiosk; Type: TABLE; Schema: inm_test; Owner: dbservice
--

CREATE TABLE inm_test.temp_kiosk (
    id bigint,
    campus_id bigint,
    serial character varying(45),
    title character varying(46),
    address character varying(127),
    location_x numeric(9,6),
    location_y numeric(9,6),
    gcm_id character varying(255),
    app_vname character varying(63),
    app_vcode integer,
    archived bigint,
    creation_time bigint,
    deployment_time bigint,
    last_update bigint,
    client_name character varying(255),
    last_status bigint,
    last_inventory bigint,
    kiosk_name character varying(255),
    payment_start bigint,
    payment_stop bigint,
    features character varying(255),
    sales_tax smallint,
    default_fee_plan bigint,
    timezone character varying(50),
    estd_num_users bigint,
    tags character varying(255),
    publicly_accessible bigint,
    cardkey_required bigint,
    delivery_insns character varying(65535),
    fridge_loc_info character varying(65535),
    contact_first_name character varying(65535),
    contact_last_name character varying(65535),
    contact_email character varying(65535),
    contact_phone character varying(65535),
    accounting_email character varying(65535),
    byte_discount character varying(255),
    subsidy_info character varying(50),
    subsidy_notes character varying(65535),
    max_subscription character varying(50),
    delivery_window_mon character varying(50),
    delivery_window_tue character varying(50),
    delivery_window_wed character varying(50),
    delivery_window_thu character varying(50),
    delivery_window_fri character varying(50),
    delivery_window_sat character varying(50),
    delivery_window_sun character varying(50),
    notes character varying(2000),
    components text,
    email_receipt_subject character varying(255),
    ops_team_notes character varying(65535),
    geo character varying(3),
    server_url character varying(127),
    subscription_amount numeric(8,2),
    enable_reporting bigint,
    enable_monitoring bigint,
    employees_num bigint,
    kiosk_restrictions character varying(2000)
);


ALTER TABLE inm_test.temp_kiosk OWNER TO dbservice;

--
-- Name: test; Type: TABLE; Schema: inm_test; Owner: dbservice
--

CREATE TABLE inm_test.test (
    id integer NOT NULL
);


ALTER TABLE inm_test.test OWNER TO dbservice;

--
-- Name: test_hours; Type: TABLE; Schema: inm_test; Owner: dbservice
--

CREATE TABLE inm_test.test_hours (
    h smallint NOT NULL
);


ALTER TABLE inm_test.test_hours OWNER TO dbservice;

--
-- Name: facing_category; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.facing_category (
    id bigint NOT NULL,
    title character varying(765) NOT NULL,
    shelf_level bigint,
    sku_count bigint,
    min_slotted bigint,
    max_slotted bigint,
    mixed_slotted bigint
);


ALTER TABLE pantry.facing_category OWNER TO dbservice;

--
-- Name: facing_category_v1; Type: VIEW; Schema: iplanner; Owner: dbservice
--

CREATE VIEW iplanner.facing_category_v1 AS
 SELECT facing_category.id,
    facing_category.title,
    facing_category.shelf_level,
    facing_category.sku_count,
    facing_category.min_slotted,
    facing_category.max_slotted,
    facing_category.mixed_slotted
   FROM pantry.facing_category;


ALTER TABLE iplanner.facing_category_v1 OWNER TO dbservice;

--
-- Name: insync_kiosk_v1; Type: VIEW; Schema: iplanner; Owner: dbservice
--

CREATE VIEW iplanner.insync_kiosk_v1 AS
 SELECT kiosk.id,
    kiosk.campus_id,
    kiosk.title,
    kiosk.address,
    kiosk.location_x,
    kiosk.location_y,
    kiosk.archived,
    kiosk.creation_time,
    kiosk.deployment_time,
    kiosk.last_update,
    kiosk.client_name,
    kiosk.last_inventory,
    kiosk.kiosk_name,
    kiosk.payment_start,
    kiosk.payment_stop,
    kiosk.timezone,
    kiosk.estd_num_users,
    kiosk.delivery_window_mon,
    kiosk.delivery_window_tue,
    kiosk.delivery_window_wed,
    kiosk.delivery_window_thu,
    kiosk.delivery_window_fri,
    kiosk.delivery_window_sat,
    kiosk.delivery_window_sun,
    kiosk.geo,
    kiosk.kiosk_restrictions
   FROM pantry.kiosk
  WHERE ((kiosk.campus_id = 87) AND (kiosk.archived <> 1) AND ((kiosk.title)::text !~~* 'test%'::text) AND ((kiosk.title)::text !~~* 'burn%'::text));


ALTER TABLE iplanner.insync_kiosk_v1 OWNER TO dbservice;

--
-- Name: card_fact; Type: TABLE; Schema: mixalot; Owner: dbservice
--

CREATE TABLE mixalot.card_fact (
    id integer NOT NULL,
    hash text,
    first_name text,
    last_name text,
    email text,
    first_order_id text,
    first_order_ts timestamp(6) with time zone,
    first_order_num_items integer,
    first_order_sales_price double precision,
    first_order_list_price double precision,
    first_order_discount_amt double precision,
    last_order_id text,
    last_order_ts timestamp(6) with time zone,
    last_order_num_items integer,
    last_order_sales_price double precision,
    last_order_list_price double precision,
    last_order_discount_amt double precision,
    avg_order_list_price double precision,
    avg_order_num_items double precision,
    kiosk_ids text,
    user_cat text,
    cac double precision,
    acc_lt_total double precision,
    acc_lt_discount double precision,
    cnt_lt_orders integer,
    cnt_lt_voided integer,
    dow_0_pct double precision,
    dow_1_pct double precision,
    dow_2_pct double precision,
    dow_3_pct double precision,
    dow_4_pct double precision,
    dow_5_pct double precision,
    dow_6_pct double precision
);


ALTER TABLE mixalot.card_fact OWNER TO dbservice;

--
-- Name: card_fact_id_seq; Type: SEQUENCE; Schema: mixalot; Owner: dbservice
--

CREATE SEQUENCE mixalot.card_fact_id_seq
CREATE SEQUENCE mixalot.card_fact_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE mixalot.card_fact_id_seq OWNER TO dbservice;

--
-- Name: card_fact_id_seq; Type: SEQUENCE OWNED BY; Schema: mixalot; Owner: dbservice
--

ALTER SEQUENCE mixalot.card_fact_id_seq OWNED BY mixalot.card_fact.id;


--
-- Name: card_product_fact; Type: TABLE; Schema: mixalot; Owner: dbservice
--

CREATE TABLE mixalot.card_product_fact (
    id integer NOT NULL,
    card_hash text,
    product_id integer,
    sku text,
    first_available_ts timestamp(6) with time zone,
    first_purchased_ts timestamp(6) with time zone,
    acc_sales_1w double precision,
    acc_sales_30d double precision,
    acc_sales_6m double precision,
    avg_item_price double precision,
    avg_item_discount double precision,
    cnt_purchases_lt integer,
    cnt_purchased_30d integer,
    cnt_purchased_6m integer,
    cnt_purchased_1y integer,
    prob_purch_first double precision,
    prob_purch_again double precision,
    number_not_purchased_before_1st integer,
    number_available_lt integer,
    number_not_purchased_lt integer,
    number_available_after_1st integer,
    number_not_purchased_after_1st integer,
    number_stockouts_after_1st integer
);


ALTER TABLE mixalot.card_product_fact OWNER TO dbservice;

--
-- Name: card_product_fact_id_seq; Type: SEQUENCE; Schema: mixalot; Owner: dbservice
--

CREATE SEQUENCE mixalot.card_product_fact_id_seq
CREATE SEQUENCE mixalot.card_product_fact_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE mixalot.card_product_fact_id_seq OWNER TO dbservice;

--
-- Name: card_product_fact_id_seq; Type: SEQUENCE OWNED BY; Schema: mixalot; Owner: dbservice
--

ALTER SEQUENCE mixalot.card_product_fact_id_seq OWNED BY mixalot.card_product_fact.id;


--
-- Name: discount_rule; Type: TABLE; Schema: mixalot; Owner: dbservice
--

CREATE TABLE mixalot.discount_rule (
    id character varying(25) NOT NULL,
    create_d timestamp(6) without time zone NOT NULL,
    update_d timestamp(6) without time zone NOT NULL,
    hash character varying(32) NOT NULL,
    json text NOT NULL,
    repeat_count integer NOT NULL,
    repeat_cycle timestamp(6) without time zone NOT NULL
);


ALTER TABLE mixalot.discount_rule OWNER TO dbservice;

--
-- Name: gsheet_cache; Type: TABLE; Schema: mixalot; Owner: dbservice
--

CREATE TABLE mixalot.gsheet_cache (
    id character varying(50) NOT NULL,
    update_d timestamp(6) with time zone,
    email_count integer,
    email_json text,
    payload json
);


ALTER TABLE mixalot.gsheet_cache OWNER TO dbservice;

--
-- Name: gsheets_kiosk_restriction; Type: TABLE; Schema: mixalot; Owner: dbservice
--

CREATE TABLE mixalot.gsheets_kiosk_restriction (
    kiosk_id integer NOT NULL,
    restriction character varying(512) NOT NULL
);


ALTER TABLE mixalot.gsheets_kiosk_restriction OWNER TO dbservice;

--
-- Name: history_order_pipeline; Type: TABLE; Schema: mixalot; Owner: dbservice
--

CREATE TABLE mixalot.history_order_pipeline (
    id integer NOT NULL,
    order_id character varying(45),
    action character varying(45),
    system character varying(45),
    "user" character varying(45),
    data text,
    ts timestamp(6) with time zone
);


ALTER TABLE mixalot.history_order_pipeline OWNER TO dbservice;

--
-- Name: history_order_id_seq; Type: SEQUENCE; Schema: mixalot; Owner: dbservice
--

CREATE SEQUENCE mixalot.history_order_id_seq
CREATE SEQUENCE mixalot.history_order_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE mixalot.history_order_id_seq OWNER TO dbservice;

--
-- Name: history_order_id_seq; Type: SEQUENCE OWNED BY; Schema: mixalot; Owner: dbservice
--

ALTER SEQUENCE mixalot.history_order_id_seq OWNED BY mixalot.history_order_pipeline.id;


--
-- Name: inm_byte_kiosk; Type: VIEW; Schema: mixalot; Owner: dbservice
--

CREATE VIEW mixalot.inm_byte_kiosk AS
 SELECT kiosk.id,
    kiosk.campus_id,
    kiosk.title,
    kiosk.address
   FROM pantry.kiosk
  WHERE ((kiosk.archived <> 0) AND (kiosk.campus_id = 87));


ALTER TABLE mixalot.inm_byte_kiosk OWNER TO dbservice;

--
-- Name: inm_data; Type: TABLE; Schema: mixalot; Owner: dbservice
--

CREATE TABLE mixalot.inm_data (
    id integer NOT NULL,
    import_ts timestamp(6) with time zone,
    kiosk_id integer,
    product_id integer,
    fc_title text,
    qty integer,
    data_type text,
    route_date timestamp(6) with time zone,
    route_name text,
    route_time text,
    driver_name text,
    refrigerated smallint,
    sort_order integer
);


ALTER TABLE mixalot.inm_data OWNER TO dbservice;

--
-- Name: inm_data_id_seq; Type: SEQUENCE; Schema: mixalot; Owner: dbservice
--

CREATE SEQUENCE mixalot.inm_data_id_seq
CREATE SEQUENCE mixalot.inm_data_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE mixalot.inm_data_id_seq OWNER TO dbservice;

--
-- Name: inm_data_id_seq; Type: SEQUENCE OWNED BY; Schema: mixalot; Owner: dbservice
--

ALTER SEQUENCE mixalot.inm_data_id_seq OWNED BY mixalot.inm_data.id;


--
-- Name: merchandising_slot_sku_group; Type: TABLE; Schema: mixalot; Owner: dbservice
--

CREATE TABLE mixalot.merchandising_slot_sku_group (
    sku_group_id integer NOT NULL,
    merchandising_slot_id integer NOT NULL
);


ALTER TABLE mixalot.merchandising_slot_sku_group OWNER TO dbservice;

--
-- Name: TABLE merchandising_slot_sku_group; Type: COMMENT; Schema: mixalot; Owner: dbservice
--

COMMENT ON TABLE mixalot.merchandising_slot_sku_group IS 'store all the sku groups for each merchandising slot';


--
-- Name: sku_group_def; Type: TABLE; Schema: mixalot; Owner: dbservice
--

CREATE TABLE mixalot.sku_group_def (
    id integer NOT NULL,
    title character varying(512) NOT NULL,
    volume numeric(4,2)
);


ALTER TABLE mixalot.sku_group_def OWNER TO dbservice;

--
-- Name: TABLE sku_group_def; Type: COMMENT; Schema: mixalot; Owner: dbservice
--

COMMENT ON TABLE mixalot.sku_group_def IS 'sku group id''s and names';


--
-- Name: sku_group_sku; Type: TABLE; Schema: mixalot; Owner: dbservice
--

CREATE TABLE mixalot.sku_group_sku (
    sku_id integer NOT NULL,
    sku_group_id integer NOT NULL
);


ALTER TABLE mixalot.sku_group_sku OWNER TO dbservice;

--
-- Name: TABLE sku_group_sku; Type: COMMENT; Schema: mixalot; Owner: dbservice
--

COMMENT ON TABLE mixalot.sku_group_sku IS 'store SKUs for each sku_group';


--
-- Name: inm_dc_inventory; Type: VIEW; Schema: mixalot; Owner: dbservice
--

CREATE VIEW mixalot.inm_dc_inventory AS
 SELECT dc_sku.product_id AS sku_id,
    sku_group.sku_group_id,
    sgd.title AS sku_group_title,
    ms.merchandising_slot_id,
    dc_sku.qty,
    dc_sku.sort_order,
    dc_sku.import_ts
   FROM (((mixalot.inm_data dc_sku
     JOIN mixalot.sku_group_sku sku_group ON ((dc_sku.product_id = sku_group.sku_id)))
     JOIN mixalot.merchandising_slot_sku_group ms ON ((sku_group.sku_group_id = ms.sku_group_id)))
     JOIN mixalot.sku_group_def sgd ON ((sku_group.sku_group_id = sgd.id)))
  WHERE ((dc_sku.data_type = 'Warehouse SKU Inventory'::text) AND (dc_sku.import_ts = ( SELECT max(dc_sku_1.import_ts) AS max
           FROM mixalot.inm_data dc_sku_1
          WHERE (dc_sku_1.data_type = 'Warehouse SKU Inventory'::text))));


ALTER TABLE mixalot.inm_dc_inventory OWNER TO dbservice;

--
-- Name: inm_demand; Type: VIEW; Schema: mixalot; Owner: dbservice
--

CREATE VIEW mixalot.inm_demand AS
 SELECT demand.kiosk_id,
    demand.fc_title,
    demand.qty
   FROM mixalot.inm_data demand
  WHERE ((demand.data_type = 'Plan Demand'::text) AND (demand.qty > 0) AND (demand.import_ts = ( SELECT max(dc_sku.import_ts) AS max
           FROM mixalot.inm_data dc_sku
          WHERE (dc_sku.data_type = 'Plan Demand'::text))));


ALTER TABLE mixalot.inm_demand OWNER TO dbservice;

--
-- Name: inm_gsheets_kiosk_restriction; Type: TABLE; Schema: mixalot; Owner: dbservice
--

CREATE TABLE mixalot.inm_gsheets_kiosk_restriction (
    kiosk_id integer NOT NULL,
    restriction character varying(512) NOT NULL
);


ALTER TABLE mixalot.inm_gsheets_kiosk_restriction OWNER TO dbservice;

--
-- Name: inm_kiosk_restriction_list; Type: VIEW; Schema: mixalot; Owner: dbservice
--

CREATE VIEW mixalot.inm_kiosk_restriction_list AS
 SELECT gsheets_kiosk_restriction.kiosk_id,
    string_agg((gsheets_kiosk_restriction.restriction)::text, ','::text) AS restrictions
   FROM mixalot.gsheets_kiosk_restriction
  GROUP BY gsheets_kiosk_restriction.kiosk_id;


ALTER TABLE mixalot.inm_kiosk_restriction_list OWNER TO dbservice;

--
-- Name: kiosk_restriction_by_property; Type: TABLE; Schema: mixalot; Owner: dbservice
--

CREATE TABLE mixalot.kiosk_restriction_by_property (
    kiosk_id integer NOT NULL,
    property_id integer NOT NULL
);


ALTER TABLE mixalot.kiosk_restriction_by_property OWNER TO dbservice;

--
-- Name: kiosk_restriction_by_sku; Type: TABLE; Schema: mixalot; Owner: dbservice
--

CREATE TABLE mixalot.kiosk_restriction_by_sku (
    kiosk_id integer NOT NULL,
    sku_id integer NOT NULL
);


ALTER TABLE mixalot.kiosk_restriction_by_sku OWNER TO dbservice;

--
-- Name: sku_def; Type: TABLE; Schema: mixalot; Owner: dbservice
--

CREATE TABLE mixalot.sku_def (
    id integer NOT NULL,
    title character varying(512) NOT NULL
);


ALTER TABLE mixalot.sku_def OWNER TO dbservice;

--
-- Name: TABLE sku_def; Type: COMMENT; Schema: mixalot; Owner: dbservice
--

COMMENT ON TABLE mixalot.sku_def IS 'SKUs id''s and names';


--
-- Name: sku_property; Type: TABLE; Schema: mixalot; Owner: dbservice
--

CREATE TABLE mixalot.sku_property (
    sku_id integer NOT NULL,
    property_id integer NOT NULL
);


ALTER TABLE mixalot.sku_property OWNER TO dbservice;

--
-- Name: TABLE sku_property; Type: COMMENT; Schema: mixalot; Owner: dbservice
--

COMMENT ON TABLE mixalot.sku_property IS 'all the properties for each sku';


--
-- Name: sku_property_def; Type: TABLE; Schema: mixalot; Owner: dbservice
--

CREATE TABLE mixalot.sku_property_def (
    id integer NOT NULL,
    attribute character varying(256),
    title character varying(512) NOT NULL
);


ALTER TABLE mixalot.sku_property_def OWNER TO dbservice;

--
-- Name: TABLE sku_property_def; Type: COMMENT; Schema: mixalot; Owner: dbservice
--

COMMENT ON TABLE mixalot.sku_property_def IS 'property_id, attribute, value.
Example:
1234 | container | glass
1235 | allergen | peanut
';


--
-- Name: inm_kiosk_sku_disabled; Type: VIEW; Schema: mixalot; Owner: dbservice
--

CREATE VIEW mixalot.inm_kiosk_sku_disabled AS
 SELECT DISTINCT krbp.kiosk_id,
    sd.id AS sku_id
   FROM (((mixalot.sku_def sd
     JOIN mixalot.sku_property sp ON ((sd.id = sp.sku_id)))
     JOIN mixalot.sku_property_def spd ON ((sp.property_id = spd.id)))
     JOIN mixalot.kiosk_restriction_by_property krbp ON ((krbp.property_id = spd.id)))
UNION
 SELECT DISTINCT kiosk_restriction_by_sku.kiosk_id,
    kiosk_restriction_by_sku.sku_id
   FROM mixalot.kiosk_restriction_by_sku;


ALTER TABLE mixalot.inm_kiosk_sku_disabled OWNER TO dbservice;

--
-- Name: inm_sku_enabled; Type: VIEW; Schema: mixalot; Owner: dbservice
--

CREATE VIEW mixalot.inm_sku_enabled AS
 SELECT k.id AS kiosk_id,
    s.id AS sku_id
   FROM ((mixalot.inm_byte_kiosk k
     CROSS JOIN mixalot.sku_def s)
     LEFT JOIN mixalot.inm_kiosk_sku_disabled d ON (((k.id = d.kiosk_id) AND (s.id = d.sku_id))))
  WHERE ((d.kiosk_id IS NULL) AND (d.sku_id IS NULL));


ALTER TABLE mixalot.inm_sku_enabled OWNER TO dbservice;

--
-- Name: inm_sku_group_title_to_merchandising_slot; Type: VIEW; Schema: mixalot; Owner: dbservice
--

CREATE VIEW mixalot.inm_sku_group_title_to_merchandising_slot AS
 SELECT sgd.title AS sku_group_title,
    mssg.merchandising_slot_id
   FROM (mixalot.merchandising_slot_sku_group mssg
     JOIN mixalot.sku_group_def sgd ON ((mssg.sku_group_id = sgd.id)))
  ORDER BY mssg.merchandising_slot_id;


ALTER TABLE mixalot.inm_sku_group_title_to_merchandising_slot OWNER TO dbservice;

--
-- Name: kiosk; Type: TABLE; Schema: mixalot; Owner: dbservice
--

CREATE TABLE mixalot.kiosk (
    kiosk_id integer NOT NULL,
    gcm_id text,
    app_vname text,
    app_vcode text,
    last_login timestamp(6) with time zone,
    last_update timestamp(6) with time zone,
    last_inventory timestamp(6) with time zone,
    last_status timestamp(6) with time zone,
    components json
);


ALTER TABLE mixalot.kiosk OWNER TO dbservice;

--
-- Name: kiosk_contents; Type: TABLE; Schema: mixalot; Owner: dbservice
--

CREATE TABLE mixalot.kiosk_contents (
    id integer NOT NULL,
    product_id integer,
    quantity integer,
    "time" bigint
);


ALTER TABLE mixalot.kiosk_contents OWNER TO dbservice;

--
-- Name: kiosk_contents_id_seq; Type: SEQUENCE; Schema: mixalot; Owner: dbservice
--

CREATE SEQUENCE mixalot.kiosk_contents_id_seq
CREATE SEQUENCE mixalot.kiosk_contents_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE mixalot.kiosk_contents_id_seq OWNER TO dbservice;

--
-- Name: kiosk_contents_id_seq; Type: SEQUENCE OWNED BY; Schema: mixalot; Owner: dbservice
--

ALTER SEQUENCE mixalot.kiosk_contents_id_seq OWNED BY mixalot.kiosk_contents.id;


--
-- Name: kiosk_fact; Type: TABLE; Schema: mixalot; Owner: dbservice
--

CREATE TABLE mixalot.kiosk_fact (
    id integer NOT NULL,
    kiosk_id integer,
    kiosk_title text,
    campus_id integer,
    serials text,
    current_serial text,
    archived integer,
    last_delivery_ts timestamp(6) with time zone,
    last_purchase_ts timestamp(6) with time zone,
    cnt_deliveries_1w double precision,
    cnt_deliveries_30d double precision,
    cnt_deliveries_6m double precision,
    acc_list_price_1w double precision,
    acc_list_price_30d double precision,
    acc_list_price_6m double precision,
    cnt_orders_1w double precision,
    cnt_orders_30d double precision,
    cnt_orders_6m double precision,
    cnt_unique_cards_1w double precision,
    cnt_unique_cards_30d double precision,
    cnt_unique_cards_6m double precision
);


ALTER TABLE mixalot.kiosk_fact OWNER TO dbservice;

--
-- Name: kiosk_fact_id_seq; Type: SEQUENCE; Schema: mixalot; Owner: dbservice
--

CREATE SEQUENCE mixalot.kiosk_fact_id_seq
CREATE SEQUENCE mixalot.kiosk_fact_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE mixalot.kiosk_fact_id_seq OWNER TO dbservice;

--
-- Name: kiosk_fact_id_seq; Type: SEQUENCE OWNED BY; Schema: mixalot; Owner: dbservice
--

ALTER SEQUENCE mixalot.kiosk_fact_id_seq OWNED BY mixalot.kiosk_fact.id;


--
-- Name: kiosk_restriction; Type: TABLE; Schema: mixalot; Owner: dbservice
--

CREATE TABLE mixalot.kiosk_restriction (
    kiosk_id integer NOT NULL,
    sku_id integer NOT NULL
);


ALTER TABLE mixalot.kiosk_restriction OWNER TO dbservice;

--
-- Name: request_log; Type: TABLE; Schema: mixalot; Owner: dbservice
--

CREATE TABLE mixalot.request_log (
    request_uuid uuid NOT NULL,
    endpoint text,
    client_ip text,
    version text,
    cookie text,
    message text,
    request_body text,
    request_headers text,
    start_ts timestamp(6) with time zone,
    response_body text,
    response_headers text,
    status_code integer,
    end_ts timestamp(6) with time zone,
    traceback text,
    request_body_json text,
    request_headers_json text,
    response_headers_json text,
    kiosk_id character varying(50),
    source text,
    flushed timestamp(6) with time zone,
    order_id character varying(135),
    stamp bigint,
    "time" bigint,
    kid bigint,
    client_time timestamp(6) with time zone,
    rec_version integer,
    query_string text
);


ALTER TABLE mixalot.request_log OWNER TO dbservice;

--
-- Name: kiosk_status; Type: VIEW; Schema: mixalot; Owner: dbservice
--

CREATE VIEW mixalot.kiosk_status AS
 SELECT l.kiosk_id AS auth_token_kiosk_id,
    l.start_ts AS server_time,
    to_timestamp(((((l.request_body_json)::json ->> 'time'::text))::integer)::double precision) AS "time",
    ((l.request_body_json)::json ->> 'kiosk_id'::text) AS kiosk_id,
    ((l.request_body_json)::json ->> 'retry_queue_length'::text) AS retry_queue_length,
    ((l.request_body_json)::json ->> 'retry_count'::text) AS retry_count,
    ((l.request_body_json)::json ->> 'happy_hour'::text) AS happy_hour,
    ((l.request_body_json)::json ->> 'app_uptime'::text) AS app_uptime,
    ((l.request_body_json)::json ->> 'system_uptime'::text) AS system_uptime,
    ((l.request_body_json)::json ->> 'kiosk_temperature'::text) AS kiosk_temperature,
    ((l.request_body_json)::json ->> 'kit_temperature'::text) AS kit_temperature,
    ((l.request_body_json)::json ->> 'power'::text) AS power,
    ((l.request_body_json)::json ->> 'battery_level'::text) AS battery_level,
    ((l.request_body_json)::json ->> 'rfid_0'::text) AS rfid_0,
    ((l.request_body_json)::json ->> 'rfid_1'::text) AS rfid_1,
    ((l.request_body_json)::json ->> 'rfid_2'::text) AS rfid_2,
    ((l.request_body_json)::json ->> 'rfid_3'::text) AS rfid_3,
    ((l.request_body_json)::json ->> 'rfid_4'::text) AS rfid_4,
    ((l.request_body_json)::json ->> 'rfid_5'::text) AS rfid_5,
    ((l.request_body_json)::json ->> 'rfid_6'::text) AS rfid_6,
    ((l.request_body_json)::json ->> 'rfid_7'::text) AS rfid_7
   FROM mixalot.request_log l
  WHERE ((((l.request_headers_json)::json ->> 'User-Agent'::text) !~~ '%monitis%'::text) AND (l.endpoint = '/status'::text))
  ORDER BY l.start_ts;


ALTER TABLE mixalot.kiosk_status OWNER TO dbservice;

--
-- Name: last_kiosk_status; Type: TABLE; Schema: mixalot; Owner: dbservice
--

CREATE TABLE mixalot.last_kiosk_status (
    id bigint NOT NULL,
    kiosk_id bigint NOT NULL,
    kiosk_temperature numeric(6,3),
    kiosk_temperature_count smallint,
    kit_temperature numeric(6,3),
    temperature_tags character varying(6141),
    kiosk_temperature_source character varying(93),
    power integer,
    battery_level smallint,
    rfid_0 integer,
    rfid_1 integer,
    rfid_2 integer,
    rfid_3 integer,
    rfid_4 integer,
    rfid_5 integer,
    rfid_6 integer,
    rfid_7 integer,
    "time" bigint,
    modem_signal_percentage smallint,
    modem_signal_type character varying(81),
    ip character varying(135),
    app_uptime bigint,
    system_uptime bigint,
    is_locked smallint
);


ALTER TABLE mixalot.last_kiosk_status OWNER TO dbservice;

--
-- Name: tmp_unit; Type: TABLE; Schema: mixalot; Owner: dbservice
--

CREATE TABLE mixalot.tmp_unit (
    id integer NOT NULL,
    order_id character varying(135),
    epc character varying(135),
    product_id integer,
    name text,
    discounts json,
    price numeric(28,6),
    list_price numeric(28,6),
    cost numeric(28,6),
    create_dt timestamp(6) with time zone,
    modify_dt timestamp(6) with time zone
);


ALTER TABLE mixalot.tmp_unit OWNER TO dbservice;

--
-- Name: lineitem_id_seq; Type: SEQUENCE; Schema: mixalot; Owner: dbservice
--

CREATE SEQUENCE mixalot.lineitem_id_seq
CREATE SEQUENCE mixalot.lineitem_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE mixalot.lineitem_id_seq OWNER TO dbservice;

--
-- Name: lineitem_id_seq; Type: SEQUENCE OWNED BY; Schema: mixalot; Owner: dbservice
--

ALTER SEQUENCE mixalot.lineitem_id_seq OWNED BY mixalot.tmp_unit.id;


--
-- Name: log; Type: TABLE; Schema: mixalot; Owner: dbservice
--

CREATE TABLE mixalot.log (
    id integer NOT NULL,
    request_uuid uuid,
    endpoint text,
    version text,
    system text,
    subsystem text,
    ts timestamp(6) with time zone,
    message text,
    herenow text,
    traceback text,
    kiosk_id integer,
    order_id character varying(135),
    product_id integer,
    epc text,
    client_ip text,
    attributes json
);


ALTER TABLE mixalot.log OWNER TO dbservice;

--
-- Name: log_id_seq; Type: SEQUENCE; Schema: mixalot; Owner: dbservice
--

CREATE SEQUENCE mixalot.log_id_seq
CREATE SEQUENCE mixalot.log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE mixalot.log_id_seq OWNER TO dbservice;

--
-- Name: log_id_seq; Type: SEQUENCE OWNED BY; Schema: mixalot; Owner: dbservice
--

ALTER SEQUENCE mixalot.log_id_seq OWNED BY mixalot.log.id;


--
-- Name: merchandising_slot; Type: TABLE; Schema: mixalot; Owner: dbservice
--

CREATE TABLE mixalot.merchandising_slot (
    id integer NOT NULL,
    title character varying(512) NOT NULL
);


ALTER TABLE mixalot.merchandising_slot OWNER TO dbservice;

--
-- Name: merchandising_slot_def; Type: TABLE; Schema: mixalot; Owner: dbservice
--

CREATE TABLE mixalot.merchandising_slot_def (
    id integer NOT NULL,
    title character varying(512) NOT NULL
);


ALTER TABLE mixalot.merchandising_slot_def OWNER TO dbservice;

--
-- Name: merchandising_slot_def_id_seq; Type: SEQUENCE; Schema: mixalot; Owner: dbservice
--

CREATE SEQUENCE mixalot.merchandising_slot_def_id_seq
CREATE SEQUENCE mixalot.merchandising_slot_def_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE mixalot.merchandising_slot_def_id_seq OWNER TO dbservice;

--
-- Name: merchandising_slot_def_id_seq; Type: SEQUENCE OWNED BY; Schema: mixalot; Owner: dbservice
--

ALTER SEQUENCE mixalot.merchandising_slot_def_id_seq OWNED BY mixalot.merchandising_slot_def.id;


--
-- Name: merchandising_slot_id_seq; Type: SEQUENCE; Schema: mixalot; Owner: dbservice
--

CREATE SEQUENCE mixalot.merchandising_slot_id_seq
CREATE SEQUENCE mixalot.merchandising_slot_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE mixalot.merchandising_slot_id_seq OWNER TO dbservice;

--
-- Name: merchandising_slot_id_seq; Type: SEQUENCE OWNED BY; Schema: mixalot; Owner: dbservice
--

ALTER SEQUENCE mixalot.merchandising_slot_id_seq OWNED BY mixalot.merchandising_slot.id;


--
-- Name: order_fact; Type: TABLE; Schema: mixalot; Owner: dbservice
--

CREATE TABLE mixalot.order_fact (
    id integer NOT NULL,
    order_id text,
    hash text,
    email text,
    first_name text,
    last_name text,
    kiosk_id integer,
    kiosk_title text,
    campus_id integer,
    sales_price double precision,
    list_price double precision,
    contents_id integer
);


ALTER TABLE mixalot.order_fact OWNER TO dbservice;

--
-- Name: order_fact_id_seq; Type: SEQUENCE; Schema: mixalot; Owner: dbservice
--

CREATE SEQUENCE mixalot.order_fact_id_seq
CREATE SEQUENCE mixalot.order_fact_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE mixalot.order_fact_id_seq OWNER TO dbservice;

--
-- Name: order_fact_id_seq; Type: SEQUENCE OWNED BY; Schema: mixalot; Owner: dbservice
--

ALTER SEQUENCE mixalot.order_fact_id_seq OWNED BY mixalot.order_fact.id;


--
-- Name: pgdu_bytes; Type: VIEW; Schema: mixalot; Owner: dbservice
--

CREATE VIEW mixalot.pgdu_bytes AS
 SELECT all_tables.table_name,
    pg_table_size((all_tables.table_name)::regclass) AS table_size,
    pg_indexes_size((all_tables.table_name)::regclass) AS indexes_size,
    pg_total_relation_size((all_tables.table_name)::regclass) AS total_size
   FROM ( SELECT (((('"'::text || (tables.table_schema)::text) || '"."'::text) || (tables.table_name)::text) || '"'::text) AS table_name
           FROM information_schema.tables) all_tables
  ORDER BY (pg_total_relation_size((all_tables.table_name)::regclass)) DESC;


ALTER TABLE mixalot.pgdu_bytes OWNER TO dbservice;

--
-- Name: pgdu; Type: VIEW; Schema: mixalot; Owner: dbservice
--

CREATE VIEW mixalot.pgdu AS
 SELECT pgdu_bytes.table_name,
    pg_size_pretty(pgdu_bytes.table_size) AS table_size,
    pg_size_pretty(pgdu_bytes.indexes_size) AS indexes_size,
    pg_size_pretty(pgdu_bytes.total_size) AS total_size
   FROM mixalot.pgdu_bytes;


ALTER TABLE mixalot.pgdu OWNER TO dbservice;

--
-- Name: pick; Type: TABLE; Schema: mixalot; Owner: dbservice
--

CREATE TABLE mixalot.pick (
    kiosk_id integer NOT NULL,
    sku_id integer NOT NULL,
    inventory_qty smallint,
    demand_qty smallint,
    allocated_qty smallint,
    substituted_qty smallint,
    driver_name character varying(60) NOT NULL,
    route_time time(6) without time zone NOT NULL,
    route_date date NOT NULL,
    route_number character varying(60) NOT NULL,
    delivery_order smallint NOT NULL,
    pick_date date NOT NULL
);


ALTER TABLE mixalot.pick OWNER TO dbservice;

--
-- Name: pick_preference_kiosk_sku; Type: TABLE; Schema: mixalot; Owner: dbservice
--

CREATE TABLE mixalot.pick_preference_kiosk_sku (
    kiosk_id integer NOT NULL,
    sku_id integer NOT NULL,
    preference smallint NOT NULL
);


ALTER TABLE mixalot.pick_preference_kiosk_sku OWNER TO dbservice;

--
-- Name: pick_priority_kiosk; Type: TABLE; Schema: mixalot; Owner: dbservice
--

CREATE TABLE mixalot.pick_priority_kiosk (
    kiosk_id integer NOT NULL,
    priority integer,
    comment text,
    end_date date
);


ALTER TABLE mixalot.pick_priority_kiosk OWNER TO dbservice;

--
-- Name: pick_priority_sku; Type: TABLE; Schema: mixalot; Owner: dbservice
--

CREATE TABLE mixalot.pick_priority_sku (
    sku_id integer NOT NULL,
    priority integer
);


ALTER TABLE mixalot.pick_priority_sku OWNER TO dbservice;

--
-- Name: product_fact; Type: TABLE; Schema: mixalot; Owner: dbservice
--

CREATE TABLE mixalot.product_fact (
    id integer NOT NULL,
    product_id integer,
    sku text,
    first_available_ts timestamp(6) with time zone,
    first_purchased_ts timestamp(6) with time zone,
    kiosks text,
    cnt_sales_1w integer,
    cnt_sales_30d integer,
    cnt_sales_6m integer
);


ALTER TABLE mixalot.product_fact OWNER TO dbservice;

--
-- Name: product_fact_id_seq; Type: SEQUENCE; Schema: mixalot; Owner: dbservice
--

CREATE SEQUENCE mixalot.product_fact_id_seq
CREATE SEQUENCE mixalot.product_fact_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE mixalot.product_fact_id_seq OWNER TO dbservice;

--
-- Name: product_fact_id_seq; Type: SEQUENCE OWNED BY; Schema: mixalot; Owner: dbservice
--

ALTER SEQUENCE mixalot.product_fact_id_seq OWNED BY mixalot.product_fact.id;


--
-- Name: product_kiosk_fact; Type: TABLE; Schema: mixalot; Owner: dbservice
--

CREATE TABLE mixalot.product_kiosk_fact (
    id integer NOT NULL,
    product_id integer,
    kiosk_id integer,
    qty integer,
    "timestamp" timestamp(6) with time zone
);


ALTER TABLE mixalot.product_kiosk_fact OWNER TO dbservice;

--
-- Name: product_kiosk_fact_id_seq; Type: SEQUENCE; Schema: mixalot; Owner: dbservice
--

CREATE SEQUENCE mixalot.product_kiosk_fact_id_seq
CREATE SEQUENCE mixalot.product_kiosk_fact_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE mixalot.product_kiosk_fact_id_seq OWNER TO dbservice;

--
-- Name: product_kiosk_fact_id_seq; Type: SEQUENCE OWNED BY; Schema: mixalot; Owner: dbservice
--

ALTER SEQUENCE mixalot.product_kiosk_fact_id_seq OWNED BY mixalot.product_kiosk_fact.id;


--
-- Name: route; Type: TABLE; Schema: mixalot; Owner: dbservice
--

CREATE TABLE mixalot.route (
    route_date_time timestamp(6) with time zone NOT NULL,
    duration integer,
    vehicle_label character varying(200),
    vehicle_registration character varying(200),
    driver_serial character varying(200),
    distance numeric(28,6),
    driver_name character varying(200) NOT NULL
);


ALTER TABLE mixalot.route OWNER TO dbservice;

--
-- Name: server; Type: TABLE; Schema: mixalot; Owner: dbservice
--

CREATE TABLE mixalot.server (
    id integer NOT NULL,
    name text,
    time_offset integer,
    modify_dt timestamp(6) with time zone
);


ALTER TABLE mixalot.server OWNER TO dbservice;

--
-- Name: server_id_seq; Type: SEQUENCE; Schema: mixalot; Owner: dbservice
--

CREATE SEQUENCE mixalot.server_id_seq
CREATE SEQUENCE mixalot.server_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE mixalot.server_id_seq OWNER TO dbservice;

--
-- Name: server_id_seq; Type: SEQUENCE OWNED BY; Schema: mixalot; Owner: dbservice
--

ALTER SEQUENCE mixalot.server_id_seq OWNED BY mixalot.server.id;


--
-- Name: sku_attribute_def_id_seq; Type: SEQUENCE; Schema: mixalot; Owner: dbservice
--

CREATE SEQUENCE mixalot.sku_attribute_def_id_seq
CREATE SEQUENCE mixalot.sku_attribute_def_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE mixalot.sku_attribute_def_id_seq OWNER TO dbservice;

--
-- Name: sku_attribute_def_id_seq; Type: SEQUENCE OWNED BY; Schema: mixalot; Owner: dbservice
--

ALTER SEQUENCE mixalot.sku_attribute_def_id_seq OWNED BY mixalot.sku_property_def.id;


--
-- Name: sku_group; Type: TABLE; Schema: mixalot; Owner: dbservice
--

CREATE TABLE mixalot.sku_group (
    id integer NOT NULL,
    title character varying(50),
    group_type character varying(50),
    replacement_type character varying(50),
    created timestamp(6) with time zone,
    updated timestamp(6) with time zone
);


ALTER TABLE mixalot.sku_group OWNER TO dbservice;

--
-- Name: sku_group_def_id_seq; Type: SEQUENCE; Schema: mixalot; Owner: dbservice
--

CREATE SEQUENCE mixalot.sku_group_def_id_seq
CREATE SEQUENCE mixalot.sku_group_def_id_seq
    START WITH 1
    INCREMENT BY 1
    MINVALUE 0
    NO MAXVALUE
    CACHE 1;


ALTER TABLE mixalot.sku_group_def_id_seq OWNER TO dbservice;

--
-- Name: sku_group_def_id_seq; Type: SEQUENCE OWNED BY; Schema: mixalot; Owner: dbservice
--

ALTER SEQUENCE mixalot.sku_group_def_id_seq OWNED BY mixalot.sku_group_def.id;


--
-- Name: sku_group_id_seq; Type: SEQUENCE; Schema: mixalot; Owner: dbservice
--

CREATE SEQUENCE mixalot.sku_group_id_seq
CREATE SEQUENCE mixalot.sku_group_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE mixalot.sku_group_id_seq OWNER TO dbservice;

--
-- Name: sku_group_id_seq; Type: SEQUENCE OWNED BY; Schema: mixalot; Owner: dbservice
--

ALTER SEQUENCE mixalot.sku_group_id_seq OWNED BY mixalot.sku_group.id;


--
-- Name: sku_group_member; Type: TABLE; Schema: mixalot; Owner: dbservice
--

CREATE TABLE mixalot.sku_group_member (
    id integer NOT NULL,
    sku_group_id integer,
    product_id integer,
    created timestamp(6) with time zone,
    updated timestamp(6) with time zone
);


ALTER TABLE mixalot.sku_group_member OWNER TO dbservice;

--
-- Name: sku_group_member_id_seq; Type: SEQUENCE; Schema: mixalot; Owner: dbservice
--

CREATE SEQUENCE mixalot.sku_group_member_id_seq
CREATE SEQUENCE mixalot.sku_group_member_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE mixalot.sku_group_member_id_seq OWNER TO dbservice;

--
-- Name: sku_group_member_id_seq; Type: SEQUENCE OWNED BY; Schema: mixalot; Owner: dbservice
--

ALTER SEQUENCE mixalot.sku_group_member_id_seq OWNED BY mixalot.sku_group_member.id;


--
-- Name: tally; Type: TABLE; Schema: mixalot; Owner: dbservice
--

CREATE TABLE mixalot.tally (
    n integer NOT NULL
);


ALTER TABLE mixalot.tally OWNER TO dbservice;

--
-- Name: temp_kiosk_restriction; Type: TABLE; Schema: mixalot; Owner: dbservice
--

CREATE TABLE mixalot.temp_kiosk_restriction (
    kiosk_id integer NOT NULL,
    restriction character varying(256) NOT NULL,
    property_id integer
);


ALTER TABLE mixalot.temp_kiosk_restriction OWNER TO dbservice;

--
-- Name: temp_ms_to_sg; Type: TABLE; Schema: mixalot; Owner: dbservice
--

CREATE TABLE mixalot.temp_ms_to_sg (
    mslot character varying(512) NOT NULL,
    sgroup character varying(512) NOT NULL
);


ALTER TABLE mixalot.temp_ms_to_sg OWNER TO dbservice;

--
-- Name: TABLE temp_ms_to_sg; Type: COMMENT; Schema: mixalot; Owner: dbservice
--

COMMENT ON TABLE mixalot.temp_ms_to_sg IS 'temp lookup table for merchandising slot to skugroup';


--
-- Name: temp_sku_group_volume; Type: TABLE; Schema: mixalot; Owner: dbservice
--

CREATE TABLE mixalot.temp_sku_group_volume (
    title character varying(512) NOT NULL,
    volume numeric(4,2) NOT NULL,
    minimum smallint
);


ALTER TABLE mixalot.temp_sku_group_volume OWNER TO dbservice;

--
-- Name: temp_sku_to_skugroup; Type: TABLE; Schema: mixalot; Owner: dbservice
--

CREATE TABLE mixalot.temp_sku_to_skugroup (
    sku integer NOT NULL,
    sku_group character varying(512) NOT NULL
);


ALTER TABLE mixalot.temp_sku_to_skugroup OWNER TO dbservice;

--
-- Name: TABLE temp_sku_to_skugroup; Type: COMMENT; Schema: mixalot; Owner: dbservice
--

COMMENT ON TABLE mixalot.temp_sku_to_skugroup IS 'temp lookup table for sku-sku_group';


--
-- Name: temp_test; Type: TABLE; Schema: mixalot; Owner: dbservice
--

CREATE TABLE mixalot.temp_test (
    id integer NOT NULL,
    name character varying(16) NOT NULL,
    total integer NOT NULL
);


ALTER TABLE mixalot.temp_test OWNER TO dbservice;

--
-- Name: temp_test_id_seq; Type: SEQUENCE; Schema: mixalot; Owner: dbservice
--

CREATE SEQUENCE mixalot.temp_test_id_seq
CREATE SEQUENCE mixalot.temp_test_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE mixalot.temp_test_id_seq OWNER TO dbservice;

--
-- Name: temp_test_id_seq; Type: SEQUENCE OWNED BY; Schema: mixalot; Owner: dbservice
--

ALTER SEQUENCE mixalot.temp_test_id_seq OWNED BY mixalot.temp_test.id;


--
-- Name: test_time; Type: TABLE; Schema: mixalot; Owner: dbservice
--

CREATE TABLE mixalot.test_time (
    id integer NOT NULL,
    ts timestamp(6) with time zone
);


ALTER TABLE mixalot.test_time OWNER TO dbservice;

--
-- Name: test_time_id_seq; Type: SEQUENCE; Schema: mixalot; Owner: dbservice
--

CREATE SEQUENCE mixalot.test_time_id_seq
CREATE SEQUENCE mixalot.test_time_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE mixalot.test_time_id_seq OWNER TO dbservice;

--
-- Name: test_time_id_seq; Type: SEQUENCE OWNED BY; Schema: mixalot; Owner: dbservice
--

ALTER SEQUENCE mixalot.test_time_id_seq OWNED BY mixalot.test_time.id;


--
-- Name: tmp_discount_applied; Type: TABLE; Schema: mixalot; Owner: dbservice
--

CREATE TABLE mixalot.tmp_discount_applied (
    id integer NOT NULL,
    order_id character varying(135),
    sequence integer,
    epc character varying(135),
    product_id integer,
    discount json,
    price_before numeric(28,6),
    price_after numeric(28,6),
    sponsor character varying(135),
    ts timestamp(6) with time zone
);


ALTER TABLE mixalot.tmp_discount_applied OWNER TO dbservice;

--
-- Name: tmp_discount_applied_id_seq; Type: SEQUENCE; Schema: mixalot; Owner: dbservice
--

CREATE SEQUENCE mixalot.tmp_discount_applied_id_seq
CREATE SEQUENCE mixalot.tmp_discount_applied_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE mixalot.tmp_discount_applied_id_seq OWNER TO dbservice;

--
-- Name: tmp_discount_applied_id_seq; Type: SEQUENCE OWNED BY; Schema: mixalot; Owner: dbservice
--

ALTER SEQUENCE mixalot.tmp_discount_applied_id_seq OWNED BY mixalot.tmp_discount_applied.id;


--
-- Name: tmp_kiosk_status; Type: TABLE; Schema: mixalot; Owner: dbservice
--

CREATE TABLE mixalot.tmp_kiosk_status (
    id integer NOT NULL,
    kiosk_id integer NOT NULL,
    kiosk_temperature numeric(6,3),
    kit_temperature numeric(6,3),
    power integer,
    battery_level smallint,
    rfid_0 integer,
    rfid_1 integer,
    rfid_2 integer,
    rfid_3 integer,
    rfid_4 integer,
    rfid_5 integer,
    rfid_6 integer,
    rfid_7 integer,
    "time" bigint,
    modem_signal_percentage smallint,
    modem_signal_type character varying(81),
    ip character varying(135),
    notes text
);


ALTER TABLE mixalot.tmp_kiosk_status OWNER TO dbservice;

--
-- Name: tmp_kiosk_status_id_seq; Type: SEQUENCE; Schema: mixalot; Owner: dbservice
--

CREATE SEQUENCE mixalot.tmp_kiosk_status_id_seq
CREATE SEQUENCE mixalot.tmp_kiosk_status_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE mixalot.tmp_kiosk_status_id_seq OWNER TO dbservice;

--
-- Name: tmp_kiosk_status_id_seq; Type: SEQUENCE OWNED BY; Schema: mixalot; Owner: dbservice
--

ALTER SEQUENCE mixalot.tmp_kiosk_status_id_seq OWNED BY mixalot.tmp_kiosk_status.id;


--
-- Name: tmp_transact; Type: TABLE; Schema: mixalot; Owner: dbservice
--

CREATE TABLE mixalot.tmp_transact (
    order_id character varying(135) NOT NULL,
    first_name text,
    last_name text,
    kiosk_id integer,
    kiosk_title text,
    email text,
    amount_paid numeric(28,6),
    payment_system text,
    transaction_id text,
    approval_code text,
    status_code text,
    status_message text,
    created timestamp(6) with time zone,
    time_opened timestamp(6) with time zone,
    time_closed timestamp(6) with time zone,
    card_hash text,
    card_number text,
    card_type text,
    state text,
    stamp integer,
    last_update timestamp(6) with time zone,
    balance numeric(28,6),
    coupon_id integer,
    coupon text,
    refund numeric(28,6),
    receipt integer,
    campus_id integer,
    amount_list_price numeric(28,6),
    flushed timestamp(6) with time zone,
    create_dt timestamp(6) with time zone,
    modify_dt timestamp(6) with time zone,
    finalized integer
);


ALTER TABLE mixalot.tmp_transact OWNER TO dbservice;

--
-- Name: v_kiosk_request_log; Type: VIEW; Schema: mixalot; Owner: dbservice
--

CREATE VIEW mixalot.v_kiosk_request_log AS
 SELECT l.start_ts AS ts,
    (((l.request_body_json)::json ->> 'time'::text))::bigint AS "time",
    l.request_uuid,
    l.endpoint,
    l.client_ip,
    l.version,
    l.cookie,
    l.message,
    l.request_body,
    l.request_headers,
    l.start_ts,
    l.response_body,
    l.response_headers,
    l.status_code,
    l.end_ts,
    l.traceback,
    l.request_body_json,
    l.request_headers_json,
    l.response_headers_json,
    l.kiosk_id,
    l.source
   FROM mixalot.request_log l
  WHERE ((((l.request_headers_json)::json ->> 'User-Agent'::text) !~~ '%monitis%'::text) AND (l.source = 'mixalot'::text));


ALTER TABLE mixalot.v_kiosk_request_log OWNER TO dbservice;

--
-- Name: v_kiosk_inventory_log; Type: VIEW; Schema: mixalot; Owner: dbservice
--

CREATE VIEW mixalot.v_kiosk_inventory_log AS
 SELECT l.ts,
    l."time",
    l.request_uuid,
    l.endpoint,
    l.client_ip,
    l.version,
    l.cookie,
    l.message,
    l.request_body,
    l.request_headers,
    l.start_ts,
    l.response_body,
    l.response_headers,
    l.status_code,
    l.end_ts,
    l.traceback,
    l.request_body_json,
    l.request_headers_json,
    l.response_headers_json,
    l.kiosk_id,
    l.source,
    (((l.request_body_json)::json ->> 'epc'::text))::character varying AS epc,
    (((l.request_body_json)::json ->> 'retry_count'::text))::integer AS retry_count
   FROM mixalot.v_kiosk_request_log l
  WHERE ((l.endpoint = '/inventory'::text) AND (l.source = 'mixalot'::text));


ALTER TABLE mixalot.v_kiosk_inventory_log OWNER TO dbservice;

--
-- Name: v_kiosk_item_log; Type: VIEW; Schema: mixalot; Owner: dbservice
--

CREATE VIEW mixalot.v_kiosk_item_log AS
 SELECT l.ts,
    l."time",
    l.request_uuid,
    l.endpoint,
    l.client_ip,
    l.version,
    l.cookie,
    l.message,
    l.request_body,
    l.request_headers,
    l.start_ts,
    l.response_body,
    l.response_headers,
    l.status_code,
    l.end_ts,
    l.traceback,
    l.request_body_json,
    l.request_headers_json,
    l.response_headers_json,
    l.kiosk_id,
    l.source,
    (((l.request_body_json)::json ->> 'epc'::text))::character varying AS epc,
    (((l.request_body_json)::json ->> 'direction'::text))::character varying AS direction,
    (((l.request_body_json)::json ->> 'rssi'::text))::integer AS rssi,
    (((l.request_body_json)::json ->> 'read_count'::text))::integer AS read_count
   FROM mixalot.v_kiosk_request_log l
  WHERE ((l.endpoint = '/item'::text) AND (l.source = 'mixalot'::text));


ALTER TABLE mixalot.v_kiosk_item_log OWNER TO dbservice;

--
-- Name: v_kiosk_status_log; Type: VIEW; Schema: mixalot; Owner: dbservice
--

CREATE VIEW mixalot.v_kiosk_status_log AS
 SELECT l.ts,
    l."time",
    l.request_uuid,
    l.endpoint,
    l.client_ip,
    l.version,
    l.cookie,
    l.message,
    l.request_body,
    l.request_headers,
    l.start_ts,
    l.response_body,
    l.response_headers,
    l.status_code,
    l.end_ts,
    l.traceback,
    l.request_body_json,
    l.request_headers_json,
    l.response_headers_json,
    l.kiosk_id,
    l.source,
    (((l.request_body_json)::json ->> 'kiosk_id'::text))::integer AS client_kiosk_id,
    (((l.request_body_json)::json ->> 'retry_queue_length'::text))::integer AS retry_queue_length,
    (((l.request_body_json)::json ->> 'retry_count'::text))::integer AS retry_count,
    (((l.request_body_json)::json ->> 'happy_hour'::text))::integer AS happy_hour,
    (((l.request_body_json)::json ->> 'app_uptime'::text))::integer AS app_uptime,
    (((l.request_body_json)::json ->> 'system_uptime'::text))::integer AS system_uptime,
    (((l.request_body_json)::json ->> 'kiosk_temperature'::text))::numeric AS kiosk_temperature,
    (((l.request_body_json)::json ->> 'kit_temperature'::text))::numeric AS kit_temperature,
    (((l.request_body_json)::json ->> 'power'::text))::integer AS power,
    (((l.request_body_json)::json ->> 'battery_level'::text))::integer AS battery_level,
    (((l.request_body_json)::json ->> 'rfid_0'::text))::integer AS rfid_0,
    (((l.request_body_json)::json ->> 'rfid_1'::text))::integer AS rfid_1,
    (((l.request_body_json)::json ->> 'rfid_2'::text))::integer AS rfid_2,
    (((l.request_body_json)::json ->> 'rfid_3'::text))::integer AS rfid_3,
    (((l.request_body_json)::json ->> 'rfid_4'::text))::integer AS rfid_4,
    (((l.request_body_json)::json ->> 'rfid_5'::text))::integer AS rfid_5,
    (((l.request_body_json)::json ->> 'rfid_6'::text))::integer AS rfid_6,
    (((l.request_body_json)::json ->> 'rfid_7'::text))::integer AS rfid_7
   FROM mixalot.v_kiosk_request_log l
  WHERE ((l.endpoint = '/status'::text) AND (l.source = 'mixalot'::text));


ALTER TABLE mixalot.v_kiosk_status_log OWNER TO dbservice;

--
-- Name: v_node_kiosk_request_log; Type: VIEW; Schema: mixalot; Owner: dbservice
--

CREATE VIEW mixalot.v_node_kiosk_request_log AS
 SELECT l.start_ts AS ts,
    (((l.request_body_json)::json ->> 'time'::text))::bigint AS "time",
    l.request_uuid,
    l.endpoint,
    l.client_ip,
    l.version,
    l.cookie,
    l.message,
    l.request_body,
    l.request_headers,
    l.start_ts,
    l.response_body,
    l.response_headers,
    l.status_code,
    l.end_ts,
    l.traceback,
    l.request_body_json,
    l.request_headers_json,
    l.response_headers_json,
    l.kiosk_id,
    l.source
   FROM mixalot.request_log l
  WHERE (l.source = 'node'::text);


ALTER TABLE mixalot.v_node_kiosk_request_log OWNER TO dbservice;

--
-- Name: v_node_kiosk_status_log; Type: VIEW; Schema: mixalot; Owner: dbservice
--

CREATE VIEW mixalot.v_node_kiosk_status_log AS
 SELECT l.ts,
    l."time",
    l.request_uuid,
    l.endpoint,
    l.client_ip,
    l.version,
    l.cookie,
    l.message,
    l.request_body,
    l.request_headers,
    l.start_ts,
    l.response_body,
    l.response_headers,
    l.status_code,
    l.end_ts,
    l.traceback,
    l.request_body_json,
    l.request_headers_json,
    l.response_headers_json,
    l.kiosk_id,
    l.source,
    (((l.request_body_json)::json ->> 'kiosk_id'::text))::integer AS client_kiosk_id,
    (((l.request_body_json)::json ->> 'retry_queue_length'::text))::integer AS retry_queue_length,
    (((l.request_body_json)::json ->> 'retry_count'::text))::integer AS retry_count,
    (((l.request_body_json)::json ->> 'happy_hour'::text))::integer AS happy_hour,
    (((l.request_body_json)::json ->> 'app_uptime'::text))::bigint AS app_uptime,
    (((l.request_body_json)::json ->> 'system_uptime'::text))::bigint AS system_uptime,
    (((l.request_body_json)::json ->> 'kiosk_temperature'::text))::numeric AS kiosk_temperature,
    (((l.request_body_json)::json ->> 'kit_temperature'::text))::numeric AS kit_temperature,
    (((l.request_body_json)::json ->> 'power'::text))::integer AS power,
    (((l.request_body_json)::json ->> 'battery_level'::text))::integer AS battery_level,
    (((l.request_body_json)::json ->> 'rfid_0'::text))::integer AS rfid_0,
    (((l.request_body_json)::json ->> 'rfid_1'::text))::integer AS rfid_1,
    (((l.request_body_json)::json ->> 'rfid_2'::text))::integer AS rfid_2,
    (((l.request_body_json)::json ->> 'rfid_3'::text))::integer AS rfid_3,
    (((l.request_body_json)::json ->> 'rfid_4'::text))::integer AS rfid_4,
    (((l.request_body_json)::json ->> 'rfid_5'::text))::integer AS rfid_5,
    (((l.request_body_json)::json ->> 'rfid_6'::text))::integer AS rfid_6,
    (((l.request_body_json)::json ->> 'rfid_7'::text))::integer AS rfid_7
   FROM mixalot.v_node_kiosk_request_log l
  WHERE ((l.endpoint = '/status'::text) AND (l.source = 'node'::text));


ALTER TABLE mixalot.v_node_kiosk_status_log OWNER TO dbservice;

--
-- Name: warehouse_order_history; Type: TABLE; Schema: mixalot; Owner: dbservice
--

CREATE TABLE mixalot.warehouse_order_history (
    time_added timestamp(6) with time zone NOT NULL,
    sku integer NOT NULL,
    qty integer NOT NULL,
    order_date date NOT NULL,
    delivery_date date NOT NULL,
    amount_arrived integer,
    status character varying(200),
    warehouse_comment text,
    ordering_comment text,
    action character varying(200),
    purchase_order character varying(200),
    best_by_date character varying(200)
);


ALTER TABLE mixalot.warehouse_order_history OWNER TO dbservice;

--
-- Name: cron_state; Type: TABLE; Schema: monitor; Owner: dbservice
--

CREATE TABLE monitor.cron_state (
    key text NOT NULL,
    value text
);


ALTER TABLE monitor.cron_state OWNER TO dbservice;

--
-- Name: kiosk_status; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.kiosk_status (
    id bigint NOT NULL,
    kiosk_id bigint NOT NULL,
    kiosk_temperature numeric(6,3),
    kiosk_temperature_count smallint,
    kit_temperature numeric(6,3),
    temperature_tags character varying(2047),
    kiosk_temperature_source character varying(31),
    power integer,
    battery_level smallint,
    rfid_0 integer,
    rfid_1 integer,
    rfid_2 integer,
    rfid_3 integer,
    rfid_4 integer,
    rfid_5 integer,
    rfid_6 integer,
    rfid_7 integer,
    "time" bigint,
    modem_signal_percentage smallint,
    modem_signal_type character varying(27),
    ip character varying(45),
    notes text,
    app_uptime bigint,
    system_uptime bigint,
    is_locked smallint,
    num_payment_messages_pending_sync integer DEFAULT 0,
    offline smallint DEFAULT 0
);


ALTER TABLE pantry.kiosk_status OWNER TO dbservice;

--
-- Name: kiosk_not_heard; Type: VIEW; Schema: monitor; Owner: dbservice
--

CREATE VIEW monitor.kiosk_not_heard AS
 SELECT kiosk_last_beat.id,
    kiosk_last_beat.geo,
    kiosk_last_beat.title,
    kiosk_last_beat.last_heard,
    kiosk_last_beat.last_heart_beat_minutes,
    kiosk_last_beat.campus_id
   FROM ( SELECT ks.kiosk_id AS id,
            k.geo,
            k.title,
            k.last_inventory AS last_heard,
            round((date_part('epoch'::text, (CURRENT_TIMESTAMP - max(to_timestamp((ks."time")::double precision)))) / (60.0)::double precision)) AS last_heart_beat_minutes,
            k.campus_id
           FROM (pantry.kiosk_status ks
             JOIN pantry.kiosk k ON ((k.id = ks.kiosk_id)))
          WHERE ((k.archived = 0) AND (k.last_inventory > 0))
          GROUP BY ks.kiosk_id, k.title, k.geo, k.last_inventory, k.campus_id) kiosk_last_beat
  WHERE (kiosk_last_beat.last_heart_beat_minutes > (40)::double precision);


ALTER TABLE monitor.kiosk_not_heard OWNER TO dbservice;

--
-- Name: opt_connect; Type: TABLE; Schema: monitor; Owner: dbservice
--

CREATE TABLE monitor.opt_connect (
    date_time timestamp(6) without time zone NOT NULL,
    summit_id integer NOT NULL,
    carrier text,
    customer_name text,
    customer_id integer,
    your_device_id text,
    signal_strength text,
    description text,
    device_model text,
    serial_number text,
    device_up_time text,
    static_ip text,
    snapshot_refresh_time bigint,
    last_check_in_time bigint,
    signal_quality text,
    data_plan bigint,
    data_used_date date,
    data_used bigint
);


ALTER TABLE monitor.opt_connect OWNER TO dbservice;

--
-- Name: accounting; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.accounting (
    id bigint NOT NULL,
    date character varying(45) NOT NULL,
    kiosk_id bigint NOT NULL,
    campus_id bigint NOT NULL,
    sales_ipc numeric(6,2) NOT NULL,
    sales_fp numeric(6,2) NOT NULL,
    sales_cs numeric(6,2) NOT NULL,
    sales_cp numeric(6,2) NOT NULL,
    tags_got bigint NOT NULL,
    tags_spent bigint NOT NULL,
    timezone smallint DEFAULT 0 NOT NULL,
    sales_tax numeric(4,2) NOT NULL,
    sales_tax_ipc numeric(6,2) NOT NULL,
    sales_tax_fp numeric(6,2) NOT NULL,
    sales_tax_cs numeric(6,2) NOT NULL,
    sales_tax_cp numeric(6,2) NOT NULL,
    prepaid bigint NOT NULL,
    current_fee bigint NOT NULL,
    next_fee bigint NOT NULL,
    recalculated_fee numeric(6,2),
    prepaid_day bigint NOT NULL,
    next_fee_from character varying(45),
    fee_connectivity numeric(5,2) NOT NULL
);


ALTER TABLE pantry.accounting OWNER TO dbservice;

--
-- Name: accounting_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.accounting_id_seq
CREATE SEQUENCE pantry.accounting_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.accounting_id_seq OWNER TO dbservice;

--
-- Name: accounting_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.accounting_id_seq OWNED BY pantry.accounting.id;


--
-- Name: bad_timestamp; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.bad_timestamp (
    id bigint NOT NULL,
    kiosk_id bigint,
    endpoint character varying(93),
    server_time bigint,
    data character varying(3069)
);


ALTER TABLE pantry.bad_timestamp OWNER TO dbservice;

--
-- Name: bad_timestamp_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.bad_timestamp_id_seq
CREATE SEQUENCE pantry.bad_timestamp_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.bad_timestamp_id_seq OWNER TO dbservice;

--
-- Name: bad_timestamp_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.bad_timestamp_id_seq OWNED BY pantry.bad_timestamp.id;


--
-- Name: campus; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.campus (
    id bigint NOT NULL,
    title character varying(45) NOT NULL,
    timezone character varying(50),
    archived integer DEFAULT 0
);


ALTER TABLE pantry.campus OWNER TO dbservice;

--
-- Name: campus_assets; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.campus_assets (
    campus_id bigint NOT NULL,
    logo character varying(255),
    background_image character varying(255),
    background_color character varying(50),
    receipt_header_text character varying(1000),
    receipt_footer_text character varying(1000),
    from_email text
);


ALTER TABLE pantry.campus_assets OWNER TO dbservice;

--
-- Name: campus_attribute; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.campus_attribute (
    id integer NOT NULL,
    campus_id bigint NOT NULL,
    key_id integer NOT NULL,
    value character varying(150) NOT NULL
);


ALTER TABLE pantry.campus_attribute OWNER TO dbservice;

--
-- Name: campus_attribute_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.campus_attribute_id_seq
CREATE SEQUENCE pantry.campus_attribute_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.campus_attribute_id_seq OWNER TO dbservice;

--
-- Name: campus_attribute_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.campus_attribute_id_seq OWNED BY pantry.campus_attribute.id;


--
-- Name: campus_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.campus_id_seq
CREATE SEQUENCE pantry.campus_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.campus_id_seq OWNER TO dbservice;

--
-- Name: campus_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.campus_id_seq OWNED BY pantry.campus.id;


--
-- Name: card; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.card (
    id bigint NOT NULL,
    hash character varying(88) NOT NULL,
    first_name character varying(45),
    last_name character varying(45),
    type character varying(15),
    number character varying(31),
    email character varying(127) NOT NULL,
    notes text,
    created bigint,
    last_update bigint
);


ALTER TABLE pantry.card OWNER TO dbservice;

--
-- Name: card_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.card_id_seq
CREATE SEQUENCE pantry.card_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.card_id_seq OWNER TO dbservice;

--
-- Name: card_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.card_id_seq OWNED BY pantry.card.id;


--
-- Name: kiosk_components_history; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.kiosk_components_history (
    id bigint NOT NULL,
    kiosk_id bigint NOT NULL,
    "time" bigint NOT NULL,
    type character varying(63),
    common_name character varying(63),
    version character varying(63),
    "full" character varying(255),
    notes text
);


ALTER TABLE pantry.kiosk_components_history OWNER TO dbservice;

--
-- Name: component_history_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.component_history_id_seq
CREATE SEQUENCE pantry.component_history_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.component_history_id_seq OWNER TO dbservice;

--
-- Name: component_history_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.component_history_id_seq OWNED BY pantry.kiosk_components_history.id;


--
-- Name: contract; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.contract (
    id bigint NOT NULL,
    url character varying(255) NOT NULL,
    user_id integer,
    name character varying(127),
    email character varying(127),
    payment_type character varying(50),
    pantry_quantity bigint,
    step smallint,
    paid smallint,
    archived smallint,
    initials character varying(50),
    total bigint,
    pricing_structure smallint,
    payment_transaction_id character varying(255),
    fee_monthly numeric(8,2),
    fee_6_month_pre_payment numeric(8,2),
    fee_12_month_pre_payment numeric(8,2),
    fee_label numeric(3,2),
    fee_transact numeric(5,4),
    fee_deposit numeric(8,2),
    logo character varying(255),
    terms character varying(255),
    requester_id bigint,
    monthly_allowed smallint NOT NULL
);


ALTER TABLE pantry.contract OWNER TO dbservice;

--
-- Name: contract_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.contract_id_seq
CREATE SEQUENCE pantry.contract_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.contract_id_seq OWNER TO dbservice;

--
-- Name: contract_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.contract_id_seq OWNED BY pantry.contract.id;


--
-- Name: coupon; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.coupon (
    id bigint NOT NULL,
    code character varying(45) NOT NULL,
    flat_discount numeric(5,2) DEFAULT 0.00 NOT NULL,
    real_discount numeric(5,2) DEFAULT 0.00 NOT NULL,
    used bigint DEFAULT 0 NOT NULL,
    kiosk_list character varying(255),
    campaign character varying(255),
    created_by character varying(255)
);


ALTER TABLE pantry.coupon OWNER TO dbservice;

--
-- Name: coupon_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.coupon_id_seq
CREATE SEQUENCE pantry.coupon_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.coupon_id_seq OWNER TO dbservice;

--
-- Name: coupon_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.coupon_id_seq OWNED BY pantry.coupon.id;


--
-- Name: cron; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.cron (
    id integer NOT NULL,
    "time" character varying(300),
    kiosks character varying(30000),
    command character varying(300),
    payload text,
    trigger_id integer,
    dependencies character varying(300),
    user_id integer,
    raw_task text,
    active integer DEFAULT 1,
    group_id integer,
    timezone character varying(210),
    archived integer DEFAULT 0 NOT NULL
);


ALTER TABLE pantry.cron OWNER TO dbservice;

--
-- Name: cron_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.cron_id_seq
CREATE SEQUENCE pantry.cron_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.cron_id_seq OWNER TO dbservice;

--
-- Name: cron_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.cron_id_seq OWNED BY pantry.cron.id;


--
-- Name: currency_symbol; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.currency_symbol (
    id integer NOT NULL,
    code character(3) NOT NULL,
    symbol text NOT NULL
);


ALTER TABLE pantry.currency_symbol OWNER TO dbservice;

--
-- Name: currency_symbol_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.currency_symbol_id_seq
CREATE SEQUENCE pantry.currency_symbol_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.currency_symbol_id_seq OWNER TO dbservice;

--
-- Name: currency_symbol_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.currency_symbol_id_seq OWNED BY pantry.currency_symbol.id;


--
-- Name: current_label_status_365days; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.current_label_status_365days (
    epc character varying(72) NOT NULL,
    campus_id bigint NOT NULL,
    product_id bigint NOT NULL,
    product_title character varying(381) NOT NULL,
    price numeric(5,2) NOT NULL,
    status character varying(12) NOT NULL,
    kiosk_id bigint NOT NULL,
    order_id character varying(150) NOT NULL,
    first_timestamp bigint NOT NULL,
    last_timestamp bigint NOT NULL,
    cost numeric(5,2)
);


ALTER TABLE pantry.current_label_status_365days OWNER TO dbservice;

--
-- Name: dc_inventory; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.dc_inventory (
    product_id bigint NOT NULL,
    product_title character varying(765),
    tesla_inv bigint,
    inventory bigint,
    spoil bigint,
    date date
);


ALTER TABLE pantry.dc_inventory OWNER TO dbservice;

--
-- Name: delivery_schedule; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.delivery_schedule (
    id bigint NOT NULL,
    date date,
    driver character varying(765),
    route character varying(765),
    start_time character varying(30),
    location character varying(765),
    day character varying(765),
    pull_count bigint,
    kiosk_id bigint,
    loc_name character varying(765),
    pull_date date,
    clean_list character varying(765),
    clean_key bigint,
    kiosk_for_key character varying(765)
);


ALTER TABLE pantry.delivery_schedule OWNER TO dbservice;

--
-- Name: delivery_schedule_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.delivery_schedule_id_seq
CREATE SEQUENCE pantry.delivery_schedule_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.delivery_schedule_id_seq OWNER TO dbservice;

--
-- Name: delivery_schedule_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.delivery_schedule_id_seq OWNED BY pantry.delivery_schedule.id;


--
-- Name: discount; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.discount (
    id bigint NOT NULL,
    kiosk_id bigint,
    product_id bigint,
    value integer NOT NULL,
    type character varying(10),
    end_time integer,
    cron_task_id integer
);


ALTER TABLE pantry.discount OWNER TO dbservice;

--
-- Name: discount_applied; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.discount_applied (
    id integer NOT NULL,
    order_id character varying(135),
    sequence integer,
    epc character varying(135),
    product_id integer,
    discount character varying(65535),
    price_before numeric(6,2),
    price_after numeric(6,2),
    sponsor character varying(135),
    ts integer,
    notes text
);


ALTER TABLE pantry.discount_applied OWNER TO dbservice;

--
-- Name: discount_applied_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.discount_applied_id_seq
CREATE SEQUENCE pantry.discount_applied_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.discount_applied_id_seq OWNER TO dbservice;

--
-- Name: discount_applied_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.discount_applied_id_seq OWNED BY pantry.discount_applied.id;


--
-- Name: discount_history; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.discount_history (
    id integer NOT NULL,
    kiosk_id integer,
    product_id integer,
    value integer,
    start_time integer,
    end_time integer,
    discount_id integer
);


ALTER TABLE pantry.discount_history OWNER TO dbservice;

--
-- Name: discount_history_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.discount_history_id_seq
CREATE SEQUENCE pantry.discount_history_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.discount_history_id_seq OWNER TO dbservice;

--
-- Name: discount_history_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.discount_history_id_seq OWNED BY pantry.discount_history.id;


--
-- Name: discount_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.discount_id_seq
CREATE SEQUENCE pantry.discount_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.discount_id_seq OWNER TO dbservice;

--
-- Name: discount_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.discount_id_seq OWNED BY pantry.discount.id;


--
-- Name: email; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.email (
    id integer NOT NULL,
    hash character varying(100),
    "timestamp" integer NOT NULL,
    "from" character varying(200),
    "to" character varying(200),
    cc character varying(200),
    bcc character varying(200),
    subject character varying(200),
    body text,
    order_id character varying(12),
    kiosk_id integer,
    type character varying(100) NOT NULL
);


ALTER TABLE pantry.email OWNER TO dbservice;

--
-- Name: email_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.email_id_seq
CREATE SEQUENCE pantry.email_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.email_id_seq OWNER TO dbservice;

--
-- Name: email_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.email_id_seq OWNED BY pantry.email.id;


--
-- Name: empty_transaction; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.empty_transaction (
    id integer NOT NULL,
    order_id character varying(36),
    kiosk_name character varying(192),
    email character varying(384),
    created character varying(384),
    representative character varying(384),
    notes character varying(65535),
    fixed character varying(90),
    status character varying(150)
);


ALTER TABLE pantry.empty_transaction OWNER TO dbservice;

--
-- Name: empty_transaction_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.empty_transaction_id_seq
CREATE SEQUENCE pantry.empty_transaction_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.empty_transaction_id_seq OWNER TO dbservice;

--
-- Name: empty_transaction_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.empty_transaction_id_seq OWNED BY pantry.empty_transaction.id;


--
-- Name: event; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.event (
    id bigint NOT NULL,
    user_id bigint NOT NULL,
    params character varying(6141) NOT NULL,
    action character varying(45) NOT NULL,
    options character varying(6141) NOT NULL,
    archived bigint NOT NULL
);


ALTER TABLE pantry.event OWNER TO dbservice;

--
-- Name: event_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.event_id_seq
CREATE SEQUENCE pantry.event_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.event_id_seq OWNER TO dbservice;

--
-- Name: event_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.event_id_seq OWNED BY pantry.event.id;


--
-- Name: facing_category_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.facing_category_id_seq
CREATE SEQUENCE pantry.facing_category_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.facing_category_id_seq OWNER TO dbservice;

--
-- Name: facing_category_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.facing_category_id_seq OWNED BY pantry.facing_category.id;


--
-- Name: fee_rates; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.fee_rates (
    id bigint NOT NULL,
    fee_lease numeric(6,2) DEFAULT 0.00 NOT NULL,
    fee_tags numeric(3,2) DEFAULT 0.00 NOT NULL,
    fee_ipc numeric(5,4) DEFAULT 0.0000 NOT NULL,
    bi_monthly smallint DEFAULT 0 NOT NULL,
    archived smallint DEFAULT 0 NOT NULL,
    custom smallint DEFAULT 0 NOT NULL,
    prepaid_amount bigint DEFAULT 0 NOT NULL,
    name character varying(128) NOT NULL
);


ALTER TABLE pantry.fee_rates OWNER TO dbservice;

--
-- Name: fee_rates_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.fee_rates_id_seq
CREATE SEQUENCE pantry.fee_rates_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.fee_rates_id_seq OWNER TO dbservice;

--
-- Name: fee_rates_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.fee_rates_id_seq OWNED BY pantry.fee_rates.id;


--
-- Name: feedback; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.feedback (
    id bigint NOT NULL,
    rate bigint NOT NULL,
    order_id character varying(45) NOT NULL,
    message character varying(512),
    taste bigint,
    freshness bigint,
    variety bigint,
    value bigint,
    ticket_created bigint
);


ALTER TABLE pantry.feedback OWNER TO dbservice;

--
-- Name: feedback_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.feedback_id_seq
CREATE SEQUENCE pantry.feedback_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.feedback_id_seq OWNER TO dbservice;

--
-- Name: feedback_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.feedback_id_seq OWNED BY pantry.feedback.id;


--
-- Name: global_attribute_def; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.global_attribute_def (
    id integer NOT NULL,
    key character varying(150) NOT NULL,
    default_value character varying(150)
);


ALTER TABLE pantry.global_attribute_def OWNER TO dbservice;

--
-- Name: global_attribute_def_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.global_attribute_def_id_seq
CREATE SEQUENCE pantry.global_attribute_def_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.global_attribute_def_id_seq OWNER TO dbservice;

--
-- Name: global_attribute_def_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.global_attribute_def_id_seq OWNED BY pantry.global_attribute_def.id;


--
-- Name: group; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry."group" (
    id bigint NOT NULL,
    name character varying(45) NOT NULL,
    title character varying(45) NOT NULL,
    notes character varying(2000) DEFAULT ''::character varying NOT NULL,
    archived integer DEFAULT 0
);


ALTER TABLE pantry."group" OWNER TO dbservice;

--
-- Name: group_campus; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.group_campus (
    group_id bigint NOT NULL,
    campus_id bigint NOT NULL,
    owner smallint DEFAULT 0 NOT NULL,
    archived integer DEFAULT 0
);


ALTER TABLE pantry.group_campus OWNER TO dbservice;

--
-- Name: group_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.group_id_seq
CREATE SEQUENCE pantry.group_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.group_id_seq OWNER TO dbservice;

--
-- Name: group_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.group_id_seq OWNED BY pantry."group".id;


--
-- Name: history; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.history (
    id bigint NOT NULL,
    epc character varying(24) NOT NULL,
    kiosk_id bigint NOT NULL,
    user_id bigint,
    order_id character varying(45),
    direction character varying(3) NOT NULL,
    "time" bigint NOT NULL
);


ALTER TABLE pantry.history OWNER TO dbservice;

--
-- Name: history_campus_attribute; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.history_campus_attribute (
    id integer NOT NULL,
    time_modified timestamp with time zone,
    campus_id integer,
    gad_id integer,
    value character varying(100),
    action character varying(100)
);


ALTER TABLE pantry.history_campus_attribute OWNER TO dbservice;

--
-- Name: TABLE history_campus_attribute; Type: COMMENT; Schema: pantry; Owner: dbservice
--

COMMENT ON TABLE pantry.history_campus_attribute IS 'Table used to store changes information relating to history_campus_attribute';


--
-- Name: history_campus_attribute_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

ALTER TABLE pantry.history_campus_attribute ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME pantry.history_campus_attribute_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: history_epc_order; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.history_epc_order (
    id bigint NOT NULL,
    epc character varying(72) NOT NULL,
    kiosk_id bigint NOT NULL,
    order_id character varying(135),
    "time" bigint NOT NULL,
    product_id integer,
    price numeric(5,2),
    action character varying(135),
    system character varying(135),
    "user" character varying(135)
);


ALTER TABLE pantry.history_epc_order OWNER TO dbservice;

--
-- Name: history_epc_order_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.history_epc_order_id_seq
CREATE SEQUENCE pantry.history_epc_order_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.history_epc_order_id_seq OWNER TO dbservice;

--
-- Name: history_epc_order_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.history_epc_order_id_seq OWNED BY pantry.history_epc_order.id;


--
-- Name: history_global_attribute_def; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.history_global_attribute_def (
    id integer NOT NULL,
    time_modified timestamp with time zone,
    key character varying(45) NOT NULL,
    value character varying(100),
    action character varying(100)
);


ALTER TABLE pantry.history_global_attribute_def OWNER TO dbservice;

--
-- Name: TABLE history_global_attribute_def; Type: COMMENT; Schema: pantry; Owner: dbservice
--

COMMENT ON TABLE pantry.history_global_attribute_def IS 'Table used to store changes to global_attribute_def';


--
-- Name: history_global_attribute_def_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

ALTER TABLE pantry.history_global_attribute_def ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME pantry.history_global_attribute_def_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: history_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.history_id_seq
CREATE SEQUENCE pantry.history_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.history_id_seq OWNER TO dbservice;

--
-- Name: history_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.history_id_seq OWNED BY pantry.history.id;


--
-- Name: history_kiosk_attribute; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.history_kiosk_attribute (
    id integer NOT NULL,
    time_modified timestamp with time zone,
    kiosk_id integer,
    gad_id integer,
    value character varying(100),
    action character varying(100)
);


ALTER TABLE pantry.history_kiosk_attribute OWNER TO dbservice;

--
-- Name: TABLE history_kiosk_attribute; Type: COMMENT; Schema: pantry; Owner: dbservice
--

COMMENT ON TABLE pantry.history_kiosk_attribute IS 'Table used to store changes information relating to kiosk_attribute';


--
-- Name: history_kiosk_attribute_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

ALTER TABLE pantry.history_kiosk_attribute ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME pantry.history_kiosk_attribute_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: history_kiosk_device; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.history_kiosk_device (
    id integer NOT NULL,
    time_modified timestamp with time zone,
    kiosk_id integer,
    payload jsonb,
    action character varying(100)
);


ALTER TABLE pantry.history_kiosk_device OWNER TO dbservice;

--
-- Name: TABLE history_kiosk_device; Type: COMMENT; Schema: pantry; Owner: dbservice
--

COMMENT ON TABLE pantry.history_kiosk_device IS 'Table used to store changes information relating to kiosk_device';


--
-- Name: history_kiosk_device_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

ALTER TABLE pantry.history_kiosk_device ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME pantry.history_kiosk_device_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: history_kiosk_service_version; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.history_kiosk_service_version (
    id integer NOT NULL,
    time_modified timestamp with time zone,
    kiosk_id integer,
    service character varying(150),
    version character varying(100),
    action character varying(100)
);


ALTER TABLE pantry.history_kiosk_service_version OWNER TO dbservice;

--
-- Name: TABLE history_kiosk_service_version; Type: COMMENT; Schema: pantry; Owner: dbservice
--

COMMENT ON TABLE pantry.history_kiosk_service_version IS 'Table used to store changes information relating to kiosk_service_version';


--
-- Name: history_kiosk_service_version_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

ALTER TABLE pantry.history_kiosk_service_version ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME pantry.history_kiosk_service_version_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: inventory_history; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.inventory_history (
    id integer NOT NULL,
    "time" integer NOT NULL,
    kiosk_id integer NOT NULL,
    product_id integer NOT NULL,
    qty integer NOT NULL,
    campus_id integer NOT NULL,
    is_restored bigint NOT NULL
);


ALTER TABLE pantry.inventory_history OWNER TO dbservice;

--
-- Name: inventory_history_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.inventory_history_id_seq
CREATE SEQUENCE pantry.inventory_history_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.inventory_history_id_seq OWNER TO dbservice;

--
-- Name: inventory_history_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.inventory_history_id_seq OWNED BY pantry.inventory_history.id;


--
-- Name: inventory_request; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.inventory_request (
    id bigint NOT NULL,
    kiosk_id bigint,
    "time" bigint,
    epc character varying(72)
);


ALTER TABLE pantry.inventory_request OWNER TO dbservice;

--
-- Name: inventory_request_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.inventory_request_id_seq
CREATE SEQUENCE pantry.inventory_request_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.inventory_request_id_seq OWNER TO dbservice;

--
-- Name: inventory_request_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.inventory_request_id_seq OWNED BY pantry.inventory_request.id;


--
-- Name: kiosk_attribute; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.kiosk_attribute (
    id integer NOT NULL,
    kiosk_id bigint NOT NULL,
    key_id integer NOT NULL,
    value character varying(150) NOT NULL
);


ALTER TABLE pantry.kiosk_attribute OWNER TO dbservice;

--
-- Name: kiosk_attribute_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.kiosk_attribute_id_seq
CREATE SEQUENCE pantry.kiosk_attribute_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.kiosk_attribute_id_seq OWNER TO dbservice;

--
-- Name: kiosk_attribute_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.kiosk_attribute_id_seq OWNED BY pantry.kiosk_attribute.id;


--
-- Name: kiosk_audit_log; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.kiosk_audit_log (
    id bigint NOT NULL,
    kiosk_id integer NOT NULL,
    created_at timestamp without time zone DEFAULT now(),
    archived smallint,
    enable_reporting smallint,
    enable_monitoring smallint
);


ALTER TABLE pantry.kiosk_audit_log OWNER TO dbservice;

--
-- Name: kiosk_audit_log_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.kiosk_audit_log_id_seq
CREATE SEQUENCE pantry.kiosk_audit_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.kiosk_audit_log_id_seq OWNER TO dbservice;

--
-- Name: kiosk_audit_log_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.kiosk_audit_log_id_seq OWNED BY pantry.kiosk_audit_log.id;


--
-- Name: kiosk_catalog_downloads; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.kiosk_catalog_downloads (
    id bigint NOT NULL,
    kiosk_id bigint NOT NULL,
    "timestamp" bigint NOT NULL,
    duration bigint NOT NULL,
    num_bytes bigint NOT NULL,
    num_products bigint NOT NULL,
    current_discounts text,
    recent_discount_history text
);


ALTER TABLE pantry.kiosk_catalog_downloads OWNER TO dbservice;

--
-- Name: kiosk_catalog_downloads_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.kiosk_catalog_downloads_id_seq
CREATE SEQUENCE pantry.kiosk_catalog_downloads_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.kiosk_catalog_downloads_id_seq OWNER TO dbservice;

--
-- Name: kiosk_catalog_downloads_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.kiosk_catalog_downloads_id_seq OWNED BY pantry.kiosk_catalog_downloads.id;


--
-- Name: kiosk_cd_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.kiosk_cd_id_seq
CREATE SEQUENCE pantry.kiosk_cd_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.kiosk_cd_id_seq OWNER TO dbservice;

--
-- Name: kiosk_cd_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.kiosk_cd_id_seq OWNED BY pantry.kiosk_catalog_downloads.id;


--
-- Name: kiosk_components_history_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.kiosk_components_history_id_seq
CREATE SEQUENCE pantry.kiosk_components_history_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.kiosk_components_history_id_seq OWNER TO dbservice;

--
-- Name: kiosk_components_history_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.kiosk_components_history_id_seq OWNED BY pantry.kiosk_components_history.id;


--
-- Name: kiosk_device; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.kiosk_device (
    id integer NOT NULL,
    kiosk_id bigint NOT NULL,
    payload jsonb
);


ALTER TABLE pantry.kiosk_device OWNER TO dbservice;

--
-- Name: kiosk_device_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.kiosk_device_id_seq
CREATE SEQUENCE pantry.kiosk_device_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.kiosk_device_id_seq OWNER TO dbservice;

--
-- Name: kiosk_device_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.kiosk_device_id_seq OWNED BY pantry.kiosk_device.id;


--
-- Name: kiosk_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.kiosk_id_seq
CREATE SEQUENCE pantry.kiosk_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.kiosk_id_seq OWNER TO dbservice;

--
-- Name: kiosk_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.kiosk_id_seq OWNED BY pantry.kiosk.id;


--
-- Name: kiosk_par_level; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.kiosk_par_level (
    kiosk_id bigint NOT NULL,
    product_id bigint NOT NULL,
    amount bigint
);


ALTER TABLE pantry.kiosk_par_level OWNER TO dbservice;

--
-- Name: kiosk_service_version; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.kiosk_service_version (
    kiosk_id integer NOT NULL,
    service character varying(150) NOT NULL,
    version character varying(100)
);


ALTER TABLE pantry.kiosk_service_version OWNER TO dbservice;

--
-- Name: kiosk_status_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.kiosk_status_id_seq
CREATE SEQUENCE pantry.kiosk_status_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.kiosk_status_id_seq OWNER TO dbservice;

--
-- Name: kiosk_status_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.kiosk_status_id_seq OWNED BY pantry.kiosk_status.id;


--
-- Name: kiosks_date_non_new; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.kiosks_date_non_new (
    id integer NOT NULL,
    kiosk_id integer NOT NULL,
    new_ts integer NOT NULL
);


ALTER TABLE pantry.kiosks_date_non_new OWNER TO dbservice;

--
-- Name: kiosks_date_non_new_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.kiosks_date_non_new_id_seq
CREATE SEQUENCE pantry.kiosks_date_non_new_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.kiosks_date_non_new_id_seq OWNER TO dbservice;

--
-- Name: kiosks_date_non_new_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.kiosks_date_non_new_id_seq OWNED BY pantry.kiosks_date_non_new.id;


--
-- Name: label_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.label_id_seq
CREATE SEQUENCE pantry.label_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.label_id_seq OWNER TO dbservice;

--
-- Name: label_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.label_id_seq OWNED BY pantry.label.id;


--
-- Name: label_order; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.label_order (
    id bigint NOT NULL,
    product_id bigint,
    group_id bigint,
    box_id character varying(16),
    amount bigint NOT NULL,
    time_order bigint NOT NULL,
    time_encoded bigint,
    time_delivery bigint,
    time_updated bigint,
    status character varying(15),
    delivery_option character varying(255),
    priority character varying(255)
);


ALTER TABLE pantry.label_order OWNER TO dbservice;

--
-- Name: label_order_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.label_order_id_seq
CREATE SEQUENCE pantry.label_order_id_seq
    START WITH 1
    INCREMENT BY 2
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.label_order_id_seq OWNER TO dbservice;

--
-- Name: label_order_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.label_order_id_seq OWNED BY pantry.label_order.id;


--
-- Name: label_stats; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.label_stats (
    product_id bigint,
    used_since_last_delivery bigint,
    used_total bigint,
    last_delivery_date bigint,
    last_delivery bigint,
    delivered_total bigint
);


ALTER TABLE pantry.label_stats OWNER TO dbservice;

--
-- Name: last_kiosk_status; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.last_kiosk_status (
    id bigint NOT NULL,
    kiosk_id bigint NOT NULL,
    kiosk_temperature numeric(6,3),
    kiosk_temperature_count smallint,
    kit_temperature numeric(6,3),
    temperature_tags character varying(6141),
    kiosk_temperature_source character varying(93),
    power integer,
    battery_level smallint,
    rfid_0 integer,
    rfid_1 integer,
    rfid_2 integer,
    rfid_3 integer,
    rfid_4 integer,
    rfid_5 integer,
    rfid_6 integer,
    rfid_7 integer,
    "time" bigint,
    modem_signal_percentage smallint,
    modem_signal_type character varying(81),
    ip character varying(135),
    app_uptime bigint,
    system_uptime bigint,
    is_locked smallint,
    num_payment_messages_pending_sync integer DEFAULT 0
);


ALTER TABLE pantry.last_kiosk_status OWNER TO dbservice;

--
-- Name: last_kiosk_status_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.last_kiosk_status_id_seq
CREATE SEQUENCE pantry.last_kiosk_status_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.last_kiosk_status_id_seq OWNER TO dbservice;

--
-- Name: last_kiosk_status_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.last_kiosk_status_id_seq OWNED BY pantry.last_kiosk_status.id;


--
-- Name: manual_adjustment; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.manual_adjustment (
    id bigint NOT NULL,
    kiosk_id bigint NOT NULL,
    date character varying(45) NOT NULL,
    sum numeric(6,2) NOT NULL,
    reason character varying(128) NOT NULL,
    auto_generated smallint DEFAULT 0 NOT NULL,
    archived bigint DEFAULT 0 NOT NULL
);


ALTER TABLE pantry.manual_adjustment OWNER TO dbservice;

--
-- Name: manual_adjustment_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.manual_adjustment_id_seq
CREATE SEQUENCE pantry.manual_adjustment_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.manual_adjustment_id_seq OWNER TO dbservice;

--
-- Name: manual_adjustment_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.manual_adjustment_id_seq OWNED BY pantry.manual_adjustment.id;


--
-- Name: nutrition_filter; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.nutrition_filter (
    id bigint NOT NULL,
    tag_id bigint,
    label character varying(150),
    icon character varying(381)
);


ALTER TABLE pantry.nutrition_filter OWNER TO dbservice;

--
-- Name: nutrition_filter_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.nutrition_filter_id_seq
CREATE SEQUENCE pantry.nutrition_filter_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.nutrition_filter_id_seq OWNER TO dbservice;

--
-- Name: nutrition_filter_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.nutrition_filter_id_seq OWNED BY pantry.nutrition_filter.id;


--
-- Name: order_meta; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.order_meta (
    id integer NOT NULL,
    order_id character varying(45) NOT NULL,
    time_auth bigint,
    time_capture bigint,
    currency character varying DEFAULT 'USD'::character varying,
    num_scans_completed integer DEFAULT 0,
    tablet_processing_done boolean DEFAULT false,
    time_preauth bigint
);


ALTER TABLE pantry.order_meta OWNER TO dbservice;

--
-- Name: TABLE order_meta; Type: COMMENT; Schema: pantry; Owner: dbservice
--

COMMENT ON TABLE pantry.order_meta IS 'Table used to store additional information relating to pantry_meta';


--
-- Name: order_meta_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.order_meta_id_seq
CREATE SEQUENCE pantry.order_meta_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.order_meta_id_seq OWNER TO dbservice;

--
-- Name: order_meta_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.order_meta_id_seq OWNED BY pantry.order_meta.id;


--
-- Name: par_history; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.par_history (
    id integer NOT NULL,
    kiosk_id integer,
    par_level character varying(3069),
    end_time integer
);


ALTER TABLE pantry.par_history OWNER TO dbservice;

--
-- Name: par_history_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.par_history_id_seq
CREATE SEQUENCE pantry.par_history_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.par_history_id_seq OWNER TO dbservice;

--
-- Name: par_history_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.par_history_id_seq OWNED BY pantry.par_history.id;


--
-- Name: payment_order; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.payment_order (
    order_id character varying(45) NOT NULL,
    payload jsonb,
    re_auth_attempts integer DEFAULT 0,
    id integer NOT NULL
);


ALTER TABLE pantry.payment_order OWNER TO dbservice;

--
-- Name: payment_order_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.payment_order_id_seq
CREATE SEQUENCE pantry.payment_order_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.payment_order_id_seq OWNER TO dbservice;

--
-- Name: payment_order_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.payment_order_id_seq OWNED BY pantry.payment_order.id;


--
-- Name: payment_order_nursing; Type: VIEW; Schema: pantry; Owner: dbservice
--

CREATE VIEW pantry.payment_order_nursing AS
 SELECT payment_order.order_id,
    (payment_order.payload ->> 'nurse_id'::text) AS nurse_id,
    (payment_order.payload ->> 'patient_id'::text) AS patient_id
   FROM pantry.payment_order
  WHERE (((payment_order.payload ->> 'nurse_id'::text) IS NOT NULL) AND ((payment_order.payload ->> 'patient_id'::text) IS NOT NULL));


ALTER TABLE pantry.payment_order_nursing OWNER TO dbservice;

--
-- Name: permission; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.permission (
    id integer NOT NULL,
    permission character varying(765),
    api character varying(765),
    "isFrontend" integer NOT NULL
);


ALTER TABLE pantry.permission OWNER TO dbservice;

--
-- Name: permission_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.permission_id_seq
CREATE SEQUENCE pantry.permission_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.permission_id_seq OWNER TO dbservice;

--
-- Name: permission_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.permission_id_seq OWNED BY pantry.permission.id;


--
-- Name: permission_mapping; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.permission_mapping (
    role_id integer NOT NULL,
    permission_id integer NOT NULL
);


ALTER TABLE pantry.permission_mapping OWNER TO dbservice;

--
-- Name: pick_list_row; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.pick_list_row (
    id integer NOT NULL,
    "SiteCode" character varying(384),
    "SiteName" character varying(384),
    "PickStation" character varying(384),
    "Vendor" character varying(384),
    "ItemName" character varying(384),
    "ProposedSupply" integer,
    status character varying(150),
    "DriverName" character varying(384),
    "RouteTime" character varying(384),
    "RouteDate" character varying(384),
    "RouteNumber" character varying(384),
    route_time bigint,
    created bigint,
    "Refrigerated" character varying(65535),
    "TotalPickQty" character varying(65535),
    "TotalPickSKU" integer,
    "KioskInvQty" character varying(65535),
    "KioskSKUCnt" integer
);


ALTER TABLE pantry.pick_list_row OWNER TO dbservice;

--
-- Name: pick_list_row_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.pick_list_row_id_seq
CREATE SEQUENCE pantry.pick_list_row_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.pick_list_row_id_seq OWNER TO dbservice;

--
-- Name: pick_list_row_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.pick_list_row_id_seq OWNED BY pantry.pick_list_row.id;


--
-- Name: product_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.product_id_seq
CREATE SEQUENCE pantry.product_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.product_id_seq OWNER TO dbservice;

--
-- Name: product_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.product_id_seq OWNED BY pantry.product.id;


--
-- Name: product_20190507; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.product_20190507 (
    id bigint DEFAULT nextval('pantry.product_id_seq'::regclass) NOT NULL,
    title character varying(127) NOT NULL,
    description character varying(4095) DEFAULT 'No description yet'::character varying,
    tiny_description character varying(40),
    short_description character varying(100),
    medium_description character varying(400),
    long_description character varying(1200),
    price numeric(5,2) DEFAULT 0.00 NOT NULL,
    cost numeric(5,2) DEFAULT 0.00 NOT NULL,
    shelf_time integer DEFAULT 1 NOT NULL,
    campus_id bigint NOT NULL,
    image smallint DEFAULT 0 NOT NULL,
    image_time bigint,
    last_update bigint DEFAULT 0 NOT NULL,
    archived bigint DEFAULT 0,
    taxable smallint DEFAULT 0,
    allergens character varying(255),
    attribute_names character varying(511),
    categories character varying(255),
    category_names character varying(511),
    vendor character varying(135),
    source character varying(135),
    notes character varying(2000),
    total_cal bigint,
    num_servings real,
    ingredients character varying(2000),
    calories real,
    proteins real,
    sugar real,
    carbohydrates real,
    fat real,
    consumer_category character varying(2000),
    ws_case_size bigint,
    kiosk_ship_qty bigint,
    ws_case_cost numeric(5,2),
    pick_station bigint,
    fc_title character varying(255),
    pricing_tier character varying(255),
    width_space real,
    height_space real,
    depth_space real,
    slotted_width real,
    tag_volume bigint,
    delivery_option character varying(255) DEFAULT 'M'::character varying,
    tag_applied_by character varying(255) DEFAULT 'W'::character varying
);


ALTER TABLE pantry.product_20190507 OWNER TO dbservice;

--
-- Name: product_categories; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.product_categories (
    id bigint NOT NULL,
    cat_name character varying(50) NOT NULL,
    cat_name_tiny character varying(50),
    subcat_name character varying(50) NOT NULL,
    subcat_name_tiny character varying(50),
    tags character varying(255) NOT NULL,
    no_image_placeholder character varying(255),
    icon character varying(255)
);


ALTER TABLE pantry.product_categories OWNER TO dbservice;

--
-- Name: product_categories_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.product_categories_id_seq
CREATE SEQUENCE pantry.product_categories_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.product_categories_id_seq OWNER TO dbservice;

--
-- Name: product_categories_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.product_categories_id_seq OWNED BY pantry.product_categories.id;


--
-- Name: product_history; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.product_history (
    id integer NOT NULL,
    price numeric(5,2),
    cost numeric(5,2),
    start_time integer,
    end_time integer,
    product_id integer,
    campus_id integer
);


ALTER TABLE pantry.product_history OWNER TO dbservice;

--
-- Name: product_history_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.product_history_id_seq
CREATE SEQUENCE pantry.product_history_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.product_history_id_seq OWNER TO dbservice;

--
-- Name: product_history_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.product_history_id_seq OWNED BY pantry.product_history.id;


--
-- Name: product_kiosk_price_offset; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.product_kiosk_price_offset (
    id integer NOT NULL,
    name character varying(384),
    kiosk character varying(12288),
    product character varying(12288),
    vendor character varying(12288),
    discount character varying(3072),
    end_timestamp bigint
);


ALTER TABLE pantry.product_kiosk_price_offset OWNER TO dbservice;

--
-- Name: product_kiosk_price_offset_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.product_kiosk_price_offset_id_seq
CREATE SEQUENCE pantry.product_kiosk_price_offset_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.product_kiosk_price_offset_id_seq OWNER TO dbservice;

--
-- Name: product_kiosk_price_offset_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.product_kiosk_price_offset_id_seq OWNED BY pantry.product_kiosk_price_offset.id;


--
-- Name: product_request; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.product_request (
    id bigint NOT NULL,
    customer character varying(765),
    request_date date,
    customer_email character varying(765),
    product_id bigint,
    product_title character varying(765),
    kiosk_id bigint,
    kiosk_title character varying(765),
    request character varying(765),
    date_item_added date,
    increase_factor bigint,
    expiry_date date,
    purchased character varying(765)
);


ALTER TABLE pantry.product_request OWNER TO dbservice;

--
-- Name: product_request_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.product_request_id_seq
CREATE SEQUENCE pantry.product_request_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.product_request_id_seq OWNER TO dbservice;

--
-- Name: product_request_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.product_request_id_seq OWNED BY pantry.product_request.id;


--
-- Name: product_stats_by_kiosk; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.product_stats_by_kiosk (
    kiosk_id bigint,
    product_id bigint,
    is_new integer,
    is_popular integer,
    "timestamp" integer,
    date_when_new bigint,
    popularity_ranking bigint
);


ALTER TABLE pantry.product_stats_by_kiosk OWNER TO dbservice;

--
-- Name: recent_transactions; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.recent_transactions (
    kiosk_id integer NOT NULL,
    current_less_recent integer,
    current_most_recent integer,
    less_recent integer,
    most_recent integer
);


ALTER TABLE pantry.recent_transactions OWNER TO dbservice;

--
-- Name: refunds; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.refunds (
    order_id character varying(135) NOT NULL,
    product_id integer NOT NULL,
    price numeric(6,2) NOT NULL
);


ALTER TABLE pantry.refunds OWNER TO dbservice;

--
-- Name: restock_item; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.restock_item (
    id integer NOT NULL,
    order_id character varying(36),
    epc character varying(72),
    created integer,
    kiosk_id integer,
    product_id integer
);


ALTER TABLE pantry.restock_item OWNER TO dbservice;

--
-- Name: restock_item_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.restock_item_id_seq
CREATE SEQUENCE pantry.restock_item_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.restock_item_id_seq OWNER TO dbservice;

--
-- Name: restock_item_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.restock_item_id_seq OWNED BY pantry.restock_item.id;


--
-- Name: ro_order; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.ro_order (
    order_id character varying(135) NOT NULL,
    campus_id bigint NOT NULL,
    kiosk_id bigint NOT NULL,
    kiosk_title character varying(138),
    created bigint,
    state character varying(45) NOT NULL,
    customer_full_name character varying(300),
    full_price numeric(6,2),
    real_full_price numeric(6,2),
    archived bigint DEFAULT 0,
    time_updated bigint
);


ALTER TABLE pantry.ro_order OWNER TO dbservice;

--
-- Name: role; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.role (
    id integer NOT NULL,
    role character varying(765)
);


ALTER TABLE pantry.role OWNER TO dbservice;

--
-- Name: role_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.role_id_seq
CREATE SEQUENCE pantry.role_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.role_id_seq OWNER TO dbservice;

--
-- Name: role_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.role_id_seq OWNED BY pantry.role.id;


--
-- Name: role_mapping; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.role_mapping (
    role_id integer NOT NULL,
    parent_id integer NOT NULL
);


ALTER TABLE pantry.role_mapping OWNER TO dbservice;

--
-- Name: running_service; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.running_service (
    app_name text NOT NULL,
    started_at timestamp without time zone,
    host text
);


ALTER TABLE pantry.running_service OWNER TO dbservice;

--
-- Name: spoilage; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.spoilage (
    id integer NOT NULL,
    epc character varying(72) NOT NULL,
    kiosk_id integer NOT NULL,
    order_id character varying(135),
    time_removed integer,
    time_added integer,
    product_id integer,
    "timestamp" integer
);


ALTER TABLE pantry.spoilage OWNER TO dbservice;

--
-- Name: spoilage_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.spoilage_id_seq
CREATE SEQUENCE pantry.spoilage_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.spoilage_id_seq OWNER TO dbservice;

--
-- Name: spoilage_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.spoilage_id_seq OWNED BY pantry.spoilage.id;


--
-- Name: stockout; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.stockout (
    id integer NOT NULL,
    kiosk_id integer,
    product_id integer,
    order_id character varying(36),
    "timestamp" integer,
    restock_timestamp integer,
    restock_order_id character varying(36)
);


ALTER TABLE pantry.stockout OWNER TO dbservice;

--
-- Name: stockout_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.stockout_id_seq
CREATE SEQUENCE pantry.stockout_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.stockout_id_seq OWNER TO dbservice;

--
-- Name: stockout_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.stockout_id_seq OWNED BY pantry.stockout.id;


--
-- Name: tag; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.tag (
    id bigint NOT NULL,
    tag character varying(100)
);


ALTER TABLE pantry.tag OWNER TO dbservice;

--
-- Name: tag_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.tag_id_seq
CREATE SEQUENCE pantry.tag_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.tag_id_seq OWNER TO dbservice;

--
-- Name: tag_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.tag_id_seq OWNED BY pantry.tag.id;


--
-- Name: temp_kiosk_backup; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.temp_kiosk_backup (
    id bigint NOT NULL,
    campus_id bigint NOT NULL,
    serial character varying(135) NOT NULL,
    title character varying(138),
    address character varying(381),
    location_x numeric(9,6) NOT NULL,
    location_y numeric(9,6) NOT NULL,
    gcm_id character varying(765),
    app_vname character varying(189),
    app_vcode integer,
    archived bigint,
    creation_time bigint,
    deployment_time bigint,
    last_update bigint,
    client_name character varying(765),
    last_status bigint,
    last_inventory bigint NOT NULL,
    kiosk_name character varying(765) NOT NULL,
    payment_start bigint,
    payment_stop bigint,
    features character varying(765) NOT NULL,
    sales_tax smallint NOT NULL,
    default_fee_plan bigint NOT NULL,
    timezone character varying(150),
    estd_num_users bigint,
    tags character varying(765),
    publicly_accessible bigint,
    cardkey_required bigint,
    delivery_insns character varying(65535),
    fridge_loc_info character varying(65535),
    contact_first_name character varying(65535),
    contact_last_name character varying(65535),
    contact_email character varying(65535),
    contact_phone character varying(65535),
    accounting_email character varying(65535),
    byte_discount character varying(765),
    subsidy_info character varying(150),
    subsidy_notes character varying(65535),
    max_subscription character varying(150),
    delivery_window_mon character varying(150),
    delivery_window_tue character varying(150),
    delivery_window_wed character varying(150),
    delivery_window_thu character varying(150),
    delivery_window_fri character varying(150),
    delivery_window_sat character varying(150),
    delivery_window_sun character varying(150),
    notes character varying(6000),
    email_receipt_subject character varying(765),
    ops_team_notes character varying(65535),
    geo character varying(9),
    server_url character varying(381),
    subscription_amount numeric(8,2) NOT NULL,
    enable_reporting bigint,
    enable_monitoring bigint,
    employees_num bigint,
    kiosk_restrictions character varying(6000)
);


ALTER TABLE pantry.temp_kiosk_backup OWNER TO dbservice;

--
-- Name: temp_product_backup; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.temp_product_backup (
    id bigint NOT NULL,
    title character varying(127) NOT NULL,
    description character varying(4095),
    tiny_description character varying(40),
    short_description character varying(100),
    medium_description character varying(400),
    long_description character varying(1200),
    price numeric(5,2) NOT NULL,
    cost numeric(5,2) NOT NULL,
    shelf_time integer NOT NULL,
    campus_id bigint NOT NULL,
    image smallint NOT NULL,
    image_time bigint,
    last_update bigint NOT NULL,
    archived bigint,
    taxable smallint,
    allergens character varying(255),
    attribute_names character varying(511),
    categories character varying(255),
    category_names character varying(511),
    vendor character varying(135),
    source character varying(135),
    notes character varying(2000),
    total_cal bigint,
    num_servings real,
    ingredients character varying(2000),
    calories real,
    proteins real,
    sugar real,
    carbohydrates real,
    fat real,
    consumer_category character varying(2000),
    ws_case_size bigint,
    kiosk_ship_qty bigint,
    ws_case_cost numeric(5,2),
    pick_station bigint,
    fc_title character varying(255),
    pricing_tier character varying(255),
    width_space real,
    height_space real,
    depth_space real,
    slotted_width real,
    tag_volume bigint,
    delivery_option character varying(255),
    tag_applied_by character varying(255)
);


ALTER TABLE pantry.temp_product_backup OWNER TO dbservice;

--
-- Name: temperature_tag_history; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.temperature_tag_history (
    id bigint NOT NULL,
    kiosk_id bigint,
    "time" bigint,
    epc character varying(72),
    current numeric(5,2),
    average numeric(5,2),
    "full" character varying(381),
    read_count smallint
);


ALTER TABLE pantry.temperature_tag_history OWNER TO dbservice;

--
-- Name: temperature_tag_history_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.temperature_tag_history_id_seq
CREATE SEQUENCE pantry.temperature_tag_history_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.temperature_tag_history_id_seq OWNER TO dbservice;

--
-- Name: temperature_tag_history_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.temperature_tag_history_id_seq OWNED BY pantry.temperature_tag_history.id;


--
-- Name: tmp_april23_error_order_fixes; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.tmp_april23_error_order_fixes (
    order_id character varying(45) NOT NULL,
    transaction_id character varying(45),
    amount_paid numeric(6,2)
);


ALTER TABLE pantry.tmp_april23_error_order_fixes OWNER TO dbservice;

--
-- Name: tmp_backup_order_before_05_03_process_will; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.tmp_backup_order_before_05_03_process_will (
    order_id character varying(45),
    first_name character varying(45),
    last_name character varying(45),
    kiosk_id bigint,
    kiosk_title character varying(46),
    email character varying(127),
    amount_paid numeric(6,2),
    payment_system character varying(45),
    transaction_id character varying(45),
    approval_code character varying(45),
    status_code character varying(45),
    status_message character varying(45),
    status character varying(45),
    batch_id character varying(15),
    created bigint,
    auth_amount character varying(7),
    data_token character varying(2047),
    time_opened bigint,
    time_closed bigint,
    card_hash character varying(88),
    state character varying(15),
    archived bigint,
    stamp bigint,
    last_update bigint,
    balance numeric(7,2),
    delta character varying(4),
    coupon_id bigint,
    coupon character varying(45),
    refund numeric(6,2),
    receipt bigint,
    campus_id bigint,
    amount_list_price numeric(6,2),
    time_door_opened bigint,
    time_door_closed bigint,
    notes text
);


ALTER TABLE pantry.tmp_backup_order_before_05_03_process_will OWNER TO dbservice;

--
-- Name: tmp_cards_to_update; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.tmp_cards_to_update (
    card_id bigint NOT NULL,
    c_fn character varying(135),
    c_ln character varying(135),
    email character varying(381) NOT NULL
);


ALTER TABLE pantry.tmp_cards_to_update OWNER TO dbservice;

--
-- Name: tmp_eng_3692; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.tmp_eng_3692 (
    order_id character varying(45) NOT NULL
);


ALTER TABLE pantry.tmp_eng_3692 OWNER TO dbservice;

--
-- Name: tmp_eng_495_cards_to_update; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.tmp_eng_495_cards_to_update (
    card_id bigint NOT NULL,
    c_fn character varying(135),
    c_ln character varying(135)
);


ALTER TABLE pantry.tmp_eng_495_cards_to_update OWNER TO dbservice;

--
-- Name: tmp_march1_rollingback_auths; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.tmp_march1_rollingback_auths (
    order_id character varying(45)
);


ALTER TABLE pantry.tmp_march1_rollingback_auths OWNER TO dbservice;

--
-- Name: tmp_may4_error_order_fixes; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.tmp_may4_error_order_fixes (
    order_id character varying(45) NOT NULL,
    transaction_id character varying(45),
    amount_paid numeric(6,2)
);


ALTER TABLE pantry.tmp_may4_error_order_fixes OWNER TO dbservice;

--
-- Name: tmp_may4_pricefinalize_order_fixes; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.tmp_may4_pricefinalize_order_fixes (
    order_id character varying(45) NOT NULL,
    transaction_id character varying(45),
    amount_paid numeric(6,2)
);


ALTER TABLE pantry.tmp_may4_pricefinalize_order_fixes OWNER TO dbservice;

--
-- Name: tmp_order_eng_1915; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.tmp_order_eng_1915 (
    order_id character varying(45),
    campus_id bigint,
    kiosk_id bigint,
    receipt bigint,
    amount_paid numeric(6,2),
    state character varying(15),
    status character varying(45),
    created bigint,
    last_update bigint
);


ALTER TABLE pantry.tmp_order_eng_1915 OWNER TO dbservice;

--
-- Name: tmp_order_may_6_preapr23; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.tmp_order_may_6_preapr23 (
    order_id character varying(45),
    first_name character varying(45),
    last_name character varying(45),
    kiosk_id bigint,
    kiosk_title character varying(46),
    email character varying(127),
    amount_paid numeric(6,2),
    payment_system character varying(45),
    transaction_id character varying(45),
    approval_code character varying(45),
    status_code character varying(45),
    status_message character varying(45),
    status character varying(45),
    batch_id character varying(15),
    created bigint,
    auth_amount character varying(7),
    data_token character varying(2047),
    time_opened bigint,
    time_closed bigint,
    card_hash character varying(88),
    state character varying(15),
    archived bigint,
    stamp bigint,
    last_update bigint,
    balance numeric(7,2),
    delta character varying(4),
    coupon_id bigint,
    coupon character varying(45),
    refund numeric(6,2),
    receipt bigint,
    campus_id bigint,
    amount_list_price numeric(6,2),
    time_door_opened bigint,
    time_door_closed bigint,
    notes text
);


ALTER TABLE pantry.tmp_order_may_6_preapr23 OWNER TO dbservice;

--
-- Name: tmp_order_transaction_id_map; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.tmp_order_transaction_id_map (
    transaction_id integer NOT NULL,
    order_id character varying(45),
    amount numeric(5,2),
    direction character varying(5)
);


ALTER TABLE pantry.tmp_order_transaction_id_map OWNER TO dbservice;

--
-- Name: tmp_orderstoerror; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.tmp_orderstoerror (
    order_id character varying(45)
);


ALTER TABLE pantry.tmp_orderstoerror OWNER TO dbservice;

--
-- Name: tmp_payment_order; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.tmp_payment_order (
    order_id character varying(45) NOT NULL,
    payload text,
    re_auth_attempts integer DEFAULT 0
);


ALTER TABLE pantry.tmp_payment_order OWNER TO dbservice;

--
-- Name: tmp_payment_order_with_id; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.tmp_payment_order_with_id (
    order_id character varying(45) NOT NULL,
    payload text,
    re_auth_attempts integer DEFAULT 0,
    id integer NOT NULL
);


ALTER TABLE pantry.tmp_payment_order_with_id OWNER TO dbservice;

--
-- Name: tmp_payment_order_with_id_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

ALTER TABLE pantry.tmp_payment_order_with_id ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME pantry.tmp_payment_order_with_id_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: tmp_price_finalized_order_ids; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.tmp_price_finalized_order_ids (
    order_id character varying(45) DEFAULT 0 NOT NULL
);


ALTER TABLE pantry.tmp_price_finalized_order_ids OWNER TO dbservice;

--
-- Name: tmp_process_order_txt; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.tmp_process_order_txt (
    amount_paid character varying(15),
    approval_code character varying(45),
    batch_id character varying(15),
    state character varying(15),
    status character varying(45),
    status_code character varying(45),
    status_message character varying(45),
    transaction_id character varying(45),
    order_id character varying(45) NOT NULL,
    id integer NOT NULL
);


ALTER TABLE pantry.tmp_process_order_txt OWNER TO dbservice;

--
-- Name: tmp_process_order; Type: VIEW; Schema: pantry; Owner: dbservice
--

CREATE VIEW pantry.tmp_process_order AS
 SELECT ("substring"((tmp_process_order_txt.amount_paid)::text, 5))::numeric(6,2) AS amount_paid,
    tmp_process_order_txt.approval_code,
    tmp_process_order_txt.batch_id,
    tmp_process_order_txt.state,
    tmp_process_order_txt.status,
    tmp_process_order_txt.status_code,
    tmp_process_order_txt.status_message,
    tmp_process_order_txt.transaction_id,
    tmp_process_order_txt.order_id,
    tmp_process_order_txt.id
   FROM pantry.tmp_process_order_txt;


ALTER TABLE pantry.tmp_process_order OWNER TO dbservice;

--
-- Name: tmp_process_order_txt_d_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

ALTER TABLE pantry.tmp_process_order_txt ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME pantry.tmp_process_order_txt_d_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: tmp_process_order_vantiv; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.tmp_process_order_vantiv (
    date integer,
    "time" integer,
    transactionid integer,
    status character varying(40),
    accountid character varying(40),
    acceptorid character varying(40),
    transactiontype character varying(40),
    rc integer,
    rm character varying(40),
    amount numeric(6,2),
    card character varying(40),
    apprv character varying(40),
    id integer NOT NULL
);


ALTER TABLE pantry.tmp_process_order_vantiv OWNER TO dbservice;

--
-- Name: tmp_process_order_vantiv_d_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

ALTER TABLE pantry.tmp_process_order_vantiv ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME pantry.tmp_process_order_vantiv_d_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: tmp_revert_order_status; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.tmp_revert_order_status (
    order_id character varying(45) NOT NULL
);


ALTER TABLE pantry.tmp_revert_order_status OWNER TO dbservice;

--
-- Name: tmp_watcher; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.tmp_watcher (
    label_id bigint,
    order_id character varying(135) NOT NULL,
    created bigint
);


ALTER TABLE pantry.tmp_watcher OWNER TO dbservice;

--
-- Name: transact_comp; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.transact_comp (
    id bigint NOT NULL,
    order_id character varying(93),
    result character varying(3069),
    "time" bigint
);


ALTER TABLE pantry.transact_comp OWNER TO dbservice;

--
-- Name: transact_comp_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.transact_comp_id_seq
CREATE SEQUENCE pantry.transact_comp_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.transact_comp_id_seq OWNER TO dbservice;

--
-- Name: transact_comp_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.transact_comp_id_seq OWNED BY pantry.transact_comp.id;


--
-- Name: transact_express; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.transact_express (
    id bigint NOT NULL,
    order_id character varying(93),
    amount numeric(4,2),
    "time" bigint,
    ksn character varying(93),
    magne_print character varying(381),
    magne_print_status character varying(381),
    track2 character varying(381),
    transaction_id character varying(150),
    approval_code character varying(150),
    status_code character varying(150),
    status_message character varying(150),
    status character varying(150),
    batch_id character varying(45)
);


ALTER TABLE pantry.transact_express OWNER TO dbservice;

--
-- Name: transact_express_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.transact_express_id_seq
CREATE SEQUENCE pantry.transact_express_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.transact_express_id_seq OWNER TO dbservice;

--
-- Name: transact_express_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.transact_express_id_seq OWNED BY pantry.transact_express.id;


--
-- Name: transact_fp; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.transact_fp (
    id bigint NOT NULL,
    order_id character varying(93),
    result character varying(3069),
    "time" bigint
);


ALTER TABLE pantry.transact_fp OWNER TO dbservice;

--
-- Name: transact_fp_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.transact_fp_id_seq
CREATE SEQUENCE pantry.transact_fp_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.transact_fp_id_seq OWNER TO dbservice;

--
-- Name: transact_fp_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.transact_fp_id_seq OWNED BY pantry.transact_fp.id;


--
-- Name: transact_ipc; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry.transact_ipc (
    id bigint NOT NULL,
    order_id character varying(93),
    result character varying(12285),
    "time" bigint
);


ALTER TABLE pantry.transact_ipc OWNER TO dbservice;

--
-- Name: transact_ipc_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.transact_ipc_id_seq
CREATE SEQUENCE pantry.transact_ipc_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.transact_ipc_id_seq OWNER TO dbservice;

--
-- Name: transact_ipc_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.transact_ipc_id_seq OWNED BY pantry.transact_ipc.id;


--
-- Name: user; Type: TABLE; Schema: pantry; Owner: dbservice
--

CREATE TABLE pantry."user" (
    id bigint NOT NULL,
    login character varying(45) NOT NULL,
    first_name character varying(127),
    last_name character varying(127),
    password character varying(88) NOT NULL,
    email character varying(127),
    role_id bigint DEFAULT 2 NOT NULL,
    group_id bigint DEFAULT 0 NOT NULL,
    archived bigint DEFAULT 0 NOT NULL,
    date_registered bigint NOT NULL,
    timezone character varying(50),
    email_params character varying(65535),
    token character varying(40),
    notes character varying(2000)
);


ALTER TABLE pantry."user" OWNER TO dbservice;

--
-- Name: user_id_seq; Type: SEQUENCE; Schema: pantry; Owner: dbservice
--

CREATE SEQUENCE pantry.user_id_seq
CREATE SEQUENCE pantry.user_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.user_id_seq OWNER TO dbservice;

--
-- Name: user_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: dbservice
--

ALTER SEQUENCE pantry.user_id_seq OWNED BY pantry."user".id;


--
-- Name: awsdms_apply_exceptions; Type: TABLE; Schema: public; Owner: dbservice
--

CREATE TABLE public.awsdms_apply_exceptions (
    "TASK_NAME" character varying(384) NOT NULL,
    "TABLE_OWNER" character varying(384) NOT NULL,
    "TABLE_NAME" character varying(384) NOT NULL,
    "ERROR_TIME" timestamp without time zone NOT NULL,
    "STATEMENT" text NOT NULL,
    "ERROR" text NOT NULL
);


ALTER TABLE public.awsdms_apply_exceptions OWNER TO dbservice;

--
-- Name: awsdms_ddl_audit; Type: TABLE; Schema: public; Owner: dbservice
--

CREATE TABLE public.awsdms_ddl_audit (
    c_key bigint NOT NULL,
    c_time timestamp(6) without time zone,
    c_user character varying(64),
    c_txn character varying(16),
    c_tag character varying(24),
    c_oid integer,
    c_name character varying(64),
    c_schema character varying(64),
    c_ddlqry text
);


ALTER TABLE public.awsdms_ddl_audit OWNER TO dbservice;

--
-- Name: awsdms_ddl_audit_c_key_seq; Type: SEQUENCE; Schema: public; Owner: dbservice
--

CREATE SEQUENCE public.awsdms_ddl_audit_c_key_seq
CREATE SEQUENCE public.awsdms_ddl_audit_c_key_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.awsdms_ddl_audit_c_key_seq OWNER TO dbservice;

--
-- Name: awsdms_ddl_audit_c_key_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: dbservice
--

ALTER SEQUENCE public.awsdms_ddl_audit_c_key_seq OWNED BY public.awsdms_ddl_audit.c_key;


--
-- Name: awsdms_heartbeat; Type: TABLE; Schema: public; Owner: dbservice
--

CREATE TABLE public.awsdms_heartbeat (
    hb_key integer NOT NULL,
    hb_created_at timestamp without time zone,
    hb_created_by character varying(64),
    hb_last_heartbeat_at timestamp without time zone,
    hb_last_heartbeat_by character varying(64)
);


ALTER TABLE public.awsdms_heartbeat OWNER TO dbservice;

--
-- Name: awsdms_heartbeat_hb_key_seq; Type: SEQUENCE; Schema: public; Owner: dbservice
--

CREATE SEQUENCE public.awsdms_heartbeat_hb_key_seq
CREATE SEQUENCE public.awsdms_heartbeat_hb_key_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.awsdms_heartbeat_hb_key_seq OWNER TO dbservice;

--
-- Name: awsdms_heartbeat_hb_key_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: dbservice
--

ALTER SEQUENCE public.awsdms_heartbeat_hb_key_seq OWNED BY public.awsdms_heartbeat.hb_key;


--
-- Name: awsdms_history; Type: TABLE; Schema: public; Owner: dbservice
--

CREATE TABLE public.awsdms_history (
    server_name character varying(384) NOT NULL,
    task_name character varying(384) NOT NULL,
    timeslot_type character varying(96) NOT NULL,
    timeslot timestamp without time zone NOT NULL,
    timeslot_duration bigint,
    timeslot_latency bigint,
    timeslot_records bigint,
    timeslot_volume bigint
);


ALTER TABLE public.awsdms_history OWNER TO dbservice;

--
-- Name: awsdms_status; Type: TABLE; Schema: public; Owner: dbservice
--

CREATE TABLE public.awsdms_status (
    server_name character varying(384) NOT NULL,
    task_name character varying(384) NOT NULL,
    task_status character varying(96),
    status_time timestamp without time zone,
    pending_changes bigint,
    disk_swap_size bigint,
    task_memory bigint,
    source_current_position character varying(384),
    source_current_timestamp timestamp without time zone,
    source_tail_position character varying(384),
    source_tail_timestamp timestamp without time zone,
    source_timestamp_applied timestamp without time zone
);


ALTER TABLE public.awsdms_status OWNER TO dbservice;

--
-- Name: awsdms_suspended_tables; Type: TABLE; Schema: public; Owner: dbservice
--

CREATE TABLE public.awsdms_suspended_tables (
    server_name character varying(384) NOT NULL,
    task_name character varying(384) NOT NULL,
    table_owner character varying(384) NOT NULL,
    table_name character varying(384) NOT NULL,
    suspend_reason character varying(96),
    suspend_timestamp timestamp without time zone
);


ALTER TABLE public.awsdms_suspended_tables OWNER TO dbservice;

--
-- Name: awsdms_validation_failures_v1; Type: TABLE; Schema: public; Owner: dbservice
--

CREATE TABLE public.awsdms_validation_failures_v1 (
    "TASK_NAME" character varying(128) NOT NULL,
    "TABLE_OWNER" character varying(128) NOT NULL,
    "TABLE_NAME" character varying(128) NOT NULL,
    "FAILURE_TIME" timestamp without time zone NOT NULL,
    "KEY_TYPE" character varying(128) NOT NULL,
    "KEY" character varying(8000) NOT NULL,
    "FAILURE_TYPE" character varying(128) NOT NULL,
    "DETAILS" character varying(8000) NOT NULL
);


ALTER TABLE public.awsdms_validation_failures_v1 OWNER TO dbservice;

--
-- Name: byte_tickets_120days; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_tickets_120days AS
 SELECT byte_tickets.order_id,
    byte_tickets.first_name,
    byte_tickets.last_name,
    byte_tickets.kiosk_id,
    byte_tickets.kiosk_title,
    byte_tickets.email,
    byte_tickets.amount_paid,
    byte_tickets.payment_system,
    byte_tickets.transaction_id,
    byte_tickets.approval_code,
    byte_tickets.status_code,
    byte_tickets.status_message,
    byte_tickets.status,
    byte_tickets.batch_id,
    byte_tickets.created,
    byte_tickets.auth_amount,
    byte_tickets.data_token,
    byte_tickets.time_opened,
    byte_tickets.time_closed,
    byte_tickets.card_hash,
    byte_tickets.state,
    byte_tickets.archived,
    byte_tickets.stamp,
    byte_tickets.last_update,
    byte_tickets.balance,
    byte_tickets.delta,
    byte_tickets.coupon_id,
    byte_tickets.coupon,
    byte_tickets.refund,
    byte_tickets.receipt,
    byte_tickets.campus_id,
    byte_tickets.amount_list_price,
    byte_tickets.notes,
    byte_tickets.time_door_opened,
    byte_tickets.time_door_closed,
    byte_tickets.client_name,
    byte_tickets.estd_num_users,
    byte_tickets.ts,
    byte_tickets.full_name,
    byte_tickets.door_opened_secs,
    byte_tickets.month,
    byte_tickets.week,
    byte_tickets.date,
    byte_tickets.dayofweek,
    byte_tickets.hour,
    byte_tickets.dowhour,
    byte_tickets.uniq_user
   FROM public.byte_tickets
  WHERE (byte_tickets.ts > (now() - '120 days'::interval day));


ALTER TABLE public.byte_tickets_120days OWNER TO dbservice;

--
-- Name: byte_epcssold_120days; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_epcssold_120days AS
 SELECT o.order_id,
    o.first_name,
    o.last_name,
    o.kiosk_id,
    o.kiosk_title,
    o.email,
    o.amount_paid,
    o.payment_system,
    o.transaction_id,
    o.approval_code,
    o.status_code,
    o.status_message,
    o.status,
    o.batch_id,
    o.created,
    o.auth_amount,
    o.data_token,
    o.time_opened,
    o.time_closed,
    o.card_hash,
    o.state,
    o.archived,
    o.stamp,
    o.last_update,
    o.balance,
    o.delta,
    o.coupon_id,
    o.coupon,
    o.refund,
    o.receipt,
    o.campus_id,
    o.amount_list_price,
    o.notes,
    o.time_door_opened,
    o.time_door_closed,
    o.client_name,
    o.estd_num_users,
    o.ts,
    o.full_name,
    o.door_opened_secs,
    o.month,
    o.week,
    o.date,
    o.dayofweek,
    o.hour,
    o.dowhour,
    o.uniq_user,
    lp.epc,
    lp.label_order_id,
    lp.label_status,
    lp.label_price,
    lp.time_created,
    lp.time_added,
    lp.time_updated,
    lp.ts_created,
    lp.ts_added,
    lp.ts_updated,
    lp.label_kiosk_id,
    lp.product_id,
    lp.product_title,
    lp.product_archived,
    lp.product_vendor,
    lp.product_price,
    lp.product_cost,
    lp.product_shelf_life_days,
    lp.product_attributes,
    lp.product_categories,
    lp.consumer_category,
    lp.product_source
   FROM (public.byte_tickets_120days o
     JOIN public.byte_label_product lp ON (((lp.label_order_id)::text = (o.order_id)::text)))
  WHERE ((lp.label_status)::text = 'sold'::text);


ALTER TABLE public.byte_epcssold_120days OWNER TO dbservice;

--
-- Name: byte_addicted_users_120days; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_addicted_users_120days AS
 SELECT t.kiosk_id,
    t.kiosk_title,
    t.product_id,
    t.product_title,
    count(*) AS count
   FROM ( SELECT items.kiosk_id,
            items.kiosk_title,
            ((btrim((items.first_name)::text) || ' '::text) || btrim((items.last_name)::text)) AS username,
            items.product_id,
            items.product_title,
            count(*) AS last_120d_purchases,
            sum(public.if((items.ts > (now() - '14 days'::interval day)), 1, 0)) AS last_14d_purchases
           FROM public.byte_epcssold_120days items
          GROUP BY items.kiosk_id, items.kiosk_title, ((btrim((items.first_name)::text) || ' '::text) || btrim((items.last_name)::text)), items.product_id, items.product_title) t
  WHERE ((t.last_14d_purchases >= 1) AND (t.last_120d_purchases >= 6) AND (t.username <> ALL (ARRAY[''::text, 'Free Complimentary'::text])))
  GROUP BY t.kiosk_id, t.kiosk_title, t.product_id, t.product_title;


ALTER TABLE public.byte_addicted_users_120days OWNER TO dbservice;

--
-- Name: iplanner_inventory; Type: TABLE; Schema: public; Owner: dbservice
--

CREATE TABLE public.iplanner_inventory (
    dccode character varying(250),
    dcname character varying(250),
    bytesku integer,
    product character varying(250),
    date timestamp(6) without time zone,
    lotnumber timestamp(6) without time zone,
    inventory_count numeric(28,6),
    inventory_amount numeric(28,6),
    unit_amount numeric(28,6),
    expiration_date timestamp(6) without time zone,
    id integer
);


ALTER TABLE public.iplanner_inventory OWNER TO dbservice;

--
-- Name: byte_dc_inventory_history; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_dc_inventory_history AS
 SELECT iplanner_inventory.dccode AS dc,
    iplanner_inventory.bytesku AS product_id,
    iplanner_inventory.date,
    iplanner_inventory.inventory_count
   FROM public.iplanner_inventory;


ALTER TABLE public.byte_dc_inventory_history OWNER TO dbservice;

--
-- Name: byte_epcssold; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_epcssold AS
 SELECT o.order_id,
    o.first_name,
    o.last_name,
    o.kiosk_id,
    o.kiosk_title,
    o.email,
    o.amount_paid,
    o.payment_system,
    o.transaction_id,
    o.approval_code,
    o.status_code,
    o.status_message,
    o.status,
    o.batch_id,
    o.created,
    o.auth_amount,
    o.data_token,
    o.time_opened,
    o.time_closed,
    o.card_hash,
    o.state,
    o.archived,
    o.stamp,
    o.last_update,
    o.balance,
    o.delta,
    o.coupon_id,
    o.coupon,
    o.refund,
    o.receipt,
    o.campus_id,
    o.amount_list_price,
    o.notes,
    o.time_door_opened,
    o.time_door_closed,
    o.client_name,
    o.estd_num_users,
    o.ts,
    o.full_name,
    o.door_opened_secs,
    o.month,
    o.week,
    o.date,
    o.dayofweek,
    o.hour,
    o.dowhour,
    o.uniq_user,
    lp.epc,
    lp.label_order_id,
    lp.label_status,
    lp.label_price,
    lp.time_created,
    lp.time_added,
    lp.time_updated,
    lp.ts_created,
    lp.ts_added,
    lp.ts_updated,
    lp.label_kiosk_id,
    lp.product_id,
    lp.product_title,
    lp.product_archived,
    lp.product_vendor,
    lp.product_price,
    lp.product_cost,
    lp.product_shelf_life_days,
    lp.product_attributes,
    lp.product_categories,
    lp.consumer_category,
    lp.product_source
   FROM (public.byte_tickets o
     JOIN public.byte_label_product lp ON (((lp.label_order_id)::text = (o.order_id)::text)))
  WHERE ((lp.label_status)::text = 'sold'::text);


ALTER TABLE public.byte_epcssold OWNER TO dbservice;

--
-- Name: byte_tickets_10weeks; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_tickets_10weeks AS
 SELECT byte_tickets.order_id,
    byte_tickets.first_name,
    byte_tickets.last_name,
    byte_tickets.kiosk_id,
    byte_tickets.kiosk_title,
    byte_tickets.email,
    byte_tickets.amount_paid,
    byte_tickets.payment_system,
    byte_tickets.transaction_id,
    byte_tickets.approval_code,
    byte_tickets.status_code,
    byte_tickets.status_message,
    byte_tickets.status,
    byte_tickets.batch_id,
    byte_tickets.created,
    byte_tickets.auth_amount,
    byte_tickets.data_token,
    byte_tickets.time_opened,
    byte_tickets.time_closed,
    byte_tickets.card_hash,
    byte_tickets.state,
    byte_tickets.archived,
    byte_tickets.stamp,
    byte_tickets.last_update,
    byte_tickets.balance,
    byte_tickets.delta,
    byte_tickets.coupon_id,
    byte_tickets.coupon,
    byte_tickets.refund,
    byte_tickets.receipt,
    byte_tickets.campus_id,
    byte_tickets.amount_list_price,
    byte_tickets.notes,
    byte_tickets.time_door_opened,
    byte_tickets.time_door_closed,
    byte_tickets.client_name,
    byte_tickets.estd_num_users,
    byte_tickets.ts,
    byte_tickets.full_name,
    byte_tickets.door_opened_secs,
    byte_tickets.month,
    byte_tickets.week,
    byte_tickets.date,
    byte_tickets.dayofweek,
    byte_tickets.hour,
    byte_tickets.dowhour,
    byte_tickets.uniq_user
   FROM public.byte_tickets
  WHERE (byte_tickets.ts > (now() - '70 days'::interval day));


ALTER TABLE public.byte_tickets_10weeks OWNER TO dbservice;

--
-- Name: byte_epcssold_10weeks; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_epcssold_10weeks AS
 SELECT o.order_id,
    o.first_name,
    o.last_name,
    o.kiosk_id,
    o.kiosk_title,
    o.email,
    o.amount_paid,
    o.payment_system,
    o.transaction_id,
    o.approval_code,
    o.status_code,
    o.status_message,
    o.status,
    o.batch_id,
    o.created,
    o.auth_amount,
    o.data_token,
    o.time_opened,
    o.time_closed,
    o.card_hash,
    o.state,
    o.archived,
    o.stamp,
    o.last_update,
    o.balance,
    o.delta,
    o.coupon_id,
    o.coupon,
    o.refund,
    o.receipt,
    o.campus_id,
    o.amount_list_price,
    o.notes,
    o.time_door_opened,
    o.time_door_closed,
    o.client_name,
    o.estd_num_users,
    o.ts,
    o.full_name,
    o.door_opened_secs,
    o.month,
    o.week,
    o.date,
    o.dayofweek,
    o.hour,
    o.dowhour,
    o.uniq_user,
    lp.epc,
    lp.label_order_id,
    lp.label_status,
    lp.label_price,
    lp.time_created,
    lp.time_added,
    lp.time_updated,
    lp.ts_created,
    lp.ts_added,
    lp.ts_updated,
    lp.label_kiosk_id,
    lp.product_id,
    lp.product_title,
    lp.product_archived,
    lp.product_vendor,
    lp.product_price,
    lp.product_cost,
    lp.product_shelf_life_days,
    lp.product_attributes,
    lp.product_categories,
    lp.consumer_category,
    lp.product_source
   FROM (public.byte_tickets_10weeks o
     JOIN public.byte_label_product lp ON (((lp.label_order_id)::text = (o.order_id)::text)))
  WHERE ((lp.label_status)::text = 'sold'::text);


ALTER TABLE public.byte_epcssold_10weeks OWNER TO dbservice;

--
-- Name: byte_tickets_12months; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_tickets_12months AS
 SELECT byte_tickets.order_id,
    byte_tickets.first_name,
    byte_tickets.last_name,
    byte_tickets.kiosk_id,
    byte_tickets.kiosk_title,
    byte_tickets.email,
    byte_tickets.amount_paid,
    byte_tickets.payment_system,
    byte_tickets.transaction_id,
    byte_tickets.approval_code,
    byte_tickets.status_code,
    byte_tickets.status_message,
    byte_tickets.status,
    byte_tickets.batch_id,
    byte_tickets.created,
    byte_tickets.auth_amount,
    byte_tickets.data_token,
    byte_tickets.time_opened,
    byte_tickets.time_closed,
    byte_tickets.card_hash,
    byte_tickets.state,
    byte_tickets.archived,
    byte_tickets.stamp,
    byte_tickets.last_update,
    byte_tickets.balance,
    byte_tickets.delta,
    byte_tickets.coupon_id,
    byte_tickets.coupon,
    byte_tickets.refund,
    byte_tickets.receipt,
    byte_tickets.campus_id,
    byte_tickets.amount_list_price,
    byte_tickets.notes,
    byte_tickets.time_door_opened,
    byte_tickets.time_door_closed,
    byte_tickets.client_name,
    byte_tickets.estd_num_users,
    byte_tickets.ts,
    byte_tickets.full_name,
    byte_tickets.door_opened_secs,
    byte_tickets.month,
    byte_tickets.week,
    byte_tickets.date,
    byte_tickets.dayofweek,
    byte_tickets.hour,
    byte_tickets.dowhour,
    byte_tickets.uniq_user
   FROM public.byte_tickets
  WHERE (byte_tickets.ts > (now() - '1 year'::interval month));


ALTER TABLE public.byte_tickets_12months OWNER TO dbservice;

--
-- Name: byte_epcssold_12months; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_epcssold_12months AS
 SELECT o.order_id,
    o.first_name,
    o.last_name,
    o.kiosk_id,
    o.kiosk_title,
    o.email,
    o.amount_paid,
    o.payment_system,
    o.transaction_id,
    o.approval_code,
    o.status_code,
    o.status_message,
    o.status,
    o.batch_id,
    o.created,
    o.auth_amount,
    o.data_token,
    o.time_opened,
    o.time_closed,
    o.card_hash,
    o.state,
    o.archived,
    o.stamp,
    o.last_update,
    o.balance,
    o.delta,
    o.coupon_id,
    o.coupon,
    o.refund,
    o.receipt,
    o.campus_id,
    o.amount_list_price,
    o.notes,
    o.time_door_opened,
    o.time_door_closed,
    o.client_name,
    o.estd_num_users,
    o.ts,
    o.full_name,
    o.door_opened_secs,
    o.month,
    o.week,
    o.date,
    o.dayofweek,
    o.hour,
    o.dowhour,
    o.uniq_user,
    lp.epc,
    lp.label_order_id,
    lp.label_status,
    lp.label_price,
    lp.time_created,
    lp.time_added,
    lp.time_updated,
    lp.ts_created,
    lp.ts_added,
    lp.ts_updated,
    lp.label_kiosk_id,
    lp.product_id,
    lp.product_title,
    lp.product_archived,
    lp.product_vendor,
    lp.product_price,
    lp.product_cost,
    lp.product_shelf_life_days,
    lp.product_attributes,
    lp.product_categories,
    lp.consumer_category,
    lp.product_source,
    lp.fc_title
   FROM (public.byte_tickets_12months o
     JOIN public.byte_label_product lp ON (((lp.label_order_id)::text = (o.order_id)::text)))
  WHERE ((lp.label_status)::text = 'sold'::text);


ALTER TABLE public.byte_epcssold_12months OWNER TO dbservice;

--
-- Name: byte_tickets_180days; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_tickets_180days AS
 SELECT byte_tickets.order_id,
    byte_tickets.first_name,
    byte_tickets.last_name,
    byte_tickets.kiosk_id,
    byte_tickets.kiosk_title,
    byte_tickets.email,
    byte_tickets.amount_paid,
    byte_tickets.payment_system,
    byte_tickets.transaction_id,
    byte_tickets.approval_code,
    byte_tickets.status_code,
    byte_tickets.status_message,
    byte_tickets.status,
    byte_tickets.batch_id,
    byte_tickets.created,
    byte_tickets.auth_amount,
    byte_tickets.data_token,
    byte_tickets.time_opened,
    byte_tickets.time_closed,
    byte_tickets.card_hash,
    byte_tickets.state,
    byte_tickets.archived,
    byte_tickets.stamp,
    byte_tickets.last_update,
    byte_tickets.balance,
    byte_tickets.delta,
    byte_tickets.coupon_id,
    byte_tickets.coupon,
    byte_tickets.refund,
    byte_tickets.receipt,
    byte_tickets.campus_id,
    byte_tickets.amount_list_price,
    byte_tickets.notes,
    byte_tickets.time_door_opened,
    byte_tickets.time_door_closed,
    byte_tickets.client_name,
    byte_tickets.estd_num_users,
    byte_tickets.ts,
    byte_tickets.full_name,
    byte_tickets.door_opened_secs,
    byte_tickets.month,
    byte_tickets.week,
    byte_tickets.date,
    byte_tickets.dayofweek,
    byte_tickets.hour,
    byte_tickets.dowhour,
    byte_tickets.uniq_user
   FROM public.byte_tickets
  WHERE (byte_tickets.ts > (now() - '180 days'::interval day));


ALTER TABLE public.byte_tickets_180days OWNER TO dbservice;

--
-- Name: byte_epcssold_180days; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_epcssold_180days AS
 SELECT o.order_id,
    o.first_name,
    o.last_name,
    o.kiosk_id,
    o.kiosk_title,
    o.email,
    o.amount_paid,
    o.payment_system,
    o.transaction_id,
    o.approval_code,
    o.status_code,
    o.status_message,
    o.status,
    o.batch_id,
    o.created,
    o.auth_amount,
    o.data_token,
    o.time_opened,
    o.time_closed,
    o.card_hash,
    o.state,
    o.archived,
    o.stamp,
    o.last_update,
    o.balance,
    o.delta,
    o.coupon_id,
    o.coupon,
    o.refund,
    o.receipt,
    o.campus_id,
    o.amount_list_price,
    o.notes,
    o.time_door_opened,
    o.time_door_closed,
    o.client_name,
    o.estd_num_users,
    o.ts,
    o.full_name,
    o.door_opened_secs,
    o.month,
    o.week,
    o.date,
    o.dayofweek,
    o.hour,
    o.dowhour,
    o.uniq_user,
    lp.epc,
    lp.label_order_id,
    lp.label_status,
    lp.label_price,
    lp.time_created,
    lp.time_added,
    lp.time_updated,
    lp.ts_created,
    lp.ts_added,
    lp.ts_updated,
    lp.label_kiosk_id,
    lp.product_id,
    lp.product_title,
    lp.product_archived,
    lp.product_vendor,
    lp.product_price,
    lp.product_cost,
    lp.product_shelf_life_days,
    lp.product_attributes,
    lp.product_categories,
    lp.consumer_category,
    lp.product_source
   FROM (public.byte_tickets_180days o
     JOIN public.byte_label_product lp ON (((lp.label_order_id)::text = (o.order_id)::text)))
  WHERE ((lp.label_status)::text = 'sold'::text);


ALTER TABLE public.byte_epcssold_180days OWNER TO dbservice;

--
-- Name: byte_tickets_1day; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_tickets_1day AS
 SELECT byte_tickets.order_id,
    byte_tickets.first_name,
    byte_tickets.last_name,
    byte_tickets.kiosk_id,
    byte_tickets.kiosk_title,
    byte_tickets.email,
    byte_tickets.amount_paid,
    byte_tickets.payment_system,
    byte_tickets.transaction_id,
    byte_tickets.approval_code,
    byte_tickets.status_code,
    byte_tickets.status_message,
    byte_tickets.status,
    byte_tickets.batch_id,
    byte_tickets.created,
    byte_tickets.auth_amount,
    byte_tickets.data_token,
    byte_tickets.time_opened,
    byte_tickets.time_closed,
    byte_tickets.card_hash,
    byte_tickets.state,
    byte_tickets.archived,
    byte_tickets.stamp,
    byte_tickets.last_update,
    byte_tickets.balance,
    byte_tickets.delta,
    byte_tickets.coupon_id,
    byte_tickets.coupon,
    byte_tickets.refund,
    byte_tickets.receipt,
    byte_tickets.campus_id,
    byte_tickets.amount_list_price,
    byte_tickets.notes,
    byte_tickets.time_door_opened,
    byte_tickets.time_door_closed,
    byte_tickets.client_name,
    byte_tickets.estd_num_users,
    byte_tickets.ts,
    byte_tickets.full_name,
    byte_tickets.door_opened_secs,
    byte_tickets.month,
    byte_tickets.week,
    byte_tickets.date,
    byte_tickets.dayofweek,
    byte_tickets.hour,
    byte_tickets.dowhour,
    byte_tickets.uniq_user
   FROM public.byte_tickets
  WHERE (byte_tickets.ts > (now() - '1 day'::interval day));


ALTER TABLE public.byte_tickets_1day OWNER TO dbservice;

--
-- Name: byte_epcssold_1day; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_epcssold_1day AS
 SELECT o.order_id,
    o.first_name,
    o.last_name,
    o.kiosk_id,
    o.kiosk_title,
    o.email,
    o.amount_paid,
    o.payment_system,
    o.transaction_id,
    o.approval_code,
    o.status_code,
    o.status_message,
    o.status,
    o.batch_id,
    o.created,
    o.auth_amount,
    o.data_token,
    o.time_opened,
    o.time_closed,
    o.card_hash,
    o.state,
    o.archived,
    o.stamp,
    o.last_update,
    o.balance,
    o.delta,
    o.coupon_id,
    o.coupon,
    o.refund,
    o.receipt,
    o.campus_id,
    o.amount_list_price,
    o.notes,
    o.time_door_opened,
    o.time_door_closed,
    o.client_name,
    o.estd_num_users,
    o.ts,
    o.full_name,
    o.door_opened_secs,
    o.month,
    o.week,
    o.date,
    o.dayofweek,
    o.hour,
    o.dowhour,
    o.uniq_user,
    lp.epc,
    lp.label_order_id,
    lp.label_status,
    lp.label_price,
    lp.time_created,
    lp.time_added,
    lp.time_updated,
    lp.ts_created,
    lp.ts_added,
    lp.ts_updated,
    lp.label_kiosk_id,
    lp.product_id,
    lp.product_title,
    lp.product_archived,
    lp.product_vendor,
    lp.product_price,
    lp.product_cost,
    lp.product_shelf_life_days,
    lp.product_attributes,
    lp.product_categories,
    lp.consumer_category,
    lp.product_source
   FROM (public.byte_tickets_1day o
     JOIN public.byte_label_product lp ON (((lp.label_order_id)::text = (o.order_id)::text)))
  WHERE ((lp.label_status)::text = 'sold'::text);


ALTER TABLE public.byte_epcssold_1day OWNER TO dbservice;

--
-- Name: byte_tickets_1month; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_tickets_1month AS
 SELECT byte_tickets.order_id,
    byte_tickets.first_name,
    byte_tickets.last_name,
    byte_tickets.kiosk_id,
    byte_tickets.kiosk_title,
    byte_tickets.email,
    byte_tickets.amount_paid,
    byte_tickets.payment_system,
    byte_tickets.transaction_id,
    byte_tickets.approval_code,
    byte_tickets.status_code,
    byte_tickets.status_message,
    byte_tickets.status,
    byte_tickets.batch_id,
    byte_tickets.created,
    byte_tickets.auth_amount,
    byte_tickets.data_token,
    byte_tickets.time_opened,
    byte_tickets.time_closed,
    byte_tickets.card_hash,
    byte_tickets.state,
    byte_tickets.archived,
    byte_tickets.stamp,
    byte_tickets.last_update,
    byte_tickets.balance,
    byte_tickets.delta,
    byte_tickets.coupon_id,
    byte_tickets.coupon,
    byte_tickets.refund,
    byte_tickets.receipt,
    byte_tickets.campus_id,
    byte_tickets.amount_list_price,
    byte_tickets.notes,
    byte_tickets.time_door_opened,
    byte_tickets.time_door_closed,
    byte_tickets.client_name,
    byte_tickets.estd_num_users,
    byte_tickets.ts,
    byte_tickets.full_name,
    byte_tickets.door_opened_secs,
    byte_tickets.month,
    byte_tickets.week,
    byte_tickets.date,
    byte_tickets.dayofweek,
    byte_tickets.hour,
    byte_tickets.dowhour,
    byte_tickets.uniq_user
   FROM public.byte_tickets
  WHERE (byte_tickets.ts > (now() - '1 mon'::interval month));


ALTER TABLE public.byte_tickets_1month OWNER TO dbservice;

--
-- Name: byte_epcssold_1month; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_epcssold_1month AS
 SELECT o.order_id,
    o.first_name,
    o.last_name,
    o.kiosk_id,
    o.kiosk_title,
    o.email,
    o.amount_paid,
    o.payment_system,
    o.transaction_id,
    o.approval_code,
    o.status_code,
    o.status_message,
    o.status,
    o.batch_id,
    o.created,
    o.auth_amount,
    o.data_token,
    o.time_opened,
    o.time_closed,
    o.card_hash,
    o.state,
    o.archived,
    o.stamp,
    o.last_update,
    o.balance,
    o.delta,
    o.coupon_id,
    o.coupon,
    o.refund,
    o.receipt,
    o.campus_id,
    o.amount_list_price,
    o.notes,
    o.time_door_opened,
    o.time_door_closed,
    o.client_name,
    o.estd_num_users,
    o.ts,
    o.full_name,
    o.door_opened_secs,
    o.month,
    o.week,
    o.date,
    o.dayofweek,
    o.hour,
    o.dowhour,
    o.uniq_user,
    lp.epc,
    lp.label_order_id,
    lp.label_status,
    lp.label_price,
    lp.time_created,
    lp.time_added,
    lp.time_updated,
    lp.ts_created,
    lp.ts_added,
    lp.ts_updated,
    lp.label_kiosk_id,
    lp.product_id,
    lp.product_title,
    lp.product_archived,
    lp.product_vendor,
    lp.product_price,
    lp.product_cost,
    lp.product_shelf_life_days,
    lp.product_attributes,
    lp.product_categories,
    lp.consumer_category,
    lp.product_source
   FROM (public.byte_tickets_1month o
     JOIN public.byte_label_product lp ON (((lp.label_order_id)::text = (o.order_id)::text)))
  WHERE ((lp.label_status)::text = 'sold'::text);


ALTER TABLE public.byte_epcssold_1month OWNER TO dbservice;

--
-- Name: byte_tickets_1week; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_tickets_1week AS
 SELECT byte_tickets.order_id,
    byte_tickets.first_name,
    byte_tickets.last_name,
    byte_tickets.kiosk_id,
    byte_tickets.kiosk_title,
    byte_tickets.email,
    byte_tickets.amount_paid,
    byte_tickets.payment_system,
    byte_tickets.transaction_id,
    byte_tickets.approval_code,
    byte_tickets.status_code,
    byte_tickets.status_message,
    byte_tickets.status,
    byte_tickets.batch_id,
    byte_tickets.created,
    byte_tickets.auth_amount,
    byte_tickets.data_token,
    byte_tickets.time_opened,
    byte_tickets.time_closed,
    byte_tickets.card_hash,
    byte_tickets.state,
    byte_tickets.archived,
    byte_tickets.stamp,
    byte_tickets.last_update,
    byte_tickets.balance,
    byte_tickets.delta,
    byte_tickets.coupon_id,
    byte_tickets.coupon,
    byte_tickets.refund,
    byte_tickets.receipt,
    byte_tickets.campus_id,
    byte_tickets.amount_list_price,
    byte_tickets.notes,
    byte_tickets.time_door_opened,
    byte_tickets.time_door_closed,
    byte_tickets.client_name,
    byte_tickets.estd_num_users,
    byte_tickets.ts,
    byte_tickets.full_name,
    byte_tickets.door_opened_secs,
    byte_tickets.month,
    byte_tickets.week,
    byte_tickets.date,
    byte_tickets.dayofweek,
    byte_tickets.hour,
    byte_tickets.dowhour,
    byte_tickets.uniq_user
   FROM public.byte_tickets
  WHERE (byte_tickets.ts > (now() - '7 days'::interval day));


ALTER TABLE public.byte_tickets_1week OWNER TO dbservice;

--
-- Name: byte_epcssold_1week; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_epcssold_1week AS
 SELECT o.order_id,
    o.first_name,
    o.last_name,
    o.kiosk_id,
    o.kiosk_title,
    o.email,
    o.amount_paid,
    o.payment_system,
    o.transaction_id,
    o.approval_code,
    o.status_code,
    o.status_message,
    o.status,
    o.batch_id,
    o.created,
    o.auth_amount,
    o.data_token,
    o.time_opened,
    o.time_closed,
    o.card_hash,
    o.state,
    o.archived,
    o.stamp,
    o.last_update,
    o.balance,
    o.delta,
    o.coupon_id,
    o.coupon,
    o.refund,
    o.receipt,
    o.campus_id,
    o.amount_list_price,
    o.notes,
    o.time_door_opened,
    o.time_door_closed,
    o.client_name,
    o.estd_num_users,
    o.ts,
    o.full_name,
    o.door_opened_secs,
    o.month,
    o.week,
    o.date,
    o.dayofweek,
    o.hour,
    o.dowhour,
    o.uniq_user,
    lp.epc,
    lp.label_order_id,
    lp.label_status,
    lp.label_price,
    lp.time_created,
    lp.time_added,
    lp.time_updated,
    lp.ts_created,
    lp.ts_added,
    lp.ts_updated,
    lp.label_kiosk_id,
    lp.product_id,
    lp.product_title,
    lp.product_archived,
    lp.product_vendor,
    lp.product_price,
    lp.product_cost,
    lp.product_shelf_life_days,
    lp.product_attributes,
    lp.product_categories,
    lp.consumer_category,
    lp.product_source
   FROM (public.byte_tickets_1week o
     JOIN public.byte_label_product lp ON (((lp.label_order_id)::text = (o.order_id)::text)))
  WHERE ((lp.label_status)::text = 'sold'::text);


ALTER TABLE public.byte_epcssold_1week OWNER TO dbservice;

--
-- Name: byte_tickets_1year; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_tickets_1year AS
 SELECT byte_tickets.order_id,
    byte_tickets.first_name,
    byte_tickets.last_name,
    byte_tickets.kiosk_id,
    byte_tickets.kiosk_title,
    byte_tickets.email,
    byte_tickets.amount_paid,
    byte_tickets.payment_system,
    byte_tickets.transaction_id,
    byte_tickets.approval_code,
    byte_tickets.status_code,
    byte_tickets.status_message,
    byte_tickets.status,
    byte_tickets.batch_id,
    byte_tickets.created,
    byte_tickets.auth_amount,
    byte_tickets.data_token,
    byte_tickets.time_opened,
    byte_tickets.time_closed,
    byte_tickets.card_hash,
    byte_tickets.state,
    byte_tickets.archived,
    byte_tickets.stamp,
    byte_tickets.last_update,
    byte_tickets.balance,
    byte_tickets.delta,
    byte_tickets.coupon_id,
    byte_tickets.coupon,
    byte_tickets.refund,
    byte_tickets.receipt,
    byte_tickets.campus_id,
    byte_tickets.amount_list_price,
    byte_tickets.notes,
    byte_tickets.time_door_opened,
    byte_tickets.time_door_closed,
    byte_tickets.client_name,
    byte_tickets.estd_num_users,
    byte_tickets.ts,
    byte_tickets.full_name,
    byte_tickets.door_opened_secs,
    byte_tickets.month,
    byte_tickets.week,
    byte_tickets.date,
    byte_tickets.dayofweek,
    byte_tickets.hour,
    byte_tickets.dowhour,
    byte_tickets.uniq_user
   FROM public.byte_tickets
  WHERE (byte_tickets.ts > (now() - '1 year'::interval year));


ALTER TABLE public.byte_tickets_1year OWNER TO dbservice;

--
-- Name: byte_epcssold_1year; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_epcssold_1year AS
 SELECT o.order_id,
    o.first_name,
    o.last_name,
    o.kiosk_id,
    o.kiosk_title,
    o.email,
    o.amount_paid,
    o.payment_system,
    o.transaction_id,
    o.approval_code,
    o.status_code,
    o.status_message,
    o.status,
    o.batch_id,
    o.created,
    o.auth_amount,
    o.data_token,
    o.time_opened,
    o.time_closed,
    o.card_hash,
    o.state,
    o.archived,
    o.stamp,
    o.last_update,
    o.balance,
    o.delta,
    o.coupon_id,
    o.coupon,
    o.refund,
    o.receipt,
    o.campus_id,
    o.amount_list_price,
    o.notes,
    o.time_door_opened,
    o.time_door_closed,
    o.client_name,
    o.estd_num_users,
    o.ts,
    o.full_name,
    o.door_opened_secs,
    o.month,
    o.week,
    o.date,
    o.dayofweek,
    o.hour,
    o.dowhour,
    o.uniq_user,
    lp.epc,
    lp.label_order_id,
    lp.label_status,
    lp.label_price,
    lp.time_created,
    lp.time_added,
    lp.time_updated,
    lp.ts_created,
    lp.ts_added,
    lp.ts_updated,
    lp.label_kiosk_id,
    lp.product_id,
    lp.product_title,
    lp.product_archived,
    lp.product_vendor,
    lp.product_price,
    lp.product_cost,
    lp.product_shelf_life_days,
    lp.product_attributes,
    lp.product_categories,
    lp.consumer_category,
    lp.product_source
   FROM (public.byte_tickets_1year o
     JOIN public.byte_label_product lp ON (((lp.label_order_id)::text = (o.order_id)::text)))
  WHERE ((lp.label_status)::text = 'sold'::text);


ALTER TABLE public.byte_epcssold_1year OWNER TO dbservice;

--
-- Name: byte_tickets_2015; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_tickets_2015 AS
 SELECT byte_tickets.order_id,
    byte_tickets.first_name,
    byte_tickets.last_name,
    byte_tickets.kiosk_id,
    byte_tickets.kiosk_title,
    byte_tickets.email,
    byte_tickets.amount_paid,
    byte_tickets.payment_system,
    byte_tickets.transaction_id,
    byte_tickets.approval_code,
    byte_tickets.status_code,
    byte_tickets.status_message,
    byte_tickets.status,
    byte_tickets.batch_id,
    byte_tickets.created,
    byte_tickets.auth_amount,
    byte_tickets.data_token,
    byte_tickets.time_opened,
    byte_tickets.time_closed,
    byte_tickets.card_hash,
    byte_tickets.state,
    byte_tickets.archived,
    byte_tickets.stamp,
    byte_tickets.last_update,
    byte_tickets.balance,
    byte_tickets.delta,
    byte_tickets.coupon_id,
    byte_tickets.coupon,
    byte_tickets.refund,
    byte_tickets.receipt,
    byte_tickets.campus_id,
    byte_tickets.amount_list_price,
    byte_tickets.notes,
    byte_tickets.time_door_opened,
    byte_tickets.time_door_closed,
    byte_tickets.client_name,
    byte_tickets.estd_num_users,
    byte_tickets.ts,
    byte_tickets.full_name,
    byte_tickets.door_opened_secs,
    byte_tickets.month,
    byte_tickets.week,
    byte_tickets.date,
    byte_tickets.dayofweek,
    byte_tickets.hour,
    byte_tickets.dowhour,
    byte_tickets.uniq_user
   FROM public.byte_tickets
  WHERE ((byte_tickets.ts >= '2015-01-01 08:00:00+00'::timestamp with time zone) AND (byte_tickets.ts < '2016-01-01 08:00:00+00'::timestamp with time zone));


ALTER TABLE public.byte_tickets_2015 OWNER TO dbservice;

--
-- Name: byte_epcssold_2015; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_epcssold_2015 AS
 SELECT o.order_id,
    o.first_name,
    o.last_name,
    o.kiosk_id,
    o.kiosk_title,
    o.email,
    o.amount_paid,
    o.payment_system,
    o.transaction_id,
    o.approval_code,
    o.status_code,
    o.status_message,
    o.status,
    o.batch_id,
    o.created,
    o.auth_amount,
    o.data_token,
    o.time_opened,
    o.time_closed,
    o.card_hash,
    o.state,
    o.archived,
    o.stamp,
    o.last_update,
    o.balance,
    o.delta,
    o.coupon_id,
    o.coupon,
    o.refund,
    o.receipt,
    o.campus_id,
    o.amount_list_price,
    o.notes,
    o.time_door_opened,
    o.time_door_closed,
    o.client_name,
    o.estd_num_users,
    o.ts,
    o.full_name,
    o.door_opened_secs,
    o.month,
    o.week,
    o.date,
    o.dayofweek,
    o.hour,
    o.dowhour,
    o.uniq_user,
    lp.epc,
    lp.label_order_id,
    lp.label_status,
    lp.label_price,
    lp.time_created,
    lp.time_added,
    lp.time_updated,
    lp.ts_created,
    lp.ts_added,
    lp.ts_updated,
    lp.label_kiosk_id,
    lp.product_id,
    lp.product_title,
    lp.product_archived,
    lp.product_vendor,
    lp.product_price,
    lp.product_cost,
    lp.product_shelf_life_days,
    lp.product_attributes,
    lp.product_categories,
    lp.consumer_category,
    lp.product_source
   FROM (public.byte_tickets_2015 o
     JOIN public.byte_label_product lp ON (((lp.label_order_id)::text = (o.order_id)::text)))
  WHERE ((lp.label_status)::text = 'sold'::text);


ALTER TABLE public.byte_epcssold_2015 OWNER TO dbservice;

--
-- Name: byte_tickets_2016; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_tickets_2016 AS
 SELECT byte_tickets.order_id,
    byte_tickets.first_name,
    byte_tickets.last_name,
    byte_tickets.kiosk_id,
    byte_tickets.kiosk_title,
    byte_tickets.email,
    byte_tickets.amount_paid,
    byte_tickets.payment_system,
    byte_tickets.transaction_id,
    byte_tickets.approval_code,
    byte_tickets.status_code,
    byte_tickets.status_message,
    byte_tickets.status,
    byte_tickets.batch_id,
    byte_tickets.created,
    byte_tickets.auth_amount,
    byte_tickets.data_token,
    byte_tickets.time_opened,
    byte_tickets.time_closed,
    byte_tickets.card_hash,
    byte_tickets.state,
    byte_tickets.archived,
    byte_tickets.stamp,
    byte_tickets.last_update,
    byte_tickets.balance,
    byte_tickets.delta,
    byte_tickets.coupon_id,
    byte_tickets.coupon,
    byte_tickets.refund,
    byte_tickets.receipt,
    byte_tickets.campus_id,
    byte_tickets.amount_list_price,
    byte_tickets.notes,
    byte_tickets.time_door_opened,
    byte_tickets.time_door_closed,
    byte_tickets.client_name,
    byte_tickets.estd_num_users,
    byte_tickets.ts,
    byte_tickets.full_name,
    byte_tickets.door_opened_secs,
    byte_tickets.month,
    byte_tickets.week,
    byte_tickets.date,
    byte_tickets.dayofweek,
    byte_tickets.hour,
    byte_tickets.dowhour,
    byte_tickets.uniq_user
   FROM public.byte_tickets
  WHERE ((byte_tickets.ts >= '2016-01-01 08:00:00+00'::timestamp with time zone) AND (byte_tickets.ts < '2017-01-01 08:00:00+00'::timestamp with time zone));


ALTER TABLE public.byte_tickets_2016 OWNER TO dbservice;

--
-- Name: byte_epcssold_2016; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_epcssold_2016 AS
 SELECT o.order_id,
    o.first_name,
    o.last_name,
    o.kiosk_id,
    o.kiosk_title,
    o.email,
    o.amount_paid,
    o.payment_system,
    o.transaction_id,
    o.approval_code,
    o.status_code,
    o.status_message,
    o.status,
    o.batch_id,
    o.created,
    o.auth_amount,
    o.data_token,
    o.time_opened,
    o.time_closed,
    o.card_hash,
    o.state,
    o.archived,
    o.stamp,
    o.last_update,
    o.balance,
    o.delta,
    o.coupon_id,
    o.coupon,
    o.refund,
    o.receipt,
    o.campus_id,
    o.amount_list_price,
    o.notes,
    o.time_door_opened,
    o.time_door_closed,
    o.client_name,
    o.estd_num_users,
    o.ts,
    o.full_name,
    o.door_opened_secs,
    o.month,
    o.week,
    o.date,
    o.dayofweek,
    o.hour,
    o.dowhour,
    o.uniq_user,
    lp.epc,
    lp.label_order_id,
    lp.label_status,
    lp.label_price,
    lp.time_created,
    lp.time_added,
    lp.time_updated,
    lp.ts_created,
    lp.ts_added,
    lp.ts_updated,
    lp.label_kiosk_id,
    lp.product_id,
    lp.product_title,
    lp.product_archived,
    lp.product_vendor,
    lp.product_price,
    lp.product_cost,
    lp.product_shelf_life_days,
    lp.product_attributes,
    lp.product_categories,
    lp.consumer_category,
    lp.product_source
   FROM (public.byte_tickets_2016 o
     JOIN public.byte_label_product lp ON (((lp.label_order_id)::text = (o.order_id)::text)))
  WHERE ((lp.label_status)::text = 'sold'::text);


ALTER TABLE public.byte_epcssold_2016 OWNER TO dbservice;

--
-- Name: byte_tickets_2017; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_tickets_2017 AS
 SELECT byte_tickets.order_id,
    byte_tickets.first_name,
    byte_tickets.last_name,
    byte_tickets.kiosk_id,
    byte_tickets.kiosk_title,
    byte_tickets.email,
    byte_tickets.amount_paid,
    byte_tickets.payment_system,
    byte_tickets.transaction_id,
    byte_tickets.approval_code,
    byte_tickets.status_code,
    byte_tickets.status_message,
    byte_tickets.status,
    byte_tickets.batch_id,
    byte_tickets.created,
    byte_tickets.auth_amount,
    byte_tickets.data_token,
    byte_tickets.time_opened,
    byte_tickets.time_closed,
    byte_tickets.card_hash,
    byte_tickets.state,
    byte_tickets.archived,
    byte_tickets.stamp,
    byte_tickets.last_update,
    byte_tickets.balance,
    byte_tickets.delta,
    byte_tickets.coupon_id,
    byte_tickets.coupon,
    byte_tickets.refund,
    byte_tickets.receipt,
    byte_tickets.campus_id,
    byte_tickets.amount_list_price,
    byte_tickets.notes,
    byte_tickets.time_door_opened,
    byte_tickets.time_door_closed,
    byte_tickets.client_name,
    byte_tickets.estd_num_users,
    byte_tickets.ts,
    byte_tickets.full_name,
    byte_tickets.door_opened_secs,
    byte_tickets.month,
    byte_tickets.week,
    byte_tickets.date,
    byte_tickets.dayofweek,
    byte_tickets.hour,
    byte_tickets.dowhour,
    byte_tickets.uniq_user
   FROM public.byte_tickets
  WHERE ((byte_tickets.ts >= '2017-01-01 08:00:00+00'::timestamp with time zone) AND (byte_tickets.ts < '2018-01-01 08:00:00+00'::timestamp with time zone));


ALTER TABLE public.byte_tickets_2017 OWNER TO dbservice;

--
-- Name: byte_epcssold_2017; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_epcssold_2017 AS
 SELECT o.order_id,
    o.first_name,
    o.last_name,
    o.kiosk_id,
    o.kiosk_title,
    o.email,
    o.amount_paid,
    o.payment_system,
    o.transaction_id,
    o.approval_code,
    o.status_code,
    o.status_message,
    o.status,
    o.batch_id,
    o.created,
    o.auth_amount,
    o.data_token,
    o.time_opened,
    o.time_closed,
    o.card_hash,
    o.state,
    o.archived,
    o.stamp,
    o.last_update,
    o.balance,
    o.delta,
    o.coupon_id,
    o.coupon,
    o.refund,
    o.receipt,
    o.campus_id,
    o.amount_list_price,
    o.notes,
    o.time_door_opened,
    o.time_door_closed,
    o.client_name,
    o.estd_num_users,
    o.ts,
    o.full_name,
    o.door_opened_secs,
    o.month,
    o.week,
    o.date,
    o.dayofweek,
    o.hour,
    o.dowhour,
    o.uniq_user,
    lp.epc,
    lp.label_order_id,
    lp.label_status,
    lp.label_price,
    lp.time_created,
    lp.time_added,
    lp.time_updated,
    lp.ts_created,
    lp.ts_added,
    lp.ts_updated,
    lp.label_kiosk_id,
    lp.product_id,
    lp.product_title,
    lp.product_archived,
    lp.product_vendor,
    lp.product_price,
    lp.product_cost,
    lp.product_shelf_life_days,
    lp.product_attributes,
    lp.product_categories,
    lp.consumer_category,
    lp.product_source
   FROM (public.byte_tickets_2017 o
     JOIN public.byte_label_product lp ON (((lp.label_order_id)::text = (o.order_id)::text)))
  WHERE ((lp.label_status)::text = 'sold'::text);


ALTER TABLE public.byte_epcssold_2017 OWNER TO dbservice;

--
-- Name: byte_tickets_2days; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_tickets_2days AS
 SELECT byte_tickets.order_id,
    byte_tickets.first_name,
    byte_tickets.last_name,
    byte_tickets.kiosk_id,
    byte_tickets.kiosk_title,
    byte_tickets.email,
    byte_tickets.amount_paid,
    byte_tickets.payment_system,
    byte_tickets.transaction_id,
    byte_tickets.approval_code,
    byte_tickets.status_code,
    byte_tickets.status_message,
    byte_tickets.status,
    byte_tickets.batch_id,
    byte_tickets.created,
    byte_tickets.auth_amount,
    byte_tickets.data_token,
    byte_tickets.time_opened,
    byte_tickets.time_closed,
    byte_tickets.card_hash,
    byte_tickets.state,
    byte_tickets.archived,
    byte_tickets.stamp,
    byte_tickets.last_update,
    byte_tickets.balance,
    byte_tickets.delta,
    byte_tickets.coupon_id,
    byte_tickets.coupon,
    byte_tickets.refund,
    byte_tickets.receipt,
    byte_tickets.campus_id,
    byte_tickets.amount_list_price,
    byte_tickets.notes,
    byte_tickets.time_door_opened,
    byte_tickets.time_door_closed,
    byte_tickets.client_name,
    byte_tickets.estd_num_users,
    byte_tickets.ts,
    byte_tickets.full_name,
    byte_tickets.door_opened_secs,
    byte_tickets.month,
    byte_tickets.week,
    byte_tickets.date,
    byte_tickets.dayofweek,
    byte_tickets.hour,
    byte_tickets.dowhour,
    byte_tickets.uniq_user
   FROM public.byte_tickets
  WHERE (byte_tickets.ts > (now() - '2 days'::interval day));


ALTER TABLE public.byte_tickets_2days OWNER TO dbservice;

--
-- Name: byte_epcssold_2days; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_epcssold_2days AS
 SELECT o.order_id,
    o.first_name,
    o.last_name,
    o.kiosk_id,
    o.kiosk_title,
    o.email,
    o.amount_paid,
    o.payment_system,
    o.transaction_id,
    o.approval_code,
    o.status_code,
    o.status_message,
    o.status,
    o.batch_id,
    o.created,
    o.auth_amount,
    o.data_token,
    o.time_opened,
    o.time_closed,
    o.card_hash,
    o.state,
    o.archived,
    o.stamp,
    o.last_update,
    o.balance,
    o.delta,
    o.coupon_id,
    o.coupon,
    o.refund,
    o.receipt,
    o.campus_id,
    o.amount_list_price,
    o.notes,
    o.time_door_opened,
    o.time_door_closed,
    o.client_name,
    o.estd_num_users,
    o.ts,
    o.full_name,
    o.door_opened_secs,
    o.month,
    o.week,
    o.date,
    o.dayofweek,
    o.hour,
    o.dowhour,
    o.uniq_user,
    lp.epc,
    lp.label_order_id,
    lp.label_status,
    lp.label_price,
    lp.time_created,
    lp.time_added,
    lp.time_updated,
    lp.ts_created,
    lp.ts_added,
    lp.ts_updated,
    lp.label_kiosk_id,
    lp.product_id,
    lp.product_title,
    lp.product_archived,
    lp.product_vendor,
    lp.product_price,
    lp.product_cost,
    lp.product_shelf_life_days,
    lp.product_attributes,
    lp.product_categories,
    lp.consumer_category,
    lp.product_source
   FROM (public.byte_tickets_2days o
     JOIN public.byte_label_product lp ON (((lp.label_order_id)::text = (o.order_id)::text)))
  WHERE ((lp.label_status)::text = 'sold'::text);


ALTER TABLE public.byte_epcssold_2days OWNER TO dbservice;

--
-- Name: byte_tickets_2months; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_tickets_2months AS
 SELECT byte_tickets.order_id,
    byte_tickets.first_name,
    byte_tickets.last_name,
    byte_tickets.kiosk_id,
    byte_tickets.kiosk_title,
    byte_tickets.email,
    byte_tickets.amount_paid,
    byte_tickets.payment_system,
    byte_tickets.transaction_id,
    byte_tickets.approval_code,
    byte_tickets.status_code,
    byte_tickets.status_message,
    byte_tickets.status,
    byte_tickets.batch_id,
    byte_tickets.created,
    byte_tickets.auth_amount,
    byte_tickets.data_token,
    byte_tickets.time_opened,
    byte_tickets.time_closed,
    byte_tickets.card_hash,
    byte_tickets.state,
    byte_tickets.archived,
    byte_tickets.stamp,
    byte_tickets.last_update,
    byte_tickets.balance,
    byte_tickets.delta,
    byte_tickets.coupon_id,
    byte_tickets.coupon,
    byte_tickets.refund,
    byte_tickets.receipt,
    byte_tickets.campus_id,
    byte_tickets.amount_list_price,
    byte_tickets.notes,
    byte_tickets.time_door_opened,
    byte_tickets.time_door_closed,
    byte_tickets.client_name,
    byte_tickets.estd_num_users,
    byte_tickets.ts,
    byte_tickets.full_name,
    byte_tickets.door_opened_secs,
    byte_tickets.month,
    byte_tickets.week,
    byte_tickets.date,
    byte_tickets.dayofweek,
    byte_tickets.hour,
    byte_tickets.dowhour,
    byte_tickets.uniq_user
   FROM public.byte_tickets
  WHERE (byte_tickets.ts > (now() - '2 mons'::interval month));


ALTER TABLE public.byte_tickets_2months OWNER TO dbservice;

--
-- Name: byte_epcssold_2months; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_epcssold_2months AS
 SELECT o.order_id,
    o.first_name,
    o.last_name,
    o.kiosk_id,
    o.kiosk_title,
    o.email,
    o.amount_paid,
    o.payment_system,
    o.transaction_id,
    o.approval_code,
    o.status_code,
    o.status_message,
    o.status,
    o.batch_id,
    o.created,
    o.auth_amount,
    o.data_token,
    o.time_opened,
    o.time_closed,
    o.card_hash,
    o.state,
    o.archived,
    o.stamp,
    o.last_update,
    o.balance,
    o.delta,
    o.coupon_id,
    o.coupon,
    o.refund,
    o.receipt,
    o.campus_id,
    o.amount_list_price,
    o.notes,
    o.time_door_opened,
    o.time_door_closed,
    o.client_name,
    o.estd_num_users,
    o.ts,
    o.full_name,
    o.door_opened_secs,
    o.month,
    o.week,
    o.date,
    o.dayofweek,
    o.hour,
    o.dowhour,
    o.uniq_user,
    lp.epc,
    lp.label_order_id,
    lp.label_status,
    lp.label_price,
    lp.time_created,
    lp.time_added,
    lp.time_updated,
    lp.ts_created,
    lp.ts_added,
    lp.ts_updated,
    lp.label_kiosk_id,
    lp.product_id,
    lp.product_title,
    lp.product_archived,
    lp.product_vendor,
    lp.product_price,
    lp.product_cost,
    lp.product_shelf_life_days,
    lp.product_attributes,
    lp.product_categories,
    lp.consumer_category,
    lp.product_source
   FROM (public.byte_tickets_2months o
     JOIN public.byte_label_product lp ON (((lp.label_order_id)::text = (o.order_id)::text)))
  WHERE ((lp.label_status)::text = 'sold'::text);


ALTER TABLE public.byte_epcssold_2months OWNER TO dbservice;

--
-- Name: byte_tickets_2weeks; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_tickets_2weeks AS
 SELECT byte_tickets.order_id,
    byte_tickets.first_name,
    byte_tickets.last_name,
    byte_tickets.kiosk_id,
    byte_tickets.kiosk_title,
    byte_tickets.email,
    byte_tickets.amount_paid,
    byte_tickets.payment_system,
    byte_tickets.transaction_id,
    byte_tickets.approval_code,
    byte_tickets.status_code,
    byte_tickets.status_message,
    byte_tickets.status,
    byte_tickets.batch_id,
    byte_tickets.created,
    byte_tickets.auth_amount,
    byte_tickets.data_token,
    byte_tickets.time_opened,
    byte_tickets.time_closed,
    byte_tickets.card_hash,
    byte_tickets.state,
    byte_tickets.archived,
    byte_tickets.stamp,
    byte_tickets.last_update,
    byte_tickets.balance,
    byte_tickets.delta,
    byte_tickets.coupon_id,
    byte_tickets.coupon,
    byte_tickets.refund,
    byte_tickets.receipt,
    byte_tickets.campus_id,
    byte_tickets.amount_list_price,
    byte_tickets.notes,
    byte_tickets.time_door_opened,
    byte_tickets.time_door_closed,
    byte_tickets.client_name,
    byte_tickets.estd_num_users,
    byte_tickets.ts,
    byte_tickets.full_name,
    byte_tickets.door_opened_secs,
    byte_tickets.month,
    byte_tickets.week,
    byte_tickets.date,
    byte_tickets.dayofweek,
    byte_tickets.hour,
    byte_tickets.dowhour,
    byte_tickets.uniq_user
   FROM public.byte_tickets
  WHERE (byte_tickets.ts > (now() - '14 days'::interval day));


ALTER TABLE public.byte_tickets_2weeks OWNER TO dbservice;

--
-- Name: byte_epcssold_2weeks; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_epcssold_2weeks AS
 SELECT o.order_id,
    o.first_name,
    o.last_name,
    o.kiosk_id,
    o.kiosk_title,
    o.email,
    o.amount_paid,
    o.payment_system,
    o.transaction_id,
    o.approval_code,
    o.status_code,
    o.status_message,
    o.status,
    o.batch_id,
    o.created,
    o.auth_amount,
    o.data_token,
    o.time_opened,
    o.time_closed,
    o.card_hash,
    o.state,
    o.archived,
    o.stamp,
    o.last_update,
    o.balance,
    o.delta,
    o.coupon_id,
    o.coupon,
    o.refund,
    o.receipt,
    o.campus_id,
    o.amount_list_price,
    o.notes,
    o.time_door_opened,
    o.time_door_closed,
    o.client_name,
    o.estd_num_users,
    o.ts,
    o.full_name,
    o.door_opened_secs,
    o.month,
    o.week,
    o.date,
    o.dayofweek,
    o.hour,
    o.dowhour,
    o.uniq_user,
    lp.epc,
    lp.label_order_id,
    lp.label_status,
    lp.label_price,
    lp.time_created,
    lp.time_added,
    lp.time_updated,
    lp.ts_created,
    lp.ts_added,
    lp.ts_updated,
    lp.label_kiosk_id,
    lp.product_id,
    lp.product_title,
    lp.product_archived,
    lp.product_vendor,
    lp.product_price,
    lp.product_cost,
    lp.product_shelf_life_days,
    lp.product_attributes,
    lp.product_categories,
    lp.consumer_category,
    lp.product_source
   FROM (public.byte_tickets_2weeks o
     JOIN public.byte_label_product lp ON (((lp.label_order_id)::text = (o.order_id)::text)))
  WHERE ((lp.label_status)::text = 'sold'::text);


ALTER TABLE public.byte_epcssold_2weeks OWNER TO dbservice;

--
-- Name: byte_tickets_30days; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_tickets_30days AS
 SELECT byte_tickets.order_id,
    byte_tickets.first_name,
    byte_tickets.last_name,
    byte_tickets.kiosk_id,
    byte_tickets.kiosk_title,
    byte_tickets.email,
    byte_tickets.amount_paid,
    byte_tickets.payment_system,
    byte_tickets.transaction_id,
    byte_tickets.approval_code,
    byte_tickets.status_code,
    byte_tickets.status_message,
    byte_tickets.status,
    byte_tickets.batch_id,
    byte_tickets.created,
    byte_tickets.auth_amount,
    byte_tickets.data_token,
    byte_tickets.time_opened,
    byte_tickets.time_closed,
    byte_tickets.card_hash,
    byte_tickets.state,
    byte_tickets.archived,
    byte_tickets.stamp,
    byte_tickets.last_update,
    byte_tickets.balance,
    byte_tickets.delta,
    byte_tickets.coupon_id,
    byte_tickets.coupon,
    byte_tickets.refund,
    byte_tickets.receipt,
    byte_tickets.campus_id,
    byte_tickets.amount_list_price,
    byte_tickets.notes,
    byte_tickets.time_door_opened,
    byte_tickets.time_door_closed,
    byte_tickets.client_name,
    byte_tickets.estd_num_users,
    byte_tickets.ts,
    byte_tickets.full_name,
    byte_tickets.door_opened_secs,
    byte_tickets.month,
    byte_tickets.week,
    byte_tickets.date,
    byte_tickets.dayofweek,
    byte_tickets.hour,
    byte_tickets.dowhour,
    byte_tickets.uniq_user
   FROM public.byte_tickets
  WHERE (byte_tickets.ts > (now() - '30 days'::interval day));


ALTER TABLE public.byte_tickets_30days OWNER TO dbservice;

--
-- Name: byte_epcssold_30days; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_epcssold_30days AS
 SELECT o.order_id,
    o.first_name,
    o.last_name,
    o.kiosk_id,
    o.kiosk_title,
    o.email,
    o.amount_paid,
    o.payment_system,
    o.transaction_id,
    o.approval_code,
    o.status_code,
    o.status_message,
    o.status,
    o.batch_id,
    o.created,
    o.auth_amount,
    o.data_token,
    o.time_opened,
    o.time_closed,
    o.card_hash,
    o.state,
    o.archived,
    o.stamp,
    o.last_update,
    o.balance,
    o.delta,
    o.coupon_id,
    o.coupon,
    o.refund,
    o.receipt,
    o.campus_id,
    o.amount_list_price,
    o.notes,
    o.time_door_opened,
    o.time_door_closed,
    o.client_name,
    o.estd_num_users,
    o.ts,
    o.full_name,
    o.door_opened_secs,
    o.month,
    o.week,
    o.date,
    o.dayofweek,
    o.hour,
    o.dowhour,
    o.uniq_user,
    lp.epc,
    lp.label_order_id,
    lp.label_status,
    lp.label_price,
    lp.time_created,
    lp.time_added,
    lp.time_updated,
    lp.ts_created,
    lp.ts_added,
    lp.ts_updated,
    lp.label_kiosk_id,
    lp.product_id,
    lp.product_title,
    lp.product_archived,
    lp.product_vendor,
    lp.product_price,
    lp.product_cost,
    lp.product_shelf_life_days,
    lp.product_attributes,
    lp.product_categories,
    lp.consumer_category,
    lp.product_source
   FROM (public.byte_tickets_30days o
     JOIN public.byte_label_product lp ON (((lp.label_order_id)::text = (o.order_id)::text)))
  WHERE ((lp.label_status)::text = 'sold'::text);


ALTER TABLE public.byte_epcssold_30days OWNER TO dbservice;

--
-- Name: byte_tickets_360days; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_tickets_360days AS
 SELECT byte_tickets.order_id,
    byte_tickets.first_name,
    byte_tickets.last_name,
    byte_tickets.kiosk_id,
    byte_tickets.kiosk_title,
    byte_tickets.email,
    byte_tickets.amount_paid,
    byte_tickets.payment_system,
    byte_tickets.transaction_id,
    byte_tickets.approval_code,
    byte_tickets.status_code,
    byte_tickets.status_message,
    byte_tickets.status,
    byte_tickets.batch_id,
    byte_tickets.created,
    byte_tickets.auth_amount,
    byte_tickets.data_token,
    byte_tickets.time_opened,
    byte_tickets.time_closed,
    byte_tickets.card_hash,
    byte_tickets.state,
    byte_tickets.archived,
    byte_tickets.stamp,
    byte_tickets.last_update,
    byte_tickets.balance,
    byte_tickets.delta,
    byte_tickets.coupon_id,
    byte_tickets.coupon,
    byte_tickets.refund,
    byte_tickets.receipt,
    byte_tickets.campus_id,
    byte_tickets.amount_list_price,
    byte_tickets.notes,
    byte_tickets.time_door_opened,
    byte_tickets.time_door_closed,
    byte_tickets.client_name,
    byte_tickets.estd_num_users,
    byte_tickets.ts,
    byte_tickets.full_name,
    byte_tickets.door_opened_secs,
    byte_tickets.month,
    byte_tickets.week,
    byte_tickets.date,
    byte_tickets.dayofweek,
    byte_tickets.hour,
    byte_tickets.dowhour,
    byte_tickets.uniq_user
   FROM public.byte_tickets
  WHERE (byte_tickets.ts > (now() - '360 days'::interval day));


ALTER TABLE public.byte_tickets_360days OWNER TO dbservice;

--
-- Name: byte_epcssold_360days; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_epcssold_360days AS
 SELECT o.order_id,
    o.first_name,
    o.last_name,
    o.kiosk_id,
    o.kiosk_title,
    o.email,
    o.amount_paid,
    o.payment_system,
    o.transaction_id,
    o.approval_code,
    o.status_code,
    o.status_message,
    o.status,
    o.batch_id,
    o.created,
    o.auth_amount,
    o.data_token,
    o.time_opened,
    o.time_closed,
    o.card_hash,
    o.state,
    o.archived,
    o.stamp,
    o.last_update,
    o.balance,
    o.delta,
    o.coupon_id,
    o.coupon,
    o.refund,
    o.receipt,
    o.campus_id,
    o.amount_list_price,
    o.notes,
    o.time_door_opened,
    o.time_door_closed,
    o.client_name,
    o.estd_num_users,
    o.ts,
    o.full_name,
    o.door_opened_secs,
    o.month,
    o.week,
    o.date,
    o.dayofweek,
    o.hour,
    o.dowhour,
    o.uniq_user,
    lp.epc,
    lp.label_order_id,
    lp.label_status,
    lp.label_price,
    lp.time_created,
    lp.time_added,
    lp.time_updated,
    lp.ts_created,
    lp.ts_added,
    lp.ts_updated,
    lp.label_kiosk_id,
    lp.product_id,
    lp.product_title,
    lp.product_archived,
    lp.product_vendor,
    lp.product_price,
    lp.product_cost,
    lp.product_shelf_life_days,
    lp.product_attributes,
    lp.product_categories,
    lp.consumer_category,
    lp.product_source
   FROM (public.byte_tickets_360days o
     JOIN public.byte_label_product lp ON (((lp.label_order_id)::text = (o.order_id)::text)))
  WHERE ((lp.label_status)::text = 'sold'::text);


ALTER TABLE public.byte_epcssold_360days OWNER TO dbservice;

--
-- Name: byte_tickets_365days; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_tickets_365days AS
 SELECT byte_tickets.order_id,
    byte_tickets.first_name,
    byte_tickets.last_name,
    byte_tickets.kiosk_id,
    byte_tickets.kiosk_title,
    byte_tickets.email,
    byte_tickets.amount_paid,
    byte_tickets.payment_system,
    byte_tickets.transaction_id,
    byte_tickets.approval_code,
    byte_tickets.status_code,
    byte_tickets.status_message,
    byte_tickets.status,
    byte_tickets.batch_id,
    byte_tickets.created,
    byte_tickets.auth_amount,
    byte_tickets.data_token,
    byte_tickets.time_opened,
    byte_tickets.time_closed,
    byte_tickets.card_hash,
    byte_tickets.state,
    byte_tickets.archived,
    byte_tickets.stamp,
    byte_tickets.last_update,
    byte_tickets.balance,
    byte_tickets.delta,
    byte_tickets.coupon_id,
    byte_tickets.coupon,
    byte_tickets.refund,
    byte_tickets.receipt,
    byte_tickets.campus_id,
    byte_tickets.amount_list_price,
    byte_tickets.notes,
    byte_tickets.time_door_opened,
    byte_tickets.time_door_closed,
    byte_tickets.client_name,
    byte_tickets.estd_num_users,
    byte_tickets.ts,
    byte_tickets.full_name,
    byte_tickets.door_opened_secs,
    byte_tickets.month,
    byte_tickets.week,
    byte_tickets.date,
    byte_tickets.dayofweek,
    byte_tickets.hour,
    byte_tickets.dowhour,
    byte_tickets.uniq_user
   FROM public.byte_tickets
  WHERE (byte_tickets.ts > (now() - '365 days'::interval day));


ALTER TABLE public.byte_tickets_365days OWNER TO dbservice;

--
-- Name: byte_epcssold_365days; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_epcssold_365days AS
 SELECT o.order_id,
    o.first_name,
    o.last_name,
    o.kiosk_id,
    o.kiosk_title,
    o.email,
    o.amount_paid,
    o.payment_system,
    o.transaction_id,
    o.approval_code,
    o.status_code,
    o.status_message,
    o.status,
    o.batch_id,
    o.created,
    o.auth_amount,
    o.data_token,
    o.time_opened,
    o.time_closed,
    o.card_hash,
    o.state,
    o.archived,
    o.stamp,
    o.last_update,
    o.balance,
    o.delta,
    o.coupon_id,
    o.coupon,
    o.refund,
    o.receipt,
    o.campus_id,
    o.amount_list_price,
    o.notes,
    o.time_door_opened,
    o.time_door_closed,
    o.client_name,
    o.estd_num_users,
    o.ts,
    o.full_name,
    o.door_opened_secs,
    o.month,
    o.week,
    o.date,
    o.dayofweek,
    o.hour,
    o.dowhour,
    o.uniq_user,
    lp.epc,
    lp.label_order_id,
    lp.label_status,
    lp.label_price,
    lp.time_created,
    lp.time_added,
    lp.time_updated,
    lp.ts_created,
    lp.ts_added,
    lp.ts_updated,
    lp.label_kiosk_id,
    lp.product_id,
    lp.product_title,
    lp.product_archived,
    lp.product_vendor,
    lp.product_price,
    lp.product_cost,
    lp.product_shelf_life_days,
    lp.product_attributes,
    lp.product_categories,
    lp.consumer_category,
    lp.product_source
   FROM (public.byte_tickets_365days o
     JOIN public.byte_label_product lp ON (((lp.label_order_id)::text = (o.order_id)::text)))
  WHERE ((lp.label_status)::text = 'sold'::text);


ALTER TABLE public.byte_epcssold_365days OWNER TO dbservice;

--
-- Name: byte_tickets_3days; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_tickets_3days AS
 SELECT byte_tickets.order_id,
    byte_tickets.first_name,
    byte_tickets.last_name,
    byte_tickets.kiosk_id,
    byte_tickets.kiosk_title,
    byte_tickets.email,
    byte_tickets.amount_paid,
    byte_tickets.payment_system,
    byte_tickets.transaction_id,
    byte_tickets.approval_code,
    byte_tickets.status_code,
    byte_tickets.status_message,
    byte_tickets.status,
    byte_tickets.batch_id,
    byte_tickets.created,
    byte_tickets.auth_amount,
    byte_tickets.data_token,
    byte_tickets.time_opened,
    byte_tickets.time_closed,
    byte_tickets.card_hash,
    byte_tickets.state,
    byte_tickets.archived,
    byte_tickets.stamp,
    byte_tickets.last_update,
    byte_tickets.balance,
    byte_tickets.delta,
    byte_tickets.coupon_id,
    byte_tickets.coupon,
    byte_tickets.refund,
    byte_tickets.receipt,
    byte_tickets.campus_id,
    byte_tickets.amount_list_price,
    byte_tickets.notes,
    byte_tickets.time_door_opened,
    byte_tickets.time_door_closed,
    byte_tickets.client_name,
    byte_tickets.estd_num_users,
    byte_tickets.ts,
    byte_tickets.full_name,
    byte_tickets.door_opened_secs,
    byte_tickets.month,
    byte_tickets.week,
    byte_tickets.date,
    byte_tickets.dayofweek,
    byte_tickets.hour,
    byte_tickets.dowhour,
    byte_tickets.uniq_user
   FROM public.byte_tickets
  WHERE (byte_tickets.ts > (now() - '3 days'::interval day));


ALTER TABLE public.byte_tickets_3days OWNER TO dbservice;

--
-- Name: byte_epcssold_3days; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_epcssold_3days AS
 SELECT o.order_id,
    o.first_name,
    o.last_name,
    o.kiosk_id,
    o.kiosk_title,
    o.email,
    o.amount_paid,
    o.payment_system,
    o.transaction_id,
    o.approval_code,
    o.status_code,
    o.status_message,
    o.status,
    o.batch_id,
    o.created,
    o.auth_amount,
    o.data_token,
    o.time_opened,
    o.time_closed,
    o.card_hash,
    o.state,
    o.archived,
    o.stamp,
    o.last_update,
    o.balance,
    o.delta,
    o.coupon_id,
    o.coupon,
    o.refund,
    o.receipt,
    o.campus_id,
    o.amount_list_price,
    o.notes,
    o.time_door_opened,
    o.time_door_closed,
    o.client_name,
    o.estd_num_users,
    o.ts,
    o.full_name,
    o.door_opened_secs,
    o.month,
    o.week,
    o.date,
    o.dayofweek,
    o.hour,
    o.dowhour,
    o.uniq_user,
    lp.epc,
    lp.label_order_id,
    lp.label_status,
    lp.label_price,
    lp.time_created,
    lp.time_added,
    lp.time_updated,
    lp.ts_created,
    lp.ts_added,
    lp.ts_updated,
    lp.label_kiosk_id,
    lp.product_id,
    lp.product_title,
    lp.product_archived,
    lp.product_vendor,
    lp.product_price,
    lp.product_cost,
    lp.product_shelf_life_days,
    lp.product_attributes,
    lp.product_categories,
    lp.consumer_category,
    lp.product_source
   FROM (public.byte_tickets_3days o
     JOIN public.byte_label_product lp ON (((lp.label_order_id)::text = (o.order_id)::text)))
  WHERE ((lp.label_status)::text = 'sold'::text);


ALTER TABLE public.byte_epcssold_3days OWNER TO dbservice;

--
-- Name: byte_tickets_3weeks; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_tickets_3weeks AS
 SELECT byte_tickets.order_id,
    byte_tickets.first_name,
    byte_tickets.last_name,
    byte_tickets.kiosk_id,
    byte_tickets.kiosk_title,
    byte_tickets.email,
    byte_tickets.amount_paid,
    byte_tickets.payment_system,
    byte_tickets.transaction_id,
    byte_tickets.approval_code,
    byte_tickets.status_code,
    byte_tickets.status_message,
    byte_tickets.status,
    byte_tickets.batch_id,
    byte_tickets.created,
    byte_tickets.auth_amount,
    byte_tickets.data_token,
    byte_tickets.time_opened,
    byte_tickets.time_closed,
    byte_tickets.card_hash,
    byte_tickets.state,
    byte_tickets.archived,
    byte_tickets.stamp,
    byte_tickets.last_update,
    byte_tickets.balance,
    byte_tickets.delta,
    byte_tickets.coupon_id,
    byte_tickets.coupon,
    byte_tickets.refund,
    byte_tickets.receipt,
    byte_tickets.campus_id,
    byte_tickets.amount_list_price,
    byte_tickets.notes,
    byte_tickets.time_door_opened,
    byte_tickets.time_door_closed,
    byte_tickets.client_name,
    byte_tickets.estd_num_users,
    byte_tickets.ts,
    byte_tickets.full_name,
    byte_tickets.door_opened_secs,
    byte_tickets.month,
    byte_tickets.week,
    byte_tickets.date,
    byte_tickets.dayofweek,
    byte_tickets.hour,
    byte_tickets.dowhour,
    byte_tickets.uniq_user
   FROM public.byte_tickets
  WHERE (byte_tickets.ts > (now() - '21 days'::interval day));


ALTER TABLE public.byte_tickets_3weeks OWNER TO dbservice;

--
-- Name: byte_epcssold_3weeks; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_epcssold_3weeks AS
 SELECT o.order_id,
    o.first_name,
    o.last_name,
    o.kiosk_id,
    o.kiosk_title,
    o.email,
    o.amount_paid,
    o.payment_system,
    o.transaction_id,
    o.approval_code,
    o.status_code,
    o.status_message,
    o.status,
    o.batch_id,
    o.created,
    o.auth_amount,
    o.data_token,
    o.time_opened,
    o.time_closed,
    o.card_hash,
    o.state,
    o.archived,
    o.stamp,
    o.last_update,
    o.balance,
    o.delta,
    o.coupon_id,
    o.coupon,
    o.refund,
    o.receipt,
    o.campus_id,
    o.amount_list_price,
    o.notes,
    o.time_door_opened,
    o.time_door_closed,
    o.client_name,
    o.estd_num_users,
    o.ts,
    o.full_name,
    o.door_opened_secs,
    o.month,
    o.week,
    o.date,
    o.dayofweek,
    o.hour,
    o.dowhour,
    o.uniq_user,
    lp.epc,
    lp.label_order_id,
    lp.label_status,
    lp.label_price,
    lp.time_created,
    lp.time_added,
    lp.time_updated,
    lp.ts_created,
    lp.ts_added,
    lp.ts_updated,
    lp.label_kiosk_id,
    lp.product_id,
    lp.product_title,
    lp.product_archived,
    lp.product_vendor,
    lp.product_price,
    lp.product_cost,
    lp.product_shelf_life_days,
    lp.product_attributes,
    lp.product_categories,
    lp.consumer_category,
    lp.product_source
   FROM (public.byte_tickets_3weeks o
     JOIN public.byte_label_product lp ON (((lp.label_order_id)::text = (o.order_id)::text)))
  WHERE ((lp.label_status)::text = 'sold'::text);


ALTER TABLE public.byte_epcssold_3weeks OWNER TO dbservice;

--
-- Name: byte_tickets_45days; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_tickets_45days AS
 SELECT byte_tickets.order_id,
    byte_tickets.first_name,
    byte_tickets.last_name,
    byte_tickets.kiosk_id,
    byte_tickets.kiosk_title,
    byte_tickets.email,
    byte_tickets.amount_paid,
    byte_tickets.payment_system,
    byte_tickets.transaction_id,
    byte_tickets.approval_code,
    byte_tickets.status_code,
    byte_tickets.status_message,
    byte_tickets.status,
    byte_tickets.batch_id,
    byte_tickets.created,
    byte_tickets.auth_amount,
    byte_tickets.data_token,
    byte_tickets.time_opened,
    byte_tickets.time_closed,
    byte_tickets.card_hash,
    byte_tickets.state,
    byte_tickets.archived,
    byte_tickets.stamp,
    byte_tickets.last_update,
    byte_tickets.balance,
    byte_tickets.delta,
    byte_tickets.coupon_id,
    byte_tickets.coupon,
    byte_tickets.refund,
    byte_tickets.receipt,
    byte_tickets.campus_id,
    byte_tickets.amount_list_price,
    byte_tickets.notes,
    byte_tickets.time_door_opened,
    byte_tickets.time_door_closed,
    byte_tickets.client_name,
    byte_tickets.estd_num_users,
    byte_tickets.ts,
    byte_tickets.full_name,
    byte_tickets.door_opened_secs,
    byte_tickets.month,
    byte_tickets.week,
    byte_tickets.date,
    byte_tickets.dayofweek,
    byte_tickets.hour,
    byte_tickets.dowhour,
    byte_tickets.uniq_user
   FROM public.byte_tickets
  WHERE (byte_tickets.ts > (now() - '45 days'::interval day));


ALTER TABLE public.byte_tickets_45days OWNER TO dbservice;

--
-- Name: byte_epcssold_45days; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_epcssold_45days AS
 SELECT o.order_id,
    o.first_name,
    o.last_name,
    o.kiosk_id,
    o.kiosk_title,
    o.email,
    o.amount_paid,
    o.payment_system,
    o.transaction_id,
    o.approval_code,
    o.status_code,
    o.status_message,
    o.status,
    o.batch_id,
    o.created,
    o.auth_amount,
    o.data_token,
    o.time_opened,
    o.time_closed,
    o.card_hash,
    o.state,
    o.archived,
    o.stamp,
    o.last_update,
    o.balance,
    o.delta,
    o.coupon_id,
    o.coupon,
    o.refund,
    o.receipt,
    o.campus_id,
    o.amount_list_price,
    o.notes,
    o.time_door_opened,
    o.time_door_closed,
    o.client_name,
    o.estd_num_users,
    o.ts,
    o.full_name,
    o.door_opened_secs,
    o.month,
    o.week,
    o.date,
    o.dayofweek,
    o.hour,
    o.dowhour,
    o.uniq_user,
    lp.epc,
    lp.label_order_id,
    lp.label_status,
    lp.label_price,
    lp.time_created,
    lp.time_added,
    lp.time_updated,
    lp.ts_created,
    lp.ts_added,
    lp.ts_updated,
    lp.label_kiosk_id,
    lp.product_id,
    lp.product_title,
    lp.product_archived,
    lp.product_vendor,
    lp.product_price,
    lp.product_cost,
    lp.product_shelf_life_days,
    lp.product_attributes,
    lp.product_categories,
    lp.consumer_category,
    lp.product_source
   FROM (public.byte_tickets_45days o
     JOIN public.byte_label_product lp ON (((lp.label_order_id)::text = (o.order_id)::text)))
  WHERE ((lp.label_status)::text = 'sold'::text);


ALTER TABLE public.byte_epcssold_45days OWNER TO dbservice;

--
-- Name: byte_tickets_4days; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_tickets_4days AS
 SELECT byte_tickets.order_id,
    byte_tickets.first_name,
    byte_tickets.last_name,
    byte_tickets.kiosk_id,
    byte_tickets.kiosk_title,
    byte_tickets.email,
    byte_tickets.amount_paid,
    byte_tickets.payment_system,
    byte_tickets.transaction_id,
    byte_tickets.approval_code,
    byte_tickets.status_code,
    byte_tickets.status_message,
    byte_tickets.status,
    byte_tickets.batch_id,
    byte_tickets.created,
    byte_tickets.auth_amount,
    byte_tickets.data_token,
    byte_tickets.time_opened,
    byte_tickets.time_closed,
    byte_tickets.card_hash,
    byte_tickets.state,
    byte_tickets.archived,
    byte_tickets.stamp,
    byte_tickets.last_update,
    byte_tickets.balance,
    byte_tickets.delta,
    byte_tickets.coupon_id,
    byte_tickets.coupon,
    byte_tickets.refund,
    byte_tickets.receipt,
    byte_tickets.campus_id,
    byte_tickets.amount_list_price,
    byte_tickets.notes,
    byte_tickets.time_door_opened,
    byte_tickets.time_door_closed,
    byte_tickets.client_name,
    byte_tickets.estd_num_users,
    byte_tickets.ts,
    byte_tickets.full_name,
    byte_tickets.door_opened_secs,
    byte_tickets.month,
    byte_tickets.week,
    byte_tickets.date,
    byte_tickets.dayofweek,
    byte_tickets.hour,
    byte_tickets.dowhour,
    byte_tickets.uniq_user
   FROM public.byte_tickets
  WHERE (byte_tickets.ts > (now() - '4 days'::interval day));


ALTER TABLE public.byte_tickets_4days OWNER TO dbservice;

--
-- Name: byte_epcssold_4days; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_epcssold_4days AS
 SELECT o.order_id,
    o.first_name,
    o.last_name,
    o.kiosk_id,
    o.kiosk_title,
    o.email,
    o.amount_paid,
    o.payment_system,
    o.transaction_id,
    o.approval_code,
    o.status_code,
    o.status_message,
    o.status,
    o.batch_id,
    o.created,
    o.auth_amount,
    o.data_token,
    o.time_opened,
    o.time_closed,
    o.card_hash,
    o.state,
    o.archived,
    o.stamp,
    o.last_update,
    o.balance,
    o.delta,
    o.coupon_id,
    o.coupon,
    o.refund,
    o.receipt,
    o.campus_id,
    o.amount_list_price,
    o.notes,
    o.time_door_opened,
    o.time_door_closed,
    o.client_name,
    o.estd_num_users,
    o.ts,
    o.full_name,
    o.door_opened_secs,
    o.month,
    o.week,
    o.date,
    o.dayofweek,
    o.hour,
    o.dowhour,
    o.uniq_user,
    lp.epc,
    lp.label_order_id,
    lp.label_status,
    lp.label_price,
    lp.time_created,
    lp.time_added,
    lp.time_updated,
    lp.ts_created,
    lp.ts_added,
    lp.ts_updated,
    lp.label_kiosk_id,
    lp.product_id,
    lp.product_title,
    lp.product_archived,
    lp.product_vendor,
    lp.product_price,
    lp.product_cost,
    lp.product_shelf_life_days,
    lp.product_attributes,
    lp.product_categories,
    lp.consumer_category,
    lp.product_source
   FROM (public.byte_tickets_4days o
     JOIN public.byte_label_product lp ON (((lp.label_order_id)::text = (o.order_id)::text)))
  WHERE ((lp.label_status)::text = 'sold'::text);


ALTER TABLE public.byte_epcssold_4days OWNER TO dbservice;

--
-- Name: byte_tickets_4months; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_tickets_4months AS
 SELECT byte_tickets.order_id,
    byte_tickets.first_name,
    byte_tickets.last_name,
    byte_tickets.kiosk_id,
    byte_tickets.kiosk_title,
    byte_tickets.email,
    byte_tickets.amount_paid,
    byte_tickets.payment_system,
    byte_tickets.transaction_id,
    byte_tickets.approval_code,
    byte_tickets.status_code,
    byte_tickets.status_message,
    byte_tickets.status,
    byte_tickets.batch_id,
    byte_tickets.created,
    byte_tickets.auth_amount,
    byte_tickets.data_token,
    byte_tickets.time_opened,
    byte_tickets.time_closed,
    byte_tickets.card_hash,
    byte_tickets.state,
    byte_tickets.archived,
    byte_tickets.stamp,
    byte_tickets.last_update,
    byte_tickets.balance,
    byte_tickets.delta,
    byte_tickets.coupon_id,
    byte_tickets.coupon,
    byte_tickets.refund,
    byte_tickets.receipt,
    byte_tickets.campus_id,
    byte_tickets.amount_list_price,
    byte_tickets.notes,
    byte_tickets.time_door_opened,
    byte_tickets.time_door_closed,
    byte_tickets.client_name,
    byte_tickets.estd_num_users,
    byte_tickets.ts,
    byte_tickets.full_name,
    byte_tickets.door_opened_secs,
    byte_tickets.month,
    byte_tickets.week,
    byte_tickets.date,
    byte_tickets.dayofweek,
    byte_tickets.hour,
    byte_tickets.dowhour,
    byte_tickets.uniq_user
   FROM public.byte_tickets
  WHERE (byte_tickets.ts > (now() - '4 mons'::interval month));


ALTER TABLE public.byte_tickets_4months OWNER TO dbservice;

--
-- Name: byte_epcssold_4months; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_epcssold_4months AS
 SELECT o.order_id,
    o.first_name,
    o.last_name,
    o.kiosk_id,
    o.kiosk_title,
    o.email,
    o.amount_paid,
    o.payment_system,
    o.transaction_id,
    o.approval_code,
    o.status_code,
    o.status_message,
    o.status,
    o.batch_id,
    o.created,
    o.auth_amount,
    o.data_token,
    o.time_opened,
    o.time_closed,
    o.card_hash,
    o.state,
    o.archived,
    o.stamp,
    o.last_update,
    o.balance,
    o.delta,
    o.coupon_id,
    o.coupon,
    o.refund,
    o.receipt,
    o.campus_id,
    o.amount_list_price,
    o.notes,
    o.time_door_opened,
    o.time_door_closed,
    o.client_name,
    o.estd_num_users,
    o.ts,
    o.full_name,
    o.door_opened_secs,
    o.month,
    o.week,
    o.date,
    o.dayofweek,
    o.hour,
    o.dowhour,
    o.uniq_user,
    lp.epc,
    lp.label_order_id,
    lp.label_status,
    lp.label_price,
    lp.time_created,
    lp.time_added,
    lp.time_updated,
    lp.ts_created,
    lp.ts_added,
    lp.ts_updated,
    lp.label_kiosk_id,
    lp.product_id,
    lp.product_title,
    lp.product_archived,
    lp.product_vendor,
    lp.product_price,
    lp.product_cost,
    lp.product_shelf_life_days,
    lp.product_attributes,
    lp.product_categories,
    lp.consumer_category,
    lp.product_source
   FROM (public.byte_tickets_4months o
     JOIN public.byte_label_product lp ON (((lp.label_order_id)::text = (o.order_id)::text)))
  WHERE ((lp.label_status)::text = 'sold'::text);


ALTER TABLE public.byte_epcssold_4months OWNER TO dbservice;

--
-- Name: byte_tickets_4weeks; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_tickets_4weeks AS
 SELECT byte_tickets.order_id,
    byte_tickets.first_name,
    byte_tickets.last_name,
    byte_tickets.kiosk_id,
    byte_tickets.kiosk_title,
    byte_tickets.email,
    byte_tickets.amount_paid,
    byte_tickets.payment_system,
    byte_tickets.transaction_id,
    byte_tickets.approval_code,
    byte_tickets.status_code,
    byte_tickets.status_message,
    byte_tickets.status,
    byte_tickets.batch_id,
    byte_tickets.created,
    byte_tickets.auth_amount,
    byte_tickets.data_token,
    byte_tickets.time_opened,
    byte_tickets.time_closed,
    byte_tickets.card_hash,
    byte_tickets.state,
    byte_tickets.archived,
    byte_tickets.stamp,
    byte_tickets.last_update,
    byte_tickets.balance,
    byte_tickets.delta,
    byte_tickets.coupon_id,
    byte_tickets.coupon,
    byte_tickets.refund,
    byte_tickets.receipt,
    byte_tickets.campus_id,
    byte_tickets.amount_list_price,
    byte_tickets.notes,
    byte_tickets.time_door_opened,
    byte_tickets.time_door_closed,
    byte_tickets.client_name,
    byte_tickets.estd_num_users,
    byte_tickets.ts,
    byte_tickets.full_name,
    byte_tickets.door_opened_secs,
    byte_tickets.month,
    byte_tickets.week,
    byte_tickets.date,
    byte_tickets.dayofweek,
    byte_tickets.hour,
    byte_tickets.dowhour,
    byte_tickets.uniq_user
   FROM public.byte_tickets
  WHERE (byte_tickets.ts > (now() - '28 days'::interval day));


ALTER TABLE public.byte_tickets_4weeks OWNER TO dbservice;

--
-- Name: byte_epcssold_4weeks; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_epcssold_4weeks AS
 SELECT o.order_id,
    o.first_name,
    o.last_name,
    o.kiosk_id,
    o.kiosk_title,
    o.email,
    o.amount_paid,
    o.payment_system,
    o.transaction_id,
    o.approval_code,
    o.status_code,
    o.status_message,
    o.status,
    o.batch_id,
    o.created,
    o.auth_amount,
    o.data_token,
    o.time_opened,
    o.time_closed,
    o.card_hash,
    o.state,
    o.archived,
    o.stamp,
    o.last_update,
    o.balance,
    o.delta,
    o.coupon_id,
    o.coupon,
    o.refund,
    o.receipt,
    o.campus_id,
    o.amount_list_price,
    o.notes,
    o.time_door_opened,
    o.time_door_closed,
    o.client_name,
    o.estd_num_users,
    o.ts,
    o.full_name,
    o.door_opened_secs,
    o.month,
    o.week,
    o.date,
    o.dayofweek,
    o.hour,
    o.dowhour,
    o.uniq_user,
    lp.epc,
    lp.label_order_id,
    lp.label_status,
    lp.label_price,
    lp.time_created,
    lp.time_added,
    lp.time_updated,
    lp.ts_created,
    lp.ts_added,
    lp.ts_updated,
    lp.label_kiosk_id,
    lp.product_id,
    lp.product_title,
    lp.product_archived,
    lp.product_vendor,
    lp.product_price,
    lp.product_cost,
    lp.product_shelf_life_days,
    lp.product_attributes,
    lp.product_categories,
    lp.consumer_category,
    lp.product_source
   FROM (public.byte_tickets_4weeks o
     JOIN public.byte_label_product lp ON (((lp.label_order_id)::text = (o.order_id)::text)))
  WHERE ((lp.label_status)::text = 'sold'::text);


ALTER TABLE public.byte_epcssold_4weeks OWNER TO dbservice;

--
-- Name: byte_tickets_5days; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_tickets_5days AS
 SELECT byte_tickets.order_id,
    byte_tickets.first_name,
    byte_tickets.last_name,
    byte_tickets.kiosk_id,
    byte_tickets.kiosk_title,
    byte_tickets.email,
    byte_tickets.amount_paid,
    byte_tickets.payment_system,
    byte_tickets.transaction_id,
    byte_tickets.approval_code,
    byte_tickets.status_code,
    byte_tickets.status_message,
    byte_tickets.status,
    byte_tickets.batch_id,
    byte_tickets.created,
    byte_tickets.auth_amount,
    byte_tickets.data_token,
    byte_tickets.time_opened,
    byte_tickets.time_closed,
    byte_tickets.card_hash,
    byte_tickets.state,
    byte_tickets.archived,
    byte_tickets.stamp,
    byte_tickets.last_update,
    byte_tickets.balance,
    byte_tickets.delta,
    byte_tickets.coupon_id,
    byte_tickets.coupon,
    byte_tickets.refund,
    byte_tickets.receipt,
    byte_tickets.campus_id,
    byte_tickets.amount_list_price,
    byte_tickets.notes,
    byte_tickets.time_door_opened,
    byte_tickets.time_door_closed,
    byte_tickets.client_name,
    byte_tickets.estd_num_users,
    byte_tickets.ts,
    byte_tickets.full_name,
    byte_tickets.door_opened_secs,
    byte_tickets.month,
    byte_tickets.week,
    byte_tickets.date,
    byte_tickets.dayofweek,
    byte_tickets.hour,
    byte_tickets.dowhour,
    byte_tickets.uniq_user
   FROM public.byte_tickets
  WHERE (byte_tickets.ts > (now() - '5 days'::interval day));


ALTER TABLE public.byte_tickets_5days OWNER TO dbservice;

--
-- Name: byte_epcssold_5days; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_epcssold_5days AS
 SELECT o.order_id,
    o.first_name,
    o.last_name,
    o.kiosk_id,
    o.kiosk_title,
    o.email,
    o.amount_paid,
    o.payment_system,
    o.transaction_id,
    o.approval_code,
    o.status_code,
    o.status_message,
    o.status,
    o.batch_id,
    o.created,
    o.auth_amount,
    o.data_token,
    o.time_opened,
    o.time_closed,
    o.card_hash,
    o.state,
    o.archived,
    o.stamp,
    o.last_update,
    o.balance,
    o.delta,
    o.coupon_id,
    o.coupon,
    o.refund,
    o.receipt,
    o.campus_id,
    o.amount_list_price,
    o.notes,
    o.time_door_opened,
    o.time_door_closed,
    o.client_name,
    o.estd_num_users,
    o.ts,
    o.full_name,
    o.door_opened_secs,
    o.month,
    o.week,
    o.date,
    o.dayofweek,
    o.hour,
    o.dowhour,
    o.uniq_user,
    lp.epc,
    lp.label_order_id,
    lp.label_status,
    lp.label_price,
    lp.time_created,
    lp.time_added,
    lp.time_updated,
    lp.ts_created,
    lp.ts_added,
    lp.ts_updated,
    lp.label_kiosk_id,
    lp.product_id,
    lp.product_title,
    lp.product_archived,
    lp.product_vendor,
    lp.product_price,
    lp.product_cost,
    lp.product_shelf_life_days,
    lp.product_attributes,
    lp.product_categories,
    lp.consumer_category,
    lp.product_source
   FROM (public.byte_tickets_5days o
     JOIN public.byte_label_product lp ON (((lp.label_order_id)::text = (o.order_id)::text)))
  WHERE ((lp.label_status)::text = 'sold'::text);


ALTER TABLE public.byte_epcssold_5days OWNER TO dbservice;

--
-- Name: byte_tickets_5weeks; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_tickets_5weeks AS
 SELECT byte_tickets.order_id,
    byte_tickets.first_name,
    byte_tickets.last_name,
    byte_tickets.kiosk_id,
    byte_tickets.kiosk_title,
    byte_tickets.email,
    byte_tickets.amount_paid,
    byte_tickets.payment_system,
    byte_tickets.transaction_id,
    byte_tickets.approval_code,
    byte_tickets.status_code,
    byte_tickets.status_message,
    byte_tickets.status,
    byte_tickets.batch_id,
    byte_tickets.created,
    byte_tickets.auth_amount,
    byte_tickets.data_token,
    byte_tickets.time_opened,
    byte_tickets.time_closed,
    byte_tickets.card_hash,
    byte_tickets.state,
    byte_tickets.archived,
    byte_tickets.stamp,
    byte_tickets.last_update,
    byte_tickets.balance,
    byte_tickets.delta,
    byte_tickets.coupon_id,
    byte_tickets.coupon,
    byte_tickets.refund,
    byte_tickets.receipt,
    byte_tickets.campus_id,
    byte_tickets.amount_list_price,
    byte_tickets.notes,
    byte_tickets.time_door_opened,
    byte_tickets.time_door_closed,
    byte_tickets.client_name,
    byte_tickets.estd_num_users,
    byte_tickets.ts,
    byte_tickets.full_name,
    byte_tickets.door_opened_secs,
    byte_tickets.month,
    byte_tickets.week,
    byte_tickets.date,
    byte_tickets.dayofweek,
    byte_tickets.hour,
    byte_tickets.dowhour,
    byte_tickets.uniq_user
   FROM public.byte_tickets
  WHERE (byte_tickets.ts > (now() - '35 days'::interval day));


ALTER TABLE public.byte_tickets_5weeks OWNER TO dbservice;

--
-- Name: byte_epcssold_5weeks; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_epcssold_5weeks AS
 SELECT o.order_id,
    o.first_name,
    o.last_name,
    o.kiosk_id,
    o.kiosk_title,
    o.email,
    o.amount_paid,
    o.payment_system,
    o.transaction_id,
    o.approval_code,
    o.status_code,
    o.status_message,
    o.status,
    o.batch_id,
    o.created,
    o.auth_amount,
    o.data_token,
    o.time_opened,
    o.time_closed,
    o.card_hash,
    o.state,
    o.archived,
    o.stamp,
    o.last_update,
    o.balance,
    o.delta,
    o.coupon_id,
    o.coupon,
    o.refund,
    o.receipt,
    o.campus_id,
    o.amount_list_price,
    o.notes,
    o.time_door_opened,
    o.time_door_closed,
    o.client_name,
    o.estd_num_users,
    o.ts,
    o.full_name,
    o.door_opened_secs,
    o.month,
    o.week,
    o.date,
    o.dayofweek,
    o.hour,
    o.dowhour,
    o.uniq_user,
    lp.epc,
    lp.label_order_id,
    lp.label_status,
    lp.label_price,
    lp.time_created,
    lp.time_added,
    lp.time_updated,
    lp.ts_created,
    lp.ts_added,
    lp.ts_updated,
    lp.label_kiosk_id,
    lp.product_id,
    lp.product_title,
    lp.product_archived,
    lp.product_vendor,
    lp.product_price,
    lp.product_cost,
    lp.product_shelf_life_days,
    lp.product_attributes,
    lp.product_categories,
    lp.consumer_category,
    lp.product_source
   FROM (public.byte_tickets_5weeks o
     JOIN public.byte_label_product lp ON (((lp.label_order_id)::text = (o.order_id)::text)))
  WHERE ((lp.label_status)::text = 'sold'::text);


ALTER TABLE public.byte_epcssold_5weeks OWNER TO dbservice;

--
-- Name: byte_tickets_60days; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_tickets_60days AS
 SELECT byte_tickets.order_id,
    byte_tickets.first_name,
    byte_tickets.last_name,
    byte_tickets.kiosk_id,
    byte_tickets.kiosk_title,
    byte_tickets.email,
    byte_tickets.amount_paid,
    byte_tickets.payment_system,
    byte_tickets.transaction_id,
    byte_tickets.approval_code,
    byte_tickets.status_code,
    byte_tickets.status_message,
    byte_tickets.status,
    byte_tickets.batch_id,
    byte_tickets.created,
    byte_tickets.auth_amount,
    byte_tickets.data_token,
    byte_tickets.time_opened,
    byte_tickets.time_closed,
    byte_tickets.card_hash,
    byte_tickets.state,
    byte_tickets.archived,
    byte_tickets.stamp,
    byte_tickets.last_update,
    byte_tickets.balance,
    byte_tickets.delta,
    byte_tickets.coupon_id,
    byte_tickets.coupon,
    byte_tickets.refund,
    byte_tickets.receipt,
    byte_tickets.campus_id,
    byte_tickets.amount_list_price,
    byte_tickets.notes,
    byte_tickets.time_door_opened,
    byte_tickets.time_door_closed,
    byte_tickets.client_name,
    byte_tickets.estd_num_users,
    byte_tickets.ts,
    byte_tickets.full_name,
    byte_tickets.door_opened_secs,
    byte_tickets.month,
    byte_tickets.week,
    byte_tickets.date,
    byte_tickets.dayofweek,
    byte_tickets.hour,
    byte_tickets.dowhour,
    byte_tickets.uniq_user
   FROM public.byte_tickets
  WHERE (byte_tickets.ts > (now() - '60 days'::interval day));


ALTER TABLE public.byte_tickets_60days OWNER TO dbservice;

--
-- Name: byte_epcssold_60days; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_epcssold_60days AS
 SELECT o.order_id,
    o.first_name,
    o.last_name,
    o.kiosk_id,
    o.kiosk_title,
    o.email,
    o.amount_paid,
    o.payment_system,
    o.transaction_id,
    o.approval_code,
    o.status_code,
    o.status_message,
    o.status,
    o.batch_id,
    o.created,
    o.auth_amount,
    o.data_token,
    o.time_opened,
    o.time_closed,
    o.card_hash,
    o.state,
    o.archived,
    o.stamp,
    o.last_update,
    o.balance,
    o.delta,
    o.coupon_id,
    o.coupon,
    o.refund,
    o.receipt,
    o.campus_id,
    o.amount_list_price,
    o.notes,
    o.time_door_opened,
    o.time_door_closed,
    o.client_name,
    o.estd_num_users,
    o.ts,
    o.full_name,
    o.door_opened_secs,
    o.month,
    o.week,
    o.date,
    o.dayofweek,
    o.hour,
    o.dowhour,
    o.uniq_user,
    lp.epc,
    lp.label_order_id,
    lp.label_status,
    lp.label_price,
    lp.time_created,
    lp.time_added,
    lp.time_updated,
    lp.ts_created,
    lp.ts_added,
    lp.ts_updated,
    lp.label_kiosk_id,
    lp.product_id,
    lp.product_title,
    lp.product_archived,
    lp.product_vendor,
    lp.product_price,
    lp.product_cost,
    lp.product_shelf_life_days,
    lp.product_attributes,
    lp.product_categories,
    lp.consumer_category,
    lp.product_source
   FROM (public.byte_tickets_60days o
     JOIN public.byte_label_product lp ON (((lp.label_order_id)::text = (o.order_id)::text)))
  WHERE ((lp.label_status)::text = 'sold'::text);


ALTER TABLE public.byte_epcssold_60days OWNER TO dbservice;

--
-- Name: byte_tickets_6days; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_tickets_6days AS
 SELECT byte_tickets.order_id,
    byte_tickets.first_name,
    byte_tickets.last_name,
    byte_tickets.kiosk_id,
    byte_tickets.kiosk_title,
    byte_tickets.email,
    byte_tickets.amount_paid,
    byte_tickets.payment_system,
    byte_tickets.transaction_id,
    byte_tickets.approval_code,
    byte_tickets.status_code,
    byte_tickets.status_message,
    byte_tickets.status,
    byte_tickets.batch_id,
    byte_tickets.created,
    byte_tickets.auth_amount,
    byte_tickets.data_token,
    byte_tickets.time_opened,
    byte_tickets.time_closed,
    byte_tickets.card_hash,
    byte_tickets.state,
    byte_tickets.archived,
    byte_tickets.stamp,
    byte_tickets.last_update,
    byte_tickets.balance,
    byte_tickets.delta,
    byte_tickets.coupon_id,
    byte_tickets.coupon,
    byte_tickets.refund,
    byte_tickets.receipt,
    byte_tickets.campus_id,
    byte_tickets.amount_list_price,
    byte_tickets.notes,
    byte_tickets.time_door_opened,
    byte_tickets.time_door_closed,
    byte_tickets.client_name,
    byte_tickets.estd_num_users,
    byte_tickets.ts,
    byte_tickets.full_name,
    byte_tickets.door_opened_secs,
    byte_tickets.month,
    byte_tickets.week,
    byte_tickets.date,
    byte_tickets.dayofweek,
    byte_tickets.hour,
    byte_tickets.dowhour,
    byte_tickets.uniq_user
   FROM public.byte_tickets
  WHERE (byte_tickets.ts > (now() - '6 days'::interval day));


ALTER TABLE public.byte_tickets_6days OWNER TO dbservice;

--
-- Name: byte_epcssold_6days; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_epcssold_6days AS
 SELECT o.order_id,
    o.first_name,
    o.last_name,
    o.kiosk_id,
    o.kiosk_title,
    o.email,
    o.amount_paid,
    o.payment_system,
    o.transaction_id,
    o.approval_code,
    o.status_code,
    o.status_message,
    o.status,
    o.batch_id,
    o.created,
    o.auth_amount,
    o.data_token,
    o.time_opened,
    o.time_closed,
    o.card_hash,
    o.state,
    o.archived,
    o.stamp,
    o.last_update,
    o.balance,
    o.delta,
    o.coupon_id,
    o.coupon,
    o.refund,
    o.receipt,
    o.campus_id,
    o.amount_list_price,
    o.notes,
    o.time_door_opened,
    o.time_door_closed,
    o.client_name,
    o.estd_num_users,
    o.ts,
    o.full_name,
    o.door_opened_secs,
    o.month,
    o.week,
    o.date,
    o.dayofweek,
    o.hour,
    o.dowhour,
    o.uniq_user,
    lp.epc,
    lp.label_order_id,
    lp.label_status,
    lp.label_price,
    lp.time_created,
    lp.time_added,
    lp.time_updated,
    lp.ts_created,
    lp.ts_added,
    lp.ts_updated,
    lp.label_kiosk_id,
    lp.product_id,
    lp.product_title,
    lp.product_archived,
    lp.product_vendor,
    lp.product_price,
    lp.product_cost,
    lp.product_shelf_life_days,
    lp.product_attributes,
    lp.product_categories,
    lp.consumer_category,
    lp.product_source
   FROM (public.byte_tickets_6days o
     JOIN public.byte_label_product lp ON (((lp.label_order_id)::text = (o.order_id)::text)))
  WHERE ((lp.label_status)::text = 'sold'::text);


ALTER TABLE public.byte_epcssold_6days OWNER TO dbservice;

--
-- Name: byte_tickets_6months; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_tickets_6months AS
 SELECT byte_tickets.order_id,
    byte_tickets.first_name,
    byte_tickets.last_name,
    byte_tickets.kiosk_id,
    byte_tickets.kiosk_title,
    byte_tickets.email,
    byte_tickets.amount_paid,
    byte_tickets.payment_system,
    byte_tickets.transaction_id,
    byte_tickets.approval_code,
    byte_tickets.status_code,
    byte_tickets.status_message,
    byte_tickets.status,
    byte_tickets.batch_id,
    byte_tickets.created,
    byte_tickets.auth_amount,
    byte_tickets.data_token,
    byte_tickets.time_opened,
    byte_tickets.time_closed,
    byte_tickets.card_hash,
    byte_tickets.state,
    byte_tickets.archived,
    byte_tickets.stamp,
    byte_tickets.last_update,
    byte_tickets.balance,
    byte_tickets.delta,
    byte_tickets.coupon_id,
    byte_tickets.coupon,
    byte_tickets.refund,
    byte_tickets.receipt,
    byte_tickets.campus_id,
    byte_tickets.amount_list_price,
    byte_tickets.notes,
    byte_tickets.time_door_opened,
    byte_tickets.time_door_closed,
    byte_tickets.client_name,
    byte_tickets.estd_num_users,
    byte_tickets.ts,
    byte_tickets.full_name,
    byte_tickets.door_opened_secs,
    byte_tickets.month,
    byte_tickets.week,
    byte_tickets.date,
    byte_tickets.dayofweek,
    byte_tickets.hour,
    byte_tickets.dowhour,
    byte_tickets.uniq_user
   FROM public.byte_tickets
  WHERE (byte_tickets.ts > (now() - '6 mons'::interval month));


ALTER TABLE public.byte_tickets_6months OWNER TO dbservice;

--
-- Name: byte_epcssold_6months; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_epcssold_6months AS
 SELECT o.order_id,
    o.first_name,
    o.last_name,
    o.kiosk_id,
    o.kiosk_title,
    o.email,
    o.amount_paid,
    o.payment_system,
    o.transaction_id,
    o.approval_code,
    o.status_code,
    o.status_message,
    o.status,
    o.batch_id,
    o.created,
    o.auth_amount,
    o.data_token,
    o.time_opened,
    o.time_closed,
    o.card_hash,
    o.state,
    o.archived,
    o.stamp,
    o.last_update,
    o.balance,
    o.delta,
    o.coupon_id,
    o.coupon,
    o.refund,
    o.receipt,
    o.campus_id,
    o.amount_list_price,
    o.notes,
    o.time_door_opened,
    o.time_door_closed,
    o.client_name,
    o.estd_num_users,
    o.ts,
    o.full_name,
    o.door_opened_secs,
    o.month,
    o.week,
    o.date,
    o.dayofweek,
    o.hour,
    o.dowhour,
    o.uniq_user,
    lp.epc,
    lp.label_order_id,
    lp.label_status,
    lp.label_price,
    lp.time_created,
    lp.time_added,
    lp.time_updated,
    lp.ts_created,
    lp.ts_added,
    lp.ts_updated,
    lp.label_kiosk_id,
    lp.product_id,
    lp.product_title,
    lp.product_archived,
    lp.product_vendor,
    lp.product_price,
    lp.product_cost,
    lp.product_shelf_life_days,
    lp.product_attributes,
    lp.product_categories,
    lp.consumer_category,
    lp.product_source
   FROM (public.byte_tickets_6months o
     JOIN public.byte_label_product lp ON (((lp.label_order_id)::text = (o.order_id)::text)))
  WHERE ((lp.label_status)::text = 'sold'::text);


ALTER TABLE public.byte_epcssold_6months OWNER TO dbservice;

--
-- Name: byte_tickets_6weeks; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_tickets_6weeks AS
 SELECT byte_tickets.order_id,
    byte_tickets.first_name,
    byte_tickets.last_name,
    byte_tickets.kiosk_id,
    byte_tickets.kiosk_title,
    byte_tickets.email,
    byte_tickets.amount_paid,
    byte_tickets.payment_system,
    byte_tickets.transaction_id,
    byte_tickets.approval_code,
    byte_tickets.status_code,
    byte_tickets.status_message,
    byte_tickets.status,
    byte_tickets.batch_id,
    byte_tickets.created,
    byte_tickets.auth_amount,
    byte_tickets.data_token,
    byte_tickets.time_opened,
    byte_tickets.time_closed,
    byte_tickets.card_hash,
    byte_tickets.state,
    byte_tickets.archived,
    byte_tickets.stamp,
    byte_tickets.last_update,
    byte_tickets.balance,
    byte_tickets.delta,
    byte_tickets.coupon_id,
    byte_tickets.coupon,
    byte_tickets.refund,
    byte_tickets.receipt,
    byte_tickets.campus_id,
    byte_tickets.amount_list_price,
    byte_tickets.notes,
    byte_tickets.time_door_opened,
    byte_tickets.time_door_closed,
    byte_tickets.client_name,
    byte_tickets.estd_num_users,
    byte_tickets.ts,
    byte_tickets.full_name,
    byte_tickets.door_opened_secs,
    byte_tickets.month,
    byte_tickets.week,
    byte_tickets.date,
    byte_tickets.dayofweek,
    byte_tickets.hour,
    byte_tickets.dowhour,
    byte_tickets.uniq_user
   FROM public.byte_tickets
  WHERE (byte_tickets.ts > (now() - '42 days'::interval day));


ALTER TABLE public.byte_tickets_6weeks OWNER TO dbservice;

--
-- Name: byte_epcssold_6weeks; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_epcssold_6weeks AS
 SELECT o.order_id,
    o.first_name,
    o.last_name,
    o.kiosk_id,
    o.kiosk_title,
    o.email,
    o.amount_paid,
    o.payment_system,
    o.transaction_id,
    o.approval_code,
    o.status_code,
    o.status_message,
    o.status,
    o.batch_id,
    o.created,
    o.auth_amount,
    o.data_token,
    o.time_opened,
    o.time_closed,
    o.card_hash,
    o.state,
    o.archived,
    o.stamp,
    o.last_update,
    o.balance,
    o.delta,
    o.coupon_id,
    o.coupon,
    o.refund,
    o.receipt,
    o.campus_id,
    o.amount_list_price,
    o.notes,
    o.time_door_opened,
    o.time_door_closed,
    o.client_name,
    o.estd_num_users,
    o.ts,
    o.full_name,
    o.door_opened_secs,
    o.month,
    o.week,
    o.date,
    o.dayofweek,
    o.hour,
    o.dowhour,
    o.uniq_user,
    lp.epc,
    lp.label_order_id,
    lp.label_status,
    lp.label_price,
    lp.time_created,
    lp.time_added,
    lp.time_updated,
    lp.ts_created,
    lp.ts_added,
    lp.ts_updated,
    lp.label_kiosk_id,
    lp.product_id,
    lp.product_title,
    lp.product_archived,
    lp.product_vendor,
    lp.product_price,
    lp.product_cost,
    lp.product_shelf_life_days,
    lp.product_attributes,
    lp.product_categories,
    lp.consumer_category,
    lp.product_source
   FROM (public.byte_tickets_6weeks o
     JOIN public.byte_label_product lp ON (((lp.label_order_id)::text = (o.order_id)::text)))
  WHERE ((lp.label_status)::text = 'sold'::text);


ALTER TABLE public.byte_epcssold_6weeks OWNER TO dbservice;

--
-- Name: byte_tickets_7days; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_tickets_7days AS
 SELECT byte_tickets.order_id,
    byte_tickets.first_name,
    byte_tickets.last_name,
    byte_tickets.kiosk_id,
    byte_tickets.kiosk_title,
    byte_tickets.email,
    byte_tickets.amount_paid,
    byte_tickets.payment_system,
    byte_tickets.transaction_id,
    byte_tickets.approval_code,
    byte_tickets.status_code,
    byte_tickets.status_message,
    byte_tickets.status,
    byte_tickets.batch_id,
    byte_tickets.created,
    byte_tickets.auth_amount,
    byte_tickets.data_token,
    byte_tickets.time_opened,
    byte_tickets.time_closed,
    byte_tickets.card_hash,
    byte_tickets.state,
    byte_tickets.archived,
    byte_tickets.stamp,
    byte_tickets.last_update,
    byte_tickets.balance,
    byte_tickets.delta,
    byte_tickets.coupon_id,
    byte_tickets.coupon,
    byte_tickets.refund,
    byte_tickets.receipt,
    byte_tickets.campus_id,
    byte_tickets.amount_list_price,
    byte_tickets.notes,
    byte_tickets.time_door_opened,
    byte_tickets.time_door_closed,
    byte_tickets.client_name,
    byte_tickets.estd_num_users,
    byte_tickets.ts,
    byte_tickets.full_name,
    byte_tickets.door_opened_secs,
    byte_tickets.month,
    byte_tickets.week,
    byte_tickets.date,
    byte_tickets.dayofweek,
    byte_tickets.hour,
    byte_tickets.dowhour,
    byte_tickets.uniq_user
   FROM public.byte_tickets
  WHERE (byte_tickets.ts > (now() - '7 days'::interval day));


ALTER TABLE public.byte_tickets_7days OWNER TO dbservice;

--
-- Name: byte_epcssold_7days; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_epcssold_7days AS
 SELECT o.order_id,
    o.first_name,
    o.last_name,
    o.kiosk_id,
    o.kiosk_title,
    o.email,
    o.amount_paid,
    o.payment_system,
    o.transaction_id,
    o.approval_code,
    o.status_code,
    o.status_message,
    o.status,
    o.batch_id,
    o.created,
    o.auth_amount,
    o.data_token,
    o.time_opened,
    o.time_closed,
    o.card_hash,
    o.state,
    o.archived,
    o.stamp,
    o.last_update,
    o.balance,
    o.delta,
    o.coupon_id,
    o.coupon,
    o.refund,
    o.receipt,
    o.campus_id,
    o.amount_list_price,
    o.notes,
    o.time_door_opened,
    o.time_door_closed,
    o.client_name,
    o.estd_num_users,
    o.ts,
    o.full_name,
    o.door_opened_secs,
    o.month,
    o.week,
    o.date,
    o.dayofweek,
    o.hour,
    o.dowhour,
    o.uniq_user,
    lp.epc,
    lp.label_order_id,
    lp.label_status,
    lp.label_price,
    lp.time_created,
    lp.time_added,
    lp.time_updated,
    lp.ts_created,
    lp.ts_added,
    lp.ts_updated,
    lp.label_kiosk_id,
    lp.product_id,
    lp.product_title,
    lp.product_archived,
    lp.product_vendor,
    lp.product_price,
    lp.product_cost,
    lp.product_shelf_life_days,
    lp.product_attributes,
    lp.product_categories,
    lp.consumer_category,
    lp.product_source
   FROM (public.byte_tickets_7days o
     JOIN public.byte_label_product lp ON (((lp.label_order_id)::text = (o.order_id)::text)))
  WHERE ((lp.label_status)::text = 'sold'::text);


ALTER TABLE public.byte_epcssold_7days OWNER TO dbservice;

--
-- Name: byte_tickets_8weeks; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_tickets_8weeks AS
 SELECT byte_tickets.order_id,
    byte_tickets.first_name,
    byte_tickets.last_name,
    byte_tickets.kiosk_id,
    byte_tickets.kiosk_title,
    byte_tickets.email,
    byte_tickets.amount_paid,
    byte_tickets.payment_system,
    byte_tickets.transaction_id,
    byte_tickets.approval_code,
    byte_tickets.status_code,
    byte_tickets.status_message,
    byte_tickets.status,
    byte_tickets.batch_id,
    byte_tickets.created,
    byte_tickets.auth_amount,
    byte_tickets.data_token,
    byte_tickets.time_opened,
    byte_tickets.time_closed,
    byte_tickets.card_hash,
    byte_tickets.state,
    byte_tickets.archived,
    byte_tickets.stamp,
    byte_tickets.last_update,
    byte_tickets.balance,
    byte_tickets.delta,
    byte_tickets.coupon_id,
    byte_tickets.coupon,
    byte_tickets.refund,
    byte_tickets.receipt,
    byte_tickets.campus_id,
    byte_tickets.amount_list_price,
    byte_tickets.notes,
    byte_tickets.time_door_opened,
    byte_tickets.time_door_closed,
    byte_tickets.client_name,
    byte_tickets.estd_num_users,
    byte_tickets.ts,
    byte_tickets.full_name,
    byte_tickets.door_opened_secs,
    byte_tickets.month,
    byte_tickets.week,
    byte_tickets.date,
    byte_tickets.dayofweek,
    byte_tickets.hour,
    byte_tickets.dowhour,
    byte_tickets.uniq_user
   FROM public.byte_tickets
  WHERE (byte_tickets.ts > (now() - '56 days'::interval day));


ALTER TABLE public.byte_tickets_8weeks OWNER TO dbservice;

--
-- Name: byte_epcssold_8weeks; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_epcssold_8weeks AS
 SELECT o.order_id,
    o.first_name,
    o.last_name,
    o.kiosk_id,
    o.kiosk_title,
    o.email,
    o.amount_paid,
    o.payment_system,
    o.transaction_id,
    o.approval_code,
    o.status_code,
    o.status_message,
    o.status,
    o.batch_id,
    o.created,
    o.auth_amount,
    o.data_token,
    o.time_opened,
    o.time_closed,
    o.card_hash,
    o.state,
    o.archived,
    o.stamp,
    o.last_update,
    o.balance,
    o.delta,
    o.coupon_id,
    o.coupon,
    o.refund,
    o.receipt,
    o.campus_id,
    o.amount_list_price,
    o.notes,
    o.time_door_opened,
    o.time_door_closed,
    o.client_name,
    o.estd_num_users,
    o.ts,
    o.full_name,
    o.door_opened_secs,
    o.month,
    o.week,
    o.date,
    o.dayofweek,
    o.hour,
    o.dowhour,
    o.uniq_user,
    lp.epc,
    lp.label_order_id,
    lp.label_status,
    lp.label_price,
    lp.time_created,
    lp.time_added,
    lp.time_updated,
    lp.ts_created,
    lp.ts_added,
    lp.ts_updated,
    lp.label_kiosk_id,
    lp.product_id,
    lp.product_title,
    lp.product_archived,
    lp.product_vendor,
    lp.product_price,
    lp.product_cost,
    lp.product_shelf_life_days,
    lp.product_attributes,
    lp.product_categories,
    lp.consumer_category,
    lp.product_source
   FROM (public.byte_tickets_8weeks o
     JOIN public.byte_label_product lp ON (((lp.label_order_id)::text = (o.order_id)::text)))
  WHERE ((lp.label_status)::text = 'sold'::text);


ALTER TABLE public.byte_epcssold_8weeks OWNER TO dbservice;

--
-- Name: byte_tickets_90days; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_tickets_90days AS
 SELECT byte_tickets.order_id,
    byte_tickets.first_name,
    byte_tickets.last_name,
    byte_tickets.kiosk_id,
    byte_tickets.kiosk_title,
    byte_tickets.email,
    byte_tickets.amount_paid,
    byte_tickets.payment_system,
    byte_tickets.transaction_id,
    byte_tickets.approval_code,
    byte_tickets.status_code,
    byte_tickets.status_message,
    byte_tickets.status,
    byte_tickets.batch_id,
    byte_tickets.created,
    byte_tickets.auth_amount,
    byte_tickets.data_token,
    byte_tickets.time_opened,
    byte_tickets.time_closed,
    byte_tickets.card_hash,
    byte_tickets.state,
    byte_tickets.archived,
    byte_tickets.stamp,
    byte_tickets.last_update,
    byte_tickets.balance,
    byte_tickets.delta,
    byte_tickets.coupon_id,
    byte_tickets.coupon,
    byte_tickets.refund,
    byte_tickets.receipt,
    byte_tickets.campus_id,
    byte_tickets.amount_list_price,
    byte_tickets.notes,
    byte_tickets.time_door_opened,
    byte_tickets.time_door_closed,
    byte_tickets.client_name,
    byte_tickets.estd_num_users,
    byte_tickets.ts,
    byte_tickets.full_name,
    byte_tickets.door_opened_secs,
    byte_tickets.month,
    byte_tickets.week,
    byte_tickets.date,
    byte_tickets.dayofweek,
    byte_tickets.hour,
    byte_tickets.dowhour,
    byte_tickets.uniq_user
   FROM public.byte_tickets
  WHERE (byte_tickets.ts > (now() - '90 days'::interval day));


ALTER TABLE public.byte_tickets_90days OWNER TO dbservice;

--
-- Name: byte_epcssold_90days; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_epcssold_90days AS
 SELECT o.order_id,
    o.first_name,
    o.last_name,
    o.kiosk_id,
    o.kiosk_title,
    o.email,
    o.amount_paid,
    o.payment_system,
    o.transaction_id,
    o.approval_code,
    o.status_code,
    o.status_message,
    o.status,
    o.batch_id,
    o.created,
    o.auth_amount,
    o.data_token,
    o.time_opened,
    o.time_closed,
    o.card_hash,
    o.state,
    o.archived,
    o.stamp,
    o.last_update,
    o.balance,
    o.delta,
    o.coupon_id,
    o.coupon,
    o.refund,
    o.receipt,
    o.campus_id,
    o.amount_list_price,
    o.notes,
    o.time_door_opened,
    o.time_door_closed,
    o.client_name,
    o.estd_num_users,
    o.ts,
    o.full_name,
    o.door_opened_secs,
    o.month,
    o.week,
    o.date,
    o.dayofweek,
    o.hour,
    o.dowhour,
    o.uniq_user,
    lp.epc,
    lp.label_order_id,
    lp.label_status,
    lp.label_price,
    lp.time_created,
    lp.time_added,
    lp.time_updated,
    lp.ts_created,
    lp.ts_added,
    lp.ts_updated,
    lp.label_kiosk_id,
    lp.product_id,
    lp.product_title,
    lp.product_archived,
    lp.product_vendor,
    lp.product_price,
    lp.product_cost,
    lp.product_shelf_life_days,
    lp.product_attributes,
    lp.product_categories,
    lp.consumer_category,
    lp.product_source
   FROM (public.byte_tickets_90days o
     JOIN public.byte_label_product lp ON (((lp.label_order_id)::text = (o.order_id)::text)))
  WHERE ((lp.label_status)::text = 'sold'::text);


ALTER TABLE public.byte_epcssold_90days OWNER TO dbservice;

--
-- Name: byte_tickets_9months; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_tickets_9months AS
 SELECT byte_tickets.order_id,
    byte_tickets.first_name,
    byte_tickets.last_name,
    byte_tickets.kiosk_id,
    byte_tickets.kiosk_title,
    byte_tickets.email,
    byte_tickets.amount_paid,
    byte_tickets.payment_system,
    byte_tickets.transaction_id,
    byte_tickets.approval_code,
    byte_tickets.status_code,
    byte_tickets.status_message,
    byte_tickets.status,
    byte_tickets.batch_id,
    byte_tickets.created,
    byte_tickets.auth_amount,
    byte_tickets.data_token,
    byte_tickets.time_opened,
    byte_tickets.time_closed,
    byte_tickets.card_hash,
    byte_tickets.state,
    byte_tickets.archived,
    byte_tickets.stamp,
    byte_tickets.last_update,
    byte_tickets.balance,
    byte_tickets.delta,
    byte_tickets.coupon_id,
    byte_tickets.coupon,
    byte_tickets.refund,
    byte_tickets.receipt,
    byte_tickets.campus_id,
    byte_tickets.amount_list_price,
    byte_tickets.notes,
    byte_tickets.time_door_opened,
    byte_tickets.time_door_closed,
    byte_tickets.client_name,
    byte_tickets.estd_num_users,
    byte_tickets.ts,
    byte_tickets.full_name,
    byte_tickets.door_opened_secs,
    byte_tickets.month,
    byte_tickets.week,
    byte_tickets.date,
    byte_tickets.dayofweek,
    byte_tickets.hour,
    byte_tickets.dowhour,
    byte_tickets.uniq_user
   FROM public.byte_tickets
  WHERE (byte_tickets.ts > (now() - '9 mons'::interval month));


ALTER TABLE public.byte_tickets_9months OWNER TO dbservice;

--
-- Name: byte_epcssold_9months; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_epcssold_9months AS
 SELECT o.order_id,
    o.first_name,
    o.last_name,
    o.kiosk_id,
    o.kiosk_title,
    o.email,
    o.amount_paid,
    o.payment_system,
    o.transaction_id,
    o.approval_code,
    o.status_code,
    o.status_message,
    o.status,
    o.batch_id,
    o.created,
    o.auth_amount,
    o.data_token,
    o.time_opened,
    o.time_closed,
    o.card_hash,
    o.state,
    o.archived,
    o.stamp,
    o.last_update,
    o.balance,
    o.delta,
    o.coupon_id,
    o.coupon,
    o.refund,
    o.receipt,
    o.campus_id,
    o.amount_list_price,
    o.notes,
    o.time_door_opened,
    o.time_door_closed,
    o.client_name,
    o.estd_num_users,
    o.ts,
    o.full_name,
    o.door_opened_secs,
    o.month,
    o.week,
    o.date,
    o.dayofweek,
    o.hour,
    o.dowhour,
    o.uniq_user,
    lp.epc,
    lp.label_order_id,
    lp.label_status,
    lp.label_price,
    lp.time_created,
    lp.time_added,
    lp.time_updated,
    lp.ts_created,
    lp.ts_added,
    lp.ts_updated,
    lp.label_kiosk_id,
    lp.product_id,
    lp.product_title,
    lp.product_archived,
    lp.product_vendor,
    lp.product_price,
    lp.product_cost,
    lp.product_shelf_life_days,
    lp.product_attributes,
    lp.product_categories,
    lp.consumer_category,
    lp.product_source
   FROM (public.byte_tickets_9months o
     JOIN public.byte_label_product lp ON (((lp.label_order_id)::text = (o.order_id)::text)))
  WHERE ((lp.label_status)::text = 'sold'::text);


ALTER TABLE public.byte_epcssold_9months OWNER TO dbservice;

--
-- Name: byte_epcssold_fast; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_epcssold_fast AS
 SELECT byte_epcssold.order_id,
    byte_epcssold.first_name,
    byte_epcssold.last_name,
    byte_epcssold.kiosk_id,
    byte_epcssold.kiosk_title,
    byte_epcssold.email,
    byte_epcssold.amount_paid,
    byte_epcssold.payment_system,
    byte_epcssold.transaction_id,
    byte_epcssold.approval_code,
    byte_epcssold.status_code,
    byte_epcssold.status_message,
    byte_epcssold.status,
    byte_epcssold.batch_id,
    byte_epcssold.created,
    byte_epcssold.auth_amount,
    byte_epcssold.data_token,
    byte_epcssold.time_opened,
    byte_epcssold.time_closed,
    byte_epcssold.card_hash,
    byte_epcssold.state,
    byte_epcssold.archived,
    byte_epcssold.stamp,
    byte_epcssold.last_update,
    byte_epcssold.balance,
    byte_epcssold.delta,
    byte_epcssold.coupon_id,
    byte_epcssold.coupon,
    byte_epcssold.refund,
    byte_epcssold.receipt,
    byte_epcssold.campus_id,
    byte_epcssold.amount_list_price,
    byte_epcssold.notes,
    byte_epcssold.time_door_opened,
    byte_epcssold.time_door_closed,
    byte_epcssold.client_name,
    byte_epcssold.estd_num_users,
    byte_epcssold.ts,
    byte_epcssold.full_name,
    byte_epcssold.door_opened_secs,
    byte_epcssold.month,
    byte_epcssold.week,
    byte_epcssold.date,
    byte_epcssold.dayofweek,
    byte_epcssold.hour,
    byte_epcssold.dowhour,
    byte_epcssold.uniq_user,
    byte_epcssold.epc,
    byte_epcssold.label_order_id,
    byte_epcssold.label_status,
    byte_epcssold.label_price,
    byte_epcssold.time_created,
    byte_epcssold.time_added,
    byte_epcssold.time_updated,
    byte_epcssold.ts_created,
    byte_epcssold.ts_added,
    byte_epcssold.ts_updated,
    byte_epcssold.label_kiosk_id,
    byte_epcssold.product_id,
    byte_epcssold.product_title,
    byte_epcssold.product_archived,
    byte_epcssold.product_vendor,
    byte_epcssold.product_price,
    byte_epcssold.product_cost,
    byte_epcssold.product_shelf_life_days,
    byte_epcssold.product_attributes,
    byte_epcssold.product_categories,
    byte_epcssold.consumer_category,
    byte_epcssold.product_source
   FROM public.byte_epcssold;


ALTER TABLE public.byte_epcssold_fast OWNER TO dbservice;

--
-- Name: byte_feedback; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_feedback AS
 SELECT f.id,
    f.rate,
    f.order_id,
    f.message,
    f.taste,
    f.freshness,
    f.variety,
    f.value,
    f.ticket_created,
    date_trunc('month'::text, t.ts) AS month,
    date_trunc('week'::text, t.ts) AS week,
    date_trunc('day'::text, t.ts) AS date,
    date_trunc('hour'::text, t.ts) AS hour
   FROM (pantry.feedback f
     JOIN public.byte_tickets t ON (((f.order_id)::text = (t.order_id)::text)));


ALTER TABLE public.byte_feedback OWNER TO dbservice;

--
-- Name: byte_feedback_monthly; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_feedback_monthly AS
 SELECT t1.month,
    t1.avg_rating,
    t1.avg_value,
    t1.avg_taste,
    t1.avg_freshness,
    t1.avg_variety,
    ((1.0 * (t1.feedbacks)::numeric) / (t2.tix)::numeric) AS frac_feedbacks
   FROM (( SELECT byte_feedback.month,
            avg((1.0 * (byte_feedback.rate)::numeric)) AS avg_rating,
            avg(public.if((byte_feedback.value > 0), (1.0 * (byte_feedback.value)::numeric), NULL::numeric)) AS avg_value,
            avg(public.if((byte_feedback.taste > 0), (1.0 * (byte_feedback.taste)::numeric), NULL::numeric)) AS avg_taste,
            avg(public.if((byte_feedback.freshness > 0), (1.0 * (byte_feedback.freshness)::numeric), NULL::numeric)) AS avg_freshness,
            avg(public.if((byte_feedback.variety > 0), (1.0 * (byte_feedback.variety)::numeric), NULL::numeric)) AS avg_variety,
            count(*) AS feedbacks
           FROM public.byte_feedback
          WHERE (byte_feedback.month >= '2016-01-01 08:00:00+00'::timestamp with time zone)
          GROUP BY byte_feedback.month
          ORDER BY byte_feedback.month) t1
     JOIN ( SELECT byte_tickets.month,
            count(*) AS tix
           FROM public.byte_tickets
          GROUP BY byte_tickets.month) t2 ON ((t1.month = t2.month)));


ALTER TABLE public.byte_feedback_monthly OWNER TO dbservice;

--
-- Name: byte_feedback_weekly; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_feedback_weekly AS
 SELECT t1.week,
    t1.avg_rating,
    t1.avg_value,
    t1.avg_taste,
    t1.avg_freshness,
    t1.avg_variety,
    ((1.0 * (t1.feedbacks)::numeric) / (t2.tix)::numeric) AS frac_feedbacks
   FROM (( SELECT byte_feedback.week,
            avg((1.0 * (byte_feedback.rate)::numeric)) AS avg_rating,
            avg(public.if((byte_feedback.value > 0), (1.0 * (byte_feedback.value)::numeric), NULL::numeric)) AS avg_value,
            avg(public.if((byte_feedback.taste > 0), (1.0 * (byte_feedback.taste)::numeric), NULL::numeric)) AS avg_taste,
            avg(public.if((byte_feedback.freshness > 0), (1.0 * (byte_feedback.freshness)::numeric), NULL::numeric)) AS avg_freshness,
            avg(public.if((byte_feedback.variety > 0), (1.0 * (byte_feedback.variety)::numeric), NULL::numeric)) AS avg_variety,
            count(*) AS feedbacks
           FROM public.byte_feedback
          WHERE (byte_feedback.week >= '2016-01-01 08:00:00+00'::timestamp with time zone)
          GROUP BY byte_feedback.week
          ORDER BY byte_feedback.week) t1
     JOIN ( SELECT byte_tickets.week,
            count(*) AS tix
           FROM public.byte_tickets
          GROUP BY byte_tickets.week) t2 ON ((t1.week = t2.week)));


ALTER TABLE public.byte_feedback_weekly OWNER TO dbservice;

--
-- Name: byte_kiosks; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_kiosks AS
 SELECT kiosk.id,
    kiosk.campus_id,
    kiosk.serial,
    kiosk.title,
    kiosk.address,
    kiosk.location_x,
    kiosk.location_y,
    kiosk.gcm_id,
    kiosk.app_vname,
    kiosk.app_vcode,
    kiosk.archived,
    kiosk.creation_time,
    kiosk.deployment_time,
    kiosk.last_update,
    kiosk.client_name,
    kiosk.last_status,
    kiosk.last_inventory,
    kiosk.kiosk_name,
    kiosk.payment_start,
    kiosk.payment_stop,
    kiosk.features,
    kiosk.sales_tax,
    kiosk.default_fee_plan,
    kiosk.timezone,
    kiosk.estd_num_users,
    kiosk.tags,
    kiosk.publicly_accessible,
    kiosk.cardkey_required,
    kiosk.delivery_insns,
    kiosk.fridge_loc_info,
    kiosk.contact_first_name,
    kiosk.contact_last_name,
    kiosk.contact_email,
    kiosk.contact_phone,
    kiosk.accounting_email,
    kiosk.byte_discount,
    kiosk.subsidy_info,
    kiosk.subsidy_notes,
    kiosk.max_subscription,
    kiosk.delivery_window_mon,
    kiosk.delivery_window_tue,
    kiosk.delivery_window_wed,
    kiosk.delivery_window_thu,
    kiosk.delivery_window_fri,
    kiosk.delivery_window_sat,
    kiosk.delivery_window_sun,
    kiosk.notes,
    kiosk.components,
    kiosk.email_receipt_subject,
    kiosk.ops_team_notes,
    kiosk.geo,
    kiosk.server_url,
    kiosk.subscription_amount,
    kiosk.enable_reporting,
    kiosk.enable_monitoring,
    kiosk.employees_num,
    kiosk.kiosk_restrictions,
    ( SELECT date(to_timestamp((min("order".created))::double precision)) AS date
           FROM pantry."order"
          WHERE (("order".kiosk_id = kiosk.id) AND (("order".order_id)::text ~~ 'RE%'::text))) AS first_restock,
    ( SELECT date_trunc('month'::text, (to_timestamp((min("order".created))::double precision) + '1 mon'::interval)) AS date_trunc
           FROM pantry."order"
          WHERE (("order".kiosk_id = kiosk.id) AND (("order".order_id)::text ~~ 'RE%'::text))) AS first_full_month
   FROM pantry.kiosk
  WHERE ((kiosk.campus_id = 87) AND (kiosk.enable_reporting = 1));


ALTER TABLE public.byte_kiosks OWNER TO dbservice;

--
-- Name: inventory_current_lots; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.inventory_current_lots AS
 SELECT t2.date,
    t2.product_id,
    t2.kiosk_id,
    t2.units,
    (t2.date + ('1 day'::interval day * ((p.shelf_time - 1))::double precision)) AS expir_date,
    p.shelf_time AS shelf_life_days
   FROM (( SELECT t1.date,
            t1.product_id,
            t1.kiosk_id,
            count(DISTINCT t1.epc) AS units
           FROM ( SELECT date_trunc('day'::text, to_timestamp((label.time_updated)::double precision)) AS date,
                    label.id,
                    label.product_id,
                    label.epc,
                    label.is_generic_sku,
                    label.kiosk_id,
                    label.order_id,
                    label.status,
                    label.price,
                    label.cost,
                    label.time_created,
                    label.time_added,
                    label.time_updated,
                    label.notes
                   FROM pantry.label
                  WHERE ((label.status)::text = 'ok'::text)) t1
          WHERE (t1.date > (now() - '2 days'::interval day))
          GROUP BY t1.date, t1.product_id, t1.kiosk_id) t2
     JOIN pantry.product p ON ((t2.product_id = p.id)))
  ORDER BY t2.product_id, t2.kiosk_id, (t2.date + ('1 day'::interval day * ((p.shelf_time - 1))::double precision));


ALTER TABLE public.inventory_current_lots OWNER TO dbservice;

--
-- Name: inventory_current; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.inventory_current AS
 SELECT inventory_current_lots.kiosk_id,
    inventory_current_lots.product_id,
    sum(inventory_current_lots.units) AS units
   FROM public.inventory_current_lots
  GROUP BY inventory_current_lots.kiosk_id, inventory_current_lots.product_id;


ALTER TABLE public.inventory_current OWNER TO dbservice;

--
-- Name: byte_inventory_current; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_inventory_current AS
 SELECT ic.kiosk_id,
    ic.product_id,
    ic.units
   FROM (public.inventory_current ic
     JOIN public.byte_kiosks bk ON ((ic.kiosk_id = bk.id)));


ALTER TABLE public.byte_inventory_current OWNER TO dbservice;

--
-- Name: byte_inventory_current_lots; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_inventory_current_lots AS
 SELECT ic.date,
    ic.product_id,
    ic.kiosk_id,
    ic.units,
    ic.expir_date,
    ic.shelf_life_days
   FROM (public.inventory_current_lots ic
     JOIN public.byte_kiosks bk ON ((ic.kiosk_id = bk.id)));


ALTER TABLE public.byte_inventory_current_lots OWNER TO dbservice;

--
-- Name: inventory_history; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.inventory_history AS
 SELECT date_trunc('month'::text, t.ts) AS month,
    date_trunc('week'::text, t.ts) AS week,
    date_trunc('day'::text, t.ts) AS date,
    date_trunc('hour'::text, t.ts) AS hour,
    date_part('dow'::text, t.ts) AS dayofweek,
    t.ts,
    t.product_id,
    t.kiosk_id,
    t.qty,
    t.product_title,
    t.kiosk_title
   FROM ( SELECT to_timestamp((ih."time")::double precision) AS ts,
            ih.product_id,
            ih.kiosk_id,
            ih.qty,
            p.title AS product_title,
            k.title AS kiosk_title
           FROM ((pantry.inventory_history ih
             JOIN pantry.product p ON ((ih.product_id = p.id)))
             JOIN pantry.kiosk k ON ((ih.kiosk_id = k.id)))) t;


ALTER TABLE public.inventory_history OWNER TO dbservice;

--
-- Name: byte_inventory_history; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_inventory_history AS
 SELECT ih.month,
    ih.week,
    ih.date,
    ih.hour,
    ih.dayofweek,
    ih.ts,
    ih.product_id,
    ih.kiosk_id,
    ih.qty,
    ih.product_title,
    ih.kiosk_title
   FROM (public.inventory_history ih
     JOIN public.byte_kiosks bk ON ((ih.kiosk_id = bk.id)));


ALTER TABLE public.byte_inventory_history OWNER TO dbservice;

--
-- Name: byte_inventory_history_eod; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_inventory_history_eod AS
 SELECT ih.month,
    ih.week,
    ih.date,
    ih.hour,
    ih.dayofweek,
    ih.ts,
    ih.product_id,
    ih.kiosk_id,
    ih.qty,
    ih.product_title,
    ih.kiosk_title
   FROM ((public.inventory_history ih
     JOIN public.byte_kiosks bk ON ((ih.kiosk_id = bk.id)))
     JOIN ( SELECT byte_inventory_history.date,
            byte_inventory_history.kiosk_id,
            byte_inventory_history.product_id,
            max(byte_inventory_history.ts) AS maxts
           FROM public.byte_inventory_history
          GROUP BY byte_inventory_history.date, byte_inventory_history.kiosk_id, byte_inventory_history.product_id) ih_eod ON (((ih_eod.kiosk_id = ih.kiosk_id) AND (ih_eod.product_id = ih.product_id) AND (ih_eod.date = ih.date))))
  WHERE (((bk.title)::text !~~* 'burn%'::text) AND ((bk.title)::text !~~* 'test%'::text));


ALTER TABLE public.byte_inventory_history_eod OWNER TO dbservice;

--
-- Name: byte_inventory_history_eod_2wks; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_inventory_history_eod_2wks AS
 SELECT ih.month,
    ih.week,
    ih.date,
    ih.hour,
    ih.dayofweek,
    ih.ts,
    ih.product_id,
    ih.kiosk_id,
    ih.qty,
    ih.product_title,
    ih.kiosk_title
   FROM ((public.inventory_history ih
     JOIN public.byte_kiosks bk ON ((ih.kiosk_id = bk.id)))
     JOIN ( SELECT byte_inventory_history.date,
            byte_inventory_history.kiosk_id,
            byte_inventory_history.product_id,
            max(byte_inventory_history.ts) AS maxts
           FROM public.byte_inventory_history
          WHERE (byte_inventory_history.ts > (now() - '14 days'::interval day))
          GROUP BY byte_inventory_history.date, byte_inventory_history.kiosk_id, byte_inventory_history.product_id) ih_eod ON (((ih_eod.kiosk_id = ih.kiosk_id) AND (ih_eod.product_id = ih.product_id) AND (ih_eod.maxts = ih.ts) AND (ih.ts > (now() - '14 days'::interval day)))))
  WHERE (((bk.title)::text !~~* 'burn%'::text) AND ((bk.title)::text !~~* 'test%'::text));


ALTER TABLE public.byte_inventory_history_eod_2wks OWNER TO dbservice;

--
-- Name: byte_kiosks_date_non_new; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_kiosks_date_non_new AS
 SELECT kiosks_date_non_new.kiosk_id,
    to_timestamp((kiosks_date_non_new.new_ts)::double precision) AS new_ts
   FROM pantry.kiosks_date_non_new;


ALTER TABLE public.byte_kiosks_date_non_new OWNER TO dbservice;

--
-- Name: byte_restockings; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_restockings AS
 SELECT byte_orders.order_id,
    byte_orders.first_name,
    byte_orders.last_name,
    byte_orders.kiosk_id,
    byte_orders.kiosk_title,
    byte_orders.email,
    byte_orders.amount_paid,
    byte_orders.payment_system,
    byte_orders.transaction_id,
    byte_orders.approval_code,
    byte_orders.status_code,
    byte_orders.status_message,
    byte_orders.status,
    byte_orders.batch_id,
    byte_orders.created,
    byte_orders.auth_amount,
    byte_orders.data_token,
    byte_orders.time_opened,
    byte_orders.time_closed,
    byte_orders.card_hash,
    byte_orders.state,
    byte_orders.archived,
    byte_orders.stamp,
    byte_orders.last_update,
    byte_orders.balance,
    byte_orders.delta,
    byte_orders.coupon_id,
    byte_orders.coupon,
    byte_orders.refund,
    byte_orders.receipt,
    byte_orders.campus_id,
    byte_orders.amount_list_price,
    byte_orders.notes,
    byte_orders.time_door_opened,
    byte_orders.time_door_closed,
    byte_orders.client_name,
    byte_orders.estd_num_users,
    byte_orders.ts,
    byte_orders.full_name,
    byte_orders.door_opened_secs,
    byte_orders.month,
    byte_orders.week,
    byte_orders.date,
    byte_orders.dayofweek,
    byte_orders.hour,
    byte_orders.dowhour
   FROM public.byte_orders
  WHERE ((byte_orders.payment_system)::text = 'Restocking'::text);


ALTER TABLE public.byte_restockings OWNER TO dbservice;

--
-- Name: byte_kiosks_by_week; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_kiosks_by_week AS
 SELECT s.week,
    (count(DISTINCT public.if((s.ts >= k.new_ts), k.kiosk_id, 0)) - 1) AS num_old_kiosks,
    (count(DISTINCT public.if((s.ts < k.new_ts), k.kiosk_id, 0)) - 1) AS num_new_kiosks,
    count(DISTINCT k.kiosk_id) AS num_all_kiosks
   FROM (public.byte_restockings s
     JOIN public.byte_kiosks_date_non_new k ON ((s.kiosk_id = k.kiosk_id)))
  GROUP BY s.week
  ORDER BY s.week;


ALTER TABLE public.byte_kiosks_by_week OWNER TO dbservice;

--
-- Name: byte_kiosks_with_perm_subsidy; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_kiosks_with_perm_subsidy AS
 SELECT k.id,
    k.campus_id,
    k.serial,
    k.title,
    k.address,
    k.location_x,
    k.location_y,
    k.gcm_id,
    k.app_vname,
    k.app_vcode,
    k.archived,
    k.creation_time,
    k.deployment_time,
    k.last_update,
    k.client_name,
    k.last_status,
    k.last_inventory,
    k.kiosk_name,
    k.payment_start,
    k.payment_stop,
    k.features,
    k.sales_tax,
    k.default_fee_plan,
    k.timezone,
    k.estd_num_users,
    k.tags,
    k.publicly_accessible,
    k.cardkey_required,
    k.delivery_insns,
    k.fridge_loc_info,
    k.contact_first_name,
    k.contact_last_name,
    k.contact_email,
    k.contact_phone,
    k.accounting_email,
    k.byte_discount,
    k.subsidy_info,
    k.subsidy_notes,
    k.max_subscription,
    k.delivery_window_mon,
    k.delivery_window_tue,
    k.delivery_window_wed,
    k.delivery_window_thu,
    k.delivery_window_fri,
    k.delivery_window_sat,
    k.delivery_window_sun,
    k.notes,
    k.components,
    k.email_receipt_subject,
    k.ops_team_notes,
    k.geo,
    k.server_url,
    k.subscription_amount,
    k.enable_reporting,
    k.enable_monitoring,
    k.employees_num,
    k.kiosk_restrictions,
    k.first_restock,
    k.first_full_month
   FROM public.byte_kiosks k
  WHERE ((k.id IN ( SELECT discount.kiosk_id
           FROM pantry.discount)) OR ((k.id)::text IN ( SELECT regexp_split_to_table(string_agg((cron.kiosks)::text, ','::text), ','::text) AS regexp_split_to_table
           FROM pantry.cron
          WHERE ((cron.archived = 0) AND ((cron.command)::text = 'happy'::text) AND (cron.payload !~~ '%onetime":true%'::text) AND (cron.group_id = 80)))));


ALTER TABLE public.byte_kiosks_with_perm_subsidy OWNER TO dbservice;

--
-- Name: byte_kp_grid; Type: TABLE; Schema: public; Owner: dbservice
--

CREATE TABLE public.byte_kp_grid (
    hour_start timestamp(6) with time zone,
    hour_end timestamp(6) with time zone,
    dowhour double precision,
    kiosk_id bigint,
    product_id bigint
);


ALTER TABLE public.byte_kp_grid OWNER TO dbservice;

--
-- Name: byte_kp_grid2; Type: TABLE; Schema: public; Owner: dbservice
--

CREATE TABLE public.byte_kp_grid2 (
    hour_start timestamp(6) with time zone,
    hour_end timestamp(6) with time zone,
    dowhour double precision,
    kiosk_id integer,
    product_id integer
);


ALTER TABLE public.byte_kp_grid2 OWNER TO dbservice;

--
-- Name: byte_kp_oos; Type: TABLE; Schema: public; Owner: dbservice
--

CREATE TABLE public.byte_kp_oos (
    hour_start timestamp(6) with time zone,
    hour_end timestamp(6) with time zone,
    kiosk_id integer,
    product_id integer,
    ts timestamp(6) with time zone,
    restock_ts timestamp(6) with time zone,
    oos_min double precision
);


ALTER TABLE public.byte_kp_oos OWNER TO dbservice;

--
-- Name: byte_kp_oos_avgdowhour; Type: TABLE; Schema: public; Owner: dbservice
--

CREATE TABLE public.byte_kp_oos_avgdowhour (
    kiosk_id integer,
    product_id integer,
    dowhour double precision,
    avgminutes double precision
);


ALTER TABLE public.byte_kp_oos_avgdowhour OWNER TO dbservice;

--
-- Name: byte_kp_oos_grid; Type: TABLE; Schema: public; Owner: dbservice
--

CREATE TABLE public.byte_kp_oos_grid (
    sales_hour timestamp(6) with time zone,
    dowhour double precision,
    kiosk_id integer,
    product_id integer,
    oosminutes double precision
);


ALTER TABLE public.byte_kp_oos_grid OWNER TO dbservice;

--
-- Name: byte_kp_sales; Type: TABLE; Schema: public; Owner: dbservice
--

CREATE TABLE public.byte_kp_sales (
    kiosk_id bigint,
    product_id bigint,
    sales_hour timestamp(6) without time zone,
    cnt bigint
);


ALTER TABLE public.byte_kp_sales OWNER TO dbservice;

--
-- Name: byte_kp_sales_avgdowhour; Type: TABLE; Schema: public; Owner: dbservice
--

CREATE TABLE public.byte_kp_sales_avgdowhour (
    kiosk_id bigint,
    product_id bigint,
    dowhour double precision,
    avgsales numeric(28,6)
);


ALTER TABLE public.byte_kp_sales_avgdowhour OWNER TO dbservice;

--
-- Name: byte_kp_sales_first; Type: TABLE; Schema: public; Owner: dbservice
--

CREATE TABLE public.byte_kp_sales_first (
    kiosk_id bigint,
    product_id bigint,
    first_sale_hour timestamp(6) without time zone
);


ALTER TABLE public.byte_kp_sales_first OWNER TO dbservice;

--
-- Name: byte_kp_sales_grid; Type: TABLE; Schema: public; Owner: dbservice
--

CREATE TABLE public.byte_kp_sales_grid (
    sales_hour timestamp(6) with time zone,
    dowhour double precision,
    kiosk_id bigint,
    product_id bigint,
    cnt bigint
);


ALTER TABLE public.byte_kp_sales_grid OWNER TO dbservice;

--
-- Name: byte_label_product_fast; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_label_product_fast WITH (security_barrier='false') AS
 SELECT l.epc,
    l.order_id AS label_order_id,
    l.status AS label_status,
    l.price AS label_price,
    l.time_created,
    l.time_added,
    l.time_updated,
    to_timestamp((l.time_created)::double precision) AS ts_created,
    to_timestamp((l.time_added)::double precision) AS ts_added,
    to_timestamp((l.time_updated)::double precision) AS ts_updated,
    l.kiosk_id AS label_kiosk_id,
    p.id AS product_id,
    p.title AS product_title,
    p.archived AS product_archived,
    p.vendor AS product_vendor,
    p.price AS product_price,
    p.cost AS product_cost,
    p.shelf_life_days AS product_shelf_life_days,
    p.categories AS product_categories,
    p.consumer_category,
    p.source AS product_source,
    p.fc_title
   FROM (pantry.label l
     JOIN public.byte_products_fast p ON ((l.product_id = p.id)));


ALTER TABLE public.byte_label_product_fast OWNER TO dbservice;

--
-- Name: byte_product_stats_by_kiosk; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_product_stats_by_kiosk AS
 SELECT p.kiosk_id,
    p.product_id,
    p.is_new,
    p.is_popular
   FROM (pantry.product_stats_by_kiosk p
     JOIN public.byte_kiosks k ON ((p.kiosk_id = k.id)));


ALTER TABLE public.byte_product_stats_by_kiosk OWNER TO dbservice;

--
-- Name: byte_raw_orders; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_raw_orders AS
 SELECT all_raw_orders.order_id,
    all_raw_orders.first_name,
    all_raw_orders.last_name,
    all_raw_orders.kiosk_id,
    all_raw_orders.kiosk_title,
    all_raw_orders.email,
    all_raw_orders.amount_paid,
    all_raw_orders.payment_system,
    all_raw_orders.transaction_id,
    all_raw_orders.approval_code,
    all_raw_orders.status_code,
    all_raw_orders.status_message,
    all_raw_orders.status,
    all_raw_orders.batch_id,
    all_raw_orders.created,
    all_raw_orders.auth_amount,
    all_raw_orders.data_token,
    all_raw_orders.time_opened,
    all_raw_orders.time_closed,
    all_raw_orders.card_hash,
    all_raw_orders.state,
    all_raw_orders.archived,
    all_raw_orders.stamp,
    all_raw_orders.last_update,
    all_raw_orders.balance,
    all_raw_orders.delta,
    all_raw_orders.coupon_id,
    all_raw_orders.coupon,
    all_raw_orders.refund,
    all_raw_orders.receipt,
    all_raw_orders.campus_id,
    all_raw_orders.amount_list_price,
    all_raw_orders.notes,
    all_raw_orders.time_door_opened,
    all_raw_orders.time_door_closed,
    all_raw_orders.client_name,
    all_raw_orders.estd_num_users,
    all_raw_orders.ts,
    all_raw_orders.full_name,
    all_raw_orders.door_opened_secs
   FROM public.all_raw_orders
  WHERE (all_raw_orders.campus_id = 87);


ALTER TABLE public.byte_raw_orders OWNER TO dbservice;

--
-- Name: byte_restockings_labels; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_restockings_labels AS
 SELECT history_epc_order.order_id,
    history_epc_order.product_id,
    to_timestamp((min(history_epc_order."time"))::double precision) AS to_timestamp,
    min(k.id) AS kiosk_id,
    min((k.title)::text) AS title,
    count(*) AS count
   FROM (pantry.history_epc_order
     JOIN public.byte_kiosks k ON ((history_epc_order.kiosk_id = k.id)))
  WHERE ((history_epc_order.order_id)::text ~~ 'RE%'::text)
  GROUP BY history_epc_order.order_id, history_epc_order.product_id;


ALTER TABLE public.byte_restockings_labels OWNER TO dbservice;

--
-- Name: byte_sales_by_week; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_sales_by_week AS
 SELECT s.week,
    sum(public.if((s.ts >= k.new_ts), 1, 0)) AS sales_units_in_old_kiosks,
    sum(public.if((s.ts < k.new_ts), 1, 0)) AS sales_units_in_new_kiosks,
    count(*) AS sales_units_in_all_kiosks,
    sum(public.if((s.ts >= k.new_ts), s.product_price, 0.0)) AS sales_listprc_in_old_kiosks,
    sum(public.if((s.ts < k.new_ts), s.product_price, 0.0)) AS sales_listprc_in_new_kiosks,
    sum(s.product_price) AS sales_listprc_in_all_kiosks,
    sum(public.if((s.ts >= k.new_ts), s.label_price, 0.0)) AS sales_actualprc_in_old_kiosks,
    sum(public.if((s.ts < k.new_ts), s.label_price, 0.0)) AS sales_actualprc_in_new_kiosks,
    sum(s.label_price) AS sales_actualprc_in_all_kiosks,
    sum(public.if((s.ts >= k.new_ts), s.product_cost, 0.0)) AS cost_list_in_old_kiosks,
    sum(public.if((s.ts < k.new_ts), s.product_cost, 0.0)) AS cost_list_in_new_kiosks,
    sum(s.product_cost) AS cost_list_in_all_kiosks
   FROM (public.byte_epcssold s
     JOIN public.byte_kiosks_date_non_new k ON ((s.kiosk_id = k.kiosk_id)))
  GROUP BY s.week
  ORDER BY s.week DESC;


ALTER TABLE public.byte_sales_by_week OWNER TO dbservice;

--
-- Name: byte_spoilage; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_spoilage AS
 SELECT t.kiosk_id,
    t.order_id,
    t.epc,
    t.product_id,
    t.ts_added,
    t.ts_removed,
    t.id,
    t.title,
    t.description,
    t.tiny_description,
    t.short_description,
    t.medium_description,
    t.long_description,
    t.price,
    t.cost,
    t.shelf_time,
    t.campus_id,
    t.image,
    t.image_time,
    t.last_update,
    t.archived,
    t.taxable,
    t.allergens,
    t.attribute_names,
    t.categories,
    t.category_names,
    t.vendor,
    t.source,
    t.notes,
    t.total_cal,
    t.num_servings,
    t.ingredients,
    t.calories,
    t.proteins,
    t.sugar,
    t.carbohydrates,
    t.fat,
    t.consumer_category,
    t.ws_case_size,
    t.kiosk_ship_qty,
    t.ws_case_cost,
    t.pick_station,
    t.fc_title,
    t.pricing_tier,
    t.width_space,
    t.height_space,
    t.depth_space,
    t.slotted_width,
    t.tag_volume,
    t.delivery_option,
    t.kiosk_title,
    t.address,
    t.location_x,
    t.location_y,
    t.client_name,
    t.tags,
    t.estd_num_users,
    date_trunc('month'::text, t.ts_removed) AS month,
    date_trunc('week'::text, t.ts_removed) AS week,
    date_trunc('day'::text, t.ts_removed) AS date
   FROM ( SELECT s.kiosk_id,
            s.order_id,
            s.epc,
            s.product_id,
            to_timestamp((s.time_added)::double precision) AS ts_added,
            to_timestamp((s.time_removed)::double precision) AS ts_removed,
            p.id,
            p.title,
            p.description,
            p.tiny_description,
            p.short_description,
            p.medium_description,
            p.long_description,
            p.price,
            p.cost,
            p.shelf_time,
            p.campus_id,
            p.image,
            p.image_time,
            p.last_update,
            p.archived,
            p.taxable,
            p.allergens,
            p.attribute_names,
            p.categories,
            p.category_names,
            p.vendor,
            p.source,
            p.notes,
            p.total_cal,
            p.num_servings,
            p.ingredients,
            p.calories,
            p.proteins,
            p.sugar,
            p.carbohydrates,
            p.fat,
            p.consumer_category,
            p.ws_case_size,
            p.kiosk_ship_qty,
            p.ws_case_cost,
            p.pick_station,
            p.fc_title,
            p.pricing_tier,
            p.width_space,
            p.height_space,
            p.depth_space,
            p.slotted_width,
            p.tag_volume,
            p.delivery_option,
            k.title AS kiosk_title,
            k.address,
            k.location_x,
            k.location_y,
            k.client_name,
            k.tags,
            k.estd_num_users
           FROM ((pantry.spoilage s
             JOIN pantry.product p ON ((s.product_id = p.id)))
             JOIN pantry.kiosk k ON ((s.kiosk_id = k.id)))
          WHERE ((k.campus_id = 87) AND (s.order_id IS NOT NULL) AND (k.enable_reporting = 1))) t;


ALTER TABLE public.byte_spoilage OWNER TO dbservice;

--
-- Name: byte_spoilage_by_category_week_all; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_spoilage_by_category_week_all AS
 SELECT s.week,
    ((regexp_replace((s.consumer_category)::text, '[^a-zA-Z]+'::text, '_'::text, 'g'::text) || '_'::text) || 'cost_all'::text) AS cat_and_new,
    sum(s.cost) AS spoilage_cost
   FROM (public.byte_spoilage s
     JOIN public.byte_kiosks_date_non_new k ON ((s.kiosk_id = k.kiosk_id)))
  WHERE ((s.date >= '2016-01-01 08:00:00+00'::timestamp with time zone) AND (s.consumer_category IS NOT NULL))
  GROUP BY s.week, ((regexp_replace((s.consumer_category)::text, '[^a-zA-Z]+'::text, '_'::text, 'g'::text) || '_'::text) || 'cost_all'::text)
  ORDER BY s.week DESC, ((regexp_replace((s.consumer_category)::text, '[^a-zA-Z]+'::text, '_'::text, 'g'::text) || '_'::text) || 'cost_all'::text);


ALTER TABLE public.byte_spoilage_by_category_week_all OWNER TO dbservice;

--
-- Name: byte_spoilage_by_category_week_newold; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_spoilage_by_category_week_newold AS
 SELECT s.week,
    ((regexp_replace((s.consumer_category)::text, '[^a-zA-Z]+'::text, '_'::text, 'g'::text) || '_'::text) ||
        CASE
            WHEN (s.date >= k.new_ts) THEN 'cost_old'::text
            ELSE 'cost_new'::text
        END) AS cat_and_new,
    sum(s.cost) AS spoilage_cost
   FROM (public.byte_spoilage s
     JOIN public.byte_kiosks_date_non_new k ON ((s.kiosk_id = k.kiosk_id)))
  WHERE ((s.date >= '2016-01-01 08:00:00+00'::timestamp with time zone) AND (s.consumer_category IS NOT NULL))
  GROUP BY s.week, ((regexp_replace((s.consumer_category)::text, '[^a-zA-Z]+'::text, '_'::text, 'g'::text) || '_'::text) ||
        CASE
            WHEN (s.date >= k.new_ts) THEN 'cost_old'::text
            ELSE 'cost_new'::text
        END)
  ORDER BY s.week DESC, ((regexp_replace((s.consumer_category)::text, '[^a-zA-Z]+'::text, '_'::text, 'g'::text) || '_'::text) ||
        CASE
            WHEN (s.date >= k.new_ts) THEN 'cost_old'::text
            ELSE 'cost_new'::text
        END);


ALTER TABLE public.byte_spoilage_by_category_week_newold OWNER TO dbservice;

--
-- Name: byte_spoilage_by_category_week; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_spoilage_by_category_week AS
 SELECT t1.week,
    (regexp_replace(regexp_replace(t1.cat_and_new, '_cost1_'::text, '_per_'::text), '_all'::text, ''::text) || '_kiosk'::text) AS cat_and_new,
    (t1.spoilage_cost / (
        CASE
            WHEN (t1.cat_and_new ~~ '%new%'::text) THEN t2.num_new_kiosks
            WHEN (t1.cat_and_new ~~ '%old%'::text) THEN t2.num_old_kiosks
            ELSE t2.num_all_kiosks
        END)::numeric) AS spoilage_cost
   FROM (( SELECT byte_spoilage_by_category_week_newold.week,
            byte_spoilage_by_category_week_newold.cat_and_new,
            byte_spoilage_by_category_week_newold.spoilage_cost
           FROM public.byte_spoilage_by_category_week_newold
        UNION
         SELECT byte_spoilage_by_category_week_all.week,
            byte_spoilage_by_category_week_all.cat_and_new,
            byte_spoilage_by_category_week_all.spoilage_cost
           FROM public.byte_spoilage_by_category_week_all) t1
     LEFT JOIN public.byte_kiosks_by_week t2 ON ((t1.week = t2.week)));


ALTER TABLE public.byte_spoilage_by_category_week OWNER TO dbservice;

--
-- Name: byte_spoilage_by_category_week_crosstab; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_spoilage_by_category_week_crosstab AS
 SELECT ct.week,
    ct.breakfast_cost_per_old_kiosk,
    ct.breakfast_cost_per_new_kiosk,
    ct.breakfast_cost_per_kiosk,
    ct.burritos_cost_per_old_kiosk,
    ct.burritos_cost_per_new_kiosk,
    ct.burritos_cost_per_kiosk,
    ct.desserts_cost_per_old_kiosk,
    ct.desserts_cost_per_new_kiosk,
    ct.desserts_cost_per_kiosk,
    ct.drinks_cost_per_old_kiosk,
    ct.drinks_cost_per_new_kiosk,
    ct.drinks_cost_per_kiosk,
    ct.entrees_cost_per_old_kiosk,
    ct.entrees_cost_per_new_kiosk,
    ct.entrees_cost_per_kiosk,
    ct.sandwiches_wraps_cost_per_old_kiosk,
    ct.sandwiches_wraps_cost_per_new_kiosk,
    ct.sandwiches_wraps_cost_per_kiosk,
    ct.snacks_cost_per_old_kiosk,
    ct.snacks_cost_per_new_kiosk,
    ct.snacks_cost_per_kiosk,
    ct.soups_salads_cost_per_old_kiosk,
    ct.soups_salads_cost_per_new_kiosk,
    ct.soups_salads_cost_per_kiosk
   FROM public.crosstab('select to_char(week,''YYYY-MM-DD'') as week,cat_and_new,spoilage_cost from byte_spoilage_by_category_week order by week desc,cat_and_new desc'::text) ct(week text, breakfast_cost_per_old_kiosk numeric, breakfast_cost_per_new_kiosk numeric, breakfast_cost_per_kiosk numeric, burritos_cost_per_old_kiosk numeric, burritos_cost_per_new_kiosk numeric, burritos_cost_per_kiosk numeric, desserts_cost_per_old_kiosk numeric, desserts_cost_per_new_kiosk numeric, desserts_cost_per_kiosk numeric, drinks_cost_per_old_kiosk numeric, drinks_cost_per_new_kiosk numeric, drinks_cost_per_kiosk numeric, entrees_cost_per_old_kiosk numeric, entrees_cost_per_new_kiosk numeric, entrees_cost_per_kiosk numeric, sandwiches_wraps_cost_per_old_kiosk numeric, sandwiches_wraps_cost_per_new_kiosk numeric, sandwiches_wraps_cost_per_kiosk numeric, snacks_cost_per_old_kiosk numeric, snacks_cost_per_new_kiosk numeric, snacks_cost_per_kiosk numeric, soups_salads_cost_per_old_kiosk numeric, soups_salads_cost_per_new_kiosk numeric, soups_salads_cost_per_kiosk numeric);


ALTER TABLE public.byte_spoilage_by_category_week_crosstab OWNER TO dbservice;

--
-- Name: byte_spoilage_by_sku_2months; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_spoilage_by_sku_2months AS
 SELECT to_char(t2.first_sale, 'MM-DD'::text) AS first_sale,
    p.shelf_life_days AS shelf_days,
    t.spoiled,
    t2.sold,
    to_char(((1.0 * (t.spoiled)::numeric) / ((t2.sold + t.spoiled))::numeric), '0.000'::text) AS frac_spoiled,
    ((t2.sold)::numeric * p.price) AS revenue,
    ((t.spoiled)::numeric * p.cost) AS spoil_cost,
    to_char((((t.spoiled)::numeric * p.cost) / (((t2.sold)::numeric * p.price) + 0.001)), '0.000'::text) AS spoil_dolr_frac,
    t.product_id,
    p.categories,
    p.title
   FROM ((( SELECT byte_spoilage.product_id,
            count(*) AS spoiled
           FROM public.byte_spoilage
          WHERE (byte_spoilage.ts_removed > (now() - '2 mons'::interval month))
          GROUP BY byte_spoilage.product_id) t
     JOIN ( SELECT byte_epcssold_2months.product_id,
            min(byte_epcssold_2months.ts) AS first_sale,
            count(*) AS sold
           FROM public.byte_epcssold_2months
          GROUP BY byte_epcssold_2months.product_id) t2 ON ((t.product_id = t2.product_id)))
     JOIN public.byte_products p ON ((t2.product_id = p.id)))
  ORDER BY (to_char(((1.0 * (t.spoiled)::numeric) / ((t2.sold + t.spoiled))::numeric), '0.000'::text)) DESC;


ALTER TABLE public.byte_spoilage_by_sku_2months OWNER TO dbservice;

--
-- Name: byte_spoilage_by_week; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_spoilage_by_week AS
 SELECT s.week,
    sum(public.if((s.ts_removed > k.new_ts), 1, 0)) AS spoilage_units_in_old_kiosks,
    sum(public.if((s.ts_removed <= k.new_ts), 1, 0)) AS spoilage_units_in_new_kiosks,
    count(*) AS spoilage_units_in_all_kiosks,
    sum(public.if((s.ts_removed > k.new_ts), s.cost, 0.0)) AS spoilage_dolr_in_old_kiosks,
    sum(public.if((s.ts_removed <= k.new_ts), s.cost, 0.0)) AS spoilage_dolr_in_new_kiosks,
    sum(s.cost) AS spoilage_dolr_in_all_kiosks
   FROM (public.byte_spoilage s
     JOIN public.byte_kiosks_date_non_new k ON ((s.kiosk_id = k.kiosk_id)))
  WHERE (s.ts_removed >= '2016-01-01 08:00:00+00'::timestamp with time zone)
  GROUP BY s.week
  ORDER BY s.week DESC;


ALTER TABLE public.byte_spoilage_by_week OWNER TO dbservice;

--
-- Name: byte_stockouts; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_stockouts AS
 SELECT t.kiosk_id,
    t.order_id,
    t.product_id,
    t.ts,
    t.restock_ts,
    t.restock_order_id,
    t.id,
    t.title,
    t.description,
    t.tiny_description,
    t.short_description,
    t.medium_description,
    t.long_description,
    t.price,
    t.cost,
    t.shelf_time,
    t.campus_id,
    t.image,
    t.image_time,
    t.last_update,
    t.archived,
    t.taxable,
    t.allergens,
    t.attribute_names,
    t.categories,
    t.category_names,
    t.vendor,
    t.source,
    t.notes,
    t.total_cal,
    t.num_servings,
    t.ingredients,
    t.calories,
    t.proteins,
    t.sugar,
    t.carbohydrates,
    t.fat,
    t.consumer_category,
    t.ws_case_size,
    t.kiosk_ship_qty,
    t.ws_case_cost,
    t.pick_station,
    t.fc_title,
    t.pricing_tier,
    t.width_space,
    t.height_space,
    t.depth_space,
    t.slotted_width,
    t.tag_volume,
    t.delivery_option,
    t.kiosk_title,
    t.address,
    t.location_x,
    t.location_y,
    t.client_name,
    t.tags,
    t.estd_num_users,
    date_trunc('month'::text, t.ts) AS month,
    date_trunc('week'::text, t.ts) AS week,
    date_trunc('day'::text, t.ts) AS date
   FROM ( SELECT s.kiosk_id,
            s.order_id,
            s.product_id,
            to_timestamp((s."timestamp")::double precision) AS ts,
            to_timestamp((s.restock_timestamp)::double precision) AS restock_ts,
            s.restock_order_id,
            p.id,
            p.title,
            p.description,
            p.tiny_description,
            p.short_description,
            p.medium_description,
            p.long_description,
            p.price,
            p.cost,
            p.shelf_time,
            p.campus_id,
            p.image,
            p.image_time,
            p.last_update,
            p.archived,
            p.taxable,
            p.allergens,
            p.attribute_names,
            p.categories,
            p.category_names,
            p.vendor,
            p.source,
            p.notes,
            p.total_cal,
            p.num_servings,
            p.ingredients,
            p.calories,
            p.proteins,
            p.sugar,
            p.carbohydrates,
            p.fat,
            p.consumer_category,
            p.ws_case_size,
            p.kiosk_ship_qty,
            p.ws_case_cost,
            p.pick_station,
            p.fc_title,
            p.pricing_tier,
            p.width_space,
            p.height_space,
            p.depth_space,
            p.slotted_width,
            p.tag_volume,
            p.delivery_option,
            k.title AS kiosk_title,
            k.address,
            k.location_x,
            k.location_y,
            k.client_name,
            k.tags,
            k.estd_num_users
           FROM ((pantry.stockout s
             JOIN pantry.product p ON ((s.product_id = p.id)))
             JOIN public.byte_kiosks k ON ((s.kiosk_id = k.id)))
          WHERE (s.order_id IS NOT NULL)) t;


ALTER TABLE public.byte_stockouts OWNER TO dbservice;

--
-- Name: byte_stockouts_by_week; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_stockouts_by_week AS
 SELECT s.week,
    sum(public.if((s.ts >= k.new_ts), 1, 0)) AS stockout_units_in_old_kiosks,
    sum(public.if((s.ts < k.new_ts), 1, 0)) AS stockout_units_in_new_kiosks,
    count(*) AS stockout_units_in_all_kiosks,
    (sum(public.if((s.ts >= k.new_ts), (date_part('minute'::text, (s.restock_ts - s.ts)))::numeric, 0.0)) / 60.0) AS stockout_hrs_in_old_kiosks,
    (sum(public.if((s.ts < k.new_ts), (date_part('minute'::text, (s.restock_ts - s.ts)))::numeric, 0.0)) / 60.0) AS stockout_hrs_in_new_kiosks,
    sum((date_part('minute'::text, (s.restock_ts - s.ts)) / (60.0)::double precision)) AS stockout_hrs_in_all_kiosks
   FROM (public.byte_stockouts s
     JOIN public.byte_kiosks_date_non_new k ON ((s.kiosk_id = k.kiosk_id)))
  WHERE (s.ts >= '2016-01-01 08:00:00+00'::timestamp with time zone)
  GROUP BY s.week
  ORDER BY s.week DESC;


ALTER TABLE public.byte_stockouts_by_week OWNER TO dbservice;

--
-- Name: byte_spoilage_stockouts_by_week; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_spoilage_stockouts_by_week AS
 SELECT t1.week,
    ((t3.stockout_units_in_old_kiosks)::double precision / (t4.num_old_kiosks)::double precision) AS avg_stockout_units_per_old_kiosk,
    public.if((t4.num_new_kiosks > 0), ((t3.stockout_units_in_new_kiosks)::double precision / (t4.num_new_kiosks)::double precision), (0.0)::double precision) AS avg_stockout_units_per_new_kiosk,
    ((t3.stockout_units_in_all_kiosks)::double precision / (t4.num_all_kiosks)::double precision) AS avg_stockout_units_per_all_kiosk,
    (t3.stockout_hrs_in_old_kiosks / (t4.num_old_kiosks)::numeric) AS avg_stockout_hrs_per_old_kiosk,
    public.if((t4.num_new_kiosks > 0), ((t3.stockout_hrs_in_new_kiosks)::double precision / (t4.num_new_kiosks)::double precision), (0.0)::double precision) AS avg_stockout_hrs_per_new_kiosk,
    (t3.stockout_hrs_in_all_kiosks / (t4.num_all_kiosks)::double precision) AS avg_stockout_hrs_per_all_kiosk,
    (t2.spoilage_dolr_in_old_kiosks / t1.sales_listprc_in_old_kiosks) AS spoilage_frac_in_old_kiosks,
    public.if((t1.sales_listprc_in_new_kiosks > 0.0), ((t2.spoilage_dolr_in_new_kiosks)::double precision / (t1.sales_listprc_in_new_kiosks)::double precision), (0.0)::double precision) AS spoilage_frac_in_new_kiosks,
    (t2.spoilage_dolr_in_all_kiosks / t1.sales_listprc_in_all_kiosks) AS spoilage_frac_in_all_kiosks,
    t4.num_old_kiosks,
    t4.num_new_kiosks,
    t4.num_all_kiosks,
    t1.sales_units_in_old_kiosks,
    t1.sales_units_in_new_kiosks,
    t1.sales_units_in_all_kiosks,
    t1.sales_listprc_in_old_kiosks,
    t1.sales_listprc_in_new_kiosks,
    t1.sales_listprc_in_all_kiosks,
    t1.sales_actualprc_in_old_kiosks,
    t1.sales_actualprc_in_new_kiosks,
    t1.sales_actualprc_in_all_kiosks,
    t1.cost_list_in_old_kiosks,
    t1.cost_list_in_new_kiosks,
    t1.cost_list_in_all_kiosks,
    t3.stockout_units_in_old_kiosks,
    t3.stockout_units_in_new_kiosks,
    t3.stockout_units_in_all_kiosks,
    t3.stockout_hrs_in_old_kiosks,
    t3.stockout_hrs_in_new_kiosks,
    t3.stockout_hrs_in_all_kiosks,
    t2.spoilage_units_in_old_kiosks,
    t2.spoilage_units_in_new_kiosks,
    t2.spoilage_units_in_all_kiosks,
    t2.spoilage_dolr_in_old_kiosks,
    t2.spoilage_dolr_in_new_kiosks,
    t2.spoilage_dolr_in_all_kiosks
   FROM (((public.byte_sales_by_week t1
     JOIN public.byte_spoilage_by_week t2 ON ((t1.week = t2.week)))
     JOIN public.byte_stockouts_by_week t3 ON ((t1.week = t3.week)))
     JOIN public.byte_kiosks_by_week t4 ON ((t1.week = t4.week)))
  ORDER BY t1.week DESC;


ALTER TABLE public.byte_spoilage_stockouts_by_week OWNER TO dbservice;

--
-- Name: byte_stockouts_by_category_week_all; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_stockouts_by_category_week_all AS
 SELECT s.week,
    ((regexp_replace((s.consumer_category)::text, '[^a-zA-Z]+'::text, '_'::text, 'g'::text) || '_'::text) || 'hrs_all'::text) AS cat_and_new,
    sum((date_part('minute'::text, (s.restock_ts - s.ts)) / (60.0)::double precision)) AS stockout_hrs
   FROM (public.byte_stockouts s
     JOIN public.byte_kiosks_date_non_new k ON ((s.kiosk_id = k.kiosk_id)))
  WHERE ((s.ts >= '2016-01-01 08:00:00+00'::timestamp with time zone) AND (s.consumer_category IS NOT NULL))
  GROUP BY s.week, ((regexp_replace((s.consumer_category)::text, '[^a-zA-Z]+'::text, '_'::text, 'g'::text) || '_'::text) || 'hrs_all'::text)
  ORDER BY s.week DESC, ((regexp_replace((s.consumer_category)::text, '[^a-zA-Z]+'::text, '_'::text, 'g'::text) || '_'::text) || 'hrs_all'::text);


ALTER TABLE public.byte_stockouts_by_category_week_all OWNER TO dbservice;

--
-- Name: byte_stockouts_by_category_week_newold; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_stockouts_by_category_week_newold AS
 SELECT s.week,
    ((regexp_replace((s.consumer_category)::text, '[^a-zA-Z]+'::text, '_'::text, 'g'::text) || '_'::text) ||
        CASE
            WHEN (s.ts >= k.new_ts) THEN 'hrs_old'::text
            ELSE 'hrs_new'::text
        END) AS cat_and_new,
    sum((date_part('minute'::text, (s.restock_ts - s.ts)) / (60.0)::double precision)) AS stockout_hrs
   FROM (public.byte_stockouts s
     JOIN public.byte_kiosks_date_non_new k ON ((s.kiosk_id = k.kiosk_id)))
  WHERE ((s.ts >= '2016-01-01 08:00:00+00'::timestamp with time zone) AND (s.consumer_category IS NOT NULL))
  GROUP BY s.week, ((regexp_replace((s.consumer_category)::text, '[^a-zA-Z]+'::text, '_'::text, 'g'::text) || '_'::text) ||
        CASE
            WHEN (s.ts >= k.new_ts) THEN 'hrs_old'::text
            ELSE 'hrs_new'::text
        END)
  ORDER BY s.week DESC, ((regexp_replace((s.consumer_category)::text, '[^a-zA-Z]+'::text, '_'::text, 'g'::text) || '_'::text) ||
        CASE
            WHEN (s.ts >= k.new_ts) THEN 'hrs_old'::text
            ELSE 'hrs_new'::text
        END);


ALTER TABLE public.byte_stockouts_by_category_week_newold OWNER TO dbservice;

--
-- Name: byte_stockouts_by_category_week; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_stockouts_by_category_week AS
 SELECT t1.week,
    (regexp_replace(regexp_replace(t1.cat_and_new, '_hrs_'::text, '_per_'::text), '_all'::text, ''::text) || '_kiosk'::text) AS cat_and_new,
    (t1.stockout_hrs / (
        CASE
            WHEN (t1.cat_and_new ~~ '%new%'::text) THEN t2.num_new_kiosks
            WHEN (t1.cat_and_new ~~ '%old%'::text) THEN t2.num_old_kiosks
            ELSE t2.num_all_kiosks
        END)::double precision) AS stockout_hrs
   FROM (( SELECT byte_stockouts_by_category_week_newold.week,
            byte_stockouts_by_category_week_newold.cat_and_new,
            byte_stockouts_by_category_week_newold.stockout_hrs
           FROM public.byte_stockouts_by_category_week_newold
        UNION
         SELECT byte_stockouts_by_category_week_all.week,
            byte_stockouts_by_category_week_all.cat_and_new,
            byte_stockouts_by_category_week_all.stockout_hrs
           FROM public.byte_stockouts_by_category_week_all) t1
     LEFT JOIN public.byte_kiosks_by_week t2 ON ((t1.week = t2.week)));


ALTER TABLE public.byte_stockouts_by_category_week OWNER TO dbservice;

--
-- Name: byte_stockouts_by_category_week_crosstab; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_stockouts_by_category_week_crosstab AS
 SELECT ct.week,
    ct.breakfast_hrs_per_old_kiosk,
    ct.breakfast_hrs_per_new_kiosk,
    ct.breakfast_hrs_per_kiosk,
    ct.burritos_hrs_per_old_kiosk,
    ct.burritos_hrs_per_new_kiosk,
    ct.burritos_hrs_per_kiosk,
    ct.desserts_hrs_per_old_kiosk,
    ct.desserts_hrs_per_new_kiosk,
    ct.desserts_hrs_per_kiosk,
    ct.drinks_hrs_per_old_kiosk,
    ct.drinks_hrs_per_new_kiosk,
    ct.drinks_hrs_per_kiosk,
    ct.entrees_hrs_per_old_kiosk,
    ct.entrees_hrs_per_new_kiosk,
    ct.entrees_hrs_per_kiosk,
    ct.sandwiches_wraps_hrs_per_old_kiosk,
    ct.sandwiches_wraps_hrs_per_new_kiosk,
    ct.sandwiches_wraps_hrs_per_kiosk,
    ct.snacks_hrs_per_old_kiosk,
    ct.snacks_hrs_per_new_kiosk,
    ct.snacks_hrs_per_kiosk,
    ct.soups_salads_hrs_per_old_kiosk,
    ct.soups_salads_hrs_per_new_kiosk,
    ct.soups_salads_hrs_per_kiosk
   FROM public.crosstab('select to_char(week,''YYYY-MM-DD'') as week,cat_and_new,stockout_hrs from byte_stockouts_by_category_week order by week desc,cat_and_new desc'::text) ct(week text, breakfast_hrs_per_old_kiosk double precision, breakfast_hrs_per_new_kiosk double precision, breakfast_hrs_per_kiosk double precision, burritos_hrs_per_old_kiosk double precision, burritos_hrs_per_new_kiosk double precision, burritos_hrs_per_kiosk double precision, desserts_hrs_per_old_kiosk double precision, desserts_hrs_per_new_kiosk double precision, desserts_hrs_per_kiosk double precision, drinks_hrs_per_old_kiosk double precision, drinks_hrs_per_new_kiosk double precision, drinks_hrs_per_kiosk double precision, entrees_hrs_per_old_kiosk double precision, entrees_hrs_per_new_kiosk double precision, entrees_hrs_per_kiosk double precision, sandwiches_wraps_hrs_per_old_kiosk double precision, sandwiches_wraps_hrs_per_new_kiosk double precision, sandwiches_wraps_hrs_per_kiosk double precision, snacks_hrs_per_old_kiosk double precision, snacks_hrs_per_new_kiosk double precision, snacks_hrs_per_kiosk double precision, soups_salads_hrs_per_old_kiosk double precision, soups_salads_hrs_per_new_kiosk double precision, soups_salads_hrs_per_kiosk double precision);


ALTER TABLE public.byte_stockouts_by_category_week_crosstab OWNER TO dbservice;

--
-- Name: byte_tickets_labels; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_tickets_labels AS
 SELECT o.order_id,
    o.first_name,
    o.last_name,
    o.kiosk_id,
    o.kiosk_title,
    o.email,
    o.amount_paid,
    o.payment_system,
    o.transaction_id,
    o.approval_code,
    o.status_code,
    o.status_message,
    o.status,
    o.batch_id,
    o.created,
    o.auth_amount,
    o.data_token,
    o.time_opened,
    o.time_closed,
    o.card_hash,
    o.state,
    o.archived,
    o.stamp,
    o.last_update,
    o.balance,
    o.delta,
    o.coupon_id,
    o.coupon,
    o.refund,
    o.receipt,
    o.campus_id,
    o.amount_list_price,
    o.notes,
    o.time_door_opened,
    o.time_door_closed,
    o.client_name,
    o.estd_num_users,
    o.ts,
    o.full_name,
    o.door_opened_secs,
    o.month,
    o.week,
    o.date,
    o.dayofweek,
    o.hour,
    o.dowhour,
    o.uniq_user,
    l.epc AS label_epc,
    l.status AS label_status,
    l.time_created AS label_time_created
   FROM (pantry.label l
     JOIN public.byte_tickets o ON (((o.order_id)::text = (l.order_id)::text)));


ALTER TABLE public.byte_tickets_labels OWNER TO dbservice;

--
-- Name: byte_tickets_today; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_tickets_today AS
 SELECT byte_tickets.order_id,
    byte_tickets.first_name,
    byte_tickets.last_name,
    byte_tickets.kiosk_id,
    byte_tickets.kiosk_title,
    byte_tickets.email,
    byte_tickets.amount_paid,
    byte_tickets.payment_system,
    byte_tickets.transaction_id,
    byte_tickets.approval_code,
    byte_tickets.status_code,
    byte_tickets.status_message,
    byte_tickets.status,
    byte_tickets.batch_id,
    byte_tickets.created,
    byte_tickets.auth_amount,
    byte_tickets.data_token,
    byte_tickets.time_opened,
    byte_tickets.time_closed,
    byte_tickets.card_hash,
    byte_tickets.state,
    byte_tickets.archived,
    byte_tickets.stamp,
    byte_tickets.last_update,
    byte_tickets.balance,
    byte_tickets.delta,
    byte_tickets.coupon_id,
    byte_tickets.coupon,
    byte_tickets.refund,
    byte_tickets.receipt,
    byte_tickets.campus_id,
    byte_tickets.amount_list_price,
    byte_tickets.notes,
    byte_tickets.time_door_opened,
    byte_tickets.time_door_closed,
    byte_tickets.client_name,
    byte_tickets.estd_num_users,
    byte_tickets.ts,
    byte_tickets.full_name,
    byte_tickets.door_opened_secs,
    byte_tickets.month,
    byte_tickets.week,
    byte_tickets.date,
    byte_tickets.dayofweek,
    byte_tickets.hour,
    byte_tickets.dowhour,
    byte_tickets.uniq_user
   FROM public.byte_tickets
  WHERE (byte_tickets.ts > date_trunc('day'::text, ('now'::text)::timestamp without time zone));


ALTER TABLE public.byte_tickets_today OWNER TO dbservice;

--
-- Name: byte_tickets_yesterday; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_tickets_yesterday AS
 SELECT byte_tickets.order_id,
    byte_tickets.first_name,
    byte_tickets.last_name,
    byte_tickets.kiosk_id,
    byte_tickets.kiosk_title,
    byte_tickets.email,
    byte_tickets.amount_paid,
    byte_tickets.payment_system,
    byte_tickets.transaction_id,
    byte_tickets.approval_code,
    byte_tickets.status_code,
    byte_tickets.status_message,
    byte_tickets.status,
    byte_tickets.batch_id,
    byte_tickets.created,
    byte_tickets.auth_amount,
    byte_tickets.data_token,
    byte_tickets.time_opened,
    byte_tickets.time_closed,
    byte_tickets.card_hash,
    byte_tickets.state,
    byte_tickets.archived,
    byte_tickets.stamp,
    byte_tickets.last_update,
    byte_tickets.balance,
    byte_tickets.delta,
    byte_tickets.coupon_id,
    byte_tickets.coupon,
    byte_tickets.refund,
    byte_tickets.receipt,
    byte_tickets.campus_id,
    byte_tickets.amount_list_price,
    byte_tickets.notes,
    byte_tickets.time_door_opened,
    byte_tickets.time_door_closed,
    byte_tickets.client_name,
    byte_tickets.estd_num_users,
    byte_tickets.ts,
    byte_tickets.full_name,
    byte_tickets.door_opened_secs,
    byte_tickets.month,
    byte_tickets.week,
    byte_tickets.date,
    byte_tickets.dayofweek,
    byte_tickets.hour,
    byte_tickets.dowhour,
    byte_tickets.uniq_user
   FROM public.byte_tickets
  WHERE ((byte_tickets.ts >= (date_trunc('day'::text, ('now'::text)::timestamp without time zone) - '1 day'::interval day)) AND (byte_tickets.ts <= date_trunc('day'::text, ('now'::text)::timestamp without time zone)));


ALTER TABLE public.byte_tickets_yesterday OWNER TO dbservice;

--
-- Name: byte_users_multiple_fridges; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_users_multiple_fridges AS
 SELECT t.email_50chars,
    t.last_trans,
    t.cnt,
    t.clients
   FROM ( SELECT "left"((o.email)::text, 50) AS email_50chars,
            max(o.ts) AS last_trans,
            count(DISTINCT o.client_name) AS cnt,
            string_agg(DISTINCT (o.client_name)::text, ';'::text) AS clients
           FROM public.byte_tickets_1year o
          WHERE (((o.client_name)::text <> ALL (ARRAY[('Byte'::character varying)::text, ('Byte Foods'::character varying)::text, ('Byte Foods Inc'::character varying)::text, ('unknown or test'::character varying)::text, ('Megan Mokri'::character varying)::text, (''::character varying)::text])) AND ((o.email)::text <> ALL (ARRAY[('no@no.com'::character varying)::text, ('a@a.com'::character varying)::text])) AND ((o.email)::text !~~ '%pantry%'::text) AND ((o.email)::text !~~ '%bytefoods%'::text) AND ((o.email)::text <> ''::text))
          GROUP BY o.email) t
  WHERE ((t.clients <> 'ARE;Veracyte'::text) AND (t.cnt > 1) AND (t.last_trans > (now() - '3 mons'::interval month)))
  ORDER BY t.clients, t.email_50chars;


ALTER TABLE public.byte_users_multiple_fridges OWNER TO dbservice;

--
-- Name: byte_users_products_4months; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.byte_users_products_4months AS
 SELECT t1.full_name,
    t1.products
   FROM ( SELECT btrim(byte_epcssold_4months.full_name) AS full_name,
            public.sort(array_agg(DISTINCT (byte_epcssold_4months.product_id)::integer)) AS products
           FROM public.byte_epcssold_4months
          WHERE ((btrim(byte_epcssold_4months.full_name) ~~ '% %'::text) AND (byte_epcssold_4months.full_name <> ''::text))
          GROUP BY byte_epcssold_4months.full_name) t1
  WHERE (array_length(t1.products, 1) > 1);


ALTER TABLE public.byte_users_products_4months OWNER TO dbservice;

--
-- Name: bytecodelog; Type: TABLE; Schema: public; Owner: dbservice
--

CREATE TABLE public.bytecodelog (
    email text NOT NULL,
    bytecode character(6) NOT NULL,
    created_at bigint NOT NULL,
    duration integer NOT NULL,
    expires_at bigint NOT NULL
);


ALTER TABLE public.bytecodelog OWNER TO dbservice;

--
-- Name: campaigns; Type: TABLE; Schema: public; Owner: dbservice
--

CREATE TABLE public.campaigns (
    campaign_id integer NOT NULL,
    title character varying(128),
    description character varying(250),
    owner character varying(24)
);


ALTER TABLE public.campaigns OWNER TO dbservice;

--
-- Name: campaigns_campaign_id_seq; Type: SEQUENCE; Schema: public; Owner: dbservice
--

CREATE SEQUENCE public.campaigns_campaign_id_seq
CREATE SEQUENCE public.campaigns_campaign_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.campaigns_campaign_id_seq OWNER TO dbservice;

--
-- Name: campaigns_campaign_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: dbservice
--

ALTER SEQUENCE public.campaigns_campaign_id_seq OWNED BY public.campaigns.campaign_id;


--
-- Name: cogs_by_category_120d; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.cogs_by_category_120d AS
 SELECT byte_epcssold_120days.consumer_category,
    sum(byte_epcssold_120days.product_cost) AS cogs_120d,
    sum(public.if(((byte_epcssold_120days.ts >= (now() - '30 days'::interval day)) AND (byte_epcssold_120days.ts <= (now() - '00:00:00'::interval day))), byte_epcssold_120days.product_cost, 0.0)) AS cogs_0d_30d,
    sum(public.if(((byte_epcssold_120days.ts >= (now() - '60 days'::interval day)) AND (byte_epcssold_120days.ts <= (now() - '30 days'::interval day))), byte_epcssold_120days.product_cost, 0.0)) AS cogs_30d_60d,
    sum(public.if(((byte_epcssold_120days.ts >= (now() - '90 days'::interval day)) AND (byte_epcssold_120days.ts <= (now() - '60 days'::interval day))), byte_epcssold_120days.product_cost, 0.0)) AS cogs_60d_90d,
    sum(public.if(((byte_epcssold_120days.ts >= (now() - '120 days'::interval day)) AND (byte_epcssold_120days.ts <= (now() - '90 days'::interval day))), byte_epcssold_120days.product_cost, 0.0)) AS cogs_90d_120d
   FROM public.byte_epcssold_120days
  GROUP BY byte_epcssold_120days.consumer_category;


ALTER TABLE public.cogs_by_category_120d OWNER TO dbservice;

--
-- Name: sales_by_category_120d; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.sales_by_category_120d AS
 SELECT byte_epcssold_120days.consumer_category,
    sum(byte_epcssold_120days.product_price) AS sales_120d,
    sum(public.if(((byte_epcssold_120days.ts >= (now() - '30 days'::interval day)) AND (byte_epcssold_120days.ts <= (now() - '00:00:00'::interval day))), byte_epcssold_120days.product_price, 0.0)) AS sales_0d_30d,
    sum(public.if(((byte_epcssold_120days.ts >= (now() - '60 days'::interval day)) AND (byte_epcssold_120days.ts <= (now() - '30 days'::interval day))), byte_epcssold_120days.product_price, 0.0)) AS sales_30d_60d,
    sum(public.if(((byte_epcssold_120days.ts >= (now() - '90 days'::interval day)) AND (byte_epcssold_120days.ts <= (now() - '60 days'::interval day))), byte_epcssold_120days.product_price, 0.0)) AS sales_60d_90d,
    sum(public.if(((byte_epcssold_120days.ts >= (now() - '120 days'::interval day)) AND (byte_epcssold_120days.ts <= (now() - '90 days'::interval day))), byte_epcssold_120days.product_price, 0.0)) AS sales_90d_120d
   FROM public.byte_epcssold_120days
  GROUP BY byte_epcssold_120days.consumer_category;


ALTER TABLE public.sales_by_category_120d OWNER TO dbservice;

--
-- Name: spoilage_by_category_120d; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.spoilage_by_category_120d AS
 SELECT byte_spoilage.consumer_category,
    sum(byte_spoilage.cost) AS spoilage_120d,
    sum(public.if(((byte_spoilage.ts_removed >= (now() - '30 days'::interval day)) AND (byte_spoilage.ts_removed <= (now() - '00:00:00'::interval day))), byte_spoilage.cost, 0.0)) AS spoilage_0d_30d,
    sum(public.if(((byte_spoilage.ts_removed >= (now() - '60 days'::interval day)) AND (byte_spoilage.ts_removed <= (now() - '30 days'::interval day))), byte_spoilage.cost, 0.0)) AS spoilage_30d_60d,
    sum(public.if(((byte_spoilage.ts_removed >= (now() - '90 days'::interval day)) AND (byte_spoilage.ts_removed <= (now() - '60 days'::interval day))), byte_spoilage.cost, 0.0)) AS spoilage_60d_90d,
    sum(public.if(((byte_spoilage.ts_removed >= (now() - '120 days'::interval day)) AND (byte_spoilage.ts_removed <= (now() - '90 days'::interval day))), byte_spoilage.cost, 0.0)) AS spoilage_90d_120d
   FROM public.byte_spoilage
  WHERE (byte_spoilage.ts_removed > (now() - '120 days'::interval day))
  GROUP BY byte_spoilage.consumer_category;


ALTER TABLE public.spoilage_by_category_120d OWNER TO dbservice;

--
-- Name: category_stats_120d; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.category_stats_120d AS
 SELECT t1.consumer_category,
    t1.sales_0d_30d,
    t1.sales_30d_60d,
    t1.sales_60d_90d,
    t1.sales_90d_120d,
    t2.cogs_0d_30d,
    t2.cogs_30d_60d,
    t2.cogs_60d_90d,
    t2.cogs_90d_120d,
    t3.spoilage_0d_30d,
    t3.spoilage_30d_60d,
    t3.spoilage_60d_90d,
    t3.spoilage_90d_120d
   FROM ((public.sales_by_category_120d t1
     LEFT JOIN public.cogs_by_category_120d t2 ON (((t1.consumer_category)::text = (t2.consumer_category)::text)))
     LEFT JOIN public.spoilage_by_category_120d t3 ON (((t2.consumer_category)::text = (t3.consumer_category)::text)));


ALTER TABLE public.category_stats_120d OWNER TO dbservice;

--
-- Name: customer_campaigns; Type: TABLE; Schema: public; Owner: dbservice
--

CREATE TABLE public.customer_campaigns (
    customer_id integer NOT NULL,
    campaign_id integer NOT NULL,
    coupon_id character varying(14),
    status character varying(3),
    opt_out timestamp(6) with time zone,
    last_update timestamp(6) with time zone
);


ALTER TABLE public.customer_campaigns OWNER TO dbservice;

--
-- Name: customers; Type: TABLE; Schema: public; Owner: dbservice
--

CREATE TABLE public.customers (
    customer_id integer NOT NULL,
    email_address character varying(64),
    full_name character varying(64),
    kiosks integer,
    last_buy timestamp(6) with time zone,
    alt_email_address character varying(250),
    cardhash character varying(250),
    opt_out timestamp(6) with time zone,
    last_update timestamp(6) with time zone,
    editkey character varying(12),
    first_name character varying(64),
    last_name character varying(64)
);


ALTER TABLE public.customers OWNER TO dbservice;

--
-- Name: customers_customer_id_seq; Type: SEQUENCE; Schema: public; Owner: dbservice
--

CREATE SEQUENCE public.customers_customer_id_seq
CREATE SEQUENCE public.customers_customer_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.customers_customer_id_seq OWNER TO dbservice;

--
-- Name: customers_customer_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: dbservice
--

ALTER SEQUENCE public.customers_customer_id_seq OWNED BY public.customers.customer_id;


--
-- Name: dashboard_monthly_stats; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.dashboard_monthly_stats AS
 SELECT byte_epcssold.month,
    count(DISTINCT byte_epcssold.epc) AS units,
    count(DISTINCT byte_epcssold.client_name) AS active_byte_customers,
    count(DISTINCT byte_epcssold.product_id) AS active_skus,
    count(DISTINCT byte_epcssold.product_vendor) AS active_brands,
    count(DISTINCT byte_epcssold.card_hash) AS cards,
    count(DISTINCT regexp_replace(byte_epcssold.full_name, '^(.).+? (.+)'::text, ' '::text)) AS estd_uniq_usernames,
    count(DISTINCT byte_epcssold.email) AS unique_emails,
    count(DISTINCT byte_epcssold.order_id) AS tickets,
    count(DISTINCT
        CASE
            WHEN ((byte_epcssold.email IS NULL) OR ((byte_epcssold.email)::text = ''::text)) THEN ''::character varying
            ELSE byte_epcssold.order_id
        END) AS tickets_w_email
   FROM public.byte_epcssold
  GROUP BY byte_epcssold.month
  ORDER BY byte_epcssold.month;


ALTER TABLE public.dashboard_monthly_stats OWNER TO dbservice;

--
-- Name: dashboard_weekly_stats; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.dashboard_weekly_stats AS
 SELECT t1.week,
    ((t2.stockout_units_in_old_kiosks)::double precision / (((t1.num_old_kiosks)::numeric + 0.01))::double precision) AS avg_stockouts_per_old_kiosk,
    ((t2.stockout_units_in_new_kiosks)::double precision / (((t1.num_new_kiosks)::numeric + 0.01))::double precision) AS avg_stockouts_per_new_kiosk,
    ((t2.stockout_units_in_all_kiosks)::double precision / (t1.num_all_kiosks)::double precision) AS avg_stockouts_per_kiosk,
    ((t2.stockout_hrs_in_old_kiosks)::double precision / (((t1.num_old_kiosks)::numeric + 0.01))::double precision) AS avg_stockout_hrs_per_old_kiosk,
    ((t2.stockout_hrs_in_new_kiosks)::double precision / (((t1.num_new_kiosks)::numeric + 0.01))::double precision) AS avg_stockout_hrs_per_new_kiosk,
    (t2.stockout_hrs_in_all_kiosks / (t1.num_all_kiosks)::double precision) AS avg_stockout_hrs_per_kiosk
   FROM (public.byte_kiosks_by_week t1
     JOIN public.byte_stockouts_by_week t2 ON ((t1.week = t2.week)))
  ORDER BY t1.week;


ALTER TABLE public.dashboard_weekly_stats OWNER TO dbservice;

--
-- Name: date_hours_2016; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.date_hours_2016 AS
 SELECT generate_series(('2016-01-01'::date)::timestamp with time zone, ('2017-01-01'::date)::timestamp with time zone, '01:00:00'::interval) AS hour_start,
    (generate_series(('2016-01-01'::date)::timestamp with time zone, ('2017-01-01'::date)::timestamp with time zone, '01:00:00'::interval) + '01:00:00'::interval) AS hour_end;


ALTER TABLE public.date_hours_2016 OWNER TO dbservice;

--
-- Name: lastwk_hrs; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.lastwk_hrs AS
 SELECT ts.ts
   FROM generate_series((now() - '7 days'::interval day), now(), '01:00:00'::interval) ts(ts);


ALTER TABLE public.lastwk_hrs OWNER TO dbservice;

--
-- Name: dowhours; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.dowhours AS
 SELECT DISTINCT public.dowhour(lastwk_hrs.ts) AS dowhour
   FROM public.lastwk_hrs
  ORDER BY (public.dowhour(lastwk_hrs.ts));


ALTER TABLE public.dowhours OWNER TO dbservice;

--
-- Name: stockout_avg_kiosk_cat_sales_dowhour; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.stockout_avg_kiosk_cat_sales_dowhour AS
 WITH _unused AS (
         SELECT 1
        ), epcs_sold_recently AS (
         SELECT e.kiosk_id,
            e.product_id,
            e.label_price,
            e.consumer_category AS cat,
            e.dowhour
           FROM public.byte_epcssold_fast e
          WHERE (e.ts > (now() - '45 days'::interval))
        ), _avg_kiosk_sales_dowhour AS (
         SELECT epcs_sold_recently.kiosk_id,
            epcs_sold_recently.dowhour,
            sum(epcs_sold_recently.label_price) AS sales,
            count(*) AS cnt,
            (sum(epcs_sold_recently.label_price) / (count(*))::numeric) AS avg_kiosk_sales
           FROM epcs_sold_recently
          GROUP BY epcs_sold_recently.kiosk_id, epcs_sold_recently.dowhour
        ), _avg_sku_sales_dowhour AS (
         SELECT epcs_sold_recently.product_id,
            epcs_sold_recently.dowhour,
            sum(epcs_sold_recently.label_price) AS sales,
            count(*) AS cnt,
            (sum(epcs_sold_recently.label_price) / (count(*))::numeric) AS avg_sku_sales
           FROM epcs_sold_recently
          GROUP BY epcs_sold_recently.product_id, epcs_sold_recently.dowhour
        ), avg_kiosk_sales_dowhour AS (
         SELECT dh.dowhour,
            s.kiosk_id,
            s.avg_kiosk_sales
           FROM (public.dowhours dh
             JOIN _avg_kiosk_sales_dowhour s ON ((dh.dowhour = s.dowhour)))
        ), avg_sku_sales_dowhour AS (
         SELECT dh.dowhour,
            s.product_id,
            s.avg_sku_sales
           FROM (public.dowhours dh
             JOIN _avg_sku_sales_dowhour s ON ((dh.dowhour = s.dowhour)))
        ), _avg_cat_sales_dowhour AS (
         SELECT p.consumer_category AS cat,
            ss.dowhour,
            (sum(ss.sales) / sum(ss.cnt)) AS avg_cat_sales
           FROM (_avg_sku_sales_dowhour ss
             JOIN pantry.product p ON ((ss.product_id = p.id)))
          GROUP BY p.consumer_category, ss.dowhour
        ), avg_cat_sales_dowhour AS (
         SELECT dh.dowhour,
            s.cat,
            s.avg_cat_sales
           FROM (public.dowhours dh
             LEFT JOIN _avg_cat_sales_dowhour s ON ((dh.dowhour = s.dowhour)))
        ), stockout_avg_kiosk_cat_sales_dowhour AS (
         SELECT DISTINCT e.kiosk_id,
            e.cat,
            ss.dowhour,
            (COALESCE(ss.avg_cat_sales, 1.0) * COALESCE(ks.avg_kiosk_sales, 1.0)) AS avg_cat_kiosk_sales,
            ss.avg_cat_sales,
            ks.avg_kiosk_sales
           FROM ((epcs_sold_recently e
             LEFT JOIN avg_cat_sales_dowhour ss ON (((e.cat)::text = (ss.cat)::text)))
             FULL JOIN avg_kiosk_sales_dowhour ks ON (((e.kiosk_id = ks.kiosk_id) AND (ss.dowhour = ks.dowhour))))
        )
 SELECT stockout_avg_kiosk_cat_sales_dowhour.kiosk_id,
    stockout_avg_kiosk_cat_sales_dowhour.cat,
    stockout_avg_kiosk_cat_sales_dowhour.dowhour,
    stockout_avg_kiosk_cat_sales_dowhour.avg_cat_kiosk_sales,
    stockout_avg_kiosk_cat_sales_dowhour.avg_cat_sales,
    stockout_avg_kiosk_cat_sales_dowhour.avg_kiosk_sales
   FROM stockout_avg_kiosk_cat_sales_dowhour;


ALTER TABLE public.stockout_avg_kiosk_cat_sales_dowhour OWNER TO dbservice;

--
-- Name: stockout_dowhours; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.stockout_dowhours AS
 WITH _unused AS (
         SELECT 1
        ), stockouts AS (
         SELECT byte_stockouts.kiosk_id,
            byte_stockouts.product_id,
            byte_stockouts.consumer_category AS cat,
            byte_stockouts.ts AS stockout_ts,
            COALESCE(byte_stockouts.restock_ts, now()) AS restock_ts
           FROM public.byte_stockouts
          WHERE (byte_stockouts.ts > (now() - '7 days'::interval day))
        ), stockout_dowhours AS (
         SELECT s.kiosk_id,
            s.product_id,
            s.cat,
            lw.ts,
            s.restock_ts,
            public.dowhour(lw.ts) AS dowhour,
            (s.restock_ts - s.stockout_ts) AS stockout_len
           FROM stockouts s,
            public.lastwk_hrs lw
          WHERE ((s.stockout_ts <= lw.ts) AND (lw.ts < s.restock_ts))
        )
 SELECT stockout_dowhours.kiosk_id,
    stockout_dowhours.product_id,
    stockout_dowhours.cat,
    stockout_dowhours.ts,
    stockout_dowhours.restock_ts,
    stockout_dowhours.dowhour,
    stockout_dowhours.stockout_len
   FROM stockout_dowhours;


ALTER TABLE public.stockout_dowhours OWNER TO dbservice;

--
-- Name: stockout_dowhours_weighted; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.stockout_dowhours_weighted AS
 WITH _unused AS (
         SELECT 1
        ), stockout_dowhours_weighted AS (
         SELECT st.kiosk_id,
            st.product_id,
            st.cat,
            st.ts,
            st.restock_ts,
            st.dowhour,
            st.stockout_len,
            sa.avg_cat_kiosk_sales,
            sa.avg_cat_sales,
            sa.avg_kiosk_sales
           FROM (public.stockout_dowhours st
             JOIN public.stockout_avg_kiosk_cat_sales_dowhour sa ON (((st.dowhour = sa.dowhour) AND (st.kiosk_id = sa.kiosk_id) AND ((st.cat)::text = (sa.cat)::text))))
        )
 SELECT stockout_dowhours_weighted.kiosk_id,
    stockout_dowhours_weighted.product_id,
    stockout_dowhours_weighted.cat,
    stockout_dowhours_weighted.ts,
    stockout_dowhours_weighted.restock_ts,
    stockout_dowhours_weighted.dowhour,
    stockout_dowhours_weighted.stockout_len,
    stockout_dowhours_weighted.avg_cat_kiosk_sales,
    stockout_dowhours_weighted.avg_cat_sales,
    stockout_dowhours_weighted.avg_kiosk_sales
   FROM stockout_dowhours_weighted;


ALTER TABLE public.stockout_dowhours_weighted OWNER TO dbservice;

--
-- Name: dbg_stockout_dowhours_weighted; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.dbg_stockout_dowhours_weighted AS
 SELECT stockout_dowhours_weighted.kiosk_id,
    stockout_dowhours_weighted.product_id,
    stockout_dowhours_weighted.cat,
    public.fmt_ts(stockout_dowhours_weighted.ts) AS ts,
    public.fmt_ts(stockout_dowhours_weighted.restock_ts) AS restock_ts,
    stockout_dowhours_weighted.dowhour,
    public.interval_hours(stockout_dowhours_weighted.stockout_len) AS stockout_hrs,
    (stockout_dowhours_weighted.avg_cat_kiosk_sales)::numeric(6,2) AS avg_cat_kiosk_sales,
    (stockout_dowhours_weighted.avg_cat_sales)::numeric(6,2) AS avg_cat_sales,
    (stockout_dowhours_weighted.avg_kiosk_sales)::numeric(6,2) AS avg_kiosk_sales
   FROM public.stockout_dowhours_weighted
  ORDER BY stockout_dowhours_weighted.kiosk_id, stockout_dowhours_weighted.product_id, (public.fmt_ts(stockout_dowhours_weighted.ts));


ALTER TABLE public.dbg_stockout_dowhours_weighted OWNER TO dbservice;

--
-- Name: dbg_stockout_dowhours_weighted_stats; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.dbg_stockout_dowhours_weighted_stats AS
 SELECT count(*) AS count,
    count(DISTINCT stockout_dowhours_weighted.kiosk_id) AS kiosks,
    count(DISTINCT stockout_dowhours_weighted.product_id) AS products,
    count(DISTINCT stockout_dowhours_weighted.dowhour) AS dowhours,
    count(DISTINCT stockout_dowhours_weighted.cat) AS cats
   FROM public.stockout_dowhours_weighted;


ALTER TABLE public.dbg_stockout_dowhours_weighted_stats OWNER TO dbservice;

--
-- Name: stockout_runs_weighted; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.stockout_runs_weighted AS
 WITH _unused AS (
         SELECT 1
        ), stockout_runs_weighted AS (
         SELECT st.kiosk_id,
            st.product_id,
            st.stockout_len,
            min(st.ts) AS ts,
            max(st.restock_ts) AS restock_ts,
            min((st.cat)::text) AS cat,
            sum(sa.avg_cat_kiosk_sales) AS avg_cat_kiosk_sales,
            sum(sa.avg_cat_sales) AS avg_cat_sales,
            sum(sa.avg_kiosk_sales) AS avg_kiosk_sales
           FROM (public.stockout_dowhours st
             JOIN public.stockout_avg_kiosk_cat_sales_dowhour sa ON (((st.dowhour = sa.dowhour) AND (st.kiosk_id = sa.kiosk_id) AND ((st.cat)::text = (sa.cat)::text))))
          GROUP BY st.kiosk_id, st.product_id, st.stockout_len
        )
 SELECT stockout_runs_weighted.kiosk_id,
    stockout_runs_weighted.product_id,
    stockout_runs_weighted.stockout_len,
    stockout_runs_weighted.ts,
    stockout_runs_weighted.restock_ts,
    stockout_runs_weighted.cat,
    stockout_runs_weighted.avg_cat_kiosk_sales,
    stockout_runs_weighted.avg_cat_sales,
    stockout_runs_weighted.avg_kiosk_sales
   FROM stockout_runs_weighted;


ALTER TABLE public.stockout_runs_weighted OWNER TO dbservice;

--
-- Name: dbg_stockout_runs_weighted; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.dbg_stockout_runs_weighted AS
 SELECT stockout_runs_weighted.kiosk_id,
    stockout_runs_weighted.product_id,
    stockout_runs_weighted.cat,
    public.fmt_ts(stockout_runs_weighted.ts) AS stockout_ts,
    public.fmt_ts(stockout_runs_weighted.restock_ts) AS restock_ts,
    public.interval_hours(stockout_runs_weighted.stockout_len) AS stockout_hrs,
    (stockout_runs_weighted.avg_cat_kiosk_sales)::numeric(8,2) AS avg_cat_kiosk_sales,
    (stockout_runs_weighted.avg_cat_sales)::numeric(8,2) AS avg_cat_sales,
    (stockout_runs_weighted.avg_kiosk_sales)::numeric(8,2) AS avg_kiosk_sales
   FROM public.stockout_runs_weighted
  ORDER BY stockout_runs_weighted.kiosk_id, stockout_runs_weighted.product_id, stockout_runs_weighted.ts;


ALTER TABLE public.dbg_stockout_runs_weighted OWNER TO dbservice;

--
-- Name: stockout_weighted; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.stockout_weighted AS
 WITH _unused AS (
         SELECT 1
        ), stockout_weighted AS (
         SELECT stockout_runs_weighted.kiosk_id,
            stockout_runs_weighted.product_id,
            min(stockout_runs_weighted.cat) AS cat,
            sum(stockout_runs_weighted.stockout_len) AS stockout_len,
            sum(stockout_runs_weighted.avg_cat_kiosk_sales) AS avg_cat_kiosk_sales,
            sum(stockout_runs_weighted.avg_cat_sales) AS avg_cat_sales,
            sum(stockout_runs_weighted.avg_kiosk_sales) AS avg_kiosk_sales
           FROM public.stockout_runs_weighted
          GROUP BY stockout_runs_weighted.kiosk_id, stockout_runs_weighted.product_id
        )
 SELECT stockout_weighted.kiosk_id,
    stockout_weighted.product_id,
    stockout_weighted.cat,
    stockout_weighted.stockout_len,
    stockout_weighted.avg_cat_kiosk_sales,
    stockout_weighted.avg_cat_sales,
    stockout_weighted.avg_kiosk_sales
   FROM stockout_weighted;


ALTER TABLE public.stockout_weighted OWNER TO dbservice;

--
-- Name: dbg_stockout_weighted; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.dbg_stockout_weighted AS
 SELECT stockout_weighted.kiosk_id,
    stockout_weighted.product_id,
    stockout_weighted.cat,
    public.interval_hours(stockout_weighted.stockout_len) AS stockout_hrs,
    (stockout_weighted.avg_cat_kiosk_sales)::numeric(8,2) AS avg_cat_kiosk_sales,
    (stockout_weighted.avg_cat_sales)::numeric(8,2) AS avg_cat_sales,
    (stockout_weighted.avg_kiosk_sales)::numeric(8,2) AS avg_kiosk_sales
   FROM public.stockout_weighted
  ORDER BY stockout_weighted.kiosk_id, stockout_weighted.product_id, stockout_weighted.cat;


ALTER TABLE public.dbg_stockout_weighted OWNER TO dbservice;

--
-- Name: dbg_stockout_weighted_stats; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.dbg_stockout_weighted_stats AS
 SELECT count(*) AS count,
    count(DISTINCT stockout_dowhours.kiosk_id) AS kiosks,
    count(DISTINCT stockout_dowhours.product_id) AS products,
    count(DISTINCT stockout_dowhours.dowhour) AS dowhours,
    count(DISTINCT stockout_dowhours.cat) AS cats
   FROM public.stockout_dowhours;


ALTER TABLE public.dbg_stockout_weighted_stats OWNER TO dbservice;

--
-- Name: dp_epcssold; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.dp_epcssold AS
 SELECT byte_epcssold.order_id,
    byte_epcssold.first_name,
    byte_epcssold.last_name,
    byte_epcssold.kiosk_id,
    byte_epcssold.kiosk_title,
    byte_epcssold.email,
    byte_epcssold.amount_paid,
    byte_epcssold.payment_system,
    byte_epcssold.transaction_id,
    byte_epcssold.approval_code,
    byte_epcssold.status_code,
    byte_epcssold.status_message,
    byte_epcssold.status,
    byte_epcssold.batch_id,
    byte_epcssold.created,
    byte_epcssold.auth_amount,
    byte_epcssold.data_token,
    byte_epcssold.time_opened,
    byte_epcssold.time_closed,
    byte_epcssold.card_hash,
    byte_epcssold.state,
    byte_epcssold.archived,
    byte_epcssold.stamp,
    byte_epcssold.last_update,
    byte_epcssold.balance,
    byte_epcssold.delta,
    byte_epcssold.coupon_id,
    byte_epcssold.coupon,
    byte_epcssold.refund,
    byte_epcssold.receipt,
    byte_epcssold.campus_id,
    byte_epcssold.amount_list_price,
    byte_epcssold.notes,
    byte_epcssold.time_door_opened,
    byte_epcssold.time_door_closed,
    byte_epcssold.client_name,
    byte_epcssold.estd_num_users,
    byte_epcssold.ts,
    byte_epcssold.full_name,
    byte_epcssold.door_opened_secs,
    byte_epcssold.month,
    byte_epcssold.week,
    byte_epcssold.date,
    byte_epcssold.dayofweek,
    byte_epcssold.hour,
    byte_epcssold.dowhour,
    byte_epcssold.uniq_user,
    byte_epcssold.epc,
    byte_epcssold.label_order_id,
    byte_epcssold.label_status,
    byte_epcssold.label_price,
    byte_epcssold.time_created,
    byte_epcssold.time_added,
    byte_epcssold.time_updated,
    byte_epcssold.ts_created,
    byte_epcssold.ts_added,
    byte_epcssold.ts_updated,
    byte_epcssold.label_kiosk_id,
    byte_epcssold.product_id,
    byte_epcssold.product_title,
    byte_epcssold.product_archived,
    byte_epcssold.product_vendor,
    byte_epcssold.product_price,
    byte_epcssold.product_cost,
    byte_epcssold.product_shelf_life_days,
    byte_epcssold.product_attributes,
    byte_epcssold.product_categories,
    byte_epcssold.consumer_category,
    byte_epcssold.product_source
   FROM public.byte_epcssold;


ALTER TABLE public.dp_epcssold OWNER TO dbservice;

--
-- Name: dp_epcssold_2015; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.dp_epcssold_2015 AS
 SELECT dp_epcssold.order_id,
    dp_epcssold.first_name,
    dp_epcssold.last_name,
    dp_epcssold.kiosk_id,
    dp_epcssold.kiosk_title,
    dp_epcssold.email,
    dp_epcssold.amount_paid,
    dp_epcssold.payment_system,
    dp_epcssold.transaction_id,
    dp_epcssold.approval_code,
    dp_epcssold.status_code,
    dp_epcssold.status_message,
    dp_epcssold.status,
    dp_epcssold.batch_id,
    dp_epcssold.created,
    dp_epcssold.auth_amount,
    dp_epcssold.data_token,
    dp_epcssold.time_opened,
    dp_epcssold.time_closed,
    dp_epcssold.card_hash,
    dp_epcssold.state,
    dp_epcssold.archived,
    dp_epcssold.stamp,
    dp_epcssold.last_update,
    dp_epcssold.balance,
    dp_epcssold.delta,
    dp_epcssold.coupon_id,
    dp_epcssold.coupon,
    dp_epcssold.refund,
    dp_epcssold.receipt,
    dp_epcssold.campus_id,
    dp_epcssold.amount_list_price,
    dp_epcssold.notes,
    dp_epcssold.time_door_opened,
    dp_epcssold.time_door_closed,
    dp_epcssold.client_name,
    dp_epcssold.estd_num_users,
    dp_epcssold.ts,
    dp_epcssold.full_name,
    dp_epcssold.door_opened_secs,
    dp_epcssold.month,
    dp_epcssold.week,
    dp_epcssold.date,
    dp_epcssold.dayofweek,
    dp_epcssold.hour,
    dp_epcssold.dowhour,
    dp_epcssold.uniq_user,
    dp_epcssold.epc,
    dp_epcssold.label_order_id,
    dp_epcssold.label_status,
    dp_epcssold.label_price,
    dp_epcssold.time_created,
    dp_epcssold.time_added,
    dp_epcssold.time_updated,
    dp_epcssold.ts_created,
    dp_epcssold.ts_added,
    dp_epcssold.ts_updated,
    dp_epcssold.label_kiosk_id,
    dp_epcssold.product_id,
    dp_epcssold.product_title,
    dp_epcssold.product_archived,
    dp_epcssold.product_vendor,
    dp_epcssold.product_price,
    dp_epcssold.product_cost,
    dp_epcssold.product_shelf_life_days,
    dp_epcssold.product_attributes,
    dp_epcssold.product_categories,
    dp_epcssold.consumer_category,
    dp_epcssold.product_source
   FROM public.dp_epcssold
  WHERE ((dp_epcssold.ts >= '2015-01-01 08:00:00+00'::timestamp with time zone) AND (dp_epcssold.ts <= '2016-01-01 08:00:00+00'::timestamp with time zone));


ALTER TABLE public.dp_epcssold_2015 OWNER TO dbservice;

--
-- Name: dp_epcssold_2016; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.dp_epcssold_2016 AS
 SELECT dp_epcssold.order_id,
    dp_epcssold.first_name,
    dp_epcssold.last_name,
    dp_epcssold.kiosk_id,
    dp_epcssold.kiosk_title,
    dp_epcssold.email,
    dp_epcssold.amount_paid,
    dp_epcssold.payment_system,
    dp_epcssold.transaction_id,
    dp_epcssold.approval_code,
    dp_epcssold.status_code,
    dp_epcssold.status_message,
    dp_epcssold.status,
    dp_epcssold.batch_id,
    dp_epcssold.created,
    dp_epcssold.auth_amount,
    dp_epcssold.data_token,
    dp_epcssold.time_opened,
    dp_epcssold.time_closed,
    dp_epcssold.card_hash,
    dp_epcssold.state,
    dp_epcssold.archived,
    dp_epcssold.stamp,
    dp_epcssold.last_update,
    dp_epcssold.balance,
    dp_epcssold.delta,
    dp_epcssold.coupon_id,
    dp_epcssold.coupon,
    dp_epcssold.refund,
    dp_epcssold.receipt,
    dp_epcssold.campus_id,
    dp_epcssold.amount_list_price,
    dp_epcssold.notes,
    dp_epcssold.time_door_opened,
    dp_epcssold.time_door_closed,
    dp_epcssold.client_name,
    dp_epcssold.estd_num_users,
    dp_epcssold.ts,
    dp_epcssold.full_name,
    dp_epcssold.door_opened_secs,
    dp_epcssold.month,
    dp_epcssold.week,
    dp_epcssold.date,
    dp_epcssold.dayofweek,
    dp_epcssold.hour,
    dp_epcssold.dowhour,
    dp_epcssold.uniq_user,
    dp_epcssold.epc,
    dp_epcssold.label_order_id,
    dp_epcssold.label_status,
    dp_epcssold.label_price,
    dp_epcssold.time_created,
    dp_epcssold.time_added,
    dp_epcssold.time_updated,
    dp_epcssold.ts_created,
    dp_epcssold.ts_added,
    dp_epcssold.ts_updated,
    dp_epcssold.label_kiosk_id,
    dp_epcssold.product_id,
    dp_epcssold.product_title,
    dp_epcssold.product_archived,
    dp_epcssold.product_vendor,
    dp_epcssold.product_price,
    dp_epcssold.product_cost,
    dp_epcssold.product_shelf_life_days,
    dp_epcssold.product_attributes,
    dp_epcssold.product_categories,
    dp_epcssold.consumer_category,
    dp_epcssold.product_source
   FROM public.dp_epcssold
  WHERE ((dp_epcssold.ts >= '2016-01-01 08:00:00+00'::timestamp with time zone) AND (dp_epcssold.ts <= '2017-01-01 08:00:00+00'::timestamp with time zone));


ALTER TABLE public.dp_epcssold_2016 OWNER TO dbservice;

--
-- Name: dp_epcssold_2017; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.dp_epcssold_2017 AS
 SELECT dp_epcssold.order_id,
    dp_epcssold.first_name,
    dp_epcssold.last_name,
    dp_epcssold.kiosk_id,
    dp_epcssold.kiosk_title,
    dp_epcssold.email,
    dp_epcssold.amount_paid,
    dp_epcssold.payment_system,
    dp_epcssold.transaction_id,
    dp_epcssold.approval_code,
    dp_epcssold.status_code,
    dp_epcssold.status_message,
    dp_epcssold.status,
    dp_epcssold.batch_id,
    dp_epcssold.created,
    dp_epcssold.auth_amount,
    dp_epcssold.data_token,
    dp_epcssold.time_opened,
    dp_epcssold.time_closed,
    dp_epcssold.card_hash,
    dp_epcssold.state,
    dp_epcssold.archived,
    dp_epcssold.stamp,
    dp_epcssold.last_update,
    dp_epcssold.balance,
    dp_epcssold.delta,
    dp_epcssold.coupon_id,
    dp_epcssold.coupon,
    dp_epcssold.refund,
    dp_epcssold.receipt,
    dp_epcssold.campus_id,
    dp_epcssold.amount_list_price,
    dp_epcssold.notes,
    dp_epcssold.time_door_opened,
    dp_epcssold.time_door_closed,
    dp_epcssold.client_name,
    dp_epcssold.estd_num_users,
    dp_epcssold.ts,
    dp_epcssold.full_name,
    dp_epcssold.door_opened_secs,
    dp_epcssold.month,
    dp_epcssold.week,
    dp_epcssold.date,
    dp_epcssold.dayofweek,
    dp_epcssold.hour,
    dp_epcssold.dowhour,
    dp_epcssold.uniq_user,
    dp_epcssold.epc,
    dp_epcssold.label_order_id,
    dp_epcssold.label_status,
    dp_epcssold.label_price,
    dp_epcssold.time_created,
    dp_epcssold.time_added,
    dp_epcssold.time_updated,
    dp_epcssold.ts_created,
    dp_epcssold.ts_added,
    dp_epcssold.ts_updated,
    dp_epcssold.label_kiosk_id,
    dp_epcssold.product_id,
    dp_epcssold.product_title,
    dp_epcssold.product_archived,
    dp_epcssold.product_vendor,
    dp_epcssold.product_price,
    dp_epcssold.product_cost,
    dp_epcssold.product_shelf_life_days,
    dp_epcssold.product_attributes,
    dp_epcssold.product_categories,
    dp_epcssold.consumer_category,
    dp_epcssold.product_source
   FROM public.dp_epcssold
  WHERE ((dp_epcssold.ts >= '2017-01-01 08:00:00+00'::timestamp with time zone) AND (dp_epcssold.ts <= '2018-01-01 08:00:00+00'::timestamp with time zone));


ALTER TABLE public.dp_epcssold_2017 OWNER TO dbservice;

--
-- Name: dp_epcssold_4weeks; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.dp_epcssold_4weeks AS
 SELECT dp_epcssold.order_id,
    dp_epcssold.first_name,
    dp_epcssold.last_name,
    dp_epcssold.kiosk_id,
    dp_epcssold.kiosk_title,
    dp_epcssold.email,
    dp_epcssold.amount_paid,
    dp_epcssold.payment_system,
    dp_epcssold.transaction_id,
    dp_epcssold.approval_code,
    dp_epcssold.status_code,
    dp_epcssold.status_message,
    dp_epcssold.status,
    dp_epcssold.batch_id,
    dp_epcssold.created,
    dp_epcssold.auth_amount,
    dp_epcssold.data_token,
    dp_epcssold.time_opened,
    dp_epcssold.time_closed,
    dp_epcssold.card_hash,
    dp_epcssold.state,
    dp_epcssold.archived,
    dp_epcssold.stamp,
    dp_epcssold.last_update,
    dp_epcssold.balance,
    dp_epcssold.delta,
    dp_epcssold.coupon_id,
    dp_epcssold.coupon,
    dp_epcssold.refund,
    dp_epcssold.receipt,
    dp_epcssold.campus_id,
    dp_epcssold.amount_list_price,
    dp_epcssold.notes,
    dp_epcssold.time_door_opened,
    dp_epcssold.time_door_closed,
    dp_epcssold.client_name,
    dp_epcssold.estd_num_users,
    dp_epcssold.ts,
    dp_epcssold.full_name,
    dp_epcssold.door_opened_secs,
    dp_epcssold.month,
    dp_epcssold.week,
    dp_epcssold.date,
    dp_epcssold.dayofweek,
    dp_epcssold.hour,
    dp_epcssold.dowhour,
    dp_epcssold.uniq_user,
    dp_epcssold.epc,
    dp_epcssold.label_order_id,
    dp_epcssold.label_status,
    dp_epcssold.label_price,
    dp_epcssold.time_created,
    dp_epcssold.time_added,
    dp_epcssold.time_updated,
    dp_epcssold.ts_created,
    dp_epcssold.ts_added,
    dp_epcssold.ts_updated,
    dp_epcssold.label_kiosk_id,
    dp_epcssold.product_id,
    dp_epcssold.product_title,
    dp_epcssold.product_archived,
    dp_epcssold.product_vendor,
    dp_epcssold.product_price,
    dp_epcssold.product_cost,
    dp_epcssold.product_shelf_life_days,
    dp_epcssold.product_attributes,
    dp_epcssold.product_categories,
    dp_epcssold.consumer_category,
    dp_epcssold.product_source
   FROM public.dp_epcssold
  WHERE (dp_epcssold.ts > (now() - '28 days'::interval day));


ALTER TABLE public.dp_epcssold_4weeks OWNER TO dbservice;

--
-- Name: dp_epcssold_8weeks; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.dp_epcssold_8weeks AS
 SELECT dp_epcssold.order_id,
    dp_epcssold.first_name,
    dp_epcssold.last_name,
    dp_epcssold.kiosk_id,
    dp_epcssold.kiosk_title,
    dp_epcssold.email,
    dp_epcssold.amount_paid,
    dp_epcssold.payment_system,
    dp_epcssold.transaction_id,
    dp_epcssold.approval_code,
    dp_epcssold.status_code,
    dp_epcssold.status_message,
    dp_epcssold.status,
    dp_epcssold.batch_id,
    dp_epcssold.created,
    dp_epcssold.auth_amount,
    dp_epcssold.data_token,
    dp_epcssold.time_opened,
    dp_epcssold.time_closed,
    dp_epcssold.card_hash,
    dp_epcssold.state,
    dp_epcssold.archived,
    dp_epcssold.stamp,
    dp_epcssold.last_update,
    dp_epcssold.balance,
    dp_epcssold.delta,
    dp_epcssold.coupon_id,
    dp_epcssold.coupon,
    dp_epcssold.refund,
    dp_epcssold.receipt,
    dp_epcssold.campus_id,
    dp_epcssold.amount_list_price,
    dp_epcssold.notes,
    dp_epcssold.time_door_opened,
    dp_epcssold.time_door_closed,
    dp_epcssold.client_name,
    dp_epcssold.estd_num_users,
    dp_epcssold.ts,
    dp_epcssold.full_name,
    dp_epcssold.door_opened_secs,
    dp_epcssold.month,
    dp_epcssold.week,
    dp_epcssold.date,
    dp_epcssold.dayofweek,
    dp_epcssold.hour,
    dp_epcssold.dowhour,
    dp_epcssold.uniq_user,
    dp_epcssold.epc,
    dp_epcssold.label_order_id,
    dp_epcssold.label_status,
    dp_epcssold.label_price,
    dp_epcssold.time_created,
    dp_epcssold.time_added,
    dp_epcssold.time_updated,
    dp_epcssold.ts_created,
    dp_epcssold.ts_added,
    dp_epcssold.ts_updated,
    dp_epcssold.label_kiosk_id,
    dp_epcssold.product_id,
    dp_epcssold.product_title,
    dp_epcssold.product_archived,
    dp_epcssold.product_vendor,
    dp_epcssold.product_price,
    dp_epcssold.product_cost,
    dp_epcssold.product_shelf_life_days,
    dp_epcssold.product_attributes,
    dp_epcssold.product_categories,
    dp_epcssold.consumer_category,
    dp_epcssold.product_source
   FROM public.dp_epcssold
  WHERE (dp_epcssold.ts > (now() - '56 days'::interval day));


ALTER TABLE public.dp_epcssold_8weeks OWNER TO dbservice;

--
-- Name: dp_inventory_current; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.dp_inventory_current AS
 SELECT byte_inventory_current.kiosk_id,
    byte_inventory_current.product_id,
    byte_inventory_current.units
   FROM public.byte_inventory_current;


ALTER TABLE public.dp_inventory_current OWNER TO dbservice;

--
-- Name: dp_inventory_history; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.dp_inventory_history AS
 SELECT byte_inventory_history.month,
    byte_inventory_history.week,
    byte_inventory_history.date,
    byte_inventory_history.hour,
    byte_inventory_history.dayofweek,
    byte_inventory_history.ts,
    byte_inventory_history.product_id,
    byte_inventory_history.kiosk_id,
    byte_inventory_history.qty,
    byte_inventory_history.product_title,
    byte_inventory_history.kiosk_title
   FROM public.byte_inventory_history;


ALTER TABLE public.dp_inventory_history OWNER TO dbservice;

--
-- Name: dp_kiosks; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.dp_kiosks AS
 SELECT byte_kiosks.id,
    byte_kiosks.title,
    byte_kiosks.client_name,
    byte_kiosks.address,
    byte_kiosks.location_x,
    byte_kiosks.location_y,
    byte_kiosks.archived,
    to_timestamp((byte_kiosks.creation_time)::double precision) AS creation_ts,
    to_timestamp((byte_kiosks.deployment_time)::double precision) AS deployment_ts,
    byte_kiosks.timezone,
    byte_kiosks.estd_num_users
   FROM public.byte_kiosks;


ALTER TABLE public.dp_kiosks OWNER TO dbservice;

--
-- Name: dp_products; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.dp_products AS
 SELECT byte_products.id,
    byte_products.title,
    byte_products.vendor,
    byte_products.price,
    byte_products.cost,
    byte_products.shelf_life_days,
    byte_products.attributes,
    byte_products.categories
   FROM public.byte_products;


ALTER TABLE public.dp_products OWNER TO dbservice;

--
-- Name: dp_spoilage; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.dp_spoilage AS
 SELECT byte_spoilage.kiosk_id,
    byte_spoilage.order_id,
    byte_spoilage.epc,
    byte_spoilage.product_id,
    byte_spoilage.ts_added,
    byte_spoilage.ts_removed,
    byte_spoilage.id,
    byte_spoilage.title,
    byte_spoilage.description,
    byte_spoilage.tiny_description,
    byte_spoilage.short_description,
    byte_spoilage.medium_description,
    byte_spoilage.long_description,
    byte_spoilage.price,
    byte_spoilage.cost,
    byte_spoilage.shelf_time,
    byte_spoilage.campus_id,
    byte_spoilage.image,
    byte_spoilage.image_time,
    byte_spoilage.last_update,
    byte_spoilage.archived,
    byte_spoilage.taxable,
    byte_spoilage.allergens,
    byte_spoilage.attribute_names,
    byte_spoilage.categories,
    byte_spoilage.category_names,
    byte_spoilage.vendor,
    byte_spoilage.source,
    byte_spoilage.notes,
    byte_spoilage.total_cal,
    byte_spoilage.num_servings,
    byte_spoilage.ingredients,
    byte_spoilage.calories,
    byte_spoilage.proteins,
    byte_spoilage.sugar,
    byte_spoilage.carbohydrates,
    byte_spoilage.fat,
    byte_spoilage.consumer_category,
    byte_spoilage.ws_case_size,
    byte_spoilage.kiosk_ship_qty,
    byte_spoilage.ws_case_cost,
    byte_spoilage.pick_station,
    byte_spoilage.fc_title,
    byte_spoilage.pricing_tier,
    byte_spoilage.width_space,
    byte_spoilage.height_space,
    byte_spoilage.depth_space,
    byte_spoilage.slotted_width,
    byte_spoilage.tag_volume,
    byte_spoilage.delivery_option,
    byte_spoilage.kiosk_title,
    byte_spoilage.address,
    byte_spoilage.location_x,
    byte_spoilage.location_y,
    byte_spoilage.client_name,
    byte_spoilage.tags,
    byte_spoilage.estd_num_users,
    byte_spoilage.month,
    byte_spoilage.week,
    byte_spoilage.date
   FROM public.byte_spoilage;


ALTER TABLE public.dp_spoilage OWNER TO dbservice;

--
-- Name: dp_spoilage_2016; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.dp_spoilage_2016 AS
 SELECT dp_spoilage.kiosk_id,
    dp_spoilage.order_id,
    dp_spoilage.epc,
    dp_spoilage.product_id,
    dp_spoilage.ts_added,
    dp_spoilage.ts_removed,
    dp_spoilage.id,
    dp_spoilage.title,
    dp_spoilage.description,
    dp_spoilage.tiny_description,
    dp_spoilage.short_description,
    dp_spoilage.medium_description,
    dp_spoilage.long_description,
    dp_spoilage.price,
    dp_spoilage.cost,
    dp_spoilage.shelf_time,
    dp_spoilage.campus_id,
    dp_spoilage.image,
    dp_spoilage.image_time,
    dp_spoilage.last_update,
    dp_spoilage.archived,
    dp_spoilage.taxable,
    dp_spoilage.allergens,
    dp_spoilage.attribute_names,
    dp_spoilage.categories,
    dp_spoilage.category_names,
    dp_spoilage.vendor,
    dp_spoilage.source,
    dp_spoilage.notes,
    dp_spoilage.total_cal,
    dp_spoilage.num_servings,
    dp_spoilage.ingredients,
    dp_spoilage.calories,
    dp_spoilage.proteins,
    dp_spoilage.sugar,
    dp_spoilage.carbohydrates,
    dp_spoilage.fat,
    dp_spoilage.consumer_category,
    dp_spoilage.ws_case_size,
    dp_spoilage.kiosk_ship_qty,
    dp_spoilage.ws_case_cost,
    dp_spoilage.pick_station,
    dp_spoilage.fc_title,
    dp_spoilage.pricing_tier,
    dp_spoilage.width_space,
    dp_spoilage.height_space,
    dp_spoilage.depth_space,
    dp_spoilage.slotted_width,
    dp_spoilage.tag_volume,
    dp_spoilage.delivery_option,
    dp_spoilage.kiosk_title,
    dp_spoilage.address,
    dp_spoilage.location_x,
    dp_spoilage.location_y,
    dp_spoilage.client_name,
    dp_spoilage.tags,
    dp_spoilage.estd_num_users,
    dp_spoilage.month,
    dp_spoilage.week,
    dp_spoilage.date
   FROM public.dp_spoilage
  WHERE ((dp_spoilage.ts_removed >= '2016-01-01 08:00:00+00'::timestamp with time zone) AND (dp_spoilage.ts_removed <= '2017-01-01 08:00:00+00'::timestamp with time zone));


ALTER TABLE public.dp_spoilage_2016 OWNER TO dbservice;

--
-- Name: dp_spoilage_2017; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.dp_spoilage_2017 AS
 SELECT dp_spoilage.kiosk_id,
    dp_spoilage.order_id,
    dp_spoilage.epc,
    dp_spoilage.product_id,
    dp_spoilage.ts_added,
    dp_spoilage.ts_removed,
    dp_spoilage.id,
    dp_spoilage.title,
    dp_spoilage.description,
    dp_spoilage.tiny_description,
    dp_spoilage.short_description,
    dp_spoilage.medium_description,
    dp_spoilage.long_description,
    dp_spoilage.price,
    dp_spoilage.cost,
    dp_spoilage.shelf_time,
    dp_spoilage.campus_id,
    dp_spoilage.image,
    dp_spoilage.image_time,
    dp_spoilage.last_update,
    dp_spoilage.archived,
    dp_spoilage.taxable,
    dp_spoilage.allergens,
    dp_spoilage.attribute_names,
    dp_spoilage.categories,
    dp_spoilage.category_names,
    dp_spoilage.vendor,
    dp_spoilage.source,
    dp_spoilage.notes,
    dp_spoilage.total_cal,
    dp_spoilage.num_servings,
    dp_spoilage.ingredients,
    dp_spoilage.calories,
    dp_spoilage.proteins,
    dp_spoilage.sugar,
    dp_spoilage.carbohydrates,
    dp_spoilage.fat,
    dp_spoilage.consumer_category,
    dp_spoilage.ws_case_size,
    dp_spoilage.kiosk_ship_qty,
    dp_spoilage.ws_case_cost,
    dp_spoilage.pick_station,
    dp_spoilage.fc_title,
    dp_spoilage.pricing_tier,
    dp_spoilage.width_space,
    dp_spoilage.height_space,
    dp_spoilage.depth_space,
    dp_spoilage.slotted_width,
    dp_spoilage.tag_volume,
    dp_spoilage.delivery_option,
    dp_spoilage.kiosk_title,
    dp_spoilage.address,
    dp_spoilage.location_x,
    dp_spoilage.location_y,
    dp_spoilage.client_name,
    dp_spoilage.tags,
    dp_spoilage.estd_num_users,
    dp_spoilage.month,
    dp_spoilage.week,
    dp_spoilage.date
   FROM public.dp_spoilage
  WHERE ((dp_spoilage.ts_removed >= '2017-01-01 08:00:00+00'::timestamp with time zone) AND (dp_spoilage.ts_removed <= '2018-01-01 08:00:00+00'::timestamp with time zone));


ALTER TABLE public.dp_spoilage_2017 OWNER TO dbservice;

--
-- Name: dp_spoilage_4weeks; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.dp_spoilage_4weeks AS
 SELECT dp_spoilage.kiosk_id,
    dp_spoilage.order_id,
    dp_spoilage.epc,
    dp_spoilage.product_id,
    dp_spoilage.ts_added,
    dp_spoilage.ts_removed,
    dp_spoilage.id,
    dp_spoilage.title,
    dp_spoilage.description,
    dp_spoilage.tiny_description,
    dp_spoilage.short_description,
    dp_spoilage.medium_description,
    dp_spoilage.long_description,
    dp_spoilage.price,
    dp_spoilage.cost,
    dp_spoilage.shelf_time,
    dp_spoilage.campus_id,
    dp_spoilage.image,
    dp_spoilage.image_time,
    dp_spoilage.last_update,
    dp_spoilage.archived,
    dp_spoilage.taxable,
    dp_spoilage.allergens,
    dp_spoilage.attribute_names,
    dp_spoilage.categories,
    dp_spoilage.category_names,
    dp_spoilage.vendor,
    dp_spoilage.source,
    dp_spoilage.notes,
    dp_spoilage.total_cal,
    dp_spoilage.num_servings,
    dp_spoilage.ingredients,
    dp_spoilage.calories,
    dp_spoilage.proteins,
    dp_spoilage.sugar,
    dp_spoilage.carbohydrates,
    dp_spoilage.fat,
    dp_spoilage.consumer_category,
    dp_spoilage.ws_case_size,
    dp_spoilage.kiosk_ship_qty,
    dp_spoilage.ws_case_cost,
    dp_spoilage.pick_station,
    dp_spoilage.fc_title,
    dp_spoilage.pricing_tier,
    dp_spoilage.width_space,
    dp_spoilage.height_space,
    dp_spoilage.depth_space,
    dp_spoilage.slotted_width,
    dp_spoilage.tag_volume,
    dp_spoilage.delivery_option,
    dp_spoilage.kiosk_title,
    dp_spoilage.address,
    dp_spoilage.location_x,
    dp_spoilage.location_y,
    dp_spoilage.client_name,
    dp_spoilage.tags,
    dp_spoilage.estd_num_users,
    dp_spoilage.month,
    dp_spoilage.week,
    dp_spoilage.date
   FROM public.dp_spoilage
  WHERE (dp_spoilage.ts_removed > (now() - '28 days'::interval day));


ALTER TABLE public.dp_spoilage_4weeks OWNER TO dbservice;

--
-- Name: dp_spoilage_8weeks; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.dp_spoilage_8weeks AS
 SELECT dp_spoilage.kiosk_id,
    dp_spoilage.order_id,
    dp_spoilage.epc,
    dp_spoilage.product_id,
    dp_spoilage.ts_added,
    dp_spoilage.ts_removed,
    dp_spoilage.id,
    dp_spoilage.title,
    dp_spoilage.description,
    dp_spoilage.tiny_description,
    dp_spoilage.short_description,
    dp_spoilage.medium_description,
    dp_spoilage.long_description,
    dp_spoilage.price,
    dp_spoilage.cost,
    dp_spoilage.shelf_time,
    dp_spoilage.campus_id,
    dp_spoilage.image,
    dp_spoilage.image_time,
    dp_spoilage.last_update,
    dp_spoilage.archived,
    dp_spoilage.taxable,
    dp_spoilage.allergens,
    dp_spoilage.attribute_names,
    dp_spoilage.categories,
    dp_spoilage.category_names,
    dp_spoilage.vendor,
    dp_spoilage.source,
    dp_spoilage.notes,
    dp_spoilage.total_cal,
    dp_spoilage.num_servings,
    dp_spoilage.ingredients,
    dp_spoilage.calories,
    dp_spoilage.proteins,
    dp_spoilage.sugar,
    dp_spoilage.carbohydrates,
    dp_spoilage.fat,
    dp_spoilage.consumer_category,
    dp_spoilage.ws_case_size,
    dp_spoilage.kiosk_ship_qty,
    dp_spoilage.ws_case_cost,
    dp_spoilage.pick_station,
    dp_spoilage.fc_title,
    dp_spoilage.pricing_tier,
    dp_spoilage.width_space,
    dp_spoilage.height_space,
    dp_spoilage.depth_space,
    dp_spoilage.slotted_width,
    dp_spoilage.tag_volume,
    dp_spoilage.delivery_option,
    dp_spoilage.kiosk_title,
    dp_spoilage.address,
    dp_spoilage.location_x,
    dp_spoilage.location_y,
    dp_spoilage.client_name,
    dp_spoilage.tags,
    dp_spoilage.estd_num_users,
    dp_spoilage.month,
    dp_spoilage.week,
    dp_spoilage.date
   FROM public.dp_spoilage
  WHERE (dp_spoilage.ts_removed > (now() - '56 days'::interval day));


ALTER TABLE public.dp_spoilage_8weeks OWNER TO dbservice;

--
-- Name: dp_spoilage_daily_sold_join; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.dp_spoilage_daily_sold_join AS
 SELECT COALESCE(t1.date, t2.date) AS date,
    COALESCE((t1.kiosk_id)::bigint, t2.kiosk_id) AS kiosk_id,
    COALESCE((t1.product_id)::bigint, t2.product_id) AS product_id,
    COALESCE(t1.spoiled, (0)::bigint) AS spoiled,
    COALESCE(t2.sold, (0)::bigint) AS sold
   FROM (( SELECT s.date,
            s.kiosk_id,
            s.product_id,
            count(*) AS spoiled
           FROM public.dp_spoilage s
          GROUP BY s.date, s.kiosk_id, s.product_id) t1
     FULL JOIN ( SELECT dp_epcssold.date,
            dp_epcssold.kiosk_id,
            dp_epcssold.product_id,
            count(*) AS sold
           FROM public.dp_epcssold
          GROUP BY dp_epcssold.date, dp_epcssold.kiosk_id, dp_epcssold.product_id) t2 ON (((t1.product_id = t2.product_id) AND (t1.date = t2.date) AND (t1.kiosk_id = t2.kiosk_id))));


ALTER TABLE public.dp_spoilage_daily_sold_join OWNER TO dbservice;

--
-- Name: dp_spoilage_daily_kiosk_product_pct; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.dp_spoilage_daily_kiosk_product_pct AS
 SELECT t.date,
    t.kiosk_id,
    t.product_id,
    t.spoiled,
    t.sold,
    t.product_title,
    t.kiosk_title,
    t.unit_price,
    t.unit_cost,
    t.spoiled_frac_units,
    t.revenue,
    t.cost,
    t.spoilage_frac,
    t.new_kiosk,
    (t.revenue - t.cost) AS net_profit
   FROM ( SELECT dpssj.date,
            dpssj.kiosk_id,
            dpssj.product_id,
            dpssj.spoiled,
            dpssj.sold,
            p.title AS product_title,
            k.title AS kiosk_title,
            p.price AS unit_price,
            p.cost AS unit_cost,
            public.frac((dpssj.spoiled)::numeric, (dpssj.sold)::numeric) AS spoiled_frac_units,
            ((dpssj.sold)::numeric * p.price) AS revenue,
            (((dpssj.spoiled + dpssj.sold))::numeric * p.cost) AS cost,
            public.if((dpssj.sold = 0), (9999.0)::double precision, (div(((dpssj.spoiled)::numeric * p.cost), ((dpssj.sold)::numeric * p.price)))::double precision) AS spoilage_frac,
            (dpssj.date < COALESCE(knn.new_ts, now())) AS new_kiosk
           FROM (((public.dp_spoilage_daily_sold_join dpssj
             LEFT JOIN pantry.product p ON ((dpssj.product_id = p.id)))
             LEFT JOIN public.byte_kiosks k ON ((dpssj.kiosk_id = k.id)))
             LEFT JOIN public.byte_kiosks_date_non_new knn ON ((k.id = knn.kiosk_id)))
          WHERE (dpssj.date >= '2016-01-01 08:00:00+00'::timestamp with time zone)) t
  ORDER BY t.date DESC;


ALTER TABLE public.dp_spoilage_daily_kiosk_product_pct OWNER TO dbservice;

--
-- Name: dp_spoilage_daily_kiosk_pct; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.dp_spoilage_daily_kiosk_pct AS
 SELECT dp_spoilage_daily_kiosk_product_pct.date,
    dp_spoilage_daily_kiosk_product_pct.kiosk_id,
    sum(dp_spoilage_daily_kiosk_product_pct.spoiled) AS spoiled_units,
    sum(dp_spoilage_daily_kiosk_product_pct.sold) AS sold_units,
    public.frac(sum(dp_spoilage_daily_kiosk_product_pct.spoiled), sum(dp_spoilage_daily_kiosk_product_pct.sold)) AS spoiled_frac_units,
    sum(dp_spoilage_daily_kiosk_product_pct.revenue) AS revenue,
    sum(dp_spoilage_daily_kiosk_product_pct.cost) AS cost,
    sum(((dp_spoilage_daily_kiosk_product_pct.spoiled)::numeric * dp_spoilage_daily_kiosk_product_pct.unit_cost)) AS spoilage_dolr,
    sum(dp_spoilage_daily_kiosk_product_pct.net_profit) AS net_profit,
    public.if((sum(dp_spoilage_daily_kiosk_product_pct.sold) = (0)::numeric), 9999.0, (sum(((dp_spoilage_daily_kiosk_product_pct.spoiled)::numeric * dp_spoilage_daily_kiosk_product_pct.unit_cost)) / sum(dp_spoilage_daily_kiosk_product_pct.revenue))) AS spoilage_frac,
    min((dp_spoilage_daily_kiosk_product_pct.kiosk_title)::text) AS kiosk_title,
    bool_and(dp_spoilage_daily_kiosk_product_pct.new_kiosk) AS new_kiosk
   FROM public.dp_spoilage_daily_kiosk_product_pct
  GROUP BY dp_spoilage_daily_kiosk_product_pct.date, dp_spoilage_daily_kiosk_product_pct.kiosk_id
  ORDER BY dp_spoilage_daily_kiosk_product_pct.kiosk_id, dp_spoilage_daily_kiosk_product_pct.date DESC;


ALTER TABLE public.dp_spoilage_daily_kiosk_pct OWNER TO dbservice;

--
-- Name: dp_spoilage_daily_pct; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.dp_spoilage_daily_pct AS
 SELECT dp_spoilage_daily_kiosk_product_pct.date,
    dp_spoilage_daily_kiosk_product_pct.new_kiosk,
    sum(dp_spoilage_daily_kiosk_product_pct.spoiled) AS spoiled_units,
    sum(dp_spoilage_daily_kiosk_product_pct.sold) AS sold_units,
    public.frac(sum(dp_spoilage_daily_kiosk_product_pct.spoiled), sum(dp_spoilage_daily_kiosk_product_pct.sold)) AS spoiled_frac_units,
    sum(dp_spoilage_daily_kiosk_product_pct.revenue) AS revenue,
    sum(dp_spoilage_daily_kiosk_product_pct.cost) AS cost,
    sum(((dp_spoilage_daily_kiosk_product_pct.spoiled)::numeric * dp_spoilage_daily_kiosk_product_pct.unit_cost)) AS spoilage_dolr,
    sum((dp_spoilage_daily_kiosk_product_pct.revenue - dp_spoilage_daily_kiosk_product_pct.cost)) AS net_profit,
    public.if((sum(dp_spoilage_daily_kiosk_product_pct.sold) = (0)::numeric), 9999.0, (sum(((dp_spoilage_daily_kiosk_product_pct.spoiled)::numeric * dp_spoilage_daily_kiosk_product_pct.unit_cost)) / sum(dp_spoilage_daily_kiosk_product_pct.revenue))) AS spoilage_frac_dolr
   FROM public.dp_spoilage_daily_kiosk_product_pct
  GROUP BY dp_spoilage_daily_kiosk_product_pct.date, dp_spoilage_daily_kiosk_product_pct.new_kiosk
  ORDER BY dp_spoilage_daily_kiosk_product_pct.date DESC, dp_spoilage_daily_kiosk_product_pct.new_kiosk;


ALTER TABLE public.dp_spoilage_daily_pct OWNER TO dbservice;

--
-- Name: dp_spoilage_daily_product_pct; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.dp_spoilage_daily_product_pct AS
 SELECT dp_spoilage_daily_kiosk_product_pct.date,
    dp_spoilage_daily_kiosk_product_pct.product_id,
    dp_spoilage_daily_kiosk_product_pct.new_kiosk,
    sum(dp_spoilage_daily_kiosk_product_pct.spoiled) AS spoiled_units,
    sum(dp_spoilage_daily_kiosk_product_pct.sold) AS sold_units,
    public.frac(sum(dp_spoilage_daily_kiosk_product_pct.spoiled), sum(dp_spoilage_daily_kiosk_product_pct.sold)) AS spoiled_frac_units,
    sum(dp_spoilage_daily_kiosk_product_pct.revenue) AS revenue,
    sum(dp_spoilage_daily_kiosk_product_pct.cost) AS cost,
    sum(((dp_spoilage_daily_kiosk_product_pct.spoiled)::numeric * dp_spoilage_daily_kiosk_product_pct.unit_cost)) AS spoilage_dolr,
    sum(dp_spoilage_daily_kiosk_product_pct.net_profit) AS net_profit,
    public.if((sum(dp_spoilage_daily_kiosk_product_pct.sold) = (0)::numeric), 9999.0, (sum(((dp_spoilage_daily_kiosk_product_pct.spoiled)::numeric * dp_spoilage_daily_kiosk_product_pct.unit_cost)) / sum(dp_spoilage_daily_kiosk_product_pct.revenue))) AS spoilage_frac_dolr
   FROM public.dp_spoilage_daily_kiosk_product_pct
  GROUP BY dp_spoilage_daily_kiosk_product_pct.date, dp_spoilage_daily_kiosk_product_pct.product_id, dp_spoilage_daily_kiosk_product_pct.new_kiosk
  ORDER BY dp_spoilage_daily_kiosk_product_pct.product_id, dp_spoilage_daily_kiosk_product_pct.date DESC, dp_spoilage_daily_kiosk_product_pct.new_kiosk;


ALTER TABLE public.dp_spoilage_daily_product_pct OWNER TO dbservice;

--
-- Name: dp_spoilage_monthly_sold_join; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.dp_spoilage_monthly_sold_join AS
 SELECT COALESCE(t1.month, t2.month) AS month,
    COALESCE((t1.kiosk_id)::bigint, t2.kiosk_id) AS kiosk_id,
    COALESCE((t1.product_id)::bigint, t2.product_id) AS product_id,
    COALESCE(t1.spoiled, (0)::bigint) AS spoiled,
    COALESCE(t2.sold, (0)::bigint) AS sold
   FROM (( SELECT s.month,
            s.kiosk_id,
            s.product_id,
            count(*) AS spoiled
           FROM public.dp_spoilage s
          GROUP BY s.month, s.kiosk_id, s.product_id) t1
     FULL JOIN ( SELECT dp_epcssold.month,
            dp_epcssold.kiosk_id,
            dp_epcssold.product_id,
            count(*) AS sold
           FROM public.dp_epcssold
          GROUP BY dp_epcssold.month, dp_epcssold.kiosk_id, dp_epcssold.product_id) t2 ON (((t1.product_id = t2.product_id) AND (t1.month = t2.month) AND (t1.kiosk_id = t2.kiosk_id))));


ALTER TABLE public.dp_spoilage_monthly_sold_join OWNER TO dbservice;

--
-- Name: dp_spoilage_monthly_calc; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.dp_spoilage_monthly_calc AS
 SELECT dpssj.month,
    dpssj.kiosk_id,
    dpssj.product_id,
    dpssj.spoiled,
    dpssj.sold,
    p.title AS product_title,
    k.title AS kiosk_title,
    p.price AS unit_price,
    p.cost AS unit_cost,
    public.frac((dpssj.spoiled)::numeric, (dpssj.sold)::numeric) AS spoiled_frac_units,
    ((dpssj.sold)::numeric * p.price) AS revenue,
    (((dpssj.spoiled + dpssj.sold))::numeric * p.cost) AS cost,
    public.if((dpssj.sold = 0), 9999.0, (((1.0 * (dpssj.spoiled)::numeric) * p.cost) / ((dpssj.sold)::numeric * p.price))) AS spoilage_frac,
    (dpssj.month < knn.new_ts) AS new_kiosk
   FROM (((public.dp_spoilage_monthly_sold_join dpssj
     JOIN pantry.product p ON ((dpssj.product_id = p.id)))
     JOIN public.byte_kiosks k ON ((dpssj.kiosk_id = k.id)))
     JOIN public.byte_kiosks_date_non_new knn ON ((k.id = knn.kiosk_id)))
  WHERE (dpssj.month >= '2016-01-01 08:00:00+00'::timestamp with time zone)
  ORDER BY dpssj.month DESC;


ALTER TABLE public.dp_spoilage_monthly_calc OWNER TO dbservice;

--
-- Name: dp_spoilage_monthly_kiosk_product_pct; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.dp_spoilage_monthly_kiosk_product_pct AS
 SELECT dp_spoilage_monthly_calc.month,
    dp_spoilage_monthly_calc.kiosk_id,
    dp_spoilage_monthly_calc.product_id,
    dp_spoilage_monthly_calc.spoiled,
    dp_spoilage_monthly_calc.sold,
    dp_spoilage_monthly_calc.product_title,
    dp_spoilage_monthly_calc.kiosk_title,
    dp_spoilage_monthly_calc.unit_price,
    dp_spoilage_monthly_calc.unit_cost,
    dp_spoilage_monthly_calc.spoiled_frac_units,
    dp_spoilage_monthly_calc.revenue,
    dp_spoilage_monthly_calc.cost,
    dp_spoilage_monthly_calc.spoilage_frac,
    dp_spoilage_monthly_calc.new_kiosk,
    (dp_spoilage_monthly_calc.revenue - dp_spoilage_monthly_calc.cost) AS net_profit
   FROM public.dp_spoilage_monthly_calc;


ALTER TABLE public.dp_spoilage_monthly_kiosk_product_pct OWNER TO dbservice;

--
-- Name: dp_spoilage_monthly_kiosk_pct; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.dp_spoilage_monthly_kiosk_pct AS
 SELECT dp_spoilage_monthly_kiosk_product_pct.month,
    dp_spoilage_monthly_kiosk_product_pct.kiosk_id,
    sum(dp_spoilage_monthly_kiosk_product_pct.spoiled) AS spoiled_units,
    sum(dp_spoilage_monthly_kiosk_product_pct.sold) AS sold_units,
    public.frac(sum(dp_spoilage_monthly_kiosk_product_pct.spoiled), sum(dp_spoilage_monthly_kiosk_product_pct.sold)) AS spoiled_frac_units,
    sum(dp_spoilage_monthly_kiosk_product_pct.revenue) AS revenue,
    sum(dp_spoilage_monthly_kiosk_product_pct.cost) AS cost,
    sum(((dp_spoilage_monthly_kiosk_product_pct.spoiled)::numeric * dp_spoilage_monthly_kiosk_product_pct.unit_cost)) AS spoilage_dolr,
    sum(dp_spoilage_monthly_kiosk_product_pct.net_profit) AS net_profit,
    public.if((sum(dp_spoilage_monthly_kiosk_product_pct.sold) = (0)::numeric), 9999.0, (sum(((dp_spoilage_monthly_kiosk_product_pct.spoiled)::numeric * dp_spoilage_monthly_kiosk_product_pct.unit_cost)) / sum(dp_spoilage_monthly_kiosk_product_pct.revenue))) AS spoilage_frac_dolr
   FROM public.dp_spoilage_monthly_kiosk_product_pct
  GROUP BY dp_spoilage_monthly_kiosk_product_pct.month, dp_spoilage_monthly_kiosk_product_pct.kiosk_id
  ORDER BY dp_spoilage_monthly_kiosk_product_pct.kiosk_id, dp_spoilage_monthly_kiosk_product_pct.month DESC;


ALTER TABLE public.dp_spoilage_monthly_kiosk_pct OWNER TO dbservice;

--
-- Name: dp_spoilage_monthly_pct; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.dp_spoilage_monthly_pct AS
 SELECT dp_spoilage_monthly_kiosk_product_pct.month,
    sum(dp_spoilage_monthly_kiosk_product_pct.spoiled) AS spoiled_units,
    sum(dp_spoilage_monthly_kiosk_product_pct.sold) AS sold_units,
    public.frac(sum(dp_spoilage_monthly_kiosk_product_pct.spoiled), sum(dp_spoilage_monthly_kiosk_product_pct.sold)) AS spoiled_frac_units,
    sum(dp_spoilage_monthly_kiosk_product_pct.revenue) AS revenue,
    sum(dp_spoilage_monthly_kiosk_product_pct.cost) AS cost,
    sum(((dp_spoilage_monthly_kiosk_product_pct.spoiled)::numeric * dp_spoilage_monthly_kiosk_product_pct.unit_cost)) AS spoilage_dolr,
    sum(dp_spoilage_monthly_kiosk_product_pct.net_profit) AS net_profit,
    (sum(((dp_spoilage_monthly_kiosk_product_pct.spoiled)::numeric * dp_spoilage_monthly_kiosk_product_pct.unit_cost)) / sum(((dp_spoilage_monthly_kiosk_product_pct.sold)::numeric * dp_spoilage_monthly_kiosk_product_pct.unit_price))) AS spoilage_frac_dolr
   FROM public.dp_spoilage_monthly_kiosk_product_pct
  GROUP BY dp_spoilage_monthly_kiosk_product_pct.month
  ORDER BY dp_spoilage_monthly_kiosk_product_pct.month DESC;


ALTER TABLE public.dp_spoilage_monthly_pct OWNER TO dbservice;

--
-- Name: dp_spoilage_monthly_product_pct; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.dp_spoilage_monthly_product_pct AS
 SELECT dp_spoilage_monthly_kiosk_product_pct.month,
    dp_spoilage_monthly_kiosk_product_pct.product_id,
    sum(dp_spoilage_monthly_kiosk_product_pct.spoiled) AS spoiled_units,
    sum(dp_spoilage_monthly_kiosk_product_pct.sold) AS sold_units,
    public.frac(sum(dp_spoilage_monthly_kiosk_product_pct.spoiled), sum(dp_spoilage_monthly_kiosk_product_pct.sold)) AS spoiled_frac_units,
    sum(dp_spoilage_monthly_kiosk_product_pct.revenue) AS revenue,
    sum(dp_spoilage_monthly_kiosk_product_pct.cost) AS cost,
    sum(((dp_spoilage_monthly_kiosk_product_pct.spoiled)::numeric * dp_spoilage_monthly_kiosk_product_pct.unit_cost)) AS spoilage_dolr,
    sum(dp_spoilage_monthly_kiosk_product_pct.net_profit) AS net_profit,
    public.if((sum(dp_spoilage_monthly_kiosk_product_pct.sold) = (0)::numeric), 9999.0, (sum(((dp_spoilage_monthly_kiosk_product_pct.spoiled)::numeric * dp_spoilage_monthly_kiosk_product_pct.unit_cost)) / sum(dp_spoilage_monthly_kiosk_product_pct.revenue))) AS spoilage_frac_dolr
   FROM public.dp_spoilage_monthly_kiosk_product_pct
  GROUP BY dp_spoilage_monthly_kiosk_product_pct.month, dp_spoilage_monthly_kiosk_product_pct.product_id
  ORDER BY dp_spoilage_monthly_kiosk_product_pct.product_id, dp_spoilage_monthly_kiosk_product_pct.month DESC;


ALTER TABLE public.dp_spoilage_monthly_product_pct OWNER TO dbservice;

--
-- Name: dp_spoilage_weekly_sold_join; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.dp_spoilage_weekly_sold_join AS
 SELECT date_trunc('week'::text, dp_spoilage_daily_sold_join.date) AS week,
    dp_spoilage_daily_sold_join.kiosk_id,
    dp_spoilage_daily_sold_join.product_id,
    sum(dp_spoilage_daily_sold_join.spoiled) AS spoiled,
    sum(dp_spoilage_daily_sold_join.sold) AS sold,
    count(DISTINCT dp_spoilage_daily_sold_join.date) AS days_in_week
   FROM public.dp_spoilage_daily_sold_join
  GROUP BY (date_trunc('week'::text, dp_spoilage_daily_sold_join.date)), dp_spoilage_daily_sold_join.kiosk_id, dp_spoilage_daily_sold_join.product_id;


ALTER TABLE public.dp_spoilage_weekly_sold_join OWNER TO dbservice;

--
-- Name: dp_spoilage_weekly_kiosk_product_pct; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.dp_spoilage_weekly_kiosk_product_pct AS
 SELECT t.week,
    t.kiosk_id,
    t.product_id,
    t.spoiled,
    t.sold,
    t.days_in_week,
    t.product_title,
    t.kiosk_title,
    t.unit_price,
    t.unit_cost,
    t.spoiled_frac_units,
    t.revenue,
    t.cost,
    t.spoilage_frac,
    t.new_kiosk,
    (t.revenue - t.cost) AS net_profit
   FROM ( SELECT dpssj.week,
            dpssj.kiosk_id,
            dpssj.product_id,
            dpssj.spoiled,
            dpssj.sold,
            dpssj.days_in_week,
            p.title AS product_title,
            k.title AS kiosk_title,
            p.price AS unit_price,
            p.cost AS unit_cost,
            public.frac(dpssj.spoiled, dpssj.sold) AS spoiled_frac_units,
            (dpssj.sold * p.price) AS revenue,
            ((dpssj.spoiled + dpssj.sold) * p.cost) AS cost,
            public.if((dpssj.sold = (0)::numeric), (9999.0)::double precision, (div((dpssj.spoiled * p.cost), (dpssj.sold * p.price)))::double precision) AS spoilage_frac,
            (dpssj.week < knn.new_ts) AS new_kiosk
           FROM (((public.dp_spoilage_weekly_sold_join dpssj
             JOIN pantry.product p ON ((dpssj.product_id = p.id)))
             JOIN public.byte_kiosks k ON ((dpssj.kiosk_id = k.id)))
             JOIN public.byte_kiosks_date_non_new knn ON ((k.id = knn.kiosk_id)))
          WHERE (dpssj.week >= '2016-01-01 08:00:00+00'::timestamp with time zone)) t
  ORDER BY t.week DESC;


ALTER TABLE public.dp_spoilage_weekly_kiosk_product_pct OWNER TO dbservice;

--
-- Name: dp_spoilage_weekly_kiosk_pct; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.dp_spoilage_weekly_kiosk_pct AS
 SELECT dp_spoilage_weekly_kiosk_product_pct.week,
    dp_spoilage_weekly_kiosk_product_pct.kiosk_id,
    sum(dp_spoilage_weekly_kiosk_product_pct.spoiled) AS spoiled_units,
    sum(dp_spoilage_weekly_kiosk_product_pct.sold) AS sold_units,
    public.frac(sum(dp_spoilage_weekly_kiosk_product_pct.spoiled), sum(dp_spoilage_weekly_kiosk_product_pct.sold)) AS spoiled_frac_units,
    sum(dp_spoilage_weekly_kiosk_product_pct.revenue) AS revenue,
    sum(dp_spoilage_weekly_kiosk_product_pct.cost) AS cost,
    sum((dp_spoilage_weekly_kiosk_product_pct.spoiled * dp_spoilage_weekly_kiosk_product_pct.unit_cost)) AS spoilage_dolr,
    sum(dp_spoilage_weekly_kiosk_product_pct.net_profit) AS net_profit,
    public.if((sum(dp_spoilage_weekly_kiosk_product_pct.sold) = (0)::numeric), 9999.0, (sum((dp_spoilage_weekly_kiosk_product_pct.spoiled * dp_spoilage_weekly_kiosk_product_pct.unit_cost)) / sum(dp_spoilage_weekly_kiosk_product_pct.revenue))) AS spoilage_frac,
    min((dp_spoilage_weekly_kiosk_product_pct.kiosk_title)::text) AS kiosk_title,
    bool_and(dp_spoilage_weekly_kiosk_product_pct.new_kiosk) AS new_kiosk
   FROM public.dp_spoilage_weekly_kiosk_product_pct
  GROUP BY dp_spoilage_weekly_kiosk_product_pct.week, dp_spoilage_weekly_kiosk_product_pct.kiosk_id
  ORDER BY dp_spoilage_weekly_kiosk_product_pct.kiosk_id, dp_spoilage_weekly_kiosk_product_pct.week DESC;


ALTER TABLE public.dp_spoilage_weekly_kiosk_pct OWNER TO dbservice;

--
-- Name: dp_spoilage_weekly_pct; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.dp_spoilage_weekly_pct AS
 SELECT dp_spoilage_weekly_kiosk_product_pct.week,
    dp_spoilage_weekly_kiosk_product_pct.new_kiosk,
    sum(dp_spoilage_weekly_kiosk_product_pct.spoiled) AS spoiled_units,
    sum(dp_spoilage_weekly_kiosk_product_pct.sold) AS sold_units,
    public.frac(sum(dp_spoilage_weekly_kiosk_product_pct.spoiled), sum(dp_spoilage_weekly_kiosk_product_pct.sold)) AS spoiled_frac_units,
    sum(dp_spoilage_weekly_kiosk_product_pct.revenue) AS revenue,
    sum(dp_spoilage_weekly_kiosk_product_pct.cost) AS cost,
    sum((dp_spoilage_weekly_kiosk_product_pct.spoiled * dp_spoilage_weekly_kiosk_product_pct.unit_cost)) AS spoilage_dolr,
    sum(dp_spoilage_weekly_kiosk_product_pct.net_profit) AS net_profit,
    public.if((sum(dp_spoilage_weekly_kiosk_product_pct.sold) = (0)::numeric), 9999.0, (sum((dp_spoilage_weekly_kiosk_product_pct.spoiled * dp_spoilage_weekly_kiosk_product_pct.unit_cost)) / sum(dp_spoilage_weekly_kiosk_product_pct.revenue))) AS spoilage_frac_dolr
   FROM public.dp_spoilage_weekly_kiosk_product_pct
  GROUP BY dp_spoilage_weekly_kiosk_product_pct.week, dp_spoilage_weekly_kiosk_product_pct.new_kiosk
  ORDER BY dp_spoilage_weekly_kiosk_product_pct.week DESC, dp_spoilage_weekly_kiosk_product_pct.new_kiosk;


ALTER TABLE public.dp_spoilage_weekly_pct OWNER TO dbservice;

--
-- Name: dp_spoilage_weekly_product_pct; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.dp_spoilage_weekly_product_pct AS
 SELECT dp_spoilage_weekly_kiosk_product_pct.week,
    dp_spoilage_weekly_kiosk_product_pct.product_id,
    dp_spoilage_weekly_kiosk_product_pct.new_kiosk,
    sum(dp_spoilage_weekly_kiosk_product_pct.spoiled) AS spoiled_units,
    sum(dp_spoilage_weekly_kiosk_product_pct.sold) AS sold_units,
    public.frac(sum(dp_spoilage_weekly_kiosk_product_pct.spoiled), sum(dp_spoilage_weekly_kiosk_product_pct.sold)) AS spoiled_frac_units,
    sum(dp_spoilage_weekly_kiosk_product_pct.revenue) AS revenue,
    sum(dp_spoilage_weekly_kiosk_product_pct.cost) AS cost,
    sum((dp_spoilage_weekly_kiosk_product_pct.spoiled * dp_spoilage_weekly_kiosk_product_pct.unit_cost)) AS spoilage_dolr,
    sum(dp_spoilage_weekly_kiosk_product_pct.net_profit) AS net_profit,
    public.if((sum(dp_spoilage_weekly_kiosk_product_pct.sold) = (0)::numeric), 9999.0, (sum((dp_spoilage_weekly_kiosk_product_pct.spoiled * dp_spoilage_weekly_kiosk_product_pct.unit_cost)) / sum(dp_spoilage_weekly_kiosk_product_pct.revenue))) AS spoilage_frac_dolr
   FROM public.dp_spoilage_weekly_kiosk_product_pct
  GROUP BY dp_spoilage_weekly_kiosk_product_pct.week, dp_spoilage_weekly_kiosk_product_pct.product_id, dp_spoilage_weekly_kiosk_product_pct.new_kiosk
  ORDER BY dp_spoilage_weekly_kiosk_product_pct.product_id, dp_spoilage_weekly_kiosk_product_pct.week DESC, dp_spoilage_weekly_kiosk_product_pct.new_kiosk;


ALTER TABLE public.dp_spoilage_weekly_product_pct OWNER TO dbservice;

--
-- Name: dp_stockouts; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.dp_stockouts AS
 SELECT byte_stockouts.kiosk_id,
    byte_stockouts.order_id,
    byte_stockouts.product_id,
    byte_stockouts.ts,
    byte_stockouts.restock_ts,
    byte_stockouts.restock_order_id,
    byte_stockouts.id,
    byte_stockouts.title,
    byte_stockouts.description,
    byte_stockouts.tiny_description,
    byte_stockouts.short_description,
    byte_stockouts.medium_description,
    byte_stockouts.long_description,
    byte_stockouts.price,
    byte_stockouts.cost,
    byte_stockouts.shelf_time,
    byte_stockouts.campus_id,
    byte_stockouts.image,
    byte_stockouts.image_time,
    byte_stockouts.last_update,
    byte_stockouts.archived,
    byte_stockouts.taxable,
    byte_stockouts.allergens,
    byte_stockouts.attribute_names,
    byte_stockouts.categories,
    byte_stockouts.category_names,
    byte_stockouts.vendor,
    byte_stockouts.source,
    byte_stockouts.notes,
    byte_stockouts.total_cal,
    byte_stockouts.num_servings,
    byte_stockouts.ingredients,
    byte_stockouts.calories,
    byte_stockouts.proteins,
    byte_stockouts.sugar,
    byte_stockouts.carbohydrates,
    byte_stockouts.fat,
    byte_stockouts.consumer_category,
    byte_stockouts.ws_case_size,
    byte_stockouts.kiosk_ship_qty,
    byte_stockouts.ws_case_cost,
    byte_stockouts.pick_station,
    byte_stockouts.fc_title,
    byte_stockouts.pricing_tier,
    byte_stockouts.width_space,
    byte_stockouts.height_space,
    byte_stockouts.depth_space,
    byte_stockouts.slotted_width,
    byte_stockouts.tag_volume,
    byte_stockouts.delivery_option,
    byte_stockouts.kiosk_title,
    byte_stockouts.address,
    byte_stockouts.location_x,
    byte_stockouts.location_y,
    byte_stockouts.client_name,
    byte_stockouts.tags,
    byte_stockouts.estd_num_users,
    byte_stockouts.month,
    byte_stockouts.week,
    byte_stockouts.date
   FROM public.byte_stockouts;


ALTER TABLE public.dp_stockouts OWNER TO dbservice;

--
-- Name: dp_stockouts_2016; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.dp_stockouts_2016 AS
 SELECT dp_stockouts.kiosk_id,
    dp_stockouts.order_id,
    dp_stockouts.product_id,
    dp_stockouts.ts,
    dp_stockouts.restock_ts,
    dp_stockouts.restock_order_id,
    dp_stockouts.id,
    dp_stockouts.title,
    dp_stockouts.description,
    dp_stockouts.tiny_description,
    dp_stockouts.short_description,
    dp_stockouts.medium_description,
    dp_stockouts.long_description,
    dp_stockouts.price,
    dp_stockouts.cost,
    dp_stockouts.shelf_time,
    dp_stockouts.campus_id,
    dp_stockouts.image,
    dp_stockouts.image_time,
    dp_stockouts.last_update,
    dp_stockouts.archived,
    dp_stockouts.taxable,
    dp_stockouts.allergens,
    dp_stockouts.attribute_names,
    dp_stockouts.categories,
    dp_stockouts.category_names,
    dp_stockouts.vendor,
    dp_stockouts.source,
    dp_stockouts.notes,
    dp_stockouts.total_cal,
    dp_stockouts.num_servings,
    dp_stockouts.ingredients,
    dp_stockouts.calories,
    dp_stockouts.proteins,
    dp_stockouts.sugar,
    dp_stockouts.carbohydrates,
    dp_stockouts.fat,
    dp_stockouts.consumer_category,
    dp_stockouts.ws_case_size,
    dp_stockouts.kiosk_ship_qty,
    dp_stockouts.ws_case_cost,
    dp_stockouts.pick_station,
    dp_stockouts.fc_title,
    dp_stockouts.pricing_tier,
    dp_stockouts.width_space,
    dp_stockouts.height_space,
    dp_stockouts.depth_space,
    dp_stockouts.slotted_width,
    dp_stockouts.tag_volume,
    dp_stockouts.delivery_option,
    dp_stockouts.kiosk_title,
    dp_stockouts.address,
    dp_stockouts.location_x,
    dp_stockouts.location_y,
    dp_stockouts.client_name,
    dp_stockouts.tags,
    dp_stockouts.estd_num_users,
    dp_stockouts.month,
    dp_stockouts.week,
    dp_stockouts.date
   FROM public.dp_stockouts
  WHERE ((dp_stockouts.ts >= '2016-01-01 08:00:00+00'::timestamp with time zone) AND (dp_stockouts.ts <= '2017-01-01 08:00:00+00'::timestamp with time zone));


ALTER TABLE public.dp_stockouts_2016 OWNER TO dbservice;

--
-- Name: dp_stockouts_2017; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.dp_stockouts_2017 AS
 SELECT dp_stockouts.kiosk_id,
    dp_stockouts.order_id,
    dp_stockouts.product_id,
    dp_stockouts.ts,
    dp_stockouts.restock_ts,
    dp_stockouts.restock_order_id,
    dp_stockouts.id,
    dp_stockouts.title,
    dp_stockouts.description,
    dp_stockouts.tiny_description,
    dp_stockouts.short_description,
    dp_stockouts.medium_description,
    dp_stockouts.long_description,
    dp_stockouts.price,
    dp_stockouts.cost,
    dp_stockouts.shelf_time,
    dp_stockouts.campus_id,
    dp_stockouts.image,
    dp_stockouts.image_time,
    dp_stockouts.last_update,
    dp_stockouts.archived,
    dp_stockouts.taxable,
    dp_stockouts.allergens,
    dp_stockouts.attribute_names,
    dp_stockouts.categories,
    dp_stockouts.category_names,
    dp_stockouts.vendor,
    dp_stockouts.source,
    dp_stockouts.notes,
    dp_stockouts.total_cal,
    dp_stockouts.num_servings,
    dp_stockouts.ingredients,
    dp_stockouts.calories,
    dp_stockouts.proteins,
    dp_stockouts.sugar,
    dp_stockouts.carbohydrates,
    dp_stockouts.fat,
    dp_stockouts.consumer_category,
    dp_stockouts.ws_case_size,
    dp_stockouts.kiosk_ship_qty,
    dp_stockouts.ws_case_cost,
    dp_stockouts.pick_station,
    dp_stockouts.fc_title,
    dp_stockouts.pricing_tier,
    dp_stockouts.width_space,
    dp_stockouts.height_space,
    dp_stockouts.depth_space,
    dp_stockouts.slotted_width,
    dp_stockouts.tag_volume,
    dp_stockouts.delivery_option,
    dp_stockouts.kiosk_title,
    dp_stockouts.address,
    dp_stockouts.location_x,
    dp_stockouts.location_y,
    dp_stockouts.client_name,
    dp_stockouts.tags,
    dp_stockouts.estd_num_users,
    dp_stockouts.month,
    dp_stockouts.week,
    dp_stockouts.date
   FROM public.dp_stockouts
  WHERE ((dp_stockouts.ts >= '2017-01-01 08:00:00+00'::timestamp with time zone) AND (dp_stockouts.ts <= '2018-01-01 08:00:00+00'::timestamp with time zone));


ALTER TABLE public.dp_stockouts_2017 OWNER TO dbservice;

--
-- Name: dp_stockouts_4weeks; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.dp_stockouts_4weeks AS
 SELECT dp_stockouts.kiosk_id,
    dp_stockouts.order_id,
    dp_stockouts.product_id,
    dp_stockouts.ts,
    dp_stockouts.restock_ts,
    dp_stockouts.restock_order_id,
    dp_stockouts.id,
    dp_stockouts.title,
    dp_stockouts.description,
    dp_stockouts.tiny_description,
    dp_stockouts.short_description,
    dp_stockouts.medium_description,
    dp_stockouts.long_description,
    dp_stockouts.price,
    dp_stockouts.cost,
    dp_stockouts.shelf_time,
    dp_stockouts.campus_id,
    dp_stockouts.image,
    dp_stockouts.image_time,
    dp_stockouts.last_update,
    dp_stockouts.archived,
    dp_stockouts.taxable,
    dp_stockouts.allergens,
    dp_stockouts.attribute_names,
    dp_stockouts.categories,
    dp_stockouts.category_names,
    dp_stockouts.vendor,
    dp_stockouts.source,
    dp_stockouts.notes,
    dp_stockouts.total_cal,
    dp_stockouts.num_servings,
    dp_stockouts.ingredients,
    dp_stockouts.calories,
    dp_stockouts.proteins,
    dp_stockouts.sugar,
    dp_stockouts.carbohydrates,
    dp_stockouts.fat,
    dp_stockouts.consumer_category,
    dp_stockouts.ws_case_size,
    dp_stockouts.kiosk_ship_qty,
    dp_stockouts.ws_case_cost,
    dp_stockouts.pick_station,
    dp_stockouts.fc_title,
    dp_stockouts.pricing_tier,
    dp_stockouts.width_space,
    dp_stockouts.height_space,
    dp_stockouts.depth_space,
    dp_stockouts.slotted_width,
    dp_stockouts.tag_volume,
    dp_stockouts.delivery_option,
    dp_stockouts.kiosk_title,
    dp_stockouts.address,
    dp_stockouts.location_x,
    dp_stockouts.location_y,
    dp_stockouts.client_name,
    dp_stockouts.tags,
    dp_stockouts.estd_num_users,
    dp_stockouts.month,
    dp_stockouts.week,
    dp_stockouts.date
   FROM public.dp_stockouts
  WHERE (dp_stockouts.ts > (now() - '28 days'::interval day));


ALTER TABLE public.dp_stockouts_4weeks OWNER TO dbservice;

--
-- Name: dp_stockouts_8weeks; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.dp_stockouts_8weeks AS
 SELECT dp_stockouts.kiosk_id,
    dp_stockouts.order_id,
    dp_stockouts.product_id,
    dp_stockouts.ts,
    dp_stockouts.restock_ts,
    dp_stockouts.restock_order_id,
    dp_stockouts.id,
    dp_stockouts.title,
    dp_stockouts.description,
    dp_stockouts.tiny_description,
    dp_stockouts.short_description,
    dp_stockouts.medium_description,
    dp_stockouts.long_description,
    dp_stockouts.price,
    dp_stockouts.cost,
    dp_stockouts.shelf_time,
    dp_stockouts.campus_id,
    dp_stockouts.image,
    dp_stockouts.image_time,
    dp_stockouts.last_update,
    dp_stockouts.archived,
    dp_stockouts.taxable,
    dp_stockouts.allergens,
    dp_stockouts.attribute_names,
    dp_stockouts.categories,
    dp_stockouts.category_names,
    dp_stockouts.vendor,
    dp_stockouts.source,
    dp_stockouts.notes,
    dp_stockouts.total_cal,
    dp_stockouts.num_servings,
    dp_stockouts.ingredients,
    dp_stockouts.calories,
    dp_stockouts.proteins,
    dp_stockouts.sugar,
    dp_stockouts.carbohydrates,
    dp_stockouts.fat,
    dp_stockouts.consumer_category,
    dp_stockouts.ws_case_size,
    dp_stockouts.kiosk_ship_qty,
    dp_stockouts.ws_case_cost,
    dp_stockouts.pick_station,
    dp_stockouts.fc_title,
    dp_stockouts.pricing_tier,
    dp_stockouts.width_space,
    dp_stockouts.height_space,
    dp_stockouts.depth_space,
    dp_stockouts.slotted_width,
    dp_stockouts.tag_volume,
    dp_stockouts.delivery_option,
    dp_stockouts.kiosk_title,
    dp_stockouts.address,
    dp_stockouts.location_x,
    dp_stockouts.location_y,
    dp_stockouts.client_name,
    dp_stockouts.tags,
    dp_stockouts.estd_num_users,
    dp_stockouts.month,
    dp_stockouts.week,
    dp_stockouts.date
   FROM public.dp_stockouts
  WHERE (dp_stockouts.ts > (now() - '56 days'::interval day));


ALTER TABLE public.dp_stockouts_8weeks OWNER TO dbservice;

--
-- Name: dp_stockouts_weekly_sold_join; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.dp_stockouts_weekly_sold_join AS
 SELECT COALESCE(t1.week, t2.week) AS week,
    COALESCE((t1.kiosk_id)::bigint, t2.kiosk_id) AS kiosk_id,
    COALESCE((t1.product_id)::bigint, t2.product_id) AS product_id,
    COALESCE(t1.spoiled, (0)::bigint) AS spoiled,
    COALESCE(t2.sold, (0)::bigint) AS sold,
    t2.days_in_week
   FROM (( SELECT s.week,
            s.kiosk_id,
            s.product_id,
            count(*) AS spoiled
           FROM public.dp_stockouts s
          GROUP BY s.week, s.kiosk_id, s.product_id) t1
     FULL JOIN ( SELECT dp_epcssold.week,
            dp_epcssold.kiosk_id,
            dp_epcssold.product_id,
            count(DISTINCT dp_epcssold.date) AS days_in_week,
            count(*) AS sold
           FROM public.dp_epcssold
          GROUP BY dp_epcssold.week, dp_epcssold.kiosk_id, dp_epcssold.product_id) t2 ON (((t1.product_id = t2.product_id) AND (t1.week = t2.week) AND (t1.kiosk_id = t2.kiosk_id))));


ALTER TABLE public.dp_stockouts_weekly_sold_join OWNER TO dbservice;

--
-- Name: dp_stockouts_weekly_calc; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.dp_stockouts_weekly_calc AS
 SELECT dpssj.week,
    dpssj.kiosk_id,
    dpssj.product_id,
    dpssj.spoiled,
    dpssj.sold,
    dpssj.days_in_week,
    p.title AS product_title,
    k.title AS kiosk_title,
    p.price AS unit_price,
    p.cost AS unit_cost,
    public.frac((dpssj.spoiled)::numeric, (dpssj.sold)::numeric) AS spoiled_frac_units,
    ((dpssj.sold)::numeric * p.price) AS revenue,
    (((dpssj.spoiled + dpssj.sold))::numeric * p.cost) AS cost,
    public.if((dpssj.sold = 0), 9999.0, div(((dpssj.spoiled)::numeric * p.cost), ((dpssj.sold)::numeric * p.price))) AS stockouts_frac,
    (dpssj.week < knn.new_ts) AS new_kiosk
   FROM (((public.dp_stockouts_weekly_sold_join dpssj
     JOIN pantry.product p ON ((dpssj.product_id = p.id)))
     JOIN public.byte_kiosks k ON ((dpssj.kiosk_id = k.id)))
     JOIN public.byte_kiosks_date_non_new knn ON ((k.id = knn.kiosk_id)))
  WHERE (dpssj.week >= '2016-01-01 08:00:00+00'::timestamp with time zone)
  ORDER BY dpssj.week DESC;


ALTER TABLE public.dp_stockouts_weekly_calc OWNER TO dbservice;

--
-- Name: dp_stockouts_weekly_kiosk_product_pct; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.dp_stockouts_weekly_kiosk_product_pct AS
 SELECT dp_stockouts_weekly_calc.week,
    dp_stockouts_weekly_calc.kiosk_id,
    dp_stockouts_weekly_calc.product_id,
    dp_stockouts_weekly_calc.spoiled,
    dp_stockouts_weekly_calc.sold,
    dp_stockouts_weekly_calc.days_in_week,
    dp_stockouts_weekly_calc.product_title,
    dp_stockouts_weekly_calc.kiosk_title,
    dp_stockouts_weekly_calc.unit_price,
    dp_stockouts_weekly_calc.unit_cost,
    dp_stockouts_weekly_calc.spoiled_frac_units,
    dp_stockouts_weekly_calc.revenue,
    dp_stockouts_weekly_calc.cost,
    dp_stockouts_weekly_calc.stockouts_frac,
    dp_stockouts_weekly_calc.new_kiosk,
    (dp_stockouts_weekly_calc.revenue - dp_stockouts_weekly_calc.cost) AS net_profit
   FROM public.dp_stockouts_weekly_calc;


ALTER TABLE public.dp_stockouts_weekly_kiosk_product_pct OWNER TO dbservice;

--
-- Name: dp_stockouts_weekly_kiosk_pct; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.dp_stockouts_weekly_kiosk_pct AS
 SELECT dp_stockouts_weekly_kiosk_product_pct.week,
    dp_stockouts_weekly_kiosk_product_pct.kiosk_id,
    bool_and(dp_stockouts_weekly_kiosk_product_pct.new_kiosk) AS new_kiosk,
    max(dp_stockouts_weekly_kiosk_product_pct.days_in_week) AS days_in_week,
    sum(dp_stockouts_weekly_kiosk_product_pct.spoiled) AS spoiled_units,
    sum(dp_stockouts_weekly_kiosk_product_pct.sold) AS sold_units,
    public.frac(sum(dp_stockouts_weekly_kiosk_product_pct.spoiled), sum(dp_stockouts_weekly_kiosk_product_pct.sold)) AS spoiled_frac_units,
    sum(dp_stockouts_weekly_kiosk_product_pct.revenue) AS revenue,
    sum(dp_stockouts_weekly_kiosk_product_pct.cost) AS cost,
    sum(((dp_stockouts_weekly_kiosk_product_pct.spoiled)::numeric * dp_stockouts_weekly_kiosk_product_pct.unit_cost)) AS stockouts_dolr,
    sum(dp_stockouts_weekly_kiosk_product_pct.net_profit) AS net_profit,
    (sum(((dp_stockouts_weekly_kiosk_product_pct.spoiled)::numeric * dp_stockouts_weekly_kiosk_product_pct.unit_cost)) / (0.0001 + sum(dp_stockouts_weekly_kiosk_product_pct.revenue))) AS stockouts_frac_dolr
   FROM public.dp_stockouts_weekly_kiosk_product_pct
  GROUP BY dp_stockouts_weekly_kiosk_product_pct.week, dp_stockouts_weekly_kiosk_product_pct.kiosk_id
  ORDER BY dp_stockouts_weekly_kiosk_product_pct.kiosk_id, dp_stockouts_weekly_kiosk_product_pct.week DESC;


ALTER TABLE public.dp_stockouts_weekly_kiosk_pct OWNER TO dbservice;

--
-- Name: dp_stockouts_weekly_pct; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.dp_stockouts_weekly_pct AS
 SELECT dp_stockouts_weekly_kiosk_product_pct.week,
    dp_stockouts_weekly_kiosk_product_pct.new_kiosk,
    max(dp_stockouts_weekly_kiosk_product_pct.days_in_week) AS days_in_week,
    sum(dp_stockouts_weekly_kiosk_product_pct.spoiled) AS spoiled_units,
    sum(dp_stockouts_weekly_kiosk_product_pct.sold) AS sold_units,
    public.frac(sum(dp_stockouts_weekly_kiosk_product_pct.spoiled), sum(dp_stockouts_weekly_kiosk_product_pct.sold)) AS spoiled_frac_units,
    sum(dp_stockouts_weekly_kiosk_product_pct.revenue) AS revenue,
    sum(dp_stockouts_weekly_kiosk_product_pct.cost) AS cost,
    sum(((dp_stockouts_weekly_kiosk_product_pct.spoiled)::numeric * dp_stockouts_weekly_kiosk_product_pct.unit_cost)) AS stockouts_dolr,
    sum(dp_stockouts_weekly_kiosk_product_pct.net_profit) AS net_profit,
    (sum(((dp_stockouts_weekly_kiosk_product_pct.spoiled)::numeric * dp_stockouts_weekly_kiosk_product_pct.unit_cost)) / (0.0001 + sum(((dp_stockouts_weekly_kiosk_product_pct.sold)::numeric * dp_stockouts_weekly_kiosk_product_pct.unit_price)))) AS stockouts_frac_dolr
   FROM public.dp_stockouts_weekly_kiosk_product_pct
  GROUP BY dp_stockouts_weekly_kiosk_product_pct.week, dp_stockouts_weekly_kiosk_product_pct.new_kiosk
  ORDER BY dp_stockouts_weekly_kiosk_product_pct.week, dp_stockouts_weekly_kiosk_product_pct.new_kiosk DESC;


ALTER TABLE public.dp_stockouts_weekly_pct OWNER TO dbservice;

--
-- Name: dp_stockouts_weekly_product_pct; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.dp_stockouts_weekly_product_pct AS
 SELECT dp_stockouts_weekly_kiosk_product_pct.week,
    dp_stockouts_weekly_kiosk_product_pct.product_id,
    dp_stockouts_weekly_kiosk_product_pct.new_kiosk,
    max(dp_stockouts_weekly_kiosk_product_pct.days_in_week) AS days_in_week,
    sum(dp_stockouts_weekly_kiosk_product_pct.spoiled) AS spoiled_units,
    sum(dp_stockouts_weekly_kiosk_product_pct.sold) AS sold_units,
    public.frac(sum(dp_stockouts_weekly_kiosk_product_pct.spoiled), sum(dp_stockouts_weekly_kiosk_product_pct.sold)) AS spoiled_frac_units,
    sum(dp_stockouts_weekly_kiosk_product_pct.revenue) AS revenue,
    sum(dp_stockouts_weekly_kiosk_product_pct.cost) AS cost,
    sum(((dp_stockouts_weekly_kiosk_product_pct.spoiled)::numeric * dp_stockouts_weekly_kiosk_product_pct.unit_cost)) AS stockouts_dolr,
    sum(dp_stockouts_weekly_kiosk_product_pct.net_profit) AS net_profit,
    (sum(((dp_stockouts_weekly_kiosk_product_pct.spoiled)::numeric * dp_stockouts_weekly_kiosk_product_pct.unit_cost)) / (0.0001 + sum(dp_stockouts_weekly_kiosk_product_pct.revenue))) AS stockouts_frac_dolr
   FROM public.dp_stockouts_weekly_kiosk_product_pct
  GROUP BY dp_stockouts_weekly_kiosk_product_pct.week, dp_stockouts_weekly_kiosk_product_pct.product_id, dp_stockouts_weekly_kiosk_product_pct.new_kiosk
  ORDER BY dp_stockouts_weekly_kiosk_product_pct.product_id, dp_stockouts_weekly_kiosk_product_pct.new_kiosk, dp_stockouts_weekly_kiosk_product_pct.week DESC;


ALTER TABLE public.dp_stockouts_weekly_product_pct OWNER TO dbservice;

--
-- Name: inm_kiosk_weekly_sale; Type: TABLE; Schema: public; Owner: dbservice
--

CREATE TABLE public.inm_kiosk_weekly_sale (
    key character varying(8000) NOT NULL,
    kiosk_id integer,
    woy integer,
    units_sold integer
);


ALTER TABLE public.inm_kiosk_weekly_sale OWNER TO dbservice;

--
-- Name: int_kiosk_weekly_sale; Type: TABLE; Schema: public; Owner: dbservice
--

CREATE TABLE public.int_kiosk_weekly_sale (
    key character varying(8000) NOT NULL,
    kiosk_id integer,
    woy integer,
    units_sold integer
);


ALTER TABLE public.int_kiosk_weekly_sale OWNER TO dbservice;

--
-- Name: kiosk; Type: TABLE; Schema: public; Owner: dbservice
--

CREATE TABLE public.kiosk (
    id integer NOT NULL,
    title character varying(8000)
);


ALTER TABLE public.kiosk OWNER TO dbservice;

--
-- Name: kiosk_first_seen; Type: TABLE; Schema: public; Owner: dbservice
--

CREATE TABLE public.kiosk_first_seen (
    kiosk_id bigint,
    "time" bigint
);


ALTER TABLE public.kiosk_first_seen OWNER TO dbservice;

--
-- Name: kiosk_id_seq; Type: SEQUENCE; Schema: public; Owner: dbservice
--

CREATE SEQUENCE public.kiosk_id_seq
CREATE SEQUENCE public.kiosk_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.kiosk_id_seq OWNER TO dbservice;

--
-- Name: kiosk_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: dbservice
--

ALTER SEQUENCE public.kiosk_id_seq OWNED BY public.kiosk.id;


--
-- Name: kiosk_sales_by_dayofweek; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.kiosk_sales_by_dayofweek AS
 SELECT t.kiosk_id,
    t.min_ts,
    t.sun_pct,
    t.mon_pct,
    t.tue_pct,
    t.wed_pct,
    t.thu_pct,
    t.fri_pct,
    t.sat_pct,
    t.weekend_pct,
    t.title
   FROM ( SELECT t_1.kiosk_id,
            min(t_1.ts) AS min_ts,
            ((sum(public.if((t_1.dayofweek = (0)::double precision), t_1.amount_list_price, 0.0)) / sum(t_1.amount_list_price)))::numeric(6,3) AS sun_pct,
            ((sum(public.if((t_1.dayofweek = (1)::double precision), t_1.amount_list_price, 0.0)) / sum(t_1.amount_list_price)))::numeric(6,3) AS mon_pct,
            ((sum(public.if((t_1.dayofweek = (2)::double precision), t_1.amount_list_price, 0.0)) / sum(t_1.amount_list_price)))::numeric(6,3) AS tue_pct,
            ((sum(public.if((t_1.dayofweek = (3)::double precision), t_1.amount_list_price, 0.0)) / sum(t_1.amount_list_price)))::numeric(6,3) AS wed_pct,
            ((sum(public.if((t_1.dayofweek = (4)::double precision), t_1.amount_list_price, 0.0)) / sum(t_1.amount_list_price)))::numeric(6,3) AS thu_pct,
            ((sum(public.if((t_1.dayofweek = (5)::double precision), t_1.amount_list_price, 0.0)) / sum(t_1.amount_list_price)))::numeric(6,3) AS fri_pct,
            ((sum(public.if((t_1.dayofweek = (6)::double precision), t_1.amount_list_price, 0.0)) / sum(t_1.amount_list_price)))::numeric(6,3) AS sat_pct,
            ((sum(public.if((t_1.dayofweek = ANY (ARRAY[(0)::double precision, (6)::double precision])), t_1.amount_list_price, 0.0)) / sum(t_1.amount_list_price)))::numeric(6,3) AS weekend_pct,
            min((t_1.kiosk_title)::text) AS title
           FROM ((public.byte_tickets_6months t_1
             JOIN public.byte_kiosks_date_non_new knn ON ((t_1.kiosk_id = knn.kiosk_id)))
             JOIN public.byte_kiosks k ON ((t_1.kiosk_id = k.id)))
          WHERE ((k.archived = 0) AND (t_1.ts >= knn.new_ts))
          GROUP BY t_1.kiosk_id) t
  WHERE (t.min_ts < (now() - '30 days'::interval day))
  ORDER BY t.weekend_pct DESC;


ALTER TABLE public.kiosk_sales_by_dayofweek OWNER TO dbservice;

--
-- Name: kiosk_status; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.kiosk_status AS
 SELECT tmp.id,
    tmp.kiosk_id,
    tmp.kiosk_temperature,
    tmp.kiosk_temperature_count,
    tmp.kit_temperature,
    tmp.temperature_tags,
    tmp.kiosk_temperature_source,
    tmp.power,
    tmp.battery_level,
    tmp.rfid_0,
    tmp.rfid_1,
    tmp.rfid_2,
    tmp.rfid_3,
    tmp.rfid_4,
    tmp.rfid_5,
    tmp.rfid_6,
    tmp.rfid_7,
    tmp."time",
    tmp.modem_signal_percentage,
    tmp.modem_signal_type,
    tmp.ip,
    tmp.notes,
    tmp.app_uptime,
    tmp.system_uptime,
    tmp.is_locked,
    tmp.campus_id,
    tmp.ts_10min,
    tmp.title,
    tmp.ts_utc,
    tmp.ts,
    date_trunc('day'::text, tmp.ts_10min) AS date
   FROM ( SELECT ks.id,
            ks.kiosk_id,
            ks.kiosk_temperature,
            ks.kiosk_temperature_count,
            ks.kit_temperature,
            ks.temperature_tags,
            ks.kiosk_temperature_source,
            ks.power,
            ks.battery_level,
            ks.rfid_0,
            ks.rfid_1,
            ks.rfid_2,
            ks.rfid_3,
            ks.rfid_4,
            ks.rfid_5,
            ks.rfid_6,
            ks.rfid_7,
            ks."time",
            ks.modem_signal_percentage,
            ks.modem_signal_type,
            ks.ip,
            ks.notes,
            ks.app_uptime,
            ks.system_uptime,
            ks.is_locked,
            k.campus_id,
            public.epoch_round(ks."time", '00:10:00'::interval minute) AS ts_10min,
            k.title,
            to_timestamp((ks."time")::double precision) AS ts_utc,
            to_timestamp((ks."time")::double precision) AS ts
           FROM (pantry.kiosk_status ks
             JOIN pantry.kiosk k ON ((ks.kiosk_id = k.id)))) tmp;


ALTER TABLE public.kiosk_status OWNER TO dbservice;

--
-- Name: latest_label_records; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.latest_label_records AS
 SELECT l.id,
    l.product_id,
    l.epc,
    l.is_generic_sku,
    l.kiosk_id,
    l.order_id,
    l.status,
    l.price,
    l.cost,
    l.time_created,
    l.time_added,
    l.time_updated,
    l.notes
   FROM (pantry.label l
     JOIN ( SELECT max(label.id) AS id
           FROM pantry.label
          GROUP BY label.epc) t ON ((l.id = t.id)));


ALTER TABLE public.latest_label_records OWNER TO dbservice;

--
-- Name: mkt_camp_20170111_sku_revival_sonoma; Type: TABLE; Schema: public; Owner: dbservice
--

CREATE TABLE public.mkt_camp_20170111_sku_revival_sonoma (
    "Kiosk name" text,
    "Email address" text,
    "Record Type" text,
    "Lifecycle Stage" text,
    "Coupon" text
);


ALTER TABLE public.mkt_camp_20170111_sku_revival_sonoma OWNER TO dbservice;

--
-- Name: mkt_camp_20170123_whats_new_in_kiosk; Type: TABLE; Schema: public; Owner: dbservice
--

CREATE TABLE public.mkt_camp_20170123_whats_new_in_kiosk (
    "Kiosk name" text,
    "Email address" text,
    "Record Type" text,
    "Lifecycle Stage" text,
    "Coupon" text
);


ALTER TABLE public.mkt_camp_20170123_whats_new_in_kiosk OWNER TO dbservice;

--
-- Name: pantry.kiosk; Type: TABLE; Schema: public; Owner: dbservice
--

CREATE TABLE public."pantry.kiosk" (
    id integer NOT NULL,
    title character varying(8000)
);


ALTER TABLE public."pantry.kiosk" OWNER TO dbservice;

--
-- Name: pantry.kiosk_id_seq; Type: SEQUENCE; Schema: public; Owner: dbservice
--

CREATE SEQUENCE public."pantry.kiosk_id_seq"
CREATE SEQUENCE public."pantry.kiosk_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public."pantry.kiosk_id_seq" OWNER TO dbservice;

--
-- Name: pantry.kiosk_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: dbservice
--

ALTER SEQUENCE public."pantry.kiosk_id_seq" OWNED BY public."pantry.kiosk".id;


--
-- Name: sales_by_shelflife_120d; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.sales_by_shelflife_120d AS
 SELECT public.if((byte_epcssold_120days.product_shelf_life_days > 30), 999, byte_epcssold_120days.product_shelf_life_days) AS shelf_life,
    sum(byte_epcssold_120days.product_price) AS sales
   FROM public.byte_epcssold_120days
  GROUP BY (public.if((byte_epcssold_120days.product_shelf_life_days > 30), 999, byte_epcssold_120days.product_shelf_life_days))
  ORDER BY (public.if((byte_epcssold_120days.product_shelf_life_days > 30), 999, byte_epcssold_120days.product_shelf_life_days));


ALTER TABLE public.sales_by_shelflife_120d OWNER TO dbservice;

--
-- Name: sales_by_shelflife_30d; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.sales_by_shelflife_30d AS
 SELECT public.if((byte_epcssold_30days.product_shelf_life_days > 30), 999, byte_epcssold_30days.product_shelf_life_days) AS shelf_life,
    sum(byte_epcssold_30days.product_price) AS sales
   FROM public.byte_epcssold_30days
  GROUP BY (public.if((byte_epcssold_30days.product_shelf_life_days > 30), 999, byte_epcssold_30days.product_shelf_life_days))
  ORDER BY (public.if((byte_epcssold_30days.product_shelf_life_days > 30), 999, byte_epcssold_30days.product_shelf_life_days));


ALTER TABLE public.sales_by_shelflife_30d OWNER TO dbservice;

--
-- Name: sales_by_shelflife_45d; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.sales_by_shelflife_45d AS
 SELECT public.if((byte_epcssold_45days.product_shelf_life_days > 30), 999, byte_epcssold_45days.product_shelf_life_days) AS shelf_life,
    sum(byte_epcssold_45days.product_price) AS sales
   FROM public.byte_epcssold_45days
  GROUP BY (public.if((byte_epcssold_45days.product_shelf_life_days > 30), 999, byte_epcssold_45days.product_shelf_life_days))
  ORDER BY (public.if((byte_epcssold_45days.product_shelf_life_days > 30), 999, byte_epcssold_45days.product_shelf_life_days));


ALTER TABLE public.sales_by_shelflife_45d OWNER TO dbservice;

--
-- Name: spoilage_by_shelflife_120d; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.spoilage_by_shelflife_120d AS
 SELECT public.if((byte_spoilage.shelf_time > 30), 999, byte_spoilage.shelf_time) AS shelf_life,
    sum(byte_spoilage.cost) AS spoilage_dolr
   FROM public.byte_spoilage
  WHERE (byte_spoilage.ts_removed > (now() - '120 days'::interval day))
  GROUP BY (public.if((byte_spoilage.shelf_time > 30), 999, byte_spoilage.shelf_time))
  ORDER BY (public.if((byte_spoilage.shelf_time > 30), 999, byte_spoilage.shelf_time));


ALTER TABLE public.spoilage_by_shelflife_120d OWNER TO dbservice;

--
-- Name: spoilage_by_shelflife_30d; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.spoilage_by_shelflife_30d AS
 SELECT public.if((byte_spoilage.shelf_time > 30), 999, byte_spoilage.shelf_time) AS shelf_life,
    sum(byte_spoilage.cost) AS spoilage_dolr
   FROM public.byte_spoilage
  WHERE (byte_spoilage.ts_removed > (now() - '30 days'::interval day))
  GROUP BY (public.if((byte_spoilage.shelf_time > 30), 999, byte_spoilage.shelf_time))
  ORDER BY (public.if((byte_spoilage.shelf_time > 30), 999, byte_spoilage.shelf_time));


ALTER TABLE public.spoilage_by_shelflife_30d OWNER TO dbservice;

--
-- Name: spoilage_by_shelflife_45d; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.spoilage_by_shelflife_45d AS
 SELECT public.if((byte_spoilage.shelf_time > 30), 999, byte_spoilage.shelf_time) AS shelf_life,
    sum(byte_spoilage.cost) AS spoilage_dolr
   FROM public.byte_spoilage
  WHERE (byte_spoilage.ts_removed > (now() - '45 days'::interval day))
  GROUP BY (public.if((byte_spoilage.shelf_time > 30), 999, byte_spoilage.shelf_time))
  ORDER BY (public.if((byte_spoilage.shelf_time > 30), 999, byte_spoilage.shelf_time));


ALTER TABLE public.spoilage_by_shelflife_45d OWNER TO dbservice;

--
-- Name: spoilagepct_by_shelflife_120d; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.spoilagepct_by_shelflife_120d AS
 SELECT t1.shelf_life,
    sum(t1.sales) AS sales,
    sum(t2.spoilage_dolr) AS spoilage_dolr,
    public.if((sum(t2.spoilage_dolr) > 0.0), (sum(t2.spoilage_dolr) / sum(t1.sales)), 0.0) AS spoilage_frac
   FROM (public.sales_by_shelflife_120d t1
     JOIN public.spoilage_by_shelflife_120d t2 ON ((t1.shelf_life = t2.shelf_life)))
  GROUP BY t1.shelf_life
  ORDER BY t1.shelf_life;


ALTER TABLE public.spoilagepct_by_shelflife_120d OWNER TO dbservice;

--
-- Name: spoilagepct_by_shelflife_30d; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.spoilagepct_by_shelflife_30d AS
 SELECT t1.shelf_life,
    sum(t1.sales) AS sales,
    sum(t2.spoilage_dolr) AS spoilage_dolr,
    public.if((sum(t2.spoilage_dolr) > 0.0), (sum(t2.spoilage_dolr) / sum(t1.sales)), 0.0) AS spoilage_frac
   FROM (public.sales_by_shelflife_30d t1
     JOIN public.spoilage_by_shelflife_30d t2 ON ((t1.shelf_life = t2.shelf_life)))
  GROUP BY t1.shelf_life
  ORDER BY t1.shelf_life;


ALTER TABLE public.spoilagepct_by_shelflife_30d OWNER TO dbservice;

--
-- Name: spoilagepct_by_shelflife_45d; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.spoilagepct_by_shelflife_45d AS
 SELECT t1.shelf_life,
    sum(t1.sales) AS sales,
    sum(t2.spoilage_dolr) AS spoilage_dolr,
    public.if((sum(t2.spoilage_dolr) > 0.0), (sum(t2.spoilage_dolr) / sum(t1.sales)), 0.0) AS spoilage_frac
   FROM (public.sales_by_shelflife_45d t1
     JOIN public.spoilage_by_shelflife_45d t2 ON ((t1.shelf_life = t2.shelf_life)))
  GROUP BY t1.shelf_life
  ORDER BY t1.shelf_life;


ALTER TABLE public.spoilagepct_by_shelflife_45d OWNER TO dbservice;

--
-- Name: sys_activity; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.sys_activity AS
 SELECT pg_stat_activity.datname,
    pg_stat_activity.pid,
    pg_stat_activity.usename,
    pg_stat_activity.application_name,
    pg_stat_activity.client_addr,
    pg_stat_activity.client_hostname,
    pg_stat_activity.client_port,
    pg_stat_activity.query,
    pg_stat_activity.state
   FROM pg_stat_activity;


ALTER TABLE public.sys_activity OWNER TO dbservice;

--
-- Name: sys_conninfo; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.sys_conninfo AS
 SELECT pg_stat_activity.usename,
    count(*) AS count
   FROM pg_stat_activity
  GROUP BY pg_stat_activity.usename;


ALTER TABLE public.sys_conninfo OWNER TO dbservice;

--
-- Name: sys_slow_queries; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.sys_slow_queries AS
 SELECT ((pg_stat_statements.total_time / (1000)::double precision) / (60)::double precision) AS total_minutes,
    (pg_stat_statements.total_time / (pg_stat_statements.calls)::double precision) AS average_time,
    pg_stat_statements.query
   FROM public.pg_stat_statements
  ORDER BY ((pg_stat_statements.total_time / (1000)::double precision) / (60)::double precision);


ALTER TABLE public.sys_slow_queries OWNER TO dbservice;

--
-- Name: sys_table_sizes; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.sys_table_sizes AS
 SELECT (((n.nspname)::text || '.'::text) || (c.relname)::text) AS relation,
    pg_size_pretty(pg_relation_size((c.oid)::regclass)) AS size
   FROM (pg_class c
     LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace)))
  WHERE (n.nspname <> ALL (ARRAY['pg_catalog'::name, 'information_schema'::name]))
  ORDER BY (pg_relation_size((c.oid)::regclass)) DESC;


ALTER TABLE public.sys_table_sizes OWNER TO dbservice;

--
-- Name: sys_uptime; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.sys_uptime AS
 SELECT (now() - pg_stat_activity.backend_start) AS uptime
   FROM pg_stat_activity
  WHERE (pg_stat_activity.pid = pg_backend_pid());


ALTER TABLE public.sys_uptime OWNER TO dbservice;

--
-- Name: tmp_dormant; Type: TABLE; Schema: public; Owner: dbservice
--

CREATE TABLE public.tmp_dormant (
    email character varying(255)
);


ALTER TABLE public.tmp_dormant OWNER TO dbservice;

--
-- Name: tmp_dormant2; Type: TABLE; Schema: public; Owner: dbservice
--

CREATE TABLE public.tmp_dormant2 (
    email character varying(255),
    dayssincepurchase integer,
    kiosk character varying(255),
    couponcode character varying(20),
    couponamount numeric(28,6)
);


ALTER TABLE public.tmp_dormant2 OWNER TO dbservice;

--
-- Name: tmp_reboots_log; Type: TABLE; Schema: public; Owner: dbservice
--

CREATE TABLE public.tmp_reboots_log (
    ts timestamp(6) with time zone,
    kiosk_id integer,
    ipaddr text,
    reason text
);


ALTER TABLE public.tmp_reboots_log OWNER TO dbservice;

--
-- Name: track_dashboard; Type: TABLE; Schema: public; Owner: dbservice
--

CREATE TABLE public.track_dashboard (
    date timestamp(6) with time zone,
    sum_amount_paid numeric(28,6),
    sum_list_price numeric(28,6),
    byte_kiosks bigint,
    byte_fridge_uptime numeric(28,6),
    major_byte_outages bigint,
    licensee_kiosks bigint,
    avg_inv_dolr numeric(28,6),
    avg_inv_units numeric(28,6),
    units_sold bigint,
    active_byte_customers bigint,
    active_skus bigint,
    active_brands bigint,
    cards bigint,
    estd_uniq_usernames bigint,
    unique_emails bigint,
    tickets bigint,
    tickets_w_email bigint,
    id integer NOT NULL,
    create_ts timestamp(6) with time zone
);


ALTER TABLE public.track_dashboard OWNER TO dbservice;

--
-- Name: track_dashboard_id_seq; Type: SEQUENCE; Schema: public; Owner: dbservice
--

CREATE SEQUENCE public.track_dashboard_id_seq
CREATE SEQUENCE public.track_dashboard_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.track_dashboard_id_seq OWNER TO dbservice;

--
-- Name: track_dashboard_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: dbservice
--

ALTER SEQUENCE public.track_dashboard_id_seq OWNED BY public.track_dashboard.id;


--
-- Name: track_inventory; Type: TABLE; Schema: public; Owner: dbservice
--

CREATE TABLE public.track_inventory (
    kiosk_id bigint,
    kiosk character varying(138),
    product character varying(381),
    sku bigint,
    cost numeric(6,2),
    inventory_count bigint,
    inventory_value numeric(28,6),
    "current_date" timestamp(6) with time zone,
    id integer NOT NULL,
    create_ts timestamp(6) with time zone
);


ALTER TABLE public.track_inventory OWNER TO dbservice;

--
-- Name: track_inventory_id_seq; Type: SEQUENCE; Schema: public; Owner: dbservice
--

CREATE SEQUENCE public.track_inventory_id_seq
CREATE SEQUENCE public.track_inventory_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.track_inventory_id_seq OWNER TO dbservice;

--
-- Name: track_inventory_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: dbservice
--

ALTER SEQUENCE public.track_inventory_id_seq OWNED BY public.track_inventory.id;


--
-- Name: user_retention_10weeks; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.user_retention_10weeks AS
 SELECT user_retention_by_week.week,
    user_retention_by_week.num_consumers,
    user_retention_by_week.repeat_consumers,
    user_retention_by_week.num_tickets,
    user_retention_by_week.sum_amount_list_price,
    user_retention_by_week.sum_amount_paid,
    user_retention_by_week.num_repeat_tickets,
    user_retention_by_week.sum_repeat_amount_list_price,
    user_retention_by_week.sum_repeat_amount_paid,
    user_retention_by_week.frac_users_retained,
    user_retention_by_week.frac_tickets_retained,
    user_retention_by_week.frac_listprice_retained,
    user_retention_by_week.frac_amountpaid_retained,
    user_retention_by_week.old_week,
    user_retention_by_week.old_num_consumers,
    user_retention_by_week.old_repeat_consumers,
    user_retention_by_week.old_num_tickets,
    user_retention_by_week.old_sum_amount_list_price,
    user_retention_by_week.old_sum_amount_paid
   FROM public.user_retention_by_week(10) user_retention_by_week(week, num_consumers, repeat_consumers, num_tickets, sum_amount_list_price, sum_amount_paid, num_repeat_tickets, sum_repeat_amount_list_price, sum_repeat_amount_paid, frac_users_retained, frac_tickets_retained, frac_listprice_retained, frac_amountpaid_retained, old_week, old_num_consumers, old_repeat_consumers, old_num_tickets, old_sum_amount_list_price, old_sum_amount_paid);


ALTER TABLE public.user_retention_10weeks OWNER TO dbservice;

--
-- Name: user_retention_12months; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.user_retention_12months AS
 SELECT user_retention_by_month.month,
    user_retention_by_month.num_consumers,
    user_retention_by_month.repeat_consumers,
    user_retention_by_month.num_tickets,
    user_retention_by_month.sum_amount_list_price,
    user_retention_by_month.sum_amount_paid,
    user_retention_by_month.num_repeat_tickets,
    user_retention_by_month.sum_repeat_amount_list_price,
    user_retention_by_month.sum_repeat_amount_paid,
    user_retention_by_month.frac_users_retained,
    user_retention_by_month.frac_tickets_retained,
    user_retention_by_month.frac_listprice_retained,
    user_retention_by_month.frac_amountpaid_retained,
    user_retention_by_month.old_month,
    user_retention_by_month.old_num_consumers,
    user_retention_by_month.old_repeat_consumers,
    user_retention_by_month.old_num_tickets,
    user_retention_by_month.old_sum_amount_list_price,
    user_retention_by_month.old_sum_amount_paid
   FROM public.user_retention_by_month(12) user_retention_by_month(month, num_consumers, repeat_consumers, num_tickets, sum_amount_list_price, sum_amount_paid, num_repeat_tickets, sum_repeat_amount_list_price, sum_repeat_amount_paid, frac_users_retained, frac_tickets_retained, frac_listprice_retained, frac_amountpaid_retained, old_month, old_num_consumers, old_repeat_consumers, old_num_tickets, old_sum_amount_list_price, old_sum_amount_paid);


ALTER TABLE public.user_retention_12months OWNER TO dbservice;

--
-- Name: user_retention_12weeks; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.user_retention_12weeks AS
 SELECT user_retention_by_week.week,
    user_retention_by_week.num_consumers,
    user_retention_by_week.repeat_consumers,
    user_retention_by_week.num_tickets,
    user_retention_by_week.sum_amount_list_price,
    user_retention_by_week.sum_amount_paid,
    user_retention_by_week.num_repeat_tickets,
    user_retention_by_week.sum_repeat_amount_list_price,
    user_retention_by_week.sum_repeat_amount_paid,
    user_retention_by_week.frac_users_retained,
    user_retention_by_week.frac_tickets_retained,
    user_retention_by_week.frac_listprice_retained,
    user_retention_by_week.frac_amountpaid_retained,
    user_retention_by_week.old_week,
    user_retention_by_week.old_num_consumers,
    user_retention_by_week.old_repeat_consumers,
    user_retention_by_week.old_num_tickets,
    user_retention_by_week.old_sum_amount_list_price,
    user_retention_by_week.old_sum_amount_paid
   FROM public.user_retention_by_week(12) user_retention_by_week(week, num_consumers, repeat_consumers, num_tickets, sum_amount_list_price, sum_amount_paid, num_repeat_tickets, sum_repeat_amount_list_price, sum_repeat_amount_paid, frac_users_retained, frac_tickets_retained, frac_listprice_retained, frac_amountpaid_retained, old_week, old_num_consumers, old_repeat_consumers, old_num_tickets, old_sum_amount_list_price, old_sum_amount_paid);


ALTER TABLE public.user_retention_12weeks OWNER TO dbservice;

--
-- Name: user_retention_1month; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.user_retention_1month AS
 SELECT user_retention_by_month.month,
    user_retention_by_month.num_consumers,
    user_retention_by_month.repeat_consumers,
    user_retention_by_month.num_tickets,
    user_retention_by_month.sum_amount_list_price,
    user_retention_by_month.sum_amount_paid,
    user_retention_by_month.num_repeat_tickets,
    user_retention_by_month.sum_repeat_amount_list_price,
    user_retention_by_month.sum_repeat_amount_paid,
    user_retention_by_month.frac_users_retained,
    user_retention_by_month.frac_tickets_retained,
    user_retention_by_month.frac_listprice_retained,
    user_retention_by_month.frac_amountpaid_retained,
    user_retention_by_month.old_month,
    user_retention_by_month.old_num_consumers,
    user_retention_by_month.old_repeat_consumers,
    user_retention_by_month.old_num_tickets,
    user_retention_by_month.old_sum_amount_list_price,
    user_retention_by_month.old_sum_amount_paid
   FROM public.user_retention_by_month(1) user_retention_by_month(month, num_consumers, repeat_consumers, num_tickets, sum_amount_list_price, sum_amount_paid, num_repeat_tickets, sum_repeat_amount_list_price, sum_repeat_amount_paid, frac_users_retained, frac_tickets_retained, frac_listprice_retained, frac_amountpaid_retained, old_month, old_num_consumers, old_repeat_consumers, old_num_tickets, old_sum_amount_list_price, old_sum_amount_paid);


ALTER TABLE public.user_retention_1month OWNER TO dbservice;

--
-- Name: user_retention_1week; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.user_retention_1week AS
 SELECT user_retention_by_week.week,
    user_retention_by_week.num_consumers,
    user_retention_by_week.repeat_consumers,
    user_retention_by_week.num_tickets,
    user_retention_by_week.sum_amount_list_price,
    user_retention_by_week.sum_amount_paid,
    user_retention_by_week.num_repeat_tickets,
    user_retention_by_week.sum_repeat_amount_list_price,
    user_retention_by_week.sum_repeat_amount_paid,
    user_retention_by_week.frac_users_retained,
    user_retention_by_week.frac_tickets_retained,
    user_retention_by_week.frac_listprice_retained,
    user_retention_by_week.frac_amountpaid_retained,
    user_retention_by_week.old_week,
    user_retention_by_week.old_num_consumers,
    user_retention_by_week.old_repeat_consumers,
    user_retention_by_week.old_num_tickets,
    user_retention_by_week.old_sum_amount_list_price,
    user_retention_by_week.old_sum_amount_paid
   FROM public.user_retention_by_week(1) user_retention_by_week(week, num_consumers, repeat_consumers, num_tickets, sum_amount_list_price, sum_amount_paid, num_repeat_tickets, sum_repeat_amount_list_price, sum_repeat_amount_paid, frac_users_retained, frac_tickets_retained, frac_listprice_retained, frac_amountpaid_retained, old_week, old_num_consumers, old_repeat_consumers, old_num_tickets, old_sum_amount_list_price, old_sum_amount_paid);


ALTER TABLE public.user_retention_1week OWNER TO dbservice;

--
-- Name: user_retention_26weeks; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.user_retention_26weeks AS
 SELECT user_retention_by_week.week,
    user_retention_by_week.num_consumers,
    user_retention_by_week.repeat_consumers,
    user_retention_by_week.num_tickets,
    user_retention_by_week.sum_amount_list_price,
    user_retention_by_week.sum_amount_paid,
    user_retention_by_week.num_repeat_tickets,
    user_retention_by_week.sum_repeat_amount_list_price,
    user_retention_by_week.sum_repeat_amount_paid,
    user_retention_by_week.frac_users_retained,
    user_retention_by_week.frac_tickets_retained,
    user_retention_by_week.frac_listprice_retained,
    user_retention_by_week.frac_amountpaid_retained,
    user_retention_by_week.old_week,
    user_retention_by_week.old_num_consumers,
    user_retention_by_week.old_repeat_consumers,
    user_retention_by_week.old_num_tickets,
    user_retention_by_week.old_sum_amount_list_price,
    user_retention_by_week.old_sum_amount_paid
   FROM public.user_retention_by_week(26) user_retention_by_week(week, num_consumers, repeat_consumers, num_tickets, sum_amount_list_price, sum_amount_paid, num_repeat_tickets, sum_repeat_amount_list_price, sum_repeat_amount_paid, frac_users_retained, frac_tickets_retained, frac_listprice_retained, frac_amountpaid_retained, old_week, old_num_consumers, old_repeat_consumers, old_num_tickets, old_sum_amount_list_price, old_sum_amount_paid);


ALTER TABLE public.user_retention_26weeks OWNER TO dbservice;

--
-- Name: user_retention_2months; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.user_retention_2months AS
 SELECT user_retention_by_month.month,
    user_retention_by_month.num_consumers,
    user_retention_by_month.repeat_consumers,
    user_retention_by_month.num_tickets,
    user_retention_by_month.sum_amount_list_price,
    user_retention_by_month.sum_amount_paid,
    user_retention_by_month.num_repeat_tickets,
    user_retention_by_month.sum_repeat_amount_list_price,
    user_retention_by_month.sum_repeat_amount_paid,
    user_retention_by_month.frac_users_retained,
    user_retention_by_month.frac_tickets_retained,
    user_retention_by_month.frac_listprice_retained,
    user_retention_by_month.frac_amountpaid_retained,
    user_retention_by_month.old_month,
    user_retention_by_month.old_num_consumers,
    user_retention_by_month.old_repeat_consumers,
    user_retention_by_month.old_num_tickets,
    user_retention_by_month.old_sum_amount_list_price,
    user_retention_by_month.old_sum_amount_paid
   FROM public.user_retention_by_month(2) user_retention_by_month(month, num_consumers, repeat_consumers, num_tickets, sum_amount_list_price, sum_amount_paid, num_repeat_tickets, sum_repeat_amount_list_price, sum_repeat_amount_paid, frac_users_retained, frac_tickets_retained, frac_listprice_retained, frac_amountpaid_retained, old_month, old_num_consumers, old_repeat_consumers, old_num_tickets, old_sum_amount_list_price, old_sum_amount_paid);


ALTER TABLE public.user_retention_2months OWNER TO dbservice;

--
-- Name: user_retention_2weeks; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.user_retention_2weeks AS
 SELECT user_retention_by_week.week,
    user_retention_by_week.num_consumers,
    user_retention_by_week.repeat_consumers,
    user_retention_by_week.num_tickets,
    user_retention_by_week.sum_amount_list_price,
    user_retention_by_week.sum_amount_paid,
    user_retention_by_week.num_repeat_tickets,
    user_retention_by_week.sum_repeat_amount_list_price,
    user_retention_by_week.sum_repeat_amount_paid,
    user_retention_by_week.frac_users_retained,
    user_retention_by_week.frac_tickets_retained,
    user_retention_by_week.frac_listprice_retained,
    user_retention_by_week.frac_amountpaid_retained,
    user_retention_by_week.old_week,
    user_retention_by_week.old_num_consumers,
    user_retention_by_week.old_repeat_consumers,
    user_retention_by_week.old_num_tickets,
    user_retention_by_week.old_sum_amount_list_price,
    user_retention_by_week.old_sum_amount_paid
   FROM public.user_retention_by_week(2) user_retention_by_week(week, num_consumers, repeat_consumers, num_tickets, sum_amount_list_price, sum_amount_paid, num_repeat_tickets, sum_repeat_amount_list_price, sum_repeat_amount_paid, frac_users_retained, frac_tickets_retained, frac_listprice_retained, frac_amountpaid_retained, old_week, old_num_consumers, old_repeat_consumers, old_num_tickets, old_sum_amount_list_price, old_sum_amount_paid);


ALTER TABLE public.user_retention_2weeks OWNER TO dbservice;

--
-- Name: user_retention_3months; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.user_retention_3months AS
 SELECT user_retention_by_month.month,
    user_retention_by_month.num_consumers,
    user_retention_by_month.repeat_consumers,
    user_retention_by_month.num_tickets,
    user_retention_by_month.sum_amount_list_price,
    user_retention_by_month.sum_amount_paid,
    user_retention_by_month.num_repeat_tickets,
    user_retention_by_month.sum_repeat_amount_list_price,
    user_retention_by_month.sum_repeat_amount_paid,
    user_retention_by_month.frac_users_retained,
    user_retention_by_month.frac_tickets_retained,
    user_retention_by_month.frac_listprice_retained,
    user_retention_by_month.frac_amountpaid_retained,
    user_retention_by_month.old_month,
    user_retention_by_month.old_num_consumers,
    user_retention_by_month.old_repeat_consumers,
    user_retention_by_month.old_num_tickets,
    user_retention_by_month.old_sum_amount_list_price,
    user_retention_by_month.old_sum_amount_paid
   FROM public.user_retention_by_month(3) user_retention_by_month(month, num_consumers, repeat_consumers, num_tickets, sum_amount_list_price, sum_amount_paid, num_repeat_tickets, sum_repeat_amount_list_price, sum_repeat_amount_paid, frac_users_retained, frac_tickets_retained, frac_listprice_retained, frac_amountpaid_retained, old_month, old_num_consumers, old_repeat_consumers, old_num_tickets, old_sum_amount_list_price, old_sum_amount_paid);


ALTER TABLE public.user_retention_3months OWNER TO dbservice;

--
-- Name: user_retention_3weeks; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.user_retention_3weeks AS
 SELECT user_retention_by_week.week,
    user_retention_by_week.num_consumers,
    user_retention_by_week.repeat_consumers,
    user_retention_by_week.num_tickets,
    user_retention_by_week.sum_amount_list_price,
    user_retention_by_week.sum_amount_paid,
    user_retention_by_week.num_repeat_tickets,
    user_retention_by_week.sum_repeat_amount_list_price,
    user_retention_by_week.sum_repeat_amount_paid,
    user_retention_by_week.frac_users_retained,
    user_retention_by_week.frac_tickets_retained,
    user_retention_by_week.frac_listprice_retained,
    user_retention_by_week.frac_amountpaid_retained,
    user_retention_by_week.old_week,
    user_retention_by_week.old_num_consumers,
    user_retention_by_week.old_repeat_consumers,
    user_retention_by_week.old_num_tickets,
    user_retention_by_week.old_sum_amount_list_price,
    user_retention_by_week.old_sum_amount_paid
   FROM public.user_retention_by_week(3) user_retention_by_week(week, num_consumers, repeat_consumers, num_tickets, sum_amount_list_price, sum_amount_paid, num_repeat_tickets, sum_repeat_amount_list_price, sum_repeat_amount_paid, frac_users_retained, frac_tickets_retained, frac_listprice_retained, frac_amountpaid_retained, old_week, old_num_consumers, old_repeat_consumers, old_num_tickets, old_sum_amount_list_price, old_sum_amount_paid);


ALTER TABLE public.user_retention_3weeks OWNER TO dbservice;

--
-- Name: user_retention_4months; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.user_retention_4months AS
 SELECT user_retention_by_month.month,
    user_retention_by_month.num_consumers,
    user_retention_by_month.repeat_consumers,
    user_retention_by_month.num_tickets,
    user_retention_by_month.sum_amount_list_price,
    user_retention_by_month.sum_amount_paid,
    user_retention_by_month.num_repeat_tickets,
    user_retention_by_month.sum_repeat_amount_list_price,
    user_retention_by_month.sum_repeat_amount_paid,
    user_retention_by_month.frac_users_retained,
    user_retention_by_month.frac_tickets_retained,
    user_retention_by_month.frac_listprice_retained,
    user_retention_by_month.frac_amountpaid_retained,
    user_retention_by_month.old_month,
    user_retention_by_month.old_num_consumers,
    user_retention_by_month.old_repeat_consumers,
    user_retention_by_month.old_num_tickets,
    user_retention_by_month.old_sum_amount_list_price,
    user_retention_by_month.old_sum_amount_paid
   FROM public.user_retention_by_month(4) user_retention_by_month(month, num_consumers, repeat_consumers, num_tickets, sum_amount_list_price, sum_amount_paid, num_repeat_tickets, sum_repeat_amount_list_price, sum_repeat_amount_paid, frac_users_retained, frac_tickets_retained, frac_listprice_retained, frac_amountpaid_retained, old_month, old_num_consumers, old_repeat_consumers, old_num_tickets, old_sum_amount_list_price, old_sum_amount_paid);


ALTER TABLE public.user_retention_4months OWNER TO dbservice;

--
-- Name: user_retention_4weeks; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.user_retention_4weeks AS
 SELECT user_retention_by_week.week,
    user_retention_by_week.num_consumers,
    user_retention_by_week.repeat_consumers,
    user_retention_by_week.num_tickets,
    user_retention_by_week.sum_amount_list_price,
    user_retention_by_week.sum_amount_paid,
    user_retention_by_week.num_repeat_tickets,
    user_retention_by_week.sum_repeat_amount_list_price,
    user_retention_by_week.sum_repeat_amount_paid,
    user_retention_by_week.frac_users_retained,
    user_retention_by_week.frac_tickets_retained,
    user_retention_by_week.frac_listprice_retained,
    user_retention_by_week.frac_amountpaid_retained,
    user_retention_by_week.old_week,
    user_retention_by_week.old_num_consumers,
    user_retention_by_week.old_repeat_consumers,
    user_retention_by_week.old_num_tickets,
    user_retention_by_week.old_sum_amount_list_price,
    user_retention_by_week.old_sum_amount_paid
   FROM public.user_retention_by_week(4) user_retention_by_week(week, num_consumers, repeat_consumers, num_tickets, sum_amount_list_price, sum_amount_paid, num_repeat_tickets, sum_repeat_amount_list_price, sum_repeat_amount_paid, frac_users_retained, frac_tickets_retained, frac_listprice_retained, frac_amountpaid_retained, old_week, old_num_consumers, old_repeat_consumers, old_num_tickets, old_sum_amount_list_price, old_sum_amount_paid);


ALTER TABLE public.user_retention_4weeks OWNER TO dbservice;

--
-- Name: user_retention_52weeks; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.user_retention_52weeks AS
 SELECT user_retention_by_week.week,
    user_retention_by_week.num_consumers,
    user_retention_by_week.repeat_consumers,
    user_retention_by_week.num_tickets,
    user_retention_by_week.sum_amount_list_price,
    user_retention_by_week.sum_amount_paid,
    user_retention_by_week.num_repeat_tickets,
    user_retention_by_week.sum_repeat_amount_list_price,
    user_retention_by_week.sum_repeat_amount_paid,
    user_retention_by_week.frac_users_retained,
    user_retention_by_week.frac_tickets_retained,
    user_retention_by_week.frac_listprice_retained,
    user_retention_by_week.frac_amountpaid_retained,
    user_retention_by_week.old_week,
    user_retention_by_week.old_num_consumers,
    user_retention_by_week.old_repeat_consumers,
    user_retention_by_week.old_num_tickets,
    user_retention_by_week.old_sum_amount_list_price,
    user_retention_by_week.old_sum_amount_paid
   FROM public.user_retention_by_week(52) user_retention_by_week(week, num_consumers, repeat_consumers, num_tickets, sum_amount_list_price, sum_amount_paid, num_repeat_tickets, sum_repeat_amount_list_price, sum_repeat_amount_paid, frac_users_retained, frac_tickets_retained, frac_listprice_retained, frac_amountpaid_retained, old_week, old_num_consumers, old_repeat_consumers, old_num_tickets, old_sum_amount_list_price, old_sum_amount_paid);


ALTER TABLE public.user_retention_52weeks OWNER TO dbservice;

--
-- Name: user_retention_6months; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.user_retention_6months AS
 SELECT user_retention_by_month.month,
    user_retention_by_month.num_consumers,
    user_retention_by_month.repeat_consumers,
    user_retention_by_month.num_tickets,
    user_retention_by_month.sum_amount_list_price,
    user_retention_by_month.sum_amount_paid,
    user_retention_by_month.num_repeat_tickets,
    user_retention_by_month.sum_repeat_amount_list_price,
    user_retention_by_month.sum_repeat_amount_paid,
    user_retention_by_month.frac_users_retained,
    user_retention_by_month.frac_tickets_retained,
    user_retention_by_month.frac_listprice_retained,
    user_retention_by_month.frac_amountpaid_retained,
    user_retention_by_month.old_month,
    user_retention_by_month.old_num_consumers,
    user_retention_by_month.old_repeat_consumers,
    user_retention_by_month.old_num_tickets,
    user_retention_by_month.old_sum_amount_list_price,
    user_retention_by_month.old_sum_amount_paid
   FROM public.user_retention_by_month(6) user_retention_by_month(month, num_consumers, repeat_consumers, num_tickets, sum_amount_list_price, sum_amount_paid, num_repeat_tickets, sum_repeat_amount_list_price, sum_repeat_amount_paid, frac_users_retained, frac_tickets_retained, frac_listprice_retained, frac_amountpaid_retained, old_month, old_num_consumers, old_repeat_consumers, old_num_tickets, old_sum_amount_list_price, old_sum_amount_paid);


ALTER TABLE public.user_retention_6months OWNER TO dbservice;

--
-- Name: user_retention_6weeks; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.user_retention_6weeks AS
 SELECT user_retention_by_week.week,
    user_retention_by_week.num_consumers,
    user_retention_by_week.repeat_consumers,
    user_retention_by_week.num_tickets,
    user_retention_by_week.sum_amount_list_price,
    user_retention_by_week.sum_amount_paid,
    user_retention_by_week.num_repeat_tickets,
    user_retention_by_week.sum_repeat_amount_list_price,
    user_retention_by_week.sum_repeat_amount_paid,
    user_retention_by_week.frac_users_retained,
    user_retention_by_week.frac_tickets_retained,
    user_retention_by_week.frac_listprice_retained,
    user_retention_by_week.frac_amountpaid_retained,
    user_retention_by_week.old_week,
    user_retention_by_week.old_num_consumers,
    user_retention_by_week.old_repeat_consumers,
    user_retention_by_week.old_num_tickets,
    user_retention_by_week.old_sum_amount_list_price,
    user_retention_by_week.old_sum_amount_paid
   FROM public.user_retention_by_week(6) user_retention_by_week(week, num_consumers, repeat_consumers, num_tickets, sum_amount_list_price, sum_amount_paid, num_repeat_tickets, sum_repeat_amount_list_price, sum_repeat_amount_paid, frac_users_retained, frac_tickets_retained, frac_listprice_retained, frac_amountpaid_retained, old_week, old_num_consumers, old_repeat_consumers, old_num_tickets, old_sum_amount_list_price, old_sum_amount_paid);


ALTER TABLE public.user_retention_6weeks OWNER TO dbservice;

--
-- Name: user_retention_8weeks; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.user_retention_8weeks AS
 SELECT user_retention_by_week.week,
    user_retention_by_week.num_consumers,
    user_retention_by_week.repeat_consumers,
    user_retention_by_week.num_tickets,
    user_retention_by_week.sum_amount_list_price,
    user_retention_by_week.sum_amount_paid,
    user_retention_by_week.num_repeat_tickets,
    user_retention_by_week.sum_repeat_amount_list_price,
    user_retention_by_week.sum_repeat_amount_paid,
    user_retention_by_week.frac_users_retained,
    user_retention_by_week.frac_tickets_retained,
    user_retention_by_week.frac_listprice_retained,
    user_retention_by_week.frac_amountpaid_retained,
    user_retention_by_week.old_week,
    user_retention_by_week.old_num_consumers,
    user_retention_by_week.old_repeat_consumers,
    user_retention_by_week.old_num_tickets,
    user_retention_by_week.old_sum_amount_list_price,
    user_retention_by_week.old_sum_amount_paid
   FROM public.user_retention_by_week(8) user_retention_by_week(week, num_consumers, repeat_consumers, num_tickets, sum_amount_list_price, sum_amount_paid, num_repeat_tickets, sum_repeat_amount_list_price, sum_repeat_amount_paid, frac_users_retained, frac_tickets_retained, frac_listprice_retained, frac_amountpaid_retained, old_week, old_num_consumers, old_repeat_consumers, old_num_tickets, old_sum_amount_list_price, old_sum_amount_paid);


ALTER TABLE public.user_retention_8weeks OWNER TO dbservice;

--
-- Name: user_retention_9months; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.user_retention_9months AS
 SELECT user_retention_by_month.month,
    user_retention_by_month.num_consumers,
    user_retention_by_month.repeat_consumers,
    user_retention_by_month.num_tickets,
    user_retention_by_month.sum_amount_list_price,
    user_retention_by_month.sum_amount_paid,
    user_retention_by_month.num_repeat_tickets,
    user_retention_by_month.sum_repeat_amount_list_price,
    user_retention_by_month.sum_repeat_amount_paid,
    user_retention_by_month.frac_users_retained,
    user_retention_by_month.frac_tickets_retained,
    user_retention_by_month.frac_listprice_retained,
    user_retention_by_month.frac_amountpaid_retained,
    user_retention_by_month.old_month,
    user_retention_by_month.old_num_consumers,
    user_retention_by_month.old_repeat_consumers,
    user_retention_by_month.old_num_tickets,
    user_retention_by_month.old_sum_amount_list_price,
    user_retention_by_month.old_sum_amount_paid
   FROM public.user_retention_by_month(9) user_retention_by_month(month, num_consumers, repeat_consumers, num_tickets, sum_amount_list_price, sum_amount_paid, num_repeat_tickets, sum_repeat_amount_list_price, sum_repeat_amount_paid, frac_users_retained, frac_tickets_retained, frac_listprice_retained, frac_amountpaid_retained, old_month, old_num_consumers, old_repeat_consumers, old_num_tickets, old_sum_amount_list_price, old_sum_amount_paid);


ALTER TABLE public.user_retention_9months OWNER TO dbservice;

--
-- Name: user_retention_tickets; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.user_retention_tickets AS
 SELECT byte_tickets.week,
    byte_tickets.month,
    (((byte_tickets.client_name)::text || '--'::text) || byte_tickets.uniq_user) AS consumer_id,
    byte_tickets.amount_list_price,
    byte_tickets.amount_paid
   FROM public.byte_tickets
  WHERE (byte_tickets.uniq_user <> ALL (ARRAY['F.OfflineMode'::text, 'F.Complimentary'::text]));


ALTER TABLE public.user_retention_tickets OWNER TO dbservice;

--
-- Name: valid_bytecodes; Type: VIEW; Schema: public; Owner: dbservice
--

CREATE VIEW public.valid_bytecodes AS
 SELECT bytecodelog.email,
    bytecodelog.bytecode,
    to_timestamp((bytecodelog.created_at)::double precision) AS created_at,
    bytecodelog.duration,
    to_timestamp((bytecodelog.expires_at)::double precision) AS expires_at
   FROM public.bytecodelog
  WHERE ((bytecodelog.expires_at)::double precision >= date_part('epoch'::text, now()))
  ORDER BY (to_timestamp((bytecodelog.expires_at)::double precision)) DESC;


ALTER TABLE public.valid_bytecodes OWNER TO dbservice;

--
-- Name: dependency; Type: VIEW; Schema: report; Owner: dbservice
--

CREATE VIEW report.dependency AS
 WITH RECURSIVE preference AS (
         SELECT 10 AS max_depth,
            16384 AS min_oid,
            '^(londiste|pgq|pg_toast)'::text AS schema_exclusion,
            '^pg_(conversion|language|ts_(dict|template))'::text AS class_exclusion,
            '{"SCHEMA":"00", "TABLE":"01", "TABLE CONSTRAINT":"02", "DEFAULT VALUE":"03",
        "INDEX":"05", "SEQUENCE":"06", "TRIGGER":"07", "FUNCTION":"08",
        "VIEW":"10", "MATERIALIZED VIEW":"11", "FOREIGN TABLE":"12"}'::json AS type_sort_orders
        ), dependency_pair AS (
         SELECT dep.objid,
            array_agg(dep.objsubid ORDER BY dep.objsubid) AS objsubids,
            upper(obj.type) AS object_type,
            COALESCE(obj.schema, "substring"(obj.identity, '(\w+?)\.'::text), ''::text) AS object_schema,
            obj.name AS object_name,
            obj.identity AS object_identity,
            dep.refobjid,
            array_agg(dep.refobjsubid ORDER BY dep.refobjsubid) AS refobjsubids,
            upper(refobj.type) AS refobj_type,
            COALESCE(
                CASE
                    WHEN (refobj.type = 'schema'::text) THEN refobj.identity
                    ELSE refobj.schema
                END, "substring"(refobj.identity, '(\w+?)\.'::text), ''::text) AS refobj_schema,
            refobj.name AS refobj_name,
            refobj.identity AS refobj_identity,
                CASE dep.deptype
                    WHEN 'n'::"char" THEN 'normal'::text
                    WHEN 'a'::"char" THEN 'automatic'::text
                    WHEN 'i'::"char" THEN 'internal'::text
                    WHEN 'e'::"char" THEN 'extension'::text
                    WHEN 'p'::"char" THEN 'pinned'::text
                    ELSE NULL::text
                END AS dependency_type
           FROM pg_depend dep,
            LATERAL pg_identify_object(dep.classid, dep.objid, 0) obj(type, schema, name, identity),
            LATERAL pg_identify_object(dep.refclassid, dep.refobjid, 0) refobj(type, schema, name, identity),
            preference
          WHERE ((dep.deptype = ANY ('{n,a}'::"char"[])) AND (dep.objid >= (preference.min_oid)::oid) AND ((dep.refobjid >= (preference.min_oid)::oid) OR (dep.refobjid = (2200)::oid)) AND (COALESCE(obj.schema, "substring"(obj.identity, '(\w+?)\.'::text), ''::text) !~ preference.schema_exclusion) AND (COALESCE(
                CASE
                    WHEN (refobj.type = 'schema'::text) THEN refobj.identity
                    ELSE refobj.schema
                END, "substring"(refobj.identity, '(\w+?)\.'::text), ''::text) !~ preference.schema_exclusion))
          GROUP BY dep.objid, obj.type, obj.schema, obj.name, obj.identity, dep.refobjid, refobj.type, refobj.schema, refobj.name, refobj.identity, dep.deptype
        ), dependency_hierarchy AS (
         SELECT DISTINCT 0 AS level,
            root.refobjid AS objid,
            root.refobj_type AS object_type,
            root.refobj_identity AS object_identity,
            NULL::text AS dependency_type,
            ARRAY[root.refobjid] AS dependency_chain,
            ARRAY[concat((preference.type_sort_orders ->> root.refobj_type), root.refobj_type, ':', root.refobj_identity)] AS dependency_sort_chain
           FROM dependency_pair root,
            preference
          WHERE ((NOT (EXISTS ( SELECT 'x'::text
                   FROM dependency_pair branch
                  WHERE (branch.objid = root.refobjid)))) AND (root.refobj_schema !~ preference.schema_exclusion))
        UNION ALL
         SELECT (parent.level + 1) AS level,
            child.objid,
            child.object_type,
            child.object_identity,
            child.dependency_type,
            (parent.dependency_chain || child.objid),
            (parent.dependency_sort_chain || concat((preference.type_sort_orders ->> child.object_type), child.object_type, ':', child.object_identity))
           FROM (dependency_pair child
             JOIN dependency_hierarchy parent ON ((parent.objid = child.refobjid))),
            preference
          WHERE ((parent.level < preference.max_depth) AND (child.object_schema !~ preference.schema_exclusion) AND (child.refobj_schema !~ preference.schema_exclusion) AND (NOT (child.objid = ANY (parent.dependency_chain))))
        )
 SELECT dependency_hierarchy.level,
    dependency_hierarchy.objid,
    dependency_hierarchy.object_type,
    dependency_hierarchy.object_identity,
    dependency_hierarchy.dependency_type,
    dependency_hierarchy.dependency_chain,
    dependency_hierarchy.dependency_sort_chain
   FROM dependency_hierarchy
  ORDER BY dependency_hierarchy.dependency_chain;


ALTER TABLE report.dependency OWNER TO dbservice;

--
-- Name: current_inventory; Type: VIEW; Schema: rptg; Owner: dbservice
--

CREATE VIEW rptg.current_inventory AS
 SELECT spoiled_data.epc,
    spoiled_data.kiosk_id,
    spoiled_data.product_id,
    spoiled_data.time_added,
    spoiled_data.cost,
    spoiled_data.price,
    spoiled_data.kiosk_campus_id,
    spoiled_data.product_campus_id,
    spoiled_data.enable_reporting
   FROM ( SELECT unique_epcs.epc,
            all_epc_data.kiosk_id,
            all_epc_data.product_id,
            to_timestamp((all_epc_data.time_added)::double precision) AS time_added,
            all_epc_data.cost,
            all_epc_data.price,
            all_epc_data.kiosk_campus_id,
            all_epc_data.product_campus_id,
            all_epc_data.enable_reporting
           FROM (( SELECT l.epc,
                    max(l.time_added) AS time_added
                   FROM ((pantry.label l
                     JOIN pantry.kiosk k ON ((k.id = l.kiosk_id)))
                     JOIN pantry.product p ON ((p.id = l.product_id)))
                  WHERE (((l.status)::text = 'ok'::text) AND (l.order_id IS NULL))
                  GROUP BY l.epc) unique_epcs
             LEFT JOIN ( SELECT l.epc,
                    l.product_id,
                    l.time_added,
                    p.cost,
                    p.price,
                    l.kiosk_id,
                    k.campus_id AS kiosk_campus_id,
                    p.campus_id AS product_campus_id,
                    k.enable_reporting
                   FROM ((pantry.label l
                     JOIN pantry.kiosk k ON ((k.id = l.kiosk_id)))
                     JOIN pantry.product p ON ((p.id = l.product_id)))
                  WHERE (((l.status)::text = 'ok'::text) AND (l.order_id IS NULL))) all_epc_data ON ((((unique_epcs.epc)::text = (all_epc_data.epc)::text) AND (unique_epcs.time_added = all_epc_data.time_added))))) spoiled_data
  WHERE ((NOT ((spoiled_data.epc)::text IN ( SELECT l.epc
           FROM (((pantry.label l
             JOIN pantry.kiosk k ON ((k.id = l.kiosk_id)))
             JOIN pantry.product p ON ((p.id = l.product_id)))
             JOIN pantry."order" o ON (((o.order_id)::text = (l.order_id)::text)))
          WHERE (((to_timestamp((o.created)::double precision))::date >= ( SELECT ((now() - '1 mon'::interval))::date AS date)) AND ((to_timestamp((o.created)::double precision))::date <= ( SELECT ((now() + '1 mon'::interval))::date AS date)) AND ((l.status)::text = 'sold'::text) AND ((l.order_id)::text !~~ 'RE%'::text) AND (l.order_id IS NOT NULL))))) AND (NOT ((spoiled_data.epc)::text IN ( SELECT l.epc
           FROM (((pantry.label l
             JOIN pantry.kiosk k ON ((k.id = l.kiosk_id)))
             JOIN pantry.product p ON ((p.id = l.product_id)))
             JOIN pantry."order" o ON (((o.order_id)::text = (l.order_id)::text)))
          WHERE (((to_timestamp((o.created)::double precision))::date >= ( SELECT ((now() - '1 mon'::interval))::date AS date)) AND ((to_timestamp((o.created)::double precision))::date <= ( SELECT ((now() + '1 mon'::interval))::date AS date)) AND ((l.status)::text = 'sold'::text) AND ((l.order_id)::text ~~ 'RE%'::text))))));


ALTER TABLE rptg.current_inventory OWNER TO dbservice;

--
-- Name: temp_yann_boardq3; Type: TABLE; Schema: rptg; Owner: dbservice
--

CREATE TABLE rptg.temp_yann_boardq3 (
    year double precision,
    month double precision,
    month_year text,
    product_id bigint,
    title character varying(381),
    sku_group character varying(765),
    consumer_category character varying(6000),
    "?column?" text,
    kiosk_w_sales bigint,
    units_sold_per_kiosk double precision,
    kiosk_week_sales_fix double precision,
    price numeric(5,2),
    cost numeric(5,2),
    unit_margin double precision,
    count_sales bigint,
    sales_list_price numeric,
    ttl_cost double precision,
    units_unsold double precision,
    cost_unsold double precision,
    units_lost bigint,
    cost_lost numeric,
    lost_percent double precision,
    rfid_cost double precision
);


ALTER TABLE rptg.temp_yann_boardq3 OWNER TO dbservice;

--
-- Name: temp_yann_q1; Type: TABLE; Schema: rptg; Owner: dbservice
--

CREATE TABLE rptg.temp_yann_q1 (
    year double precision,
    month double precision,
    month_year text,
    kiosk_id bigint,
    title character varying(138),
    client_name character varying(765),
    geo character varying(9),
    monthly_subscription bigint,
    coalesced_sales_list_price numeric,
    byte_discount double precision,
    sales_after_discount double precision,
    coalesced_total_food_cost numeric,
    coalesced_total_unsold_cost numeric,
    coalesced_total_lost_cost numeric,
    subsidy character varying(150)
);


ALTER TABLE rptg.temp_yann_q1 OWNER TO dbservice;

--
-- Name: accounting_bkup_20200204_partial; Type: TABLE; Schema: test; Owner: dbservice
--

CREATE TABLE test.accounting_bkup_20200204_partial (
    id bigint,
    date character varying(45),
    kiosk_id bigint,
    campus_id bigint,
    sales_ipc numeric(6,2),
    sales_fp numeric(6,2),
    sales_cs numeric(6,2),
    sales_cp numeric(6,2),
    tags_got bigint,
    tags_spent bigint,
    timezone smallint,
    sales_tax numeric(4,2),
    sales_tax_ipc numeric(6,2),
    sales_tax_fp numeric(6,2),
    sales_tax_cs numeric(6,2),
    sales_tax_cp numeric(6,2),
    prepaid bigint,
    current_fee bigint,
    next_fee bigint,
    recalculated_fee numeric(6,2),
    prepaid_day bigint,
    next_fee_from character varying(45),
    fee_connectivity numeric(5,2)
);


ALTER TABLE test.accounting_bkup_20200204_partial OWNER TO dbservice;

--
-- Name: accounting_partial_backup_20191101; Type: TABLE; Schema: test; Owner: dbservice
--

CREATE TABLE test.accounting_partial_backup_20191101 (
    id bigint,
    date character varying(45),
    kiosk_id bigint,
    campus_id bigint,
    sales_ipc numeric(6,2),
    sales_fp numeric(6,2),
    sales_cs numeric(6,2),
    sales_cp numeric(6,2),
    tags_got bigint,
    tags_spent bigint,
    timezone smallint,
    sales_tax numeric(4,2),
    sales_tax_ipc numeric(6,2),
    sales_tax_fp numeric(6,2),
    sales_tax_cs numeric(6,2),
    sales_tax_cp numeric(6,2),
    prepaid bigint,
    current_fee bigint,
    next_fee bigint,
    recalculated_fee numeric(6,2),
    prepaid_day bigint,
    next_fee_from character varying(45),
    fee_connectivity numeric(5,2)
);


ALTER TABLE test.accounting_partial_backup_20191101 OWNER TO dbservice;

--
-- Name: accounting_partial_bkup_20200131; Type: TABLE; Schema: test; Owner: dbservice
--

CREATE TABLE test.accounting_partial_bkup_20200131 (
    id bigint,
    date character varying(45),
    kiosk_id bigint,
    campus_id bigint,
    sales_ipc numeric(6,2),
    sales_fp numeric(6,2),
    sales_cs numeric(6,2),
    sales_cp numeric(6,2),
    tags_got bigint,
    tags_spent bigint,
    timezone smallint,
    sales_tax numeric(4,2),
    sales_tax_ipc numeric(6,2),
    sales_tax_fp numeric(6,2),
    sales_tax_cs numeric(6,2),
    sales_tax_cp numeric(6,2),
    prepaid bigint,
    current_fee bigint,
    next_fee bigint,
    recalculated_fee numeric(6,2),
    prepaid_day bigint,
    next_fee_from character varying(45),
    fee_connectivity numeric(5,2)
);


ALTER TABLE test.accounting_partial_bkup_20200131 OWNER TO dbservice;

--
-- Name: backup_eng_2669_order; Type: TABLE; Schema: test; Owner: dbservice
--

CREATE TABLE test.backup_eng_2669_order (
    order_id character varying(45),
    first_name character varying(45),
    last_name character varying(45),
    kiosk_id bigint,
    kiosk_title character varying(46),
    email character varying(127),
    amount_paid numeric(6,2),
    payment_system character varying(45),
    transaction_id character varying(45),
    approval_code character varying(45),
    status_code character varying(45),
    status_message character varying(45),
    status character varying(45),
    batch_id character varying(15),
    created bigint,
    auth_amount character varying(7),
    data_token character varying(2047),
    time_opened bigint,
    time_closed bigint,
    card_hash character varying(88),
    state character varying(15),
    archived bigint,
    stamp bigint,
    last_update bigint,
    balance numeric(7,2),
    delta character varying(4),
    coupon_id bigint,
    coupon character varying(45),
    refund numeric(6,2),
    receipt bigint,
    campus_id bigint,
    amount_list_price numeric(6,2),
    time_door_opened bigint,
    time_door_closed bigint,
    notes text
);


ALTER TABLE test.backup_eng_2669_order OWNER TO dbservice;

--
-- Name: campus_20190605; Type: TABLE; Schema: test; Owner: dbservice
--

CREATE TABLE test.campus_20190605 (
    id bigint,
    title character varying(45),
    timezone character varying(50),
    archived integer
);


ALTER TABLE test.campus_20190605 OWNER TO dbservice;

--
-- Name: campus_20190620; Type: TABLE; Schema: test; Owner: dbservice
--

CREATE TABLE test.campus_20190620 (
    id bigint,
    title character varying(45),
    timezone character varying(50),
    archived integer
);


ALTER TABLE test.campus_20190620 OWNER TO dbservice;

--
-- Name: cron_broken; Type: TABLE; Schema: test; Owner: dbservice
--

CREATE TABLE test.cron_broken (
    id integer,
    "time" character varying(300),
    kiosks character varying(30000),
    command character varying(300),
    payload text,
    trigger_id integer,
    dependencies character varying(300),
    user_id integer,
    raw_task text,
    active integer,
    group_id integer,
    timezone character varying(210),
    archived integer
);


ALTER TABLE test.cron_broken OWNER TO dbservice;

--
-- Name: discount_20190614; Type: TABLE; Schema: test; Owner: dbservice
--

CREATE TABLE test.discount_20190614 (
    id bigint,
    kiosk_id bigint,
    product_id bigint,
    value integer,
    type character varying(10),
    end_time integer,
    cron_task_id integer
);


ALTER TABLE test.discount_20190614 OWNER TO dbservice;

--
-- Name: eng2903; Type: TABLE; Schema: test; Owner: dbservice
--

CREATE TABLE test.eng2903 (
    order_id character varying(45) NOT NULL
);


ALTER TABLE test.eng2903 OWNER TO dbservice;

--
-- Name: fee_rate_bkup_20200131; Type: TABLE; Schema: test; Owner: dbservice
--

CREATE TABLE test.fee_rate_bkup_20200131 (
    id bigint,
    fee_lease numeric(6,2),
    fee_tags numeric(3,2),
    fee_ipc numeric(5,4),
    bi_monthly smallint,
    archived smallint,
    custom smallint,
    prepaid_amount bigint,
    name character varying(128)
);


ALTER TABLE test.fee_rate_bkup_20200131 OWNER TO dbservice;

--
-- Name: kiosk; Type: TABLE; Schema: test; Owner: dbservice
--

CREATE TABLE test.kiosk (
    id bigint,
    campus_id bigint,
    serial character varying(45),
    title character varying(46),
    address character varying(127),
    location_x numeric(9,6),
    location_y numeric(9,6),
    gcm_id character varying(255),
    app_vname character varying(63),
    app_vcode integer,
    archived bigint,
    creation_time bigint,
    deployment_time bigint,
    last_update bigint,
    client_name character varying(255),
    last_status bigint,
    last_inventory bigint,
    kiosk_name character varying(255),
    payment_start bigint,
    payment_stop bigint,
    features character varying(255),
    sales_tax smallint,
    default_fee_plan bigint,
    timezone character varying(50),
    estd_num_users bigint,
    tags character varying(255),
    publicly_accessible bigint,
    cardkey_required bigint,
    delivery_insns character varying(65535),
    fridge_loc_info character varying(65535),
    contact_first_name character varying(65535),
    contact_last_name character varying(65535),
    contact_email character varying(65535),
    contact_phone character varying(65535),
    accounting_email character varying(65535),
    byte_discount character varying(255),
    subsidy_info character varying(50),
    subsidy_notes character varying(65535),
    max_subscription character varying(50),
    delivery_window_mon character varying(50),
    delivery_window_tue character varying(50),
    delivery_window_wed character varying(50),
    delivery_window_thu character varying(50),
    delivery_window_fri character varying(50),
    delivery_window_sat character varying(50),
    delivery_window_sun character varying(50),
    notes character varying(2000),
    components text,
    email_receipt_subject character varying(255),
    ops_team_notes character varying(65535),
    geo character varying(3),
    server_url character varying(127),
    subscription_amount numeric(8,2),
    enable_reporting bigint,
    enable_monitoring bigint,
    employees_num bigint,
    kiosk_restrictions character varying(2000)
);


ALTER TABLE test.kiosk OWNER TO dbservice;

--
-- Name: kiosk_20190605; Type: TABLE; Schema: test; Owner: dbservice
--

CREATE TABLE test.kiosk_20190605 (
    id bigint,
    campus_id bigint,
    serial character varying(45),
    title character varying(46),
    address character varying(127),
    location_x numeric(9,6),
    location_y numeric(9,6),
    gcm_id character varying(255),
    app_vname character varying(63),
    app_vcode integer,
    archived bigint,
    creation_time bigint,
    deployment_time bigint,
    last_update bigint,
    client_name character varying(255),
    last_status bigint,
    last_inventory bigint,
    kiosk_name character varying(255),
    payment_start bigint,
    payment_stop bigint,
    features character varying(255),
    sales_tax smallint,
    default_fee_plan bigint,
    timezone character varying(50),
    estd_num_users bigint,
    tags character varying(255),
    publicly_accessible bigint,
    cardkey_required bigint,
    delivery_insns character varying(65535),
    fridge_loc_info character varying(65535),
    contact_first_name character varying(65535),
    contact_last_name character varying(65535),
    contact_email character varying(65535),
    contact_phone character varying(65535),
    accounting_email character varying(65535),
    byte_discount character varying(255),
    subsidy_info character varying(50),
    subsidy_notes character varying(65535),
    max_subscription character varying(50),
    delivery_window_mon character varying(50),
    delivery_window_tue character varying(50),
    delivery_window_wed character varying(50),
    delivery_window_thu character varying(50),
    delivery_window_fri character varying(50),
    delivery_window_sat character varying(50),
    delivery_window_sun character varying(50),
    notes character varying(2000),
    components text,
    email_receipt_subject character varying(255),
    ops_team_notes character varying(65535),
    geo character varying(3),
    server_url character varying(127),
    subscription_amount numeric(8,2),
    enable_reporting bigint,
    enable_monitoring bigint,
    employees_num bigint,
    kiosk_restrictions character varying(2000)
);


ALTER TABLE test.kiosk_20190605 OWNER TO dbservice;

--
-- Name: kiosk_20190606; Type: TABLE; Schema: test; Owner: dbservice
--

CREATE TABLE test.kiosk_20190606 (
    id bigint,
    campus_id bigint,
    serial character varying(45),
    title character varying(46),
    address character varying(127),
    location_x numeric(9,6),
    location_y numeric(9,6),
    gcm_id character varying(255),
    app_vname character varying(63),
    app_vcode integer,
    archived bigint,
    creation_time bigint,
    deployment_time bigint,
    last_update bigint,
    client_name character varying(255),
    last_status bigint,
    last_inventory bigint,
    kiosk_name character varying(255),
    payment_start bigint,
    payment_stop bigint,
    features character varying(255),
    sales_tax smallint,
    default_fee_plan bigint,
    timezone character varying(50),
    estd_num_users bigint,
    tags character varying(255),
    publicly_accessible bigint,
    cardkey_required bigint,
    delivery_insns character varying(65535),
    fridge_loc_info character varying(65535),
    contact_first_name character varying(65535),
    contact_last_name character varying(65535),
    contact_email character varying(65535),
    contact_phone character varying(65535),
    accounting_email character varying(65535),
    byte_discount character varying(255),
    subsidy_info character varying(50),
    subsidy_notes character varying(65535),
    max_subscription character varying(50),
    delivery_window_mon character varying(50),
    delivery_window_tue character varying(50),
    delivery_window_wed character varying(50),
    delivery_window_thu character varying(50),
    delivery_window_fri character varying(50),
    delivery_window_sat character varying(50),
    delivery_window_sun character varying(50),
    notes character varying(2000),
    components text,
    email_receipt_subject character varying(255),
    ops_team_notes character varying(65535),
    geo character varying(3),
    server_url character varying(127),
    subscription_amount numeric(8,2),
    enable_reporting bigint,
    enable_monitoring bigint,
    employees_num bigint,
    kiosk_restrictions character varying(2000)
);


ALTER TABLE test.kiosk_20190606 OWNER TO dbservice;

--
-- Name: kiosk_20190611; Type: TABLE; Schema: test; Owner: dbservice
--

CREATE TABLE test.kiosk_20190611 (
    id bigint,
    campus_id bigint,
    serial character varying(45),
    title character varying(46),
    address character varying(127),
    location_x numeric(9,6),
    location_y numeric(9,6),
    gcm_id character varying(255),
    app_vname character varying(63),
    app_vcode integer,
    archived bigint,
    creation_time bigint,
    deployment_time bigint,
    last_update bigint,
    client_name character varying(255),
    last_status bigint,
    last_inventory bigint,
    kiosk_name character varying(255),
    payment_start bigint,
    payment_stop bigint,
    features character varying(255),
    sales_tax smallint,
    default_fee_plan bigint,
    timezone character varying(50),
    estd_num_users bigint,
    tags character varying(255),
    publicly_accessible bigint,
    cardkey_required bigint,
    delivery_insns character varying(65535),
    fridge_loc_info character varying(65535),
    contact_first_name character varying(65535),
    contact_last_name character varying(65535),
    contact_email character varying(65535),
    contact_phone character varying(65535),
    accounting_email character varying(65535),
    byte_discount character varying(255),
    subsidy_info character varying(50),
    subsidy_notes character varying(65535),
    max_subscription character varying(50),
    delivery_window_mon character varying(50),
    delivery_window_tue character varying(50),
    delivery_window_wed character varying(50),
    delivery_window_thu character varying(50),
    delivery_window_fri character varying(50),
    delivery_window_sat character varying(50),
    delivery_window_sun character varying(50),
    notes character varying(2000),
    components text,
    email_receipt_subject character varying(255),
    ops_team_notes character varying(65535),
    geo character varying(3),
    server_url character varying(127),
    subscription_amount numeric(8,2),
    enable_reporting bigint,
    enable_monitoring bigint,
    employees_num bigint,
    kiosk_restrictions character varying(2000)
);


ALTER TABLE test.kiosk_20190611 OWNER TO dbservice;

--
-- Name: kiosk_20190612; Type: TABLE; Schema: test; Owner: dbservice
--

CREATE TABLE test.kiosk_20190612 (
    id bigint,
    campus_id bigint,
    serial character varying(45),
    title character varying(46),
    address character varying(127),
    location_x numeric(9,6),
    location_y numeric(9,6),
    gcm_id character varying(255),
    app_vname character varying(63),
    app_vcode integer,
    archived bigint,
    creation_time bigint,
    deployment_time bigint,
    last_update bigint,
    client_name character varying(255),
    last_status bigint,
    last_inventory bigint,
    kiosk_name character varying(255),
    payment_start bigint,
    payment_stop bigint,
    features character varying(255),
    sales_tax smallint,
    default_fee_plan bigint,
    timezone character varying(50),
    estd_num_users bigint,
    tags character varying(255),
    publicly_accessible bigint,
    cardkey_required bigint,
    delivery_insns character varying(65535),
    fridge_loc_info character varying(65535),
    contact_first_name character varying(65535),
    contact_last_name character varying(65535),
    contact_email character varying(65535),
    contact_phone character varying(65535),
    accounting_email character varying(65535),
    byte_discount character varying(255),
    subsidy_info character varying(50),
    subsidy_notes character varying(65535),
    max_subscription character varying(50),
    delivery_window_mon character varying(50),
    delivery_window_tue character varying(50),
    delivery_window_wed character varying(50),
    delivery_window_thu character varying(50),
    delivery_window_fri character varying(50),
    delivery_window_sat character varying(50),
    delivery_window_sun character varying(50),
    notes character varying(2000),
    components text,
    email_receipt_subject character varying(255),
    ops_team_notes character varying(65535),
    geo character varying(3),
    server_url character varying(127),
    subscription_amount numeric(8,2),
    enable_reporting bigint,
    enable_monitoring bigint,
    employees_num bigint,
    kiosk_restrictions character varying(2000)
);


ALTER TABLE test.kiosk_20190612 OWNER TO dbservice;

--
-- Name: kiosk_20190918; Type: TABLE; Schema: test; Owner: dbservice
--

CREATE TABLE test.kiosk_20190918 (
    id bigint,
    campus_id bigint,
    serial character varying(45),
    title character varying(46),
    address character varying(127),
    location_x numeric(9,6),
    location_y numeric(9,6),
    gcm_id character varying(255),
    app_vname character varying(63),
    app_vcode integer,
    archived bigint,
    creation_time bigint,
    deployment_time bigint,
    last_update bigint,
    client_name character varying(255),
    last_status bigint,
    last_inventory bigint,
    kiosk_name character varying(255),
    payment_start bigint,
    payment_stop bigint,
    features character varying(255),
    sales_tax smallint,
    default_fee_plan bigint,
    timezone character varying(50),
    estd_num_users bigint,
    tags character varying(255),
    publicly_accessible bigint,
    cardkey_required bigint,
    delivery_insns character varying(65535),
    fridge_loc_info character varying(65535),
    contact_first_name character varying(65535),
    contact_last_name character varying(65535),
    contact_email character varying(65535),
    contact_phone character varying(65535),
    accounting_email character varying(65535),
    byte_discount character varying(255),
    subsidy_info character varying(50),
    subsidy_notes character varying(65535),
    max_subscription character varying(50),
    delivery_window_mon character varying(50),
    delivery_window_tue character varying(50),
    delivery_window_wed character varying(50),
    delivery_window_thu character varying(50),
    delivery_window_fri character varying(50),
    delivery_window_sat character varying(50),
    delivery_window_sun character varying(50),
    notes character varying(2000),
    components text,
    email_receipt_subject character varying(255),
    ops_team_notes character varying(65535),
    geo character varying(3),
    server_url character varying(127),
    subscription_amount numeric(8,2),
    enable_reporting bigint,
    enable_monitoring bigint,
    employees_num bigint,
    kiosk_restrictions character varying(2000)
);


ALTER TABLE test.kiosk_20190918 OWNER TO dbservice;

--
-- Name: kiosk_20200304; Type: TABLE; Schema: test; Owner: dbservice
--

CREATE TABLE test.kiosk_20200304 (
    id integer,
    title character varying(8000)
);


ALTER TABLE test.kiosk_20200304 OWNER TO dbservice;

--
-- Name: kiosk_bkup_20200204; Type: TABLE; Schema: test; Owner: dbservice
--

CREATE TABLE test.kiosk_bkup_20200204 (
    id bigint,
    campus_id bigint,
    serial character varying(45),
    title character varying(46),
    address character varying(127),
    location_x numeric(9,6),
    location_y numeric(9,6),
    gcm_id character varying(255),
    app_vname character varying(63),
    app_vcode integer,
    archived bigint,
    creation_time bigint,
    deployment_time bigint,
    last_update bigint,
    client_name character varying(255),
    last_status bigint,
    last_inventory bigint,
    kiosk_name character varying(255),
    payment_start bigint,
    payment_stop bigint,
    features character varying(255),
    sales_tax smallint,
    default_fee_plan bigint,
    timezone character varying(50),
    estd_num_users bigint,
    tags character varying(255),
    publicly_accessible bigint,
    cardkey_required bigint,
    delivery_insns character varying(65535),
    fridge_loc_info character varying(65535),
    contact_first_name character varying(65535),
    contact_last_name character varying(65535),
    contact_email character varying(65535),
    contact_phone character varying(65535),
    accounting_email character varying(65535),
    byte_discount character varying(255),
    subsidy_info character varying(50),
    subsidy_notes character varying(65535),
    max_subscription character varying(50),
    delivery_window_mon character varying(50),
    delivery_window_tue character varying(50),
    delivery_window_wed character varying(50),
    delivery_window_thu character varying(50),
    delivery_window_fri character varying(50),
    delivery_window_sat character varying(50),
    delivery_window_sun character varying(50),
    notes character varying(2000),
    components text,
    email_receipt_subject character varying(255),
    ops_team_notes character varying(65535),
    geo character varying(3),
    server_url character varying(127),
    subscription_amount numeric(8,2),
    enable_reporting bigint,
    enable_monitoring bigint,
    employees_num bigint,
    kiosk_restrictions character varying(2000)
);


ALTER TABLE test.kiosk_bkup_20200204 OWNER TO dbservice;

--
-- Name: kiosk_payment_start; Type: TABLE; Schema: test; Owner: dbservice
--

CREATE TABLE test.kiosk_payment_start (
    id integer NOT NULL,
    start_date_str text
);


ALTER TABLE test.kiosk_payment_start OWNER TO dbservice;

--
-- Name: kiosk_serial_20190916; Type: TABLE; Schema: test; Owner: dbservice
--

CREATE TABLE test.kiosk_serial_20190916 (
    id bigint NOT NULL,
    serial character varying(45)
);


ALTER TABLE test.kiosk_serial_20190916 OWNER TO dbservice;

--
-- Name: locked_kiosk_by_command; Type: TABLE; Schema: test; Owner: dbservice
--

CREATE TABLE test.locked_kiosk_by_command (
    lock_ts_string text,
    kiosk_id integer,
    lock_ts timestamp with time zone
);


ALTER TABLE test.locked_kiosk_by_command OWNER TO dbservice;

--
-- Name: locked_kiosk_via_pw; Type: TABLE; Schema: test; Owner: dbservice
--

CREATE TABLE test.locked_kiosk_via_pw (
    lock_ts_string text,
    kiosk_id integer,
    lock_ts timestamp with time zone
);


ALTER TABLE test.locked_kiosk_via_pw OWNER TO dbservice;

--
-- Name: lost_wall_clock_orders; Type: TABLE; Schema: test; Owner: dbservice
--

CREATE TABLE test.lost_wall_clock_orders (
    order_id text
);


ALTER TABLE test.lost_wall_clock_orders OWNER TO dbservice;

--
-- Name: november_order; Type: TABLE; Schema: test; Owner: dbservice
--

CREATE TABLE test.november_order (
    order_id text
);


ALTER TABLE test.november_order OWNER TO dbservice;

--
-- Name: order_complimentary_eng_2292; Type: TABLE; Schema: test; Owner: dbservice
--

CREATE TABLE test.order_complimentary_eng_2292 (
    order_id character varying(45) NOT NULL
);


ALTER TABLE test.order_complimentary_eng_2292 OWNER TO dbservice;

--
-- Name: order_epc_pending_sync; Type: TABLE; Schema: test; Owner: dbservice
--

CREATE TABLE test.order_epc_pending_sync (
    epc character varying(24) NOT NULL,
    order_id text
);


ALTER TABLE test.order_epc_pending_sync OWNER TO dbservice;

--
-- Name: order_with_1970_and_2000_dates; Type: TABLE; Schema: test; Owner: dbservice
--

CREATE TABLE test.order_with_1970_and_2000_dates (
    order_id character varying(45),
    first_name character varying(45),
    last_name character varying(45),
    kiosk_id bigint,
    kiosk_title character varying(46),
    email character varying(127),
    amount_paid numeric(6,2),
    payment_system character varying(45),
    transaction_id character varying(45),
    approval_code character varying(45),
    status_code character varying(45),
    status_message character varying(45),
    status character varying(45),
    batch_id character varying(15),
    created bigint,
    auth_amount character varying(7),
    data_token character varying(2047),
    time_opened bigint,
    time_closed bigint,
    card_hash character varying(88),
    state character varying(15),
    archived bigint,
    stamp bigint,
    last_update bigint,
    balance numeric(7,2),
    delta character varying(4),
    coupon_id bigint,
    coupon character varying(45),
    refund numeric(6,2),
    receipt bigint,
    campus_id bigint,
    amount_list_price numeric(6,2),
    time_door_opened bigint,
    time_door_closed bigint,
    notes text
);


ALTER TABLE test.order_with_1970_and_2000_dates OWNER TO dbservice;

--
-- Name: reauth_2019_07_priced_finalized_orders; Type: TABLE; Schema: test; Owner: dbservice
--

CREATE TABLE test.reauth_2019_07_priced_finalized_orders (
    order_id character varying(45) NOT NULL
);


ALTER TABLE test.reauth_2019_07_priced_finalized_orders OWNER TO dbservice;

--
-- Name: request_log_epc_order; Type: TABLE; Schema: test; Owner: dbservice
--

CREATE TABLE test.request_log_epc_order (
    epc character varying(24) NOT NULL,
    order_id text,
    ts timestamp without time zone NOT NULL
);


ALTER TABLE test.request_log_epc_order OWNER TO dbservice;

--
-- Name: request_log_order; Type: TABLE; Schema: test; Owner: dbservice
--

CREATE TABLE test.request_log_order (
    order_id text NOT NULL
);


ALTER TABLE test.request_log_order OWNER TO dbservice;

--
-- Name: request_log_sold_epc; Type: TABLE; Schema: test; Owner: dbservice
--

CREATE TABLE test.request_log_sold_epc (
    id integer NOT NULL,
    epc character varying(24) NOT NULL,
    order_id text,
    kiosk_id bigint,
    direction character varying(16) NOT NULL,
    reason text,
    ts timestamp without time zone NOT NULL
);


ALTER TABLE test.request_log_sold_epc OWNER TO dbservice;

--
-- Name: request_log_sold_epc_id_seq; Type: SEQUENCE; Schema: test; Owner: dbservice
--

CREATE SEQUENCE test.request_log_sold_epc_id_seq
CREATE SEQUENCE test.request_log_sold_epc_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE test.request_log_sold_epc_id_seq OWNER TO dbservice;

--
-- Name: request_log_sold_epc_id_seq; Type: SEQUENCE OWNED BY; Schema: test; Owner: dbservice
--

ALTER SEQUENCE test.request_log_sold_epc_id_seq OWNED BY test.request_log_sold_epc.id;


--
-- Name: temp_pending; Type: TABLE; Schema: test; Owner: dbservice
--

CREATE TABLE test.temp_pending (
    epc character varying(24) NOT NULL,
    order_id text
);


ALTER TABLE test.temp_pending OWNER TO dbservice;

--
-- Name: transactions_pending_sync; Type: TABLE; Schema: test; Owner: dbservice
--

CREATE TABLE test.transactions_pending_sync (
    id integer NOT NULL,
    epc character varying(24) NOT NULL,
    order_id text,
    kiosk_id bigint,
    direction character varying(16) NOT NULL,
    reason text,
    ts timestamp without time zone NOT NULL
);


ALTER TABLE test.transactions_pending_sync OWNER TO dbservice;

--
-- Name: transactions_pending_sync_id_seq; Type: SEQUENCE; Schema: test; Owner: dbservice
--

CREATE SEQUENCE test.transactions_pending_sync_id_seq
CREATE SEQUENCE test.transactions_pending_sync_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE test.transactions_pending_sync_id_seq OWNER TO dbservice;

--
-- Name: transactions_pending_sync_id_seq; Type: SEQUENCE OWNED BY; Schema: test; Owner: dbservice
--

ALTER SEQUENCE test.transactions_pending_sync_id_seq OWNED BY test.transactions_pending_sync.id;


--
-- Name: vantiv_20190801; Type: TABLE; Schema: test; Owner: dbservice
--

CREATE TABLE test.vantiv_20190801 (
    "Merchant DBA" text,
    transactionid integer,
    name text,
    terminalid text,
    approvalnumber text,
    expirationmonth integer,
    expirationyear integer,
    expressresponsecode integer,
    expressresponsemessage text,
    originalauthorizedamount integer,
    referencenumber text,
    ticketnumber integer,
    transactionamount numeric,
    transactionstatus text,
    transactiontype text,
    cardnumbermasked text,
    cardlogo text,
    cardtype text,
    trackdatapresent text,
    expresstransactiondate integer,
    expresstransactiontime integer,
    merchantcategorycode integer,
    cardinputcode integer
);


ALTER TABLE test.vantiv_20190801 OWNER TO dbservice;

--
-- Name: vantiv_20190801b; Type: TABLE; Schema: test; Owner: dbservice
--

CREATE TABLE test.vantiv_20190801b (
    "Merchant DBA" text,
    transactionid integer,
    name text,
    terminalid text,
    approvalnumber text,
    expirationmonth integer,
    expirationyear integer,
    expressresponsecode integer,
    expressresponsemessage text,
    originalauthorizedamount numeric,
    referencenumber text,
    ticketnumber integer,
    transactionamount numeric,
    transactionstatus text,
    transactiontype text,
    cardnumbermasked text,
    cardlogo text,
    cardtype text,
    trackdatapresent text,
    expresstransactiondate integer,
    expresstransactiontime integer,
    merchantcategorycode integer,
    cardinputcode integer
);


ALTER TABLE test.vantiv_20190801b OWNER TO dbservice;

--
-- Name: deps_saved_ddl; Type: TABLE; Schema: util; Owner: dbservice
--

CREATE TABLE util.deps_saved_ddl (
    deps_id integer NOT NULL,
    deps_view_schema character varying(255),
    deps_view_name character varying(255),
    deps_ddl_to_run text
);


ALTER TABLE util.deps_saved_ddl OWNER TO dbservice;

--
-- Name: TABLE deps_saved_ddl; Type: COMMENT; Schema: util; Owner: dbservice
--

COMMENT ON TABLE util.deps_saved_ddl IS 'part of save/drop/restore dependent views suite: table to store DDL of dependent views';


--
-- Name: deps_saved_ddl_deps_id_seq; Type: SEQUENCE; Schema: util; Owner: dbservice
--

CREATE SEQUENCE util.deps_saved_ddl_deps_id_seq
CREATE SEQUENCE util.deps_saved_ddl_deps_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE util.deps_saved_ddl_deps_id_seq OWNER TO dbservice;

--
-- Name: deps_saved_ddl_deps_id_seq; Type: SEQUENCE OWNED BY; Schema: util; Owner: dbservice
--

ALTER SEQUENCE util.deps_saved_ddl_deps_id_seq OWNED BY util.deps_saved_ddl.deps_id;


--
-- Name: pick_demand id; Type: DEFAULT; Schema: beta; Owner: dbservice
--

ALTER TABLE ONLY beta.pick_demand ALTER COLUMN id SET DEFAULT nextval('beta.pick_demand_id_seq'::regclass);


--
-- Name: temp_test id; Type: DEFAULT; Schema: beta; Owner: dbservice
--

ALTER TABLE ONLY beta.temp_test ALTER COLUMN id SET DEFAULT nextval('beta.temp_test_id_seq'::regclass);


--
-- Name: temp_test2 id; Type: DEFAULT; Schema: beta; Owner: dbservice
--

ALTER TABLE ONLY beta.temp_test2 ALTER COLUMN id SET DEFAULT nextval('beta.temp_test2_id_seq'::regclass);


--
-- Name: product_property_def id; Type: DEFAULT; Schema: inm; Owner: dbservice
--

ALTER TABLE ONLY inm.product_property_def ALTER COLUMN id SET DEFAULT nextval('inm.product_property_def_id_seq'::regclass);


--
-- Name: card_fact id; Type: DEFAULT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.card_fact ALTER COLUMN id SET DEFAULT nextval('mixalot.card_fact_id_seq'::regclass);


--
-- Name: card_product_fact id; Type: DEFAULT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.card_product_fact ALTER COLUMN id SET DEFAULT nextval('mixalot.card_product_fact_id_seq'::regclass);


--
-- Name: history_order_pipeline id; Type: DEFAULT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.history_order_pipeline ALTER COLUMN id SET DEFAULT nextval('mixalot.history_order_id_seq'::regclass);


--
-- Name: inm_data id; Type: DEFAULT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.inm_data ALTER COLUMN id SET DEFAULT nextval('mixalot.inm_data_id_seq'::regclass);


--
-- Name: kiosk_contents id; Type: DEFAULT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.kiosk_contents ALTER COLUMN id SET DEFAULT nextval('mixalot.kiosk_contents_id_seq'::regclass);


--
-- Name: kiosk_fact id; Type: DEFAULT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.kiosk_fact ALTER COLUMN id SET DEFAULT nextval('mixalot.kiosk_fact_id_seq'::regclass);


--
-- Name: log id; Type: DEFAULT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.log ALTER COLUMN id SET DEFAULT nextval('mixalot.log_id_seq'::regclass);


--
-- Name: merchandising_slot id; Type: DEFAULT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.merchandising_slot ALTER COLUMN id SET DEFAULT nextval('mixalot.merchandising_slot_id_seq'::regclass);


--
-- Name: merchandising_slot_def id; Type: DEFAULT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.merchandising_slot_def ALTER COLUMN id SET DEFAULT nextval('mixalot.merchandising_slot_def_id_seq'::regclass);


--
-- Name: order_fact id; Type: DEFAULT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.order_fact ALTER COLUMN id SET DEFAULT nextval('mixalot.order_fact_id_seq'::regclass);


--
-- Name: product_fact id; Type: DEFAULT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.product_fact ALTER COLUMN id SET DEFAULT nextval('mixalot.product_fact_id_seq'::regclass);


--
-- Name: product_kiosk_fact id; Type: DEFAULT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.product_kiosk_fact ALTER COLUMN id SET DEFAULT nextval('mixalot.product_kiosk_fact_id_seq'::regclass);


--
-- Name: server id; Type: DEFAULT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.server ALTER COLUMN id SET DEFAULT nextval('mixalot.server_id_seq'::regclass);


--
-- Name: sku_group id; Type: DEFAULT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.sku_group ALTER COLUMN id SET DEFAULT nextval('mixalot.sku_group_id_seq'::regclass);


--
-- Name: sku_group_def id; Type: DEFAULT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.sku_group_def ALTER COLUMN id SET DEFAULT nextval('mixalot.sku_group_def_id_seq'::regclass);


--
-- Name: sku_group_member id; Type: DEFAULT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.sku_group_member ALTER COLUMN id SET DEFAULT nextval('mixalot.sku_group_member_id_seq'::regclass);


--
-- Name: sku_property_def id; Type: DEFAULT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.sku_property_def ALTER COLUMN id SET DEFAULT nextval('mixalot.sku_attribute_def_id_seq'::regclass);


--
-- Name: temp_test id; Type: DEFAULT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.temp_test ALTER COLUMN id SET DEFAULT nextval('mixalot.temp_test_id_seq'::regclass);


--
-- Name: test_time id; Type: DEFAULT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.test_time ALTER COLUMN id SET DEFAULT nextval('mixalot.test_time_id_seq'::regclass);


--
-- Name: tmp_discount_applied id; Type: DEFAULT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.tmp_discount_applied ALTER COLUMN id SET DEFAULT nextval('mixalot.tmp_discount_applied_id_seq'::regclass);


--
-- Name: tmp_kiosk_status id; Type: DEFAULT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.tmp_kiosk_status ALTER COLUMN id SET DEFAULT nextval('mixalot.tmp_kiosk_status_id_seq'::regclass);


--
-- Name: tmp_unit id; Type: DEFAULT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.tmp_unit ALTER COLUMN id SET DEFAULT nextval('mixalot.lineitem_id_seq'::regclass);


--
-- Name: accounting id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.accounting ALTER COLUMN id SET DEFAULT nextval('pantry.accounting_id_seq'::regclass);


--
-- Name: bad_timestamp id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.bad_timestamp ALTER COLUMN id SET DEFAULT nextval('pantry.bad_timestamp_id_seq'::regclass);


--
-- Name: campus id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.campus ALTER COLUMN id SET DEFAULT nextval('pantry.campus_id_seq'::regclass);


--
-- Name: campus_attribute id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.campus_attribute ALTER COLUMN id SET DEFAULT nextval('pantry.campus_attribute_id_seq'::regclass);


--
-- Name: card id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.card ALTER COLUMN id SET DEFAULT nextval('pantry.card_id_seq'::regclass);


--
-- Name: contract id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.contract ALTER COLUMN id SET DEFAULT nextval('pantry.contract_id_seq'::regclass);


--
-- Name: coupon id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.coupon ALTER COLUMN id SET DEFAULT nextval('pantry.coupon_id_seq'::regclass);


--
-- Name: cron id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.cron ALTER COLUMN id SET DEFAULT nextval('pantry.cron_id_seq'::regclass);


--
-- Name: currency_symbol id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.currency_symbol ALTER COLUMN id SET DEFAULT nextval('pantry.currency_symbol_id_seq'::regclass);


--
-- Name: delivery_schedule id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.delivery_schedule ALTER COLUMN id SET DEFAULT nextval('pantry.delivery_schedule_id_seq'::regclass);


--
-- Name: discount id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.discount ALTER COLUMN id SET DEFAULT nextval('pantry.discount_id_seq'::regclass);


--
-- Name: discount_applied id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.discount_applied ALTER COLUMN id SET DEFAULT nextval('pantry.discount_applied_id_seq'::regclass);


--
-- Name: discount_history id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.discount_history ALTER COLUMN id SET DEFAULT nextval('pantry.discount_history_id_seq'::regclass);


--
-- Name: email id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.email ALTER COLUMN id SET DEFAULT nextval('pantry.email_id_seq'::regclass);


--
-- Name: empty_transaction id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.empty_transaction ALTER COLUMN id SET DEFAULT nextval('pantry.empty_transaction_id_seq'::regclass);


--
-- Name: event id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.event ALTER COLUMN id SET DEFAULT nextval('pantry.event_id_seq'::regclass);


--
-- Name: facing_category id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.facing_category ALTER COLUMN id SET DEFAULT nextval('pantry.facing_category_id_seq'::regclass);


--
-- Name: fee_rates id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.fee_rates ALTER COLUMN id SET DEFAULT nextval('pantry.fee_rates_id_seq'::regclass);


--
-- Name: feedback id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.feedback ALTER COLUMN id SET DEFAULT nextval('pantry.feedback_id_seq'::regclass);


--
-- Name: global_attribute_def id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.global_attribute_def ALTER COLUMN id SET DEFAULT nextval('pantry.global_attribute_def_id_seq'::regclass);


--
-- Name: group id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry."group" ALTER COLUMN id SET DEFAULT nextval('pantry.group_id_seq'::regclass);


--
-- Name: history id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.history ALTER COLUMN id SET DEFAULT nextval('pantry.history_id_seq'::regclass);


--
-- Name: history_epc_order id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.history_epc_order ALTER COLUMN id SET DEFAULT nextval('pantry.history_epc_order_id_seq'::regclass);


--
-- Name: inventory_history id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.inventory_history ALTER COLUMN id SET DEFAULT nextval('pantry.inventory_history_id_seq'::regclass);


--
-- Name: inventory_request id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.inventory_request ALTER COLUMN id SET DEFAULT nextval('pantry.inventory_request_id_seq'::regclass);


--
-- Name: kiosk id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.kiosk ALTER COLUMN id SET DEFAULT nextval('pantry.kiosk_id_seq'::regclass);


--
-- Name: kiosk_attribute id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.kiosk_attribute ALTER COLUMN id SET DEFAULT nextval('pantry.kiosk_attribute_id_seq'::regclass);


--
-- Name: kiosk_audit_log id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.kiosk_audit_log ALTER COLUMN id SET DEFAULT nextval('pantry.kiosk_audit_log_id_seq'::regclass);


--
-- Name: kiosk_catalog_downloads id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.kiosk_catalog_downloads ALTER COLUMN id SET DEFAULT nextval('pantry.kiosk_catalog_downloads_id_seq'::regclass);


--
-- Name: kiosk_components_history id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.kiosk_components_history ALTER COLUMN id SET DEFAULT nextval('pantry.kiosk_components_history_id_seq'::regclass);


--
-- Name: kiosk_device id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.kiosk_device ALTER COLUMN id SET DEFAULT nextval('pantry.kiosk_device_id_seq'::regclass);


--
-- Name: kiosk_status id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.kiosk_status ALTER COLUMN id SET DEFAULT nextval('pantry.kiosk_status_id_seq'::regclass);


--
-- Name: kiosks_date_non_new id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.kiosks_date_non_new ALTER COLUMN id SET DEFAULT nextval('pantry.kiosks_date_non_new_id_seq'::regclass);


--
-- Name: label id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.label ALTER COLUMN id SET DEFAULT nextval('pantry.label_id_seq'::regclass);


--
-- Name: label_order id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.label_order ALTER COLUMN id SET DEFAULT nextval('pantry.label_order_id_seq'::regclass);


--
-- Name: last_kiosk_status id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.last_kiosk_status ALTER COLUMN id SET DEFAULT nextval('pantry.last_kiosk_status_id_seq'::regclass);


--
-- Name: manual_adjustment id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.manual_adjustment ALTER COLUMN id SET DEFAULT nextval('pantry.manual_adjustment_id_seq'::regclass);


--
-- Name: nutrition_filter id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.nutrition_filter ALTER COLUMN id SET DEFAULT nextval('pantry.nutrition_filter_id_seq'::regclass);


--
-- Name: order_meta id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.order_meta ALTER COLUMN id SET DEFAULT nextval('pantry.order_meta_id_seq'::regclass);


--
-- Name: par_history id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.par_history ALTER COLUMN id SET DEFAULT nextval('pantry.par_history_id_seq'::regclass);


--
-- Name: payment_order id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.payment_order ALTER COLUMN id SET DEFAULT nextval('pantry.payment_order_id_seq'::regclass);


--
-- Name: permission id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.permission ALTER COLUMN id SET DEFAULT nextval('pantry.permission_id_seq'::regclass);


--
-- Name: pick_list_row id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.pick_list_row ALTER COLUMN id SET DEFAULT nextval('pantry.pick_list_row_id_seq'::regclass);


--
-- Name: product id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.product ALTER COLUMN id SET DEFAULT nextval('pantry.product_id_seq'::regclass);


--
-- Name: product_categories id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.product_categories ALTER COLUMN id SET DEFAULT nextval('pantry.product_categories_id_seq'::regclass);


--
-- Name: product_history id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.product_history ALTER COLUMN id SET DEFAULT nextval('pantry.product_history_id_seq'::regclass);


--
-- Name: product_kiosk_price_offset id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.product_kiosk_price_offset ALTER COLUMN id SET DEFAULT nextval('pantry.product_kiosk_price_offset_id_seq'::regclass);


--
-- Name: product_request id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.product_request ALTER COLUMN id SET DEFAULT nextval('pantry.product_request_id_seq'::regclass);


--
-- Name: restock_item id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.restock_item ALTER COLUMN id SET DEFAULT nextval('pantry.restock_item_id_seq'::regclass);


--
-- Name: role id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.role ALTER COLUMN id SET DEFAULT nextval('pantry.role_id_seq'::regclass);


--
-- Name: spoilage id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.spoilage ALTER COLUMN id SET DEFAULT nextval('pantry.spoilage_id_seq'::regclass);


--
-- Name: stockout id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.stockout ALTER COLUMN id SET DEFAULT nextval('pantry.stockout_id_seq'::regclass);


--
-- Name: tag id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.tag ALTER COLUMN id SET DEFAULT nextval('pantry.tag_id_seq'::regclass);


--
-- Name: temperature_tag_history id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.temperature_tag_history ALTER COLUMN id SET DEFAULT nextval('pantry.temperature_tag_history_id_seq'::regclass);


--
-- Name: transact_comp id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.transact_comp ALTER COLUMN id SET DEFAULT nextval('pantry.transact_comp_id_seq'::regclass);


--
-- Name: transact_express id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.transact_express ALTER COLUMN id SET DEFAULT nextval('pantry.transact_express_id_seq'::regclass);


--
-- Name: transact_fp id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.transact_fp ALTER COLUMN id SET DEFAULT nextval('pantry.transact_fp_id_seq'::regclass);


--
-- Name: transact_ipc id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.transact_ipc ALTER COLUMN id SET DEFAULT nextval('pantry.transact_ipc_id_seq'::regclass);


--
-- Name: user id; Type: DEFAULT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry."user" ALTER COLUMN id SET DEFAULT nextval('pantry.user_id_seq'::regclass);


--
-- Name: awsdms_ddl_audit c_key; Type: DEFAULT; Schema: public; Owner: dbservice
--

ALTER TABLE ONLY public.awsdms_ddl_audit ALTER COLUMN c_key SET DEFAULT nextval('public.awsdms_ddl_audit_c_key_seq'::regclass);


--
-- Name: awsdms_heartbeat hb_key; Type: DEFAULT; Schema: public; Owner: dbservice
--

ALTER TABLE ONLY public.awsdms_heartbeat ALTER COLUMN hb_key SET DEFAULT nextval('public.awsdms_heartbeat_hb_key_seq'::regclass);


--
-- Name: campaigns campaign_id; Type: DEFAULT; Schema: public; Owner: dbservice
--

ALTER TABLE ONLY public.campaigns ALTER COLUMN campaign_id SET DEFAULT nextval('public.campaigns_campaign_id_seq'::regclass);


--
-- Name: customers customer_id; Type: DEFAULT; Schema: public; Owner: dbservice
--

ALTER TABLE ONLY public.customers ALTER COLUMN customer_id SET DEFAULT nextval('public.customers_customer_id_seq'::regclass);


--
-- Name: kiosk id; Type: DEFAULT; Schema: public; Owner: dbservice
--

ALTER TABLE ONLY public.kiosk ALTER COLUMN id SET DEFAULT nextval('public.kiosk_id_seq'::regclass);


--
-- Name: pantry.kiosk id; Type: DEFAULT; Schema: public; Owner: dbservice
--

ALTER TABLE ONLY public."pantry.kiosk" ALTER COLUMN id SET DEFAULT nextval('public."pantry.kiosk_id_seq"'::regclass);


--
-- Name: track_dashboard id; Type: DEFAULT; Schema: public; Owner: dbservice
--

ALTER TABLE ONLY public.track_dashboard ALTER COLUMN id SET DEFAULT nextval('public.track_dashboard_id_seq'::regclass);


--
-- Name: track_inventory id; Type: DEFAULT; Schema: public; Owner: dbservice
--

ALTER TABLE ONLY public.track_inventory ALTER COLUMN id SET DEFAULT nextval('public.track_inventory_id_seq'::regclass);


--
-- Name: request_log_sold_epc id; Type: DEFAULT; Schema: test; Owner: dbservice
--

ALTER TABLE ONLY test.request_log_sold_epc ALTER COLUMN id SET DEFAULT nextval('test.request_log_sold_epc_id_seq'::regclass);


--
-- Name: transactions_pending_sync id; Type: DEFAULT; Schema: test; Owner: dbservice
--

ALTER TABLE ONLY test.transactions_pending_sync ALTER COLUMN id SET DEFAULT nextval('test.transactions_pending_sync_id_seq'::regclass);


--
-- Name: deps_saved_ddl deps_id; Type: DEFAULT; Schema: util; Owner: dbservice
--

ALTER TABLE ONLY util.deps_saved_ddl ALTER COLUMN deps_id SET DEFAULT nextval('util.deps_saved_ddl_deps_id_seq'::regclass);


--
-- Name: kiosk_sku_group_manual_scale kiosk_sku_group_manual_scale_pkey; Type: CONSTRAINT; Schema: beta; Owner: dbservice
--

ALTER TABLE ONLY beta.kiosk_sku_group_manual_scale
    ADD CONSTRAINT kiosk_sku_group_manual_scale_pkey PRIMARY KEY (kiosk_id, fc_title);


--
-- Name: missing_hash missing_hash_pkey; Type: CONSTRAINT; Schema: beta; Owner: dbservice
--

ALTER TABLE ONLY beta.missing_hash
    ADD CONSTRAINT missing_hash_pkey PRIMARY KEY (order_id);


--
-- Name: pick_demand pick_demand_pkey; Type: CONSTRAINT; Schema: beta; Owner: dbservice
--

ALTER TABLE ONLY beta.pick_demand
    ADD CONSTRAINT pick_demand_pkey PRIMARY KEY (id);


--
-- Name: sku_group_control sku_group_control_pkey; Type: CONSTRAINT; Schema: beta; Owner: dbservice
--

ALTER TABLE ONLY beta.sku_group_control
    ADD CONSTRAINT sku_group_control_pkey PRIMARY KEY (fc_title);


--
-- Name: temp_nutrition_filter temp_nutrition_filter_pkey; Type: CONSTRAINT; Schema: beta; Owner: dbservice
--

ALTER TABLE ONLY beta.temp_nutrition_filter
    ADD CONSTRAINT temp_nutrition_filter_pkey PRIMARY KEY (id);


--
-- Name: temp_product temp_product_pkey; Type: CONSTRAINT; Schema: beta; Owner: dbservice
--

ALTER TABLE ONLY beta.temp_product
    ADD CONSTRAINT temp_product_pkey PRIMARY KEY (id);


--
-- Name: temp_sku_group_attribute temp_sku_group_attribute_pkey; Type: CONSTRAINT; Schema: beta; Owner: dbservice
--

ALTER TABLE ONLY beta.temp_sku_group_attribute
    ADD CONSTRAINT temp_sku_group_attribute_pkey PRIMARY KEY (title);


--
-- Name: temp_test2 temp_test2_pkey; Type: CONSTRAINT; Schema: beta; Owner: dbservice
--

ALTER TABLE ONLY beta.temp_test2
    ADD CONSTRAINT temp_test2_pkey PRIMARY KEY (id);


--
-- Name: temp_test temp_test_pkey; Type: CONSTRAINT; Schema: beta; Owner: dbservice
--

ALTER TABLE ONLY beta.temp_test
    ADD CONSTRAINT temp_test_pkey PRIMARY KEY (id);


--
-- Name: warehouse_inventory_history warehouse_inventory_history_pkey; Type: CONSTRAINT; Schema: beta; Owner: dbservice
--

ALTER TABLE ONLY beta.warehouse_inventory_history
    ADD CONSTRAINT warehouse_inventory_history_pkey PRIMARY KEY (date_, sku);


--
-- Name: accounting accounting_pkey; Type: CONSTRAINT; Schema: develop; Owner: dbservice
--

ALTER TABLE ONLY develop.accounting
    ADD CONSTRAINT accounting_pkey PRIMARY KEY (id);


--
-- Name: campus campus_pkey; Type: CONSTRAINT; Schema: develop; Owner: dbservice
--

ALTER TABLE ONLY develop.campus
    ADD CONSTRAINT campus_pkey PRIMARY KEY (id);


--
-- Name: card card_pkey; Type: CONSTRAINT; Schema: develop; Owner: dbservice
--

ALTER TABLE ONLY develop.card
    ADD CONSTRAINT card_pkey PRIMARY KEY (id);


--
-- Name: contract contract_pkey; Type: CONSTRAINT; Schema: develop; Owner: dbservice
--

ALTER TABLE ONLY develop.contract
    ADD CONSTRAINT contract_pkey PRIMARY KEY (id);


--
-- Name: coupon coupon_pkey; Type: CONSTRAINT; Schema: develop; Owner: dbservice
--

ALTER TABLE ONLY develop.coupon
    ADD CONSTRAINT coupon_pkey PRIMARY KEY (id);


--
-- Name: cron cron_pkey; Type: CONSTRAINT; Schema: develop; Owner: dbservice
--

ALTER TABLE ONLY develop.cron
    ADD CONSTRAINT cron_pkey PRIMARY KEY (id);


--
-- Name: current_label_status_365days current_label_status_365days_pkey; Type: CONSTRAINT; Schema: develop; Owner: dbservice
--

ALTER TABLE ONLY develop.current_label_status_365days
    ADD CONSTRAINT current_label_status_365days_pkey PRIMARY KEY (epc);


--
-- Name: discount_history discount_history_pkey; Type: CONSTRAINT; Schema: develop; Owner: dbservice
--

ALTER TABLE ONLY develop.discount_history
    ADD CONSTRAINT discount_history_pkey PRIMARY KEY (id);


--
-- Name: discount discount_pkey; Type: CONSTRAINT; Schema: develop; Owner: dbservice
--

ALTER TABLE ONLY develop.discount
    ADD CONSTRAINT discount_pkey PRIMARY KEY (id);


--
-- Name: event event_pkey; Type: CONSTRAINT; Schema: develop; Owner: dbservice
--

ALTER TABLE ONLY develop.event
    ADD CONSTRAINT event_pkey PRIMARY KEY (id);


--
-- Name: fee_rates fee_rates_pkey; Type: CONSTRAINT; Schema: develop; Owner: dbservice
--

ALTER TABLE ONLY develop.fee_rates
    ADD CONSTRAINT fee_rates_pkey PRIMARY KEY (id);


--
-- Name: feedback feedback_pkey; Type: CONSTRAINT; Schema: develop; Owner: dbservice
--

ALTER TABLE ONLY develop.feedback
    ADD CONSTRAINT feedback_pkey PRIMARY KEY (id);


--
-- Name: group_campus group_campus_pkey; Type: CONSTRAINT; Schema: develop; Owner: dbservice
--

ALTER TABLE ONLY develop.group_campus
    ADD CONSTRAINT group_campus_pkey PRIMARY KEY (group_id, campus_id);


--
-- Name: group group_pkey; Type: CONSTRAINT; Schema: develop; Owner: dbservice
--

ALTER TABLE ONLY develop."group"
    ADD CONSTRAINT group_pkey PRIMARY KEY (id);


--
-- Name: history_epc_order history_epc_order_pkey; Type: CONSTRAINT; Schema: develop; Owner: dbservice
--

ALTER TABLE ONLY develop.history_epc_order
    ADD CONSTRAINT history_epc_order_pkey PRIMARY KEY (id);


--
-- Name: history history_pkey; Type: CONSTRAINT; Schema: develop; Owner: dbservice
--

ALTER TABLE ONLY develop.history
    ADD CONSTRAINT history_pkey PRIMARY KEY (id);


--
-- Name: inventory_history inventory_history_pkey; Type: CONSTRAINT; Schema: develop; Owner: dbservice
--

ALTER TABLE ONLY develop.inventory_history
    ADD CONSTRAINT inventory_history_pkey PRIMARY KEY (id);


--
-- Name: kiosk_par_level kiosk_par_level_pkey; Type: CONSTRAINT; Schema: develop; Owner: dbservice
--

ALTER TABLE ONLY develop.kiosk_par_level
    ADD CONSTRAINT kiosk_par_level_pkey PRIMARY KEY (kiosk_id, product_id);


--
-- Name: kiosk kiosk_pkey; Type: CONSTRAINT; Schema: develop; Owner: dbservice
--

ALTER TABLE ONLY develop.kiosk
    ADD CONSTRAINT kiosk_pkey PRIMARY KEY (id);


--
-- Name: kiosk_status kiosk_status_pkey; Type: CONSTRAINT; Schema: develop; Owner: dbservice
--

ALTER TABLE ONLY develop.kiosk_status
    ADD CONSTRAINT kiosk_status_pkey PRIMARY KEY (id);


--
-- Name: label_order label_order_pkey; Type: CONSTRAINT; Schema: develop; Owner: dbservice
--

ALTER TABLE ONLY develop.label_order
    ADD CONSTRAINT label_order_pkey PRIMARY KEY (id);


--
-- Name: label label_pkey; Type: CONSTRAINT; Schema: develop; Owner: dbservice
--

ALTER TABLE ONLY develop.label
    ADD CONSTRAINT label_pkey PRIMARY KEY (id);


--
-- Name: last_kiosk_status last_kiosk_status_pkey; Type: CONSTRAINT; Schema: develop; Owner: dbservice
--

ALTER TABLE ONLY develop.last_kiosk_status
    ADD CONSTRAINT last_kiosk_status_pkey PRIMARY KEY (id);


--
-- Name: manual_adjustment manual_adjustment_pkey; Type: CONSTRAINT; Schema: develop; Owner: dbservice
--

ALTER TABLE ONLY develop.manual_adjustment
    ADD CONSTRAINT manual_adjustment_pkey PRIMARY KEY (id);


--
-- Name: order order_pkey; Type: CONSTRAINT; Schema: develop; Owner: dbservice
--

ALTER TABLE ONLY develop."order"
    ADD CONSTRAINT order_pkey PRIMARY KEY (order_id);


--
-- Name: par_history par_history_pkey; Type: CONSTRAINT; Schema: develop; Owner: dbservice
--

ALTER TABLE ONLY develop.par_history
    ADD CONSTRAINT par_history_pkey PRIMARY KEY (id);


--
-- Name: permission_mapping permission_mapping_pkey; Type: CONSTRAINT; Schema: develop; Owner: dbservice
--

ALTER TABLE ONLY develop.permission_mapping
    ADD CONSTRAINT permission_mapping_pkey PRIMARY KEY (role_id, permission_id);


--
-- Name: permission permission_pkey; Type: CONSTRAINT; Schema: develop; Owner: dbservice
--

ALTER TABLE ONLY develop.permission
    ADD CONSTRAINT permission_pkey PRIMARY KEY (id);


--
-- Name: product_history product_history_pkey; Type: CONSTRAINT; Schema: develop; Owner: dbservice
--

ALTER TABLE ONLY develop.product_history
    ADD CONSTRAINT product_history_pkey PRIMARY KEY (id);


--
-- Name: product product_pkey; Type: CONSTRAINT; Schema: develop; Owner: dbservice
--

ALTER TABLE ONLY develop.product
    ADD CONSTRAINT product_pkey PRIMARY KEY (id);


--
-- Name: ro_order ro_order_pkey; Type: CONSTRAINT; Schema: develop; Owner: dbservice
--

ALTER TABLE ONLY develop.ro_order
    ADD CONSTRAINT ro_order_pkey PRIMARY KEY (order_id);


--
-- Name: role_mapping role_mapping_pkey; Type: CONSTRAINT; Schema: develop; Owner: dbservice
--

ALTER TABLE ONLY develop.role_mapping
    ADD CONSTRAINT role_mapping_pkey PRIMARY KEY (role_id, parent_id);


--
-- Name: role role_pkey; Type: CONSTRAINT; Schema: develop; Owner: dbservice
--

ALTER TABLE ONLY develop.role
    ADD CONSTRAINT role_pkey PRIMARY KEY (id);


--
-- Name: sessions sessions_pkey; Type: CONSTRAINT; Schema: develop; Owner: dbservice
--

ALTER TABLE ONLY develop.sessions
    ADD CONSTRAINT sessions_pkey PRIMARY KEY (sid);


--
-- Name: spoilage spoilage_pkey; Type: CONSTRAINT; Schema: develop; Owner: dbservice
--

ALTER TABLE ONLY develop.spoilage
    ADD CONSTRAINT spoilage_pkey PRIMARY KEY (id);


--
-- Name: tag tag_pkey; Type: CONSTRAINT; Schema: develop; Owner: dbservice
--

ALTER TABLE ONLY develop.tag
    ADD CONSTRAINT tag_pkey PRIMARY KEY (id);


--
-- Name: temp temp_pkey; Type: CONSTRAINT; Schema: develop; Owner: dbservice
--

ALTER TABLE ONLY develop.temp
    ADD CONSTRAINT temp_pkey PRIMARY KEY (id);


--
-- Name: timezone_mapping timezone_mapping_pkey; Type: CONSTRAINT; Schema: develop; Owner: dbservice
--

ALTER TABLE ONLY develop.timezone_mapping
    ADD CONSTRAINT timezone_mapping_pkey PRIMARY KEY (id);


--
-- Name: transact_comp transact_comp_pkey; Type: CONSTRAINT; Schema: develop; Owner: dbservice
--

ALTER TABLE ONLY develop.transact_comp
    ADD CONSTRAINT transact_comp_pkey PRIMARY KEY (id);


--
-- Name: transact_cs transact_cs_pkey; Type: CONSTRAINT; Schema: develop; Owner: dbservice
--

ALTER TABLE ONLY develop.transact_cs
    ADD CONSTRAINT transact_cs_pkey PRIMARY KEY (id);


--
-- Name: transact_fp transact_fp_pkey; Type: CONSTRAINT; Schema: develop; Owner: dbservice
--

ALTER TABLE ONLY develop.transact_fp
    ADD CONSTRAINT transact_fp_pkey PRIMARY KEY (id);


--
-- Name: transact_ipc transact_ipc_pkey; Type: CONSTRAINT; Schema: develop; Owner: dbservice
--

ALTER TABLE ONLY develop.transact_ipc
    ADD CONSTRAINT transact_ipc_pkey PRIMARY KEY (id);


--
-- Name: unused_user_mapping unused_user_mapping_pkey; Type: CONSTRAINT; Schema: develop; Owner: dbservice
--

ALTER TABLE ONLY develop.unused_user_mapping
    ADD CONSTRAINT unused_user_mapping_pkey PRIMARY KEY (user_id, role_id);


--
-- Name: user user_pkey; Type: CONSTRAINT; Schema: develop; Owner: dbservice
--

ALTER TABLE ONLY develop."user"
    ADD CONSTRAINT user_pkey PRIMARY KEY (id);


--
-- Name: tmp_payment_information tmp_payment_information_pkey; Type: CONSTRAINT; Schema: fnrenames; Owner: dbservice
--

ALTER TABLE ONLY fnrenames.tmp_payment_information
    ADD CONSTRAINT tmp_payment_information_pkey PRIMARY KEY (order_id);


--
-- Name: bringg_delivery bringg_delivery_pkey; Type: CONSTRAINT; Schema: inm; Owner: dbservice
--

ALTER TABLE ONLY inm.bringg_delivery
    ADD CONSTRAINT bringg_delivery_pkey PRIMARY KEY (task_id);


--
-- Name: configuration configuration_pkey; Type: CONSTRAINT; Schema: inm; Owner: dbservice
--

ALTER TABLE ONLY inm.configuration
    ADD CONSTRAINT configuration_pkey PRIMARY KEY (setting);


--
-- Name: kiosk_attribute kiosk_attribute_pkey; Type: CONSTRAINT; Schema: inm; Owner: dbservice
--

ALTER TABLE ONLY inm.kiosk_attribute
    ADD CONSTRAINT kiosk_attribute_pkey PRIMARY KEY (id);


--
-- Name: kiosk_control kiosk_control_pkey; Type: CONSTRAINT; Schema: inm; Owner: dbservice
--

ALTER TABLE ONLY inm.kiosk_control
    ADD CONSTRAINT kiosk_control_pkey PRIMARY KEY (kiosk_id);


--
-- Name: kiosk_product_disabled kiosk_product_enabled_pkey; Type: CONSTRAINT; Schema: inm; Owner: dbservice
--

ALTER TABLE ONLY inm.kiosk_product_disabled
    ADD CONSTRAINT kiosk_product_enabled_pkey PRIMARY KEY (kiosk_id, product_id);


--
-- Name: kiosk_restriction_by_product kiosk_restriction_by_product_pkey; Type: CONSTRAINT; Schema: inm; Owner: dbservice
--

ALTER TABLE ONLY inm.kiosk_restriction_by_product
    ADD CONSTRAINT kiosk_restriction_by_product_pkey PRIMARY KEY (kiosk_id, product_id);


--
-- Name: kiosk_restriction_by_property kiosk_restriction_by_property_pkey; Type: CONSTRAINT; Schema: inm; Owner: dbservice
--

ALTER TABLE ONLY inm.kiosk_restriction_by_property
    ADD CONSTRAINT kiosk_restriction_by_property_pkey PRIMARY KEY (kiosk_id, property_id);


--
-- Name: kiosk_restriction_by_sku kiosk_restriction_by_sku_pkey; Type: CONSTRAINT; Schema: inm; Owner: dbservice
--

ALTER TABLE ONLY inm.kiosk_restriction_by_sku
    ADD CONSTRAINT kiosk_restriction_by_sku_pkey PRIMARY KEY (kiosk_id, sku_id);


--
-- Name: kiosk_sku_group_manual_scale kiosk_sku_group_manual_scale_pkey; Type: CONSTRAINT; Schema: inm; Owner: dbservice
--

ALTER TABLE ONLY inm.kiosk_sku_group_manual_scale
    ADD CONSTRAINT kiosk_sku_group_manual_scale_pkey PRIMARY KEY (kiosk_id, sku_group_id);


--
-- Name: pick_allocation pick_allocation_pkey; Type: CONSTRAINT; Schema: inm; Owner: dbservice
--

ALTER TABLE ONLY inm.pick_allocation
    ADD CONSTRAINT pick_allocation_pkey PRIMARY KEY (pick_date, route_date, kiosk_id, sku_id);


--
-- Name: pick_demand pick_demand_pkey; Type: CONSTRAINT; Schema: inm; Owner: dbservice
--

ALTER TABLE ONLY inm.pick_demand
    ADD CONSTRAINT pick_demand_pkey PRIMARY KEY (pick_date, route_date, kiosk_id, sku_group_id);


--
-- Name: pick_inventory pick_inventory_pkey; Type: CONSTRAINT; Schema: inm; Owner: dbservice
--

ALTER TABLE ONLY inm.pick_inventory
    ADD CONSTRAINT pick_inventory_pkey PRIMARY KEY (pick_date, route_date, kiosk_id, sku_group_id);


--
-- Name: pick_list pick_list_pkey; Type: CONSTRAINT; Schema: inm; Owner: dbservice
--

ALTER TABLE ONLY inm.pick_list
    ADD CONSTRAINT pick_list_pkey PRIMARY KEY (pick_date);


--
-- Name: pick_preference_kiosk_sku pick_preference_kiosk_sku_pkey; Type: CONSTRAINT; Schema: inm; Owner: dbservice
--

ALTER TABLE ONLY inm.pick_preference_kiosk_sku
    ADD CONSTRAINT pick_preference_kiosk_sku_pkey PRIMARY KEY (kiosk_id, sku_id);


--
-- Name: pick_priority_kiosk pick_priority_kiosk_pkey; Type: CONSTRAINT; Schema: inm; Owner: dbservice
--

ALTER TABLE ONLY inm.pick_priority_kiosk
    ADD CONSTRAINT pick_priority_kiosk_pkey PRIMARY KEY (kiosk_id);


--
-- Name: pick_priority_sku pick_priority_sku_pkey; Type: CONSTRAINT; Schema: inm; Owner: dbservice
--

ALTER TABLE ONLY inm.pick_priority_sku
    ADD CONSTRAINT pick_priority_sku_pkey PRIMARY KEY (sku_id);


--
-- Name: pick_rejection pick_rejection_pkey; Type: CONSTRAINT; Schema: inm; Owner: dbservice
--

ALTER TABLE ONLY inm.pick_rejection
    ADD CONSTRAINT pick_rejection_pkey PRIMARY KEY (pick_date, route_date, kiosk_id, item_id, item_type, reason);


--
-- Name: pick_route pick_route_pkey; Type: CONSTRAINT; Schema: inm; Owner: dbservice
--

ALTER TABLE ONLY inm.pick_route
    ADD CONSTRAINT pick_route_pkey PRIMARY KEY (pick_date, kiosk_id, route_date);


--
-- Name: pick_substitution pick_substitution_pkey; Type: CONSTRAINT; Schema: inm; Owner: dbservice
--

ALTER TABLE ONLY inm.pick_substitution
    ADD CONSTRAINT pick_substitution_pkey PRIMARY KEY (substituting_sku_group_id, substituted_sku_group_id, pick_date);


--
-- Name: product_property_def product_property_def_name_value_key; Type: CONSTRAINT; Schema: inm; Owner: dbservice
--

ALTER TABLE ONLY inm.product_property_def
    ADD CONSTRAINT product_property_def_name_value_key UNIQUE (name, value);


--
-- Name: product_property_def product_property_def_pkey; Type: CONSTRAINT; Schema: inm; Owner: dbservice
--

ALTER TABLE ONLY inm.product_property_def
    ADD CONSTRAINT product_property_def_pkey PRIMARY KEY (id);


--
-- Name: product_property product_property_pkey; Type: CONSTRAINT; Schema: inm; Owner: dbservice
--

ALTER TABLE ONLY inm.product_property
    ADD CONSTRAINT product_property_pkey PRIMARY KEY (product_id, property_id);


--
-- Name: sku_def sku_def_pkey; Type: CONSTRAINT; Schema: inm; Owner: dbservice
--

ALTER TABLE ONLY inm.sku_def
    ADD CONSTRAINT sku_def_pkey PRIMARY KEY (id);


--
-- Name: sku_group_attribute sku_group_attribute_pkey; Type: CONSTRAINT; Schema: inm; Owner: dbservice
--

ALTER TABLE ONLY inm.sku_group_attribute
    ADD CONSTRAINT sku_group_attribute_pkey PRIMARY KEY (id);


--
-- Name: sku_group_attribute sku_group_attribute_title_key; Type: CONSTRAINT; Schema: inm; Owner: dbservice
--

ALTER TABLE ONLY inm.sku_group_attribute
    ADD CONSTRAINT sku_group_attribute_title_key UNIQUE (title);


--
-- Name: sku_group_control sku_group_control_pkey; Type: CONSTRAINT; Schema: inm; Owner: dbservice
--

ALTER TABLE ONLY inm.sku_group_control
    ADD CONSTRAINT sku_group_control_pkey PRIMARY KEY (sku_group_id);


--
-- Name: sku_group sku_group_pkey; Type: CONSTRAINT; Schema: inm; Owner: dbservice
--

ALTER TABLE ONLY inm.sku_group
    ADD CONSTRAINT sku_group_pkey PRIMARY KEY (id);


--
-- Name: sku_property_def sku_property_def_pkey; Type: CONSTRAINT; Schema: inm; Owner: dbservice
--

ALTER TABLE ONLY inm.sku_property_def
    ADD CONSTRAINT sku_property_def_pkey PRIMARY KEY (id);


--
-- Name: sku_property sku_property_pkey; Type: CONSTRAINT; Schema: inm; Owner: dbservice
--

ALTER TABLE ONLY inm.sku_property
    ADD CONSTRAINT sku_property_pkey PRIMARY KEY (sku_id, property_id);


--
-- Name: warehouse_inventory warehouse_inventory_pkey; Type: CONSTRAINT; Schema: inm; Owner: dbservice
--

ALTER TABLE ONLY inm.warehouse_inventory
    ADD CONSTRAINT warehouse_inventory_pkey PRIMARY KEY (inventory_date, product_id);


--
-- Name: kiosk_control kiosk_control_pkey; Type: CONSTRAINT; Schema: inm_backup; Owner: dbservice
--

ALTER TABLE ONLY inm_backup.kiosk_control
    ADD CONSTRAINT kiosk_control_pkey PRIMARY KEY (kiosk_id);


--
-- Name: kiosk_control kiosk_control_pkey; Type: CONSTRAINT; Schema: inm_beta; Owner: dbservice
--

ALTER TABLE ONLY inm_beta.kiosk_control
    ADD CONSTRAINT kiosk_control_pkey PRIMARY KEY (kiosk_id);


--
-- Name: kiosk_product_disabled kiosk_product_enabled_pkey; Type: CONSTRAINT; Schema: inm_beta; Owner: dbservice
--

ALTER TABLE ONLY inm_beta.kiosk_product_disabled
    ADD CONSTRAINT kiosk_product_enabled_pkey PRIMARY KEY (kiosk_id, product_id);


--
-- Name: kiosk_restriction_by_product kiosk_restriction_by_product_pkey; Type: CONSTRAINT; Schema: inm_beta; Owner: dbservice
--

ALTER TABLE ONLY inm_beta.kiosk_restriction_by_product
    ADD CONSTRAINT kiosk_restriction_by_product_pkey PRIMARY KEY (kiosk_id, product_id);


--
-- Name: kiosk_restriction_by_property kiosk_restriction_by_property_pkey; Type: CONSTRAINT; Schema: inm_beta; Owner: dbservice
--

ALTER TABLE ONLY inm_beta.kiosk_restriction_by_property
    ADD CONSTRAINT kiosk_restriction_by_property_pkey PRIMARY KEY (kiosk_id, property_id);


--
-- Name: kiosk_sku_group_manual_scale kiosk_sku_group_manual_scale_pkey; Type: CONSTRAINT; Schema: inm_beta; Owner: dbservice
--

ALTER TABLE ONLY inm_beta.kiosk_sku_group_manual_scale
    ADD CONSTRAINT kiosk_sku_group_manual_scale_pkey PRIMARY KEY (kiosk_id, sku_group_id);


--
-- Name: pick_allocation pick_allocation_pkey; Type: CONSTRAINT; Schema: inm_beta; Owner: dbservice
--

ALTER TABLE ONLY inm_beta.pick_allocation
    ADD CONSTRAINT pick_allocation_pkey PRIMARY KEY (pick_date, route_date, kiosk_id, sku_id);


--
-- Name: pick_demand pick_demand_pkey; Type: CONSTRAINT; Schema: inm_beta; Owner: dbservice
--

ALTER TABLE ONLY inm_beta.pick_demand
    ADD CONSTRAINT pick_demand_pkey PRIMARY KEY (pick_date, route_date, kiosk_id, sku_group_id);


--
-- Name: pick_inventory pick_inventory_pkey; Type: CONSTRAINT; Schema: inm_beta; Owner: dbservice
--

ALTER TABLE ONLY inm_beta.pick_inventory
    ADD CONSTRAINT pick_inventory_pkey PRIMARY KEY (pick_date, route_date, kiosk_id, sku_group_id);


--
-- Name: pick_list pick_list_pkey; Type: CONSTRAINT; Schema: inm_beta; Owner: dbservice
--

ALTER TABLE ONLY inm_beta.pick_list
    ADD CONSTRAINT pick_list_pkey PRIMARY KEY (pick_date);


--
-- Name: pick_preference_kiosk_sku pick_preference_kiosk_sku_pkey; Type: CONSTRAINT; Schema: inm_beta; Owner: dbservice
--

ALTER TABLE ONLY inm_beta.pick_preference_kiosk_sku
    ADD CONSTRAINT pick_preference_kiosk_sku_pkey PRIMARY KEY (kiosk_id, sku_id);


--
-- Name: pick_priority_kiosk pick_priority_kiosk_pkey; Type: CONSTRAINT; Schema: inm_beta; Owner: dbservice
--

ALTER TABLE ONLY inm_beta.pick_priority_kiosk
    ADD CONSTRAINT pick_priority_kiosk_pkey PRIMARY KEY (kiosk_id);


--
-- Name: pick_priority_sku pick_priority_sku_pkey; Type: CONSTRAINT; Schema: inm_beta; Owner: dbservice
--

ALTER TABLE ONLY inm_beta.pick_priority_sku
    ADD CONSTRAINT pick_priority_sku_pkey PRIMARY KEY (sku_id);


--
-- Name: pick_rejection pick_rejection_pkey; Type: CONSTRAINT; Schema: inm_beta; Owner: dbservice
--

ALTER TABLE ONLY inm_beta.pick_rejection
    ADD CONSTRAINT pick_rejection_pkey PRIMARY KEY (pick_date, route_date, kiosk_id, item_id, item_type, reason);


--
-- Name: pick_route pick_route_pkey; Type: CONSTRAINT; Schema: inm_beta; Owner: dbservice
--

ALTER TABLE ONLY inm_beta.pick_route
    ADD CONSTRAINT pick_route_pkey PRIMARY KEY (pick_date, kiosk_id, route_date);


--
-- Name: pick_substitution pick_substitution_pkey; Type: CONSTRAINT; Schema: inm_beta; Owner: dbservice
--

ALTER TABLE ONLY inm_beta.pick_substitution
    ADD CONSTRAINT pick_substitution_pkey PRIMARY KEY (substituting_sku_group_id, substituted_sku_group_id, pick_date);


--
-- Name: sku_group_control sku_group_control_pkey; Type: CONSTRAINT; Schema: inm_beta; Owner: dbservice
--

ALTER TABLE ONLY inm_beta.sku_group_control
    ADD CONSTRAINT sku_group_control_pkey PRIMARY KEY (sku_group_id);


--
-- Name: sku_group sku_group_pkey; Type: CONSTRAINT; Schema: inm_beta; Owner: dbservice
--

ALTER TABLE ONLY inm_beta.sku_group
    ADD CONSTRAINT sku_group_pkey PRIMARY KEY (id);


--
-- Name: warehouse_inventory warehouse_inventory_pkey; Type: CONSTRAINT; Schema: inm_beta; Owner: dbservice
--

ALTER TABLE ONLY inm_beta.warehouse_inventory
    ADD CONSTRAINT warehouse_inventory_pkey PRIMARY KEY (inventory_date, product_id);


--
-- Name: kiosk_audit kiosk_audit_pkey; Type: CONSTRAINT; Schema: inm_test; Owner: dbservice
--

ALTER TABLE ONLY inm_test.kiosk_audit
    ADD CONSTRAINT kiosk_audit_pkey PRIMARY KEY (kid);


--
-- Name: kiosk_par_level kiosk_par_level_pkey; Type: CONSTRAINT; Schema: inm_test; Owner: dbservice
--

ALTER TABLE ONLY inm_test.kiosk_par_level
    ADD CONSTRAINT kiosk_par_level_pkey PRIMARY KEY (kiosk_id, product_id);


--
-- Name: pick_allocation pick_allocation_pkey; Type: CONSTRAINT; Schema: inm_test; Owner: dbservice
--

ALTER TABLE ONLY inm_test.pick_allocation
    ADD CONSTRAINT pick_allocation_pkey PRIMARY KEY (pick_date, route_date, kiosk_id, sku_id);


--
-- Name: pick_demand pick_demand_pkey; Type: CONSTRAINT; Schema: inm_test; Owner: dbservice
--

ALTER TABLE ONLY inm_test.pick_demand
    ADD CONSTRAINT pick_demand_pkey PRIMARY KEY (pick_date, route_date, kiosk_id, sku_group_id);


--
-- Name: pick_inventory pick_inventory_pkey; Type: CONSTRAINT; Schema: inm_test; Owner: dbservice
--

ALTER TABLE ONLY inm_test.pick_inventory
    ADD CONSTRAINT pick_inventory_pkey PRIMARY KEY (pick_date, route_date, kiosk_id, sku_group_id);


--
-- Name: pick_rejection pick_rejection_pkey; Type: CONSTRAINT; Schema: inm_test; Owner: dbservice
--

ALTER TABLE ONLY inm_test.pick_rejection
    ADD CONSTRAINT pick_rejection_pkey PRIMARY KEY (pick_date, route_date, kiosk_id, item_id, item_type, reason);


--
-- Name: pick_route pick_route_pkey; Type: CONSTRAINT; Schema: inm_test; Owner: dbservice
--

ALTER TABLE ONLY inm_test.pick_route
    ADD CONSTRAINT pick_route_pkey PRIMARY KEY (pick_date, kiosk_id, route_date);


--
-- Name: pick_substitution pick_substitution_pkey; Type: CONSTRAINT; Schema: inm_test; Owner: dbservice
--

ALTER TABLE ONLY inm_test.pick_substitution
    ADD CONSTRAINT pick_substitution_pkey PRIMARY KEY (substituting_sku_group_id, substituted_sku_group_id, pick_date);


--
-- Name: restricted restricted_pkey; Type: CONSTRAINT; Schema: inm_test; Owner: dbservice
--

ALTER TABLE ONLY inm_test.restricted
    ADD CONSTRAINT restricted_pkey PRIMARY KEY (kid, sku_id);


--
-- Name: test_hours test_hours_pkey; Type: CONSTRAINT; Schema: inm_test; Owner: dbservice
--

ALTER TABLE ONLY inm_test.test_hours
    ADD CONSTRAINT test_hours_pkey PRIMARY KEY (h);


--
-- Name: test test_pkey; Type: CONSTRAINT; Schema: inm_test; Owner: dbservice
--

ALTER TABLE ONLY inm_test.test
    ADD CONSTRAINT test_pkey PRIMARY KEY (id);


--
-- Name: card_fact card_fact_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.card_fact
    ADD CONSTRAINT card_fact_pkey PRIMARY KEY (id);


--
-- Name: card_product_fact card_product_fact_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.card_product_fact
    ADD CONSTRAINT card_product_fact_pkey PRIMARY KEY (id);


--
-- Name: discount_rule discount_rule_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.discount_rule
    ADD CONSTRAINT discount_rule_pkey PRIMARY KEY (id);


--
-- Name: gsheet_cache gsheet_cache_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.gsheet_cache
    ADD CONSTRAINT gsheet_cache_pkey PRIMARY KEY (id);


--
-- Name: gsheets_kiosk_restriction gsheets_kiosk_restriction_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.gsheets_kiosk_restriction
    ADD CONSTRAINT gsheets_kiosk_restriction_pkey PRIMARY KEY (kiosk_id, restriction);


--
-- Name: history_order_pipeline history_order_pipeline_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.history_order_pipeline
    ADD CONSTRAINT history_order_pipeline_pkey PRIMARY KEY (id);


--
-- Name: inm_data inm_data_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.inm_data
    ADD CONSTRAINT inm_data_pkey PRIMARY KEY (id);


--
-- Name: inm_gsheets_kiosk_restriction inm_gsheets_kiosk_restriction_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.inm_gsheets_kiosk_restriction
    ADD CONSTRAINT inm_gsheets_kiosk_restriction_pkey PRIMARY KEY (kiosk_id, restriction);


--
-- Name: kiosk_contents kiosk_contents_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.kiosk_contents
    ADD CONSTRAINT kiosk_contents_pkey PRIMARY KEY (id);


--
-- Name: kiosk_fact kiosk_fact_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.kiosk_fact
    ADD CONSTRAINT kiosk_fact_pkey PRIMARY KEY (id);


--
-- Name: kiosk kiosk_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.kiosk
    ADD CONSTRAINT kiosk_pkey PRIMARY KEY (kiosk_id);


--
-- Name: kiosk_restriction_by_property kiosk_restriction_by_property_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.kiosk_restriction_by_property
    ADD CONSTRAINT kiosk_restriction_by_property_pkey PRIMARY KEY (kiosk_id, property_id);


--
-- Name: kiosk_restriction_by_sku kiosk_restriction_by_sku_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.kiosk_restriction_by_sku
    ADD CONSTRAINT kiosk_restriction_by_sku_pkey PRIMARY KEY (kiosk_id, sku_id);


--
-- Name: kiosk_restriction kiosk_restriction_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.kiosk_restriction
    ADD CONSTRAINT kiosk_restriction_pkey PRIMARY KEY (kiosk_id, sku_id);


--
-- Name: last_kiosk_status last_kiosk_status_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.last_kiosk_status
    ADD CONSTRAINT last_kiosk_status_pkey PRIMARY KEY (id);


--
-- Name: log log_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.log
    ADD CONSTRAINT log_pkey PRIMARY KEY (id);


--
-- Name: merchandising_slot_def merchandising_slot_def_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.merchandising_slot_def
    ADD CONSTRAINT merchandising_slot_def_pkey PRIMARY KEY (id);


--
-- Name: merchandising_slot merchandising_slot_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.merchandising_slot
    ADD CONSTRAINT merchandising_slot_pkey PRIMARY KEY (id);


--
-- Name: merchandising_slot_sku_group merchandising_slot_sku_group_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.merchandising_slot_sku_group
    ADD CONSTRAINT merchandising_slot_sku_group_pkey PRIMARY KEY (sku_group_id);


--
-- Name: merchandising_slot merchandising_slot_title_key; Type: CONSTRAINT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.merchandising_slot
    ADD CONSTRAINT merchandising_slot_title_key UNIQUE (title);


--
-- Name: order_fact order_fact_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.order_fact
    ADD CONSTRAINT order_fact_pkey PRIMARY KEY (id);


--
-- Name: pick pick_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.pick
    ADD CONSTRAINT pick_pkey PRIMARY KEY (sku_id, kiosk_id, pick_date);


--
-- Name: pick_preference_kiosk_sku pick_preference_kiosk_sku_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.pick_preference_kiosk_sku
    ADD CONSTRAINT pick_preference_kiosk_sku_pkey PRIMARY KEY (kiosk_id, sku_id);


--
-- Name: pick_priority_kiosk pick_priority_kiosk_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.pick_priority_kiosk
    ADD CONSTRAINT pick_priority_kiosk_pkey PRIMARY KEY (kiosk_id);


--
-- Name: pick_priority_sku pick_priority_sku_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.pick_priority_sku
    ADD CONSTRAINT pick_priority_sku_pkey PRIMARY KEY (sku_id);


--
-- Name: product_fact product_fact_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.product_fact
    ADD CONSTRAINT product_fact_pkey PRIMARY KEY (id);


--
-- Name: product_kiosk_fact product_kiosk_fact_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.product_kiosk_fact
    ADD CONSTRAINT product_kiosk_fact_pkey PRIMARY KEY (id);


--
-- Name: request_log request_log_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.request_log
    ADD CONSTRAINT request_log_pkey PRIMARY KEY (request_uuid);


--
-- Name: route route_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.route
    ADD CONSTRAINT route_pkey PRIMARY KEY (route_date_time, driver_name);


--
-- Name: route_stop route_stop_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.route_stop
    ADD CONSTRAINT route_stop_pkey PRIMARY KEY (route_date_time, driver_name, location_name, schedule_at);


--
-- Name: server server_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.server
    ADD CONSTRAINT server_pkey PRIMARY KEY (id);


--
-- Name: sku_def sku_def_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.sku_def
    ADD CONSTRAINT sku_def_pkey PRIMARY KEY (id);


--
-- Name: sku_group_def sku_group_def_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.sku_group_def
    ADD CONSTRAINT sku_group_def_pkey PRIMARY KEY (id);


--
-- Name: sku_group_member sku_group_member_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.sku_group_member
    ADD CONSTRAINT sku_group_member_pkey PRIMARY KEY (id);


--
-- Name: sku_group sku_group_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.sku_group
    ADD CONSTRAINT sku_group_pkey PRIMARY KEY (id);


--
-- Name: sku_group_sku sku_group_sku_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.sku_group_sku
    ADD CONSTRAINT sku_group_sku_pkey PRIMARY KEY (sku_id, sku_group_id);


--
-- Name: sku_property_def sku_property_def_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.sku_property_def
    ADD CONSTRAINT sku_property_def_pkey PRIMARY KEY (id);


--
-- Name: sku_property sku_property_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.sku_property
    ADD CONSTRAINT sku_property_pkey PRIMARY KEY (sku_id, property_id);


--
-- Name: tally tally_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.tally
    ADD CONSTRAINT tally_pkey PRIMARY KEY (n);


--
-- Name: temp_kiosk_restriction temp_kiosk_restriction_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.temp_kiosk_restriction
    ADD CONSTRAINT temp_kiosk_restriction_pkey PRIMARY KEY (kiosk_id, restriction);


--
-- Name: temp_ms_to_sg temp_ms_to_sg_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.temp_ms_to_sg
    ADD CONSTRAINT temp_ms_to_sg_pkey PRIMARY KEY (sgroup);


--
-- Name: temp_sku_group_volume temp_sku_group_volume_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.temp_sku_group_volume
    ADD CONSTRAINT temp_sku_group_volume_pkey PRIMARY KEY (title);


--
-- Name: temp_sku_to_skugroup temp_sku_to_skugroup_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.temp_sku_to_skugroup
    ADD CONSTRAINT temp_sku_to_skugroup_pkey PRIMARY KEY (sku);


--
-- Name: temp_test temp_test_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.temp_test
    ADD CONSTRAINT temp_test_pkey PRIMARY KEY (id);


--
-- Name: tmp_discount_applied tmp_discount_applied_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.tmp_discount_applied
    ADD CONSTRAINT tmp_discount_applied_pkey PRIMARY KEY (id);


--
-- Name: tmp_kiosk_status tmp_kiosk_status_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.tmp_kiosk_status
    ADD CONSTRAINT tmp_kiosk_status_pkey PRIMARY KEY (id);


--
-- Name: tmp_transact tmp_transact_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.tmp_transact
    ADD CONSTRAINT tmp_transact_pkey PRIMARY KEY (order_id);


--
-- Name: tmp_unit tmp_unit_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.tmp_unit
    ADD CONSTRAINT tmp_unit_pkey PRIMARY KEY (id);


--
-- Name: warehouse_order_history warehouse_order_history_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.warehouse_order_history
    ADD CONSTRAINT warehouse_order_history_pkey PRIMARY KEY (sku, order_date, delivery_date, qty);


--
-- Name: cron_state cron_state_pkey; Type: CONSTRAINT; Schema: monitor; Owner: dbservice
--

ALTER TABLE ONLY monitor.cron_state
    ADD CONSTRAINT cron_state_pkey PRIMARY KEY (key);


--
-- Name: opt_connect opt_connect_pkey; Type: CONSTRAINT; Schema: monitor; Owner: dbservice
--

ALTER TABLE ONLY monitor.opt_connect
    ADD CONSTRAINT opt_connect_pkey PRIMARY KEY (date_time, summit_id);


--
-- Name: accounting accounting_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.accounting
    ADD CONSTRAINT accounting_pkey PRIMARY KEY (id);


--
-- Name: bad_timestamp bad_timestamp_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.bad_timestamp
    ADD CONSTRAINT bad_timestamp_pkey PRIMARY KEY (id);


--
-- Name: campus_assets campus_assets_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.campus_assets
    ADD CONSTRAINT campus_assets_pkey PRIMARY KEY (campus_id);


--
-- Name: campus_attribute campus_attribute_campus_id_key_id_key; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.campus_attribute
    ADD CONSTRAINT campus_attribute_campus_id_key_id_key UNIQUE (campus_id, key_id);


--
-- Name: campus_attribute campus_attribute_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.campus_attribute
    ADD CONSTRAINT campus_attribute_pkey PRIMARY KEY (id);


--
-- Name: campus campus_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.campus
    ADD CONSTRAINT campus_pkey PRIMARY KEY (id);


--
-- Name: card card_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.card
    ADD CONSTRAINT card_pkey PRIMARY KEY (id);


--
-- Name: contract contract_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.contract
    ADD CONSTRAINT contract_pkey PRIMARY KEY (id);


--
-- Name: coupon coupon_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.coupon
    ADD CONSTRAINT coupon_pkey PRIMARY KEY (id);


--
-- Name: cron cron_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.cron
    ADD CONSTRAINT cron_pkey PRIMARY KEY (id);


--
-- Name: currency_symbol currency_symbol_code_key; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.currency_symbol
    ADD CONSTRAINT currency_symbol_code_key UNIQUE (code);


--
-- Name: currency_symbol currency_symbol_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.currency_symbol
    ADD CONSTRAINT currency_symbol_pkey PRIMARY KEY (id);


--
-- Name: current_label_status_365days current_label_status_365days_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.current_label_status_365days
    ADD CONSTRAINT current_label_status_365days_pkey PRIMARY KEY (epc);


--
-- Name: dc_inventory dc_inventory_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.dc_inventory
    ADD CONSTRAINT dc_inventory_pkey PRIMARY KEY (product_id);


--
-- Name: delivery_schedule delivery_schedule_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.delivery_schedule
    ADD CONSTRAINT delivery_schedule_pkey PRIMARY KEY (id);


--
-- Name: discount_applied discount_applied_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.discount_applied
    ADD CONSTRAINT discount_applied_pkey PRIMARY KEY (id);


--
-- Name: discount_history discount_history_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.discount_history
    ADD CONSTRAINT discount_history_pkey PRIMARY KEY (id);


--
-- Name: discount discount_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.discount
    ADD CONSTRAINT discount_pkey PRIMARY KEY (id);


--
-- Name: email email_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.email
    ADD CONSTRAINT email_pkey PRIMARY KEY (id);


--
-- Name: empty_transaction empty_transaction_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.empty_transaction
    ADD CONSTRAINT empty_transaction_pkey PRIMARY KEY (id);


--
-- Name: event event_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.event
    ADD CONSTRAINT event_pkey PRIMARY KEY (id);


--
-- Name: facing_category facing_category_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.facing_category
    ADD CONSTRAINT facing_category_pkey PRIMARY KEY (id);


--
-- Name: fee_rates fee_rates_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.fee_rates
    ADD CONSTRAINT fee_rates_pkey PRIMARY KEY (id);


--
-- Name: feedback feedback_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.feedback
    ADD CONSTRAINT feedback_pkey PRIMARY KEY (id);


--
-- Name: global_attribute_def global_attribute_def_key_key; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.global_attribute_def
    ADD CONSTRAINT global_attribute_def_key_key UNIQUE (key);


--
-- Name: global_attribute_def global_attribute_def_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.global_attribute_def
    ADD CONSTRAINT global_attribute_def_pkey PRIMARY KEY (id);


--
-- Name: group_campus group_campus_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.group_campus
    ADD CONSTRAINT group_campus_pkey PRIMARY KEY (group_id, campus_id);


--
-- Name: group group_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry."group"
    ADD CONSTRAINT group_pkey PRIMARY KEY (id);


--
-- Name: history_campus_attribute history_campus_attribute_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.history_campus_attribute
    ADD CONSTRAINT history_campus_attribute_pkey PRIMARY KEY (id);


--
-- Name: history_epc_order history_epc_order_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.history_epc_order
    ADD CONSTRAINT history_epc_order_pkey PRIMARY KEY (id);


--
-- Name: history_global_attribute_def history_global_attribute_def_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.history_global_attribute_def
    ADD CONSTRAINT history_global_attribute_def_pkey PRIMARY KEY (id);


--
-- Name: history_kiosk_attribute history_kiosk_attribute_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.history_kiosk_attribute
    ADD CONSTRAINT history_kiosk_attribute_pkey PRIMARY KEY (id);


--
-- Name: history_kiosk_device history_kiosk_device_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.history_kiosk_device
    ADD CONSTRAINT history_kiosk_device_pkey PRIMARY KEY (id);


--
-- Name: history_kiosk_service_version history_kiosk_service_version_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.history_kiosk_service_version
    ADD CONSTRAINT history_kiosk_service_version_pkey PRIMARY KEY (id);


--
-- Name: history history_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.history
    ADD CONSTRAINT history_pkey PRIMARY KEY (id);


--
-- Name: inventory_history inventory_history_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.inventory_history
    ADD CONSTRAINT inventory_history_pkey PRIMARY KEY (id);


--
-- Name: inventory_request inventory_request_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.inventory_request
    ADD CONSTRAINT inventory_request_pkey PRIMARY KEY (id);


--
-- Name: kiosk_attribute kiosk_attribute_kiosk_id_key_id_key; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.kiosk_attribute
    ADD CONSTRAINT kiosk_attribute_kiosk_id_key_id_key UNIQUE (kiosk_id, key_id);


--
-- Name: kiosk_attribute kiosk_attribute_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.kiosk_attribute
    ADD CONSTRAINT kiosk_attribute_pkey PRIMARY KEY (id);


--
-- Name: kiosk_audit_log kiosk_audit_log_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.kiosk_audit_log
    ADD CONSTRAINT kiosk_audit_log_pkey PRIMARY KEY (id);


--
-- Name: kiosk_catalog_downloads kiosk_catalog_downloads_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.kiosk_catalog_downloads
    ADD CONSTRAINT kiosk_catalog_downloads_pkey PRIMARY KEY (id);


--
-- Name: kiosk_components_history kiosk_components_history_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.kiosk_components_history
    ADD CONSTRAINT kiosk_components_history_pkey PRIMARY KEY (id);


--
-- Name: kiosk_device kiosk_device_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.kiosk_device
    ADD CONSTRAINT kiosk_device_pkey PRIMARY KEY (kiosk_id);


--
-- Name: kiosk_par_level kiosk_par_level_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.kiosk_par_level
    ADD CONSTRAINT kiosk_par_level_pkey PRIMARY KEY (kiosk_id, product_id);


--
-- Name: kiosk kiosk_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.kiosk
    ADD CONSTRAINT kiosk_pkey PRIMARY KEY (id);


--
-- Name: kiosk_service_version kiosk_service_version_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.kiosk_service_version
    ADD CONSTRAINT kiosk_service_version_pkey PRIMARY KEY (kiosk_id, service);


--
-- Name: kiosk_status kiosk_status_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.kiosk_status
    ADD CONSTRAINT kiosk_status_pkey PRIMARY KEY (id);


--
-- Name: kiosks_date_non_new kiosks_date_non_new_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.kiosks_date_non_new
    ADD CONSTRAINT kiosks_date_non_new_pkey PRIMARY KEY (id);


--
-- Name: label_order label_order_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.label_order
    ADD CONSTRAINT label_order_pkey PRIMARY KEY (id);


--
-- Name: label label_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.label
    ADD CONSTRAINT label_pkey PRIMARY KEY (id);


--
-- Name: last_kiosk_status last_kiosk_status_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.last_kiosk_status
    ADD CONSTRAINT last_kiosk_status_pkey PRIMARY KEY (id);


--
-- Name: manual_adjustment manual_adjustment_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.manual_adjustment
    ADD CONSTRAINT manual_adjustment_pkey PRIMARY KEY (id);


--
-- Name: nutrition_filter nutrition_filter_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.nutrition_filter
    ADD CONSTRAINT nutrition_filter_pkey PRIMARY KEY (id);


--
-- Name: order_meta order_meta_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.order_meta
    ADD CONSTRAINT order_meta_pkey PRIMARY KEY (id);


--
-- Name: order order_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry."order"
    ADD CONSTRAINT order_pkey PRIMARY KEY (order_id);


--
-- Name: par_history par_history_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.par_history
    ADD CONSTRAINT par_history_pkey PRIMARY KEY (id);


--
-- Name: payment_order payment_order_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.payment_order
    ADD CONSTRAINT payment_order_pkey PRIMARY KEY (id);


--
-- Name: permission_mapping permission_mapping_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.permission_mapping
    ADD CONSTRAINT permission_mapping_pkey PRIMARY KEY (role_id, permission_id);


--
-- Name: permission permission_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.permission
    ADD CONSTRAINT permission_pkey PRIMARY KEY (id);


--
-- Name: pick_list_row pick_list_row_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.pick_list_row
    ADD CONSTRAINT pick_list_row_pkey PRIMARY KEY (id);


--
-- Name: product_20190507 product_20190507_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.product_20190507
    ADD CONSTRAINT product_20190507_pkey PRIMARY KEY (id);


--
-- Name: product_categories product_categories_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.product_categories
    ADD CONSTRAINT product_categories_pkey PRIMARY KEY (id);


--
-- Name: product_history product_history_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.product_history
    ADD CONSTRAINT product_history_pkey PRIMARY KEY (id);


--
-- Name: product_kiosk_price_offset product_kiosk_price_offset_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.product_kiosk_price_offset
    ADD CONSTRAINT product_kiosk_price_offset_pkey PRIMARY KEY (id);


--
-- Name: product product_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.product
    ADD CONSTRAINT product_pkey PRIMARY KEY (id);


--
-- Name: product_request product_request_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.product_request
    ADD CONSTRAINT product_request_pkey PRIMARY KEY (id);


--
-- Name: recent_transactions recent_transactions_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.recent_transactions
    ADD CONSTRAINT recent_transactions_pkey PRIMARY KEY (kiosk_id);


--
-- Name: restock_item restock_item_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.restock_item
    ADD CONSTRAINT restock_item_pkey PRIMARY KEY (id);


--
-- Name: ro_order ro_order_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.ro_order
    ADD CONSTRAINT ro_order_pkey PRIMARY KEY (order_id);


--
-- Name: role_mapping role_mapping_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.role_mapping
    ADD CONSTRAINT role_mapping_pkey PRIMARY KEY (role_id, parent_id);


--
-- Name: role role_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.role
    ADD CONSTRAINT role_pkey PRIMARY KEY (id);


--
-- Name: running_service running_service_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.running_service
    ADD CONSTRAINT running_service_pkey PRIMARY KEY (app_name);


--
-- Name: spoilage spoilage_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.spoilage
    ADD CONSTRAINT spoilage_pkey PRIMARY KEY (id);


--
-- Name: stockout stockout_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.stockout
    ADD CONSTRAINT stockout_pkey PRIMARY KEY (id);


--
-- Name: tag tag_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.tag
    ADD CONSTRAINT tag_pkey PRIMARY KEY (id);


--
-- Name: temperature_tag_history temperature_tag_history_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.temperature_tag_history
    ADD CONSTRAINT temperature_tag_history_pkey PRIMARY KEY (id);


--
-- Name: tmp_april23_error_order_fixes tmp_april23_error_order_fixes_pk; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.tmp_april23_error_order_fixes
    ADD CONSTRAINT tmp_april23_error_order_fixes_pk PRIMARY KEY (order_id);


--
-- Name: tmp_eng_3692 tmp_eng_3692_pk; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.tmp_eng_3692
    ADD CONSTRAINT tmp_eng_3692_pk PRIMARY KEY (order_id);


--
-- Name: tmp_may4_error_order_fixes tmp_may4_error_order_fixes_pk; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.tmp_may4_error_order_fixes
    ADD CONSTRAINT tmp_may4_error_order_fixes_pk PRIMARY KEY (order_id);


--
-- Name: tmp_may4_pricefinalize_order_fixes tmp_may4_error_pricefinalize_fixes_pk; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.tmp_may4_pricefinalize_order_fixes
    ADD CONSTRAINT tmp_may4_error_pricefinalize_fixes_pk PRIMARY KEY (order_id);


--
-- Name: tmp_order_transaction_id_map tmp_order_transaction_id_map_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.tmp_order_transaction_id_map
    ADD CONSTRAINT tmp_order_transaction_id_map_pkey PRIMARY KEY (transaction_id);


--
-- Name: tmp_payment_order tmp_payment_order_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.tmp_payment_order
    ADD CONSTRAINT tmp_payment_order_pkey PRIMARY KEY (order_id);


--
-- Name: tmp_payment_order_with_id tmp_payment_order_with_id_order_id_key; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.tmp_payment_order_with_id
    ADD CONSTRAINT tmp_payment_order_with_id_order_id_key UNIQUE (order_id);


--
-- Name: tmp_payment_order_with_id tmp_payment_order_with_id_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.tmp_payment_order_with_id
    ADD CONSTRAINT tmp_payment_order_with_id_pkey PRIMARY KEY (id);


--
-- Name: tmp_price_finalized_order_ids tmp_price_finalized_order_ids_pk; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.tmp_price_finalized_order_ids
    ADD CONSTRAINT tmp_price_finalized_order_ids_pk PRIMARY KEY (order_id);


--
-- Name: tmp_process_order_txt tmp_process_order_txt_order_id_key; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.tmp_process_order_txt
    ADD CONSTRAINT tmp_process_order_txt_order_id_key UNIQUE (order_id);


--
-- Name: tmp_process_order_txt tmp_process_order_txt_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.tmp_process_order_txt
    ADD CONSTRAINT tmp_process_order_txt_pkey PRIMARY KEY (id);


--
-- Name: tmp_process_order_vantiv tmp_process_order_vantiv_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.tmp_process_order_vantiv
    ADD CONSTRAINT tmp_process_order_vantiv_pkey PRIMARY KEY (id);


--
-- Name: tmp_revert_order_status tmp_re_auth_orders_pk; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.tmp_revert_order_status
    ADD CONSTRAINT tmp_re_auth_orders_pk PRIMARY KEY (order_id);


--
-- Name: transact_comp transact_comp_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.transact_comp
    ADD CONSTRAINT transact_comp_pkey PRIMARY KEY (id);


--
-- Name: transact_express transact_express_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.transact_express
    ADD CONSTRAINT transact_express_pkey PRIMARY KEY (id);


--
-- Name: transact_fp transact_fp_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.transact_fp
    ADD CONSTRAINT transact_fp_pkey PRIMARY KEY (id);


--
-- Name: transact_ipc transact_ipc_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry.transact_ipc
    ADD CONSTRAINT transact_ipc_pkey PRIMARY KEY (id);


--
-- Name: user user_pkey; Type: CONSTRAINT; Schema: pantry; Owner: dbservice
--

ALTER TABLE ONLY pantry."user"
    ADD CONSTRAINT user_pkey PRIMARY KEY (id);


--
-- Name: awsdms_ddl_audit awsdms_ddl_audit_pkey; Type: CONSTRAINT; Schema: public; Owner: dbservice
--

ALTER TABLE ONLY public.awsdms_ddl_audit
    ADD CONSTRAINT awsdms_ddl_audit_pkey PRIMARY KEY (c_key);


--
-- Name: awsdms_heartbeat awsdms_heartbeat_pkey; Type: CONSTRAINT; Schema: public; Owner: dbservice
--

ALTER TABLE ONLY public.awsdms_heartbeat
    ADD CONSTRAINT awsdms_heartbeat_pkey PRIMARY KEY (hb_key);


--
-- Name: bytecodelog bytecodelog_pkey; Type: CONSTRAINT; Schema: public; Owner: dbservice
--

ALTER TABLE ONLY public.bytecodelog
    ADD CONSTRAINT bytecodelog_pkey PRIMARY KEY (email, bytecode);


--
-- Name: campaigns campaigns_description_key; Type: CONSTRAINT; Schema: public; Owner: dbservice
--

ALTER TABLE ONLY public.campaigns
    ADD CONSTRAINT campaigns_description_key UNIQUE (description);


--
-- Name: campaigns campaigns_owner_key; Type: CONSTRAINT; Schema: public; Owner: dbservice
--

ALTER TABLE ONLY public.campaigns
    ADD CONSTRAINT campaigns_owner_key UNIQUE (owner);


--
-- Name: campaigns campaigns_pkey; Type: CONSTRAINT; Schema: public; Owner: dbservice
--

ALTER TABLE ONLY public.campaigns
    ADD CONSTRAINT campaigns_pkey PRIMARY KEY (campaign_id);


--
-- Name: campaigns campaigns_title_key; Type: CONSTRAINT; Schema: public; Owner: dbservice
--

ALTER TABLE ONLY public.campaigns
    ADD CONSTRAINT campaigns_title_key UNIQUE (title);


--
-- Name: customer_campaigns customer_campaigns_coupon_id_key; Type: CONSTRAINT; Schema: public; Owner: dbservice
--

ALTER TABLE ONLY public.customer_campaigns
    ADD CONSTRAINT customer_campaigns_coupon_id_key UNIQUE (coupon_id);


--
-- Name: customer_campaigns customer_campaigns_pkey; Type: CONSTRAINT; Schema: public; Owner: dbservice
--

ALTER TABLE ONLY public.customer_campaigns
    ADD CONSTRAINT customer_campaigns_pkey PRIMARY KEY (customer_id, campaign_id);


--
-- Name: customer_campaigns customer_campaigns_status_key; Type: CONSTRAINT; Schema: public; Owner: dbservice
--

ALTER TABLE ONLY public.customer_campaigns
    ADD CONSTRAINT customer_campaigns_status_key UNIQUE (status);


--
-- Name: customers customers_email_address_key; Type: CONSTRAINT; Schema: public; Owner: dbservice
--

ALTER TABLE ONLY public.customers
    ADD CONSTRAINT customers_email_address_key UNIQUE (email_address);


--
-- Name: customers customers_full_name_key; Type: CONSTRAINT; Schema: public; Owner: dbservice
--

ALTER TABLE ONLY public.customers
    ADD CONSTRAINT customers_full_name_key UNIQUE (full_name);


--
-- Name: customers customers_pkey; Type: CONSTRAINT; Schema: public; Owner: dbservice
--

ALTER TABLE ONLY public.customers
    ADD CONSTRAINT customers_pkey PRIMARY KEY (customer_id);


--
-- Name: inm_kiosk_weekly_sale inm_kiosk_weekly_sale_pkey; Type: CONSTRAINT; Schema: public; Owner: dbservice
--

ALTER TABLE ONLY public.inm_kiosk_weekly_sale
    ADD CONSTRAINT inm_kiosk_weekly_sale_pkey PRIMARY KEY (key);


--
-- Name: int_kiosk_weekly_sale int_kiosk_weekly_sale_pkey; Type: CONSTRAINT; Schema: public; Owner: dbservice
--

ALTER TABLE ONLY public.int_kiosk_weekly_sale
    ADD CONSTRAINT int_kiosk_weekly_sale_pkey PRIMARY KEY (key);


--
-- Name: kiosk kiosk_pkey; Type: CONSTRAINT; Schema: public; Owner: dbservice
--

ALTER TABLE ONLY public.kiosk
    ADD CONSTRAINT kiosk_pkey PRIMARY KEY (id);


--
-- Name: pantry.kiosk pantry.kiosk_pkey; Type: CONSTRAINT; Schema: public; Owner: dbservice
--

ALTER TABLE ONLY public."pantry.kiosk"
    ADD CONSTRAINT "pantry.kiosk_pkey" PRIMARY KEY (id);


--
-- Name: track_dashboard track_dashboard_pkey; Type: CONSTRAINT; Schema: public; Owner: dbservice
--

ALTER TABLE ONLY public.track_dashboard
    ADD CONSTRAINT track_dashboard_pkey PRIMARY KEY (id);


--
-- Name: track_inventory track_inventory_pkey; Type: CONSTRAINT; Schema: public; Owner: dbservice
--

ALTER TABLE ONLY public.track_inventory
    ADD CONSTRAINT track_inventory_pkey PRIMARY KEY (id);


--
-- Name: eng2903 eng2903_pk; Type: CONSTRAINT; Schema: test; Owner: dbservice
--

ALTER TABLE ONLY test.eng2903
    ADD CONSTRAINT eng2903_pk PRIMARY KEY (order_id);


--
-- Name: kiosk_payment_start kiosk_payment_start_pkey; Type: CONSTRAINT; Schema: test; Owner: dbservice
--

ALTER TABLE ONLY test.kiosk_payment_start
    ADD CONSTRAINT kiosk_payment_start_pkey PRIMARY KEY (id);


--
-- Name: kiosk_serial_20190916 kiosk_serial_20190916_pkey; Type: CONSTRAINT; Schema: test; Owner: dbservice
--

ALTER TABLE ONLY test.kiosk_serial_20190916
    ADD CONSTRAINT kiosk_serial_20190916_pkey PRIMARY KEY (id);


--
-- Name: order_complimentary_eng_2292 order_complimentary_eng_2292_pkey; Type: CONSTRAINT; Schema: test; Owner: dbservice
--

ALTER TABLE ONLY test.order_complimentary_eng_2292
    ADD CONSTRAINT order_complimentary_eng_2292_pkey PRIMARY KEY (order_id);


--
-- Name: reauth_2019_07_priced_finalized_orders reauth_2019_07_priced_finalized_orders_pk; Type: CONSTRAINT; Schema: test; Owner: dbservice
--

ALTER TABLE ONLY test.reauth_2019_07_priced_finalized_orders
    ADD CONSTRAINT reauth_2019_07_priced_finalized_orders_pk PRIMARY KEY (order_id);


--
-- Name: request_log_order request_log_order_pkey; Type: CONSTRAINT; Schema: test; Owner: dbservice
--

ALTER TABLE ONLY test.request_log_order
    ADD CONSTRAINT request_log_order_pkey PRIMARY KEY (order_id);


--
-- Name: deps_saved_ddl deps_saved_ddl_pkey; Type: CONSTRAINT; Schema: util; Owner: dbservice
--

ALTER TABLE ONLY util.deps_saved_ddl
    ADD CONSTRAINT deps_saved_ddl_pkey PRIMARY KEY (deps_id);


--
-- Name: awsdms_history_task_history_index; Type: INDEX; Schema: aws_dms; Owner: dbservice
--

CREATE UNIQUE INDEX awsdms_history_task_history_index ON aws_dms.awsdms_history USING btree (server_name, task_name, timeslot_type, timeslot);


--
-- Name: awsdms_status_task_status_index; Type: INDEX; Schema: aws_dms; Owner: dbservice
--

CREATE UNIQUE INDEX awsdms_status_task_status_index ON aws_dms.awsdms_status USING btree (server_name, task_name);


--
-- Name: awsdms_suspended_tables_task_suspended_tables_index; Type: INDEX; Schema: aws_dms; Owner: dbservice
--

CREATE UNIQUE INDEX awsdms_suspended_tables_task_suspended_tables_index ON aws_dms.awsdms_suspended_tables USING btree (server_name, task_name, table_owner, table_name);


--
-- Name: awsdms_history_task_history_index; Type: INDEX; Schema: dms7; Owner: dbservice
--

CREATE UNIQUE INDEX awsdms_history_task_history_index ON dms7.awsdms_history USING btree (server_name, task_name, timeslot_type, timeslot);


--
-- Name: awsdms_status_task_status_index; Type: INDEX; Schema: dms7; Owner: dbservice
--

CREATE UNIQUE INDEX awsdms_status_task_status_index ON dms7.awsdms_status USING btree (server_name, task_name);


--
-- Name: awsdms_suspended_tables_task_suspended_tables_index; Type: INDEX; Schema: dms7; Owner: dbservice
--

CREATE UNIQUE INDEX awsdms_suspended_tables_task_suspended_tables_index ON dms7.awsdms_suspended_tables USING btree (server_name, task_name, table_owner, table_name);


--
-- Name: sku_property_property_id_idx; Type: INDEX; Schema: inm; Owner: dbservice
--

CREATE INDEX sku_property_property_id_idx ON inm.sku_property USING btree (property_id);


--
-- Name: kiosk_restriction_by_property_property_id_idx; Type: INDEX; Schema: mixalot; Owner: dbservice
--

CREATE INDEX kiosk_restriction_by_property_property_id_idx ON mixalot.kiosk_restriction_by_property USING btree (property_id);


--
-- Name: kiosk_restriction_by_sku_sku_id_idx; Type: INDEX; Schema: mixalot; Owner: dbservice
--

CREATE INDEX kiosk_restriction_by_sku_sku_id_idx ON mixalot.kiosk_restriction_by_sku USING btree (sku_id);


--
-- Name: request_log_endpoint; Type: INDEX; Schema: mixalot; Owner: dbservice
--

CREATE INDEX request_log_endpoint ON mixalot.request_log USING btree (endpoint);


--
-- Name: request_log_kid; Type: INDEX; Schema: mixalot; Owner: dbservice
--

CREATE INDEX request_log_kid ON mixalot.request_log USING btree (kid);


--
-- Name: request_log_kiosk_id; Type: INDEX; Schema: mixalot; Owner: dbservice
--

CREATE INDEX request_log_kiosk_id ON mixalot.request_log USING btree (kiosk_id);


--
-- Name: request_log_kiosk_id_kid_rec_version; Type: INDEX; Schema: mixalot; Owner: dbservice
--

CREATE INDEX request_log_kiosk_id_kid_rec_version ON mixalot.request_log USING btree (kiosk_id, kid, rec_version);


--
-- Name: request_log_order_id; Type: INDEX; Schema: mixalot; Owner: dbservice
--

CREATE INDEX request_log_order_id ON mixalot.request_log USING btree (order_id);


--
-- Name: request_log_rec_version; Type: INDEX; Schema: mixalot; Owner: dbservice
--

CREATE INDEX request_log_rec_version ON mixalot.request_log USING btree (rec_version);


--
-- Name: request_log_source; Type: INDEX; Schema: mixalot; Owner: dbservice
--

CREATE INDEX request_log_source ON mixalot.request_log USING btree (source);


--
-- Name: request_log_stamp; Type: INDEX; Schema: mixalot; Owner: dbservice
--

CREATE INDEX request_log_stamp ON mixalot.request_log USING btree (stamp);


--
-- Name: request_log_start_ts; Type: INDEX; Schema: mixalot; Owner: dbservice
--

CREATE INDEX request_log_start_ts ON mixalot.request_log USING btree (start_ts);


--
-- Name: request_log_status_code; Type: INDEX; Schema: mixalot; Owner: dbservice
--

CREATE INDEX request_log_status_code ON mixalot.request_log USING btree (status_code);


--
-- Name: request_log_time; Type: INDEX; Schema: mixalot; Owner: dbservice
--

CREATE INDEX request_log_time ON mixalot.request_log USING btree ("time");


--
-- Name: request_log_version; Type: INDEX; Schema: mixalot; Owner: dbservice
--

CREATE INDEX request_log_version ON mixalot.request_log USING btree (version);


--
-- Name: sku_property_property_id_idx; Type: INDEX; Schema: mixalot; Owner: dbservice
--

CREATE INDEX sku_property_property_id_idx ON mixalot.sku_property USING btree (property_id);


--
-- Name: byte_created_idx; Type: INDEX; Schema: pantry; Owner: dbservice
--

CREATE INDEX byte_created_idx ON pantry."order" USING btree (created);


--
-- Name: byte_label_added_idx; Type: INDEX; Schema: pantry; Owner: dbservice
--

CREATE INDEX byte_label_added_idx ON pantry.label USING btree (to_timestamp((time_added)::double precision), product_id);


--
-- Name: byte_label_epc_idx; Type: INDEX; Schema: pantry; Owner: dbservice
--

CREATE INDEX byte_label_epc_idx ON pantry.label USING btree (epc);


--
-- Name: byte_label_kiosk_id_idx; Type: INDEX; Schema: pantry; Owner: dbservice
--

CREATE INDEX byte_label_kiosk_id_idx ON pantry.label USING btree (kiosk_id);


--
-- Name: byte_label_order_id_idx; Type: INDEX; Schema: pantry; Owner: dbservice
--

CREATE INDEX byte_label_order_id_idx ON pantry.label USING btree (order_id);


--
-- Name: byte_label_order_status_idx; Type: INDEX; Schema: pantry; Owner: dbservice
--

CREATE INDEX byte_label_order_status_idx ON pantry.label USING btree (order_id, status);


--
-- Name: byte_label_ts_idx; Type: INDEX; Schema: pantry; Owner: dbservice
--

CREATE INDEX byte_label_ts_idx ON pantry.label USING btree (to_timestamp((COALESCE(time_updated, time_created, time_added))::double precision));


--
-- Name: byte_product_stats_by_kiosk_idx; Type: INDEX; Schema: pantry; Owner: dbservice
--

CREATE INDEX byte_product_stats_by_kiosk_idx ON pantry.product_stats_by_kiosk USING btree (to_timestamp(("timestamp")::double precision));


--
-- Name: byte_raw_orders_ts_idx; Type: INDEX; Schema: pantry; Owner: dbservice
--

CREATE INDEX byte_raw_orders_ts_idx ON pantry."order" USING btree (to_timestamp((created)::double precision)) WHERE (campus_id = 87);


--
-- Name: byte_spoilage_ts_idx; Type: INDEX; Schema: pantry; Owner: dbservice
--

CREATE INDEX byte_spoilage_ts_idx ON pantry.spoilage USING btree (to_timestamp((time_removed)::double precision));


--
-- Name: byte_stockouts_restock_ts_idx; Type: INDEX; Schema: pantry; Owner: dbservice
--

CREATE INDEX byte_stockouts_restock_ts_idx ON pantry.stockout USING btree (to_timestamp((restock_timestamp)::double precision));


--
-- Name: byte_stockouts_ts_idx; Type: INDEX; Schema: pantry; Owner: dbservice
--

CREATE INDEX byte_stockouts_ts_idx ON pantry.stockout USING btree (to_timestamp(("timestamp")::double precision));


--
-- Name: byte_tickets_idx; Type: INDEX; Schema: pantry; Owner: dbservice
--

CREATE INDEX byte_tickets_idx ON pantry."order" USING btree (to_timestamp((created)::double precision)) WHERE ((campus_id = 87) AND ((state)::text = ANY (ARRAY[('Processed'::character varying)::text, ('Refunded'::character varying)::text])));


--
-- Name: byte_time_created_idx; Type: INDEX; Schema: pantry; Owner: dbservice
--

CREATE INDEX byte_time_created_idx ON pantry.label USING btree (time_created);


--
-- Name: history_epc; Type: INDEX; Schema: pantry; Owner: dbservice
--

CREATE INDEX history_epc ON pantry.history USING btree (epc);


--
-- Name: history_epc_order_epc; Type: INDEX; Schema: pantry; Owner: dbservice
--

CREATE INDEX history_epc_order_epc ON pantry.history_epc_order USING btree (epc);


--
-- Name: history_epc_order_kiosk_id; Type: INDEX; Schema: pantry; Owner: dbservice
--

CREATE INDEX history_epc_order_kiosk_id ON pantry.history_epc_order USING btree (kiosk_id);


--
-- Name: history_epc_order_order_id; Type: INDEX; Schema: pantry; Owner: dbservice
--

CREATE INDEX history_epc_order_order_id ON pantry.history_epc_order USING btree (order_id);


--
-- Name: history_epc_order_time; Type: INDEX; Schema: pantry; Owner: dbservice
--

CREATE INDEX history_epc_order_time ON pantry.history_epc_order USING btree ("time");


--
-- Name: history_idx; Type: INDEX; Schema: pantry; Owner: dbservice
--

CREATE INDEX history_idx ON pantry.history USING btree (to_timestamp(("time")::double precision));


--
-- Name: history_kiosk_id; Type: INDEX; Schema: pantry; Owner: dbservice
--

CREATE INDEX history_kiosk_id ON pantry.history USING btree (kiosk_id);


--
-- Name: history_order_id; Type: INDEX; Schema: pantry; Owner: dbservice
--

CREATE INDEX history_order_id ON pantry.history USING btree (order_id);


--
-- Name: history_time; Type: INDEX; Schema: pantry; Owner: dbservice
--

CREATE INDEX history_time ON pantry.history USING btree ("time");


--
-- Name: inventory_history_campus_id_time_idx; Type: INDEX; Schema: pantry; Owner: dbservice
--

CREATE INDEX inventory_history_campus_id_time_idx ON pantry.inventory_history USING btree (to_timestamp(("time")::double precision)) WHERE (campus_id = 87);


--
-- Name: inventory_history_idx; Type: INDEX; Schema: pantry; Owner: dbservice
--

CREATE INDEX inventory_history_idx ON pantry.inventory_history USING btree (to_timestamp(("time")::double precision));


--
-- Name: inventory_history_kiosk_id_idx; Type: INDEX; Schema: pantry; Owner: dbservice
--

CREATE INDEX inventory_history_kiosk_id_idx ON pantry.inventory_history USING btree (kiosk_id);


--
-- Name: inventory_history_product_id_idx; Type: INDEX; Schema: pantry; Owner: dbservice
--

CREATE INDEX inventory_history_product_id_idx ON pantry.inventory_history USING btree (product_id);


--
-- Name: inventory_history_time_idx; Type: INDEX; Schema: pantry; Owner: dbservice
--

CREATE INDEX inventory_history_time_idx ON pantry.inventory_history USING btree ("time");


--
-- Name: inventory_history_to_timestamp_product_id_idx; Type: INDEX; Schema: pantry; Owner: dbservice
--

CREATE INDEX inventory_history_to_timestamp_product_id_idx ON pantry.inventory_history USING btree (to_timestamp(("time")::double precision), product_id);


--
-- Name: inventory_request_epc; Type: INDEX; Schema: pantry; Owner: dbservice
--

CREATE INDEX inventory_request_epc ON pantry.inventory_request USING btree (epc);


--
-- Name: inventory_request_kiosk_id; Type: INDEX; Schema: pantry; Owner: dbservice
--

CREATE INDEX inventory_request_kiosk_id ON pantry.inventory_request USING btree (kiosk_id);


--
-- Name: inventory_request_time; Type: INDEX; Schema: pantry; Owner: dbservice
--

CREATE INDEX inventory_request_time ON pantry.inventory_request USING btree ("time");


--
-- Name: inventory_request_ts; Type: INDEX; Schema: pantry; Owner: dbservice
--

CREATE INDEX inventory_request_ts ON pantry.inventory_request USING btree (to_timestamp(("time")::double precision));


--
-- Name: last_kiosk_status_id; Type: INDEX; Schema: pantry; Owner: dbservice
--

CREATE UNIQUE INDEX last_kiosk_status_id ON pantry.last_kiosk_status USING btree (kiosk_id);


--
-- Name: order_id_unique; Type: INDEX; Schema: pantry; Owner: dbservice
--

CREATE UNIQUE INDEX order_id_unique ON pantry.feedback USING btree (order_id);


--
-- Name: pantry_coupon_code_idx; Type: INDEX; Schema: pantry; Owner: dbservice
--

CREATE INDEX pantry_coupon_code_idx ON pantry.coupon USING btree (code);


--
-- Name: pantry_order_coupon_idx; Type: INDEX; Schema: pantry; Owner: dbservice
--

CREATE INDEX pantry_order_coupon_idx ON pantry."order" USING btree (coupon);


--
-- Name: pantry_order_kiosk_id; Type: INDEX; Schema: pantry; Owner: dbservice
--

CREATE INDEX pantry_order_kiosk_id ON pantry."order" USING btree (kiosk_id);


--
-- Name: pantry_order_kiosk_id_ts; Type: INDEX; Schema: pantry; Owner: dbservice
--

CREATE INDEX pantry_order_kiosk_id_ts ON pantry."order" USING btree (kiosk_id, created) WHERE ((campus_id = 87) AND ((order_id)::text !~~ 'RE%'::text));


--
-- Name: tag_name_id; Type: INDEX; Schema: pantry; Owner: dbservice
--

CREATE UNIQUE INDEX tag_name_id ON pantry.tag USING btree (tag);


--
-- Name: tag_unique_constraint_index; Type: INDEX; Schema: pantry; Owner: dbservice
--

CREATE UNIQUE INDEX tag_unique_constraint_index ON pantry.tag USING btree (lower((tag)::text));


--
-- Name: tmp_payment_order_with_id_payload_idx; Type: INDEX; Schema: pantry; Owner: dbservice
--

CREATE INDEX tmp_payment_order_with_id_payload_idx ON pantry.tmp_payment_order_with_id USING btree (payload);


--
-- Name: awsdms_history_task_history_index; Type: INDEX; Schema: public; Owner: dbservice
--

CREATE UNIQUE INDEX awsdms_history_task_history_index ON public.awsdms_history USING btree (server_name, task_name, timeslot_type, timeslot);


--
-- Name: awsdms_status_task_status_index; Type: INDEX; Schema: public; Owner: dbservice
--

CREATE UNIQUE INDEX awsdms_status_task_status_index ON public.awsdms_status USING btree (server_name, task_name);


--
-- Name: awsdms_suspended_tables_task_suspended_tables_index; Type: INDEX; Schema: public; Owner: dbservice
--

CREATE UNIQUE INDEX awsdms_suspended_tables_task_suspended_tables_index ON public.awsdms_suspended_tables USING btree (server_name, task_name, table_owner, table_name);


--
-- Name: bytecodelog_bytecode_expires_at; Type: INDEX; Schema: public; Owner: dbservice
--

CREATE INDEX bytecodelog_bytecode_expires_at ON public.bytecodelog USING btree (bytecode, expires_at);


--
-- Name: idx_bkg_hkp; Type: INDEX; Schema: public; Owner: dbservice
--

CREATE INDEX idx_bkg_hkp ON public.byte_kp_grid USING btree (kiosk_id, product_id, hour_start);


--
-- Name: idx_bko_hkp; Type: INDEX; Schema: public; Owner: dbservice
--

CREATE INDEX idx_bko_hkp ON public.byte_kp_sales USING btree (kiosk_id, product_id, sales_hour);


--
-- Name: idx_bkp_oavg; Type: INDEX; Schema: public; Owner: dbservice
--

CREATE INDEX idx_bkp_oavg ON public.byte_kp_oos_avgdowhour USING btree (kiosk_id, product_id, dowhour);


--
-- Name: idx_bkp_savg; Type: INDEX; Schema: public; Owner: dbservice
--

CREATE INDEX idx_bkp_savg ON public.byte_kp_sales_avgdowhour USING btree (kiosk_id, product_id, dowhour);


--
-- Name: vantiv_20190801_referencenumber_idx; Type: INDEX; Schema: test; Owner: dbservice
--

CREATE UNIQUE INDEX vantiv_20190801_referencenumber_idx ON test.vantiv_20190801 USING btree (referencenumber);


--
-- Name: pick_inventory set_default_pick_date; Type: TRIGGER; Schema: inm_test; Owner: dbservice
--

CREATE TRIGGER set_default_pick_date BEFORE INSERT ON inm_test.pick_inventory FOR EACH ROW EXECUTE PROCEDURE inm_test.pick_inventory_insert();
false TRIGGER
HERE false TRIGGER
HERE map[set_default_pick_date:CREATE TRIGGER set_default_pick_date BEFORE INSERT ON inm_test.pick_inventory FOR EACH ROW EXECUTE PROCEDURE inm_test.pick_inventory_insert();]


--
-- Name: product_stats_by_kiosk before_insert_product_stats_by_kiosk; Type: TRIGGER; Schema: pantry; Owner: dbservice
--

CREATE TRIGGER before_insert_product_stats_by_kiosk BEFORE INSERT ON pantry.product_stats_by_kiosk FOR EACH ROW EXECUTE PROCEDURE pantry.fn_product_stats_by_kiosk();


--
-- Name: spoilage before_insert_spoilage; Type: TRIGGER; Schema: pantry; Owner: dbservice
--

CREATE TRIGGER before_insert_spoilage BEFORE INSERT ON pantry.spoilage FOR EACH ROW EXECUTE PROCEDURE pantry.fn_spoilage_insert();


--
-- Name: campus campus_insert; Type: TRIGGER; Schema: pantry; Owner: dbservice
--

CREATE TRIGGER campus_insert AFTER INSERT ON pantry.campus FOR EACH ROW EXECUTE PROCEDURE pantry.fn_campus_insert();


--
-- Name: card card_insert; Type: TRIGGER; Schema: pantry; Owner: dbservice
--

CREATE TRIGGER card_insert BEFORE INSERT ON pantry.card FOR EACH ROW EXECUTE PROCEDURE pantry.fn_card_insert();


--
-- Name: discount discount_delete; Type: TRIGGER; Schema: pantry; Owner: dbservice
--

CREATE TRIGGER discount_delete AFTER DELETE ON pantry.discount FOR EACH ROW EXECUTE PROCEDURE pantry.fn_discount_delete();


--
-- Name: discount discount_insert; Type: TRIGGER; Schema: pantry; Owner: dbservice
--

CREATE TRIGGER discount_insert AFTER INSERT ON pantry.discount FOR EACH ROW EXECUTE PROCEDURE pantry.fn_discount_insert();


--
-- Name: discount discount_update; Type: TRIGGER; Schema: pantry; Owner: dbservice
--

CREATE TRIGGER discount_update AFTER UPDATE ON pantry.discount FOR EACH ROW EXECUTE PROCEDURE pantry.fn_discount_update();


--
-- Name: kiosk guardrails_ssl_cert_bytetech_co; Type: TRIGGER; Schema: pantry; Owner: dbservice
--

CREATE TRIGGER guardrails_ssl_cert_bytetech_co BEFORE INSERT OR UPDATE ON pantry.kiosk FOR EACH ROW EXECUTE PROCEDURE pantry.kiosk_guardrails_ssl_cert_bytetech_co();


--
-- Name: kiosk kiosk_audit_log_insert; Type: TRIGGER; Schema: pantry; Owner: dbservice
--

CREATE TRIGGER kiosk_audit_log_insert AFTER INSERT ON pantry.kiosk FOR EACH ROW EXECUTE PROCEDURE pantry.fn_kiosk_audit_log_insert();


--
-- Name: kiosk kiosk_audit_log_update; Type: TRIGGER; Schema: pantry; Owner: dbservice
--

CREATE TRIGGER kiosk_audit_log_update BEFORE UPDATE ON pantry.kiosk FOR EACH ROW EXECUTE PROCEDURE pantry.fn_kiosk_audit_log_update();


--
-- Name: kiosk_status kiosk_status_insert; Type: TRIGGER; Schema: pantry; Owner: dbservice
--

CREATE TRIGGER kiosk_status_insert BEFORE INSERT ON pantry.kiosk_status FOR EACH ROW EXECUTE PROCEDURE pantry.fn_kiosk_status_insert();


--
-- Name: kiosk kiosk_update; Type: TRIGGER; Schema: pantry; Owner: dbservice
--

CREATE TRIGGER kiosk_update AFTER UPDATE ON pantry.kiosk FOR EACH ROW EXECUTE PROCEDURE pantry.fn_kiosk_update();


--
-- Name: label label_delete; Type: TRIGGER; Schema: pantry; Owner: dbservice
--

CREATE TRIGGER label_delete AFTER DELETE ON pantry.label FOR EACH ROW EXECUTE PROCEDURE pantry.fn_label_delete();


--
-- Name: label label_insert; Type: TRIGGER; Schema: pantry; Owner: dbservice
--

CREATE TRIGGER label_insert BEFORE INSERT ON pantry.label FOR EACH ROW EXECUTE PROCEDURE pantry.fn_label_insert();


--
-- Name: label label_update; Type: TRIGGER; Schema: pantry; Owner: dbservice
--

CREATE TRIGGER label_update AFTER UPDATE ON pantry.label FOR EACH ROW EXECUTE PROCEDURE pantry.fn_label_update();


--
-- Name: order order_insert; Type: TRIGGER; Schema: pantry; Owner: dbservice
--

CREATE TRIGGER order_insert AFTER INSERT ON pantry."order" FOR EACH ROW EXECUTE PROCEDURE pantry.fn_order_insert();


--
-- Name: order order_update; Type: TRIGGER; Schema: pantry; Owner: dbservice
--

CREATE TRIGGER order_update AFTER UPDATE ON pantry."order" FOR EACH ROW EXECUTE PROCEDURE pantry.fn_order_update();


--
-- Name: product product_delete; Type: TRIGGER; Schema: pantry; Owner: dbservice
--

CREATE TRIGGER product_delete AFTER DELETE ON pantry.product FOR EACH ROW EXECUTE PROCEDURE pantry.fn_product_delete();


--
-- Name: product product_insert; Type: TRIGGER; Schema: pantry; Owner: dbservice
--

CREATE TRIGGER product_insert AFTER INSERT ON pantry.product FOR EACH ROW EXECUTE PROCEDURE pantry.fn_product_insert();


--
-- Name: product product_update; Type: TRIGGER; Schema: pantry; Owner: dbservice
--

CREATE TRIGGER product_update AFTER UPDATE ON pantry.product FOR EACH ROW EXECUTE PROCEDURE pantry.fn_product_update();


--
-- Name: campus_attribute trg_campus_attribute; Type: TRIGGER; Schema: pantry; Owner: dbservice
--

CREATE TRIGGER trg_campus_attribute AFTER INSERT OR DELETE OR UPDATE ON pantry.campus_attribute FOR EACH ROW EXECUTE PROCEDURE pantry.fn_audit_campus_attribute();


--
-- Name: global_attribute_def trg_global_attribute_def; Type: TRIGGER; Schema: pantry; Owner: dbservice
--

CREATE TRIGGER trg_global_attribute_def AFTER INSERT OR DELETE OR UPDATE ON pantry.global_attribute_def FOR EACH ROW EXECUTE PROCEDURE pantry.fn_audit_global_attribute_def();


--
-- Name: kiosk_attribute trg_kiosk_attribute; Type: TRIGGER; Schema: pantry; Owner: dbservice
--

CREATE TRIGGER trg_kiosk_attribute AFTER INSERT OR DELETE OR UPDATE ON pantry.kiosk_attribute FOR EACH ROW EXECUTE PROCEDURE pantry.fn_audit_kiosk_attribute();


--
-- Name: kiosk_device trg_kiosk_device; Type: TRIGGER; Schema: pantry; Owner: dbservice
--

CREATE TRIGGER trg_kiosk_device AFTER INSERT OR DELETE OR UPDATE ON pantry.kiosk_device FOR EACH ROW EXECUTE PROCEDURE pantry.fn_audit_kiosk_device();


--
-- Name: kiosk_service_version trg_kiosk_service_version; Type: TRIGGER; Schema: pantry; Owner: dbservice
--

CREATE TRIGGER trg_kiosk_service_version AFTER INSERT OR DELETE OR UPDATE ON pantry.kiosk_service_version FOR EACH ROW EXECUTE PROCEDURE pantry.fn_audit_kiosk_service_version();


--
-- Name: tmp_unit lineitem_order_id_fkey; Type: FK CONSTRAINT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.tmp_unit
    ADD CONSTRAINT lineitem_order_id_fkey FOREIGN KEY (order_id) REFERENCES mixalot.tmp_transact(order_id);


--
-- Name: log log_order_id_fkey; Type: FK CONSTRAINT; Schema: mixalot; Owner: dbservice
--

ALTER TABLE ONLY mixalot.log
    ADD CONSTRAINT log_order_id_fkey FOREIGN KEY (order_id) REFERENCES mixalot.tmp_transact(order_id);


--
-- Name: awsdms_intercept_ddl; Type: EVENT TRIGGER; Schema: -; Owner: rdsadmin
--

CREATE EVENT TRIGGER awsdms_intercept_ddl ON ddl_command_end
   EXECUTE PROCEDURE public.awsdms_intercept_ddl();


ALTER EVENT TRIGGER awsdms_intercept_ddl OWNER TO rdsadmin;

--
-- Name: SCHEMA inm; Type: ACL; Schema: -; Owner: dbservice
--

GRANT ALL ON SCHEMA inm TO bytedevs;


--
-- Name: SCHEMA mixalot; Type: ACL; Schema: -; Owner: dbservice
--

GRANT USAGE ON SCHEMA mixalot TO requestlogs;
GRANT ALL ON SCHEMA mixalot TO bytedevs;


--
-- Name: SCHEMA pantry; Type: ACL; Schema: -; Owner: dbservice
--

GRANT ALL ON SCHEMA pantry TO pantry_web_user;
GRANT ALL ON SCHEMA pantry TO bytedevs;


--
-- Name: SCHEMA public; Type: ACL; Schema: -; Owner: dbservice
--

REVOKE ALL ON SCHEMA public FROM rdsadmin;
REVOKE ALL ON SCHEMA public FROM PUBLIC;
GRANT ALL ON SCHEMA public TO dbservice;
GRANT ALL ON SCHEMA public TO PUBLIC;
GRANT ALL ON SCHEMA public TO pantry_web_user;


--
-- Name: SCHEMA report; Type: ACL; Schema: -; Owner: dbservice
--

GRANT ALL ON SCHEMA report TO bytedevs;


--
-- Name: SCHEMA rptg; Type: ACL; Schema: -; Owner: dbservice
--

GRANT ALL ON SCHEMA rptg TO bytedevs;


--
-- Name: SCHEMA test; Type: ACL; Schema: -; Owner: dbservice
--

GRANT ALL ON SCHEMA test TO bytedevs;


--
-- Name: FUNCTION allocation_ratio_by_sku_group(target_date date); Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON FUNCTION inm.allocation_ratio_by_sku_group(target_date date) TO bytedevs;


--
-- Name: FUNCTION allocation_ratio_by_sku_group_test(target_date date); Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON FUNCTION inm.allocation_ratio_by_sku_group_test(target_date date) TO bytedevs;


--
-- Name: FUNCTION f_kiosk_sku_group_sku_pick_stats(pick_time timestamp with time zone); Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON FUNCTION inm.f_kiosk_sku_group_sku_pick_stats(pick_time timestamp with time zone) TO bytedevs;


--
-- Name: FUNCTION get_all_pull_list(given_kiosk_id integer); Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON FUNCTION inm.get_all_pull_list(given_kiosk_id integer) TO bytedevs;


--
-- Name: FUNCTION get_performance_pull_list(given_kiosk_id integer); Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON FUNCTION inm.get_performance_pull_list(given_kiosk_id integer) TO bytedevs;


--
-- Name: FUNCTION get_pull_date(plan_window_start timestamp with time zone, plan_window_stop timestamp with time zone); Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON FUNCTION inm.get_pull_date(plan_window_start timestamp with time zone, plan_window_stop timestamp with time zone) TO bytedevs;


--
-- Name: FUNCTION get_spoilage_pull_list(); Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON FUNCTION inm.get_spoilage_pull_list() TO bytedevs;


--
-- Name: FUNCTION get_spoilage_pull_list(given_kiosk_id integer); Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON FUNCTION inm.get_spoilage_pull_list(given_kiosk_id integer) TO bytedevs;


--
-- Name: FUNCTION pick_check_restriction(_pick_date date); Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON FUNCTION inm.pick_check_restriction(_pick_date date) TO bytedevs;


--
-- Name: FUNCTION pick_get_delivery_schedule(pick_date date); Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON FUNCTION inm.pick_get_delivery_schedule(pick_date date) TO bytedevs;


--
-- Name: FUNCTION pick_get_delivery_schedule_optimo(target_date date); Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON FUNCTION inm.pick_get_delivery_schedule_optimo(target_date date) TO bytedevs;


--
-- Name: FUNCTION pick_get_demand_weekly_by_velocity(); Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON FUNCTION inm.pick_get_demand_weekly_by_velocity() TO bytedevs;


--
-- Name: FUNCTION pick_get_demand_weekly_wo_min(); Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON FUNCTION inm.pick_get_demand_weekly_wo_min() TO bytedevs;


--
-- Name: FUNCTION pick_get_order(start_ts timestamp with time zone, end_ts timestamp with time zone); Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON FUNCTION inm.pick_get_order(start_ts timestamp with time zone, end_ts timestamp with time zone) TO bytedevs;


--
-- Name: FUNCTION pick_get_order_with_velocity(start_ts timestamp with time zone, end_ts timestamp with time zone); Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON FUNCTION inm.pick_get_order_with_velocity(start_ts timestamp with time zone, end_ts timestamp with time zone) TO bytedevs;


--
-- Name: FUNCTION pick_get_plan_kiosk(pick_date date); Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON FUNCTION inm.pick_get_plan_kiosk(pick_date date) TO bytedevs;


--
-- Name: FUNCTION pick_get_plan_kiosk(plan_window_start timestamp with time zone, plan_window_stop timestamp with time zone); Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON FUNCTION inm.pick_get_plan_kiosk(plan_window_start timestamp with time zone, plan_window_stop timestamp with time zone) TO bytedevs;


--
-- Name: FUNCTION pick_get_plan_kiosk_bringg(plan_window_start timestamp with time zone, plan_window_stop timestamp with time zone); Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON FUNCTION inm.pick_get_plan_kiosk_bringg(plan_window_start timestamp with time zone, plan_window_stop timestamp with time zone) TO bytedevs;


--
-- Name: FUNCTION pick_get_plan_kiosk_disabled_product(pick_date date); Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON FUNCTION inm.pick_get_plan_kiosk_disabled_product(pick_date date) TO bytedevs;


--
-- Name: FUNCTION pick_get_plan_kiosk_optimo(plan_window_start timestamp with time zone, plan_window_stop timestamp with time zone); Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON FUNCTION inm.pick_get_plan_kiosk_optimo(plan_window_start timestamp with time zone, plan_window_stop timestamp with time zone) TO bytedevs;


--
-- Name: FUNCTION pick_get_plan_kiosk_projected_stock(plan_window_start timestamp with time zone, plan_window_stop timestamp with time zone); Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON FUNCTION inm.pick_get_plan_kiosk_projected_stock(plan_window_start timestamp with time zone, plan_window_stop timestamp with time zone) TO bytedevs;


--
-- Name: FUNCTION pick_get_sales_period_ratio(start_ts timestamp with time zone, end_ts timestamp with time zone); Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON FUNCTION inm.pick_get_sales_period_ratio(start_ts timestamp with time zone, end_ts timestamp with time zone) TO bytedevs;


--
-- Name: FUNCTION pick_get_summary(target_date date); Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON FUNCTION inm.pick_get_summary(target_date date) TO bytedevs;


--
-- Name: FUNCTION pick_get_ticket(target_date date); Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON FUNCTION inm.pick_get_ticket(target_date date) TO bytedevs;


--
-- Name: FUNCTION pick_submit(target_date date, overwrite integer, wait_time_seconds integer, OUT submit_status text); Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON FUNCTION inm.pick_submit(target_date date, overwrite integer, wait_time_seconds integer, OUT submit_status text) TO bytedevs;


--
-- Name: FUNCTION sync_restriction_by_property(kiosk_id integer, restriction character varying); Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON FUNCTION inm.sync_restriction_by_property(kiosk_id integer, restriction character varying) TO bytedevs;


--
-- Name: FUNCTION backup_pick_allocation(target_pick_date date); Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON FUNCTION mixalot.backup_pick_allocation(target_pick_date date) TO bytedevs;


--
-- Name: FUNCTION pick_allocation_insert(); Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON FUNCTION mixalot.pick_allocation_insert() TO bytedevs;


--
-- Name: FUNCTION pick_demand_insert(); Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON FUNCTION mixalot.pick_demand_insert() TO bytedevs;


--
-- Name: FUNCTION pick_get_delivery_schedule(start_ts timestamp with time zone, end_ts timestamp with time zone); Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON FUNCTION mixalot.pick_get_delivery_schedule(start_ts timestamp with time zone, end_ts timestamp with time zone) TO bytedevs;


--
-- Name: FUNCTION pick_get_gsheets_plan_demand(start_ts timestamp with time zone, end_ts timestamp with time zone); Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON FUNCTION mixalot.pick_get_gsheets_plan_demand(start_ts timestamp with time zone, end_ts timestamp with time zone) TO bytedevs;


--
-- Name: FUNCTION pick_get_plan_demand(start_ts timestamp with time zone, end_ts timestamp with time zone); Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON FUNCTION mixalot.pick_get_plan_demand(start_ts timestamp with time zone, end_ts timestamp with time zone) TO bytedevs;


--
-- Name: FUNCTION pick_get_summary(target_date date); Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON FUNCTION mixalot.pick_get_summary(target_date date) TO bytedevs;


--
-- Name: FUNCTION pick_inventory_insert(); Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON FUNCTION mixalot.pick_inventory_insert() TO bytedevs;


--
-- Name: FUNCTION pick_summary(target_date date); Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON FUNCTION mixalot.pick_summary(target_date date) TO bytedevs;


--
-- Name: FUNCTION pick_ticket(target_date date); Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON FUNCTION mixalot.pick_ticket(target_date date) TO bytedevs;


--
-- Name: FUNCTION plan_kiosk(plan_window_start timestamp with time zone, plan_window_stop timestamp with time zone); Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON FUNCTION mixalot.plan_kiosk(plan_window_start timestamp with time zone, plan_window_stop timestamp with time zone) TO bytedevs;


--
-- Name: FUNCTION set_sequence_val_max(schema_name name, table_name name, raise_notice boolean); Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON FUNCTION mixalot.set_sequence_val_max(schema_name name, table_name name, raise_notice boolean) TO bytedevs;


--
-- Name: FUNCTION sku_pick_order(target_ts timestamp with time zone); Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON FUNCTION mixalot.sku_pick_order(target_ts timestamp with time zone) TO bytedevs;


--
-- Name: FUNCTION fn_add_to_watch(label_id bigint, order_id character varying); Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON FUNCTION pantry.fn_add_to_watch(label_id bigint, order_id character varying) TO pantry_web_user;
GRANT ALL ON FUNCTION pantry.fn_add_to_watch(label_id bigint, order_id character varying) TO bytedevs;


--
-- Name: FUNCTION fn_audit_campus_attribute(); Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON FUNCTION pantry.fn_audit_campus_attribute() TO pantry_web_user;
GRANT ALL ON FUNCTION pantry.fn_audit_campus_attribute() TO bytedevs;


--
-- Name: FUNCTION fn_audit_global_attribute_def(); Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON FUNCTION pantry.fn_audit_global_attribute_def() TO pantry_web_user;
GRANT ALL ON FUNCTION pantry.fn_audit_global_attribute_def() TO bytedevs;


--
-- Name: FUNCTION fn_audit_kiosk_attribute(); Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON FUNCTION pantry.fn_audit_kiosk_attribute() TO pantry_web_user;
GRANT ALL ON FUNCTION pantry.fn_audit_kiosk_attribute() TO bytedevs;


--
-- Name: FUNCTION fn_audit_kiosk_device(); Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON FUNCTION pantry.fn_audit_kiosk_device() TO pantry_web_user;
GRANT ALL ON FUNCTION pantry.fn_audit_kiosk_device() TO bytedevs;


--
-- Name: FUNCTION fn_audit_kiosk_service_version(); Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON FUNCTION pantry.fn_audit_kiosk_service_version() TO pantry_web_user;
GRANT ALL ON FUNCTION pantry.fn_audit_kiosk_service_version() TO bytedevs;


--
-- Name: FUNCTION fn_campus_insert(); Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON FUNCTION pantry.fn_campus_insert() TO pantry_web_user;
GRANT ALL ON FUNCTION pantry.fn_campus_insert() TO bytedevs;


--
-- Name: FUNCTION fn_card_insert(); Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON FUNCTION pantry.fn_card_insert() TO pantry_web_user;
GRANT ALL ON FUNCTION pantry.fn_card_insert() TO bytedevs;


--
-- Name: FUNCTION fn_discount_delete(); Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON FUNCTION pantry.fn_discount_delete() TO pantry_web_user;
GRANT ALL ON FUNCTION pantry.fn_discount_delete() TO bytedevs;


--
-- Name: FUNCTION fn_discount_insert(); Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON FUNCTION pantry.fn_discount_insert() TO pantry_web_user;
GRANT ALL ON FUNCTION pantry.fn_discount_insert() TO bytedevs;


--
-- Name: FUNCTION fn_discount_update(); Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON FUNCTION pantry.fn_discount_update() TO pantry_web_user;
GRANT ALL ON FUNCTION pantry.fn_discount_update() TO bytedevs;


--
-- Name: FUNCTION fn_kiosk_audit_log_insert(); Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON FUNCTION pantry.fn_kiosk_audit_log_insert() TO pantry_web_user;
GRANT ALL ON FUNCTION pantry.fn_kiosk_audit_log_insert() TO bytedevs;


--
-- Name: FUNCTION fn_kiosk_audit_log_update(); Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON FUNCTION pantry.fn_kiosk_audit_log_update() TO pantry_web_user;
GRANT ALL ON FUNCTION pantry.fn_kiosk_audit_log_update() TO bytedevs;


--
-- Name: FUNCTION fn_kiosk_status_insert(); Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON FUNCTION pantry.fn_kiosk_status_insert() TO pantry_web_user;
GRANT ALL ON FUNCTION pantry.fn_kiosk_status_insert() TO bytedevs;


--
-- Name: FUNCTION fn_kiosk_update(); Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON FUNCTION pantry.fn_kiosk_update() TO pantry_web_user;
GRANT ALL ON FUNCTION pantry.fn_kiosk_update() TO bytedevs;


--
-- Name: FUNCTION fn_label_delete(); Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON FUNCTION pantry.fn_label_delete() TO pantry_web_user;
GRANT ALL ON FUNCTION pantry.fn_label_delete() TO bytedevs;


--
-- Name: FUNCTION fn_label_insert(); Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON FUNCTION pantry.fn_label_insert() TO pantry_web_user;
GRANT ALL ON FUNCTION pantry.fn_label_insert() TO bytedevs;


--
-- Name: FUNCTION fn_label_update(); Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON FUNCTION pantry.fn_label_update() TO pantry_web_user;
GRANT ALL ON FUNCTION pantry.fn_label_update() TO bytedevs;


--
-- Name: FUNCTION fn_order_insert(); Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON FUNCTION pantry.fn_order_insert() TO pantry_web_user;
GRANT ALL ON FUNCTION pantry.fn_order_insert() TO bytedevs;


--
-- Name: FUNCTION fn_order_update(); Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON FUNCTION pantry.fn_order_update() TO pantry_web_user;
GRANT ALL ON FUNCTION pantry.fn_order_update() TO bytedevs;


--
-- Name: FUNCTION fn_product_delete(); Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON FUNCTION pantry.fn_product_delete() TO pantry_web_user;
GRANT ALL ON FUNCTION pantry.fn_product_delete() TO bytedevs;


--
-- Name: FUNCTION fn_product_insert(); Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON FUNCTION pantry.fn_product_insert() TO pantry_web_user;
GRANT ALL ON FUNCTION pantry.fn_product_insert() TO bytedevs;


--
-- Name: FUNCTION fn_product_stats_by_kiosk(); Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON FUNCTION pantry.fn_product_stats_by_kiosk() TO pantry_web_user;
GRANT ALL ON FUNCTION pantry.fn_product_stats_by_kiosk() TO bytedevs;


--
-- Name: FUNCTION fn_product_update(); Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON FUNCTION pantry.fn_product_update() TO pantry_web_user;
GRANT ALL ON FUNCTION pantry.fn_product_update() TO bytedevs;


--
-- Name: FUNCTION fn_ro_order_set_order(orderid character varying); Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON FUNCTION pantry.fn_ro_order_set_order(orderid character varying) TO pantry_web_user;
GRANT ALL ON FUNCTION pantry.fn_ro_order_set_order(orderid character varying) TO bytedevs;


--
-- Name: FUNCTION fn_ro_order_update_full_price(orderid character varying); Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON FUNCTION pantry.fn_ro_order_update_full_price(orderid character varying) TO pantry_web_user;
GRANT ALL ON FUNCTION pantry.fn_ro_order_update_full_price(orderid character varying) TO bytedevs;


--
-- Name: FUNCTION fn_spoilage_insert(); Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON FUNCTION pantry.fn_spoilage_insert() TO pantry_web_user;
GRANT ALL ON FUNCTION pantry.fn_spoilage_insert() TO bytedevs;


--
-- Name: FUNCTION get_permissions(a integer); Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON FUNCTION pantry.get_permissions(a integer) TO pantry_web_user;
GRANT ALL ON FUNCTION pantry.get_permissions(a integer) TO bytedevs;


--
-- Name: FUNCTION hierarchy(givenid integer, initial integer); Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON FUNCTION pantry.hierarchy(givenid integer, initial integer) TO pantry_web_user;
GRANT ALL ON FUNCTION pantry.hierarchy(givenid integer, initial integer) TO bytedevs;


--
-- Name: FUNCTION key_loc_lookup(param_kiosk_id bigint, key_name character varying); Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON FUNCTION pantry.key_loc_lookup(param_kiosk_id bigint, key_name character varying) TO pantry_web_user;
GRANT ALL ON FUNCTION pantry.key_loc_lookup(param_kiosk_id bigint, key_name character varying) TO bytedevs;


--
-- Name: FUNCTION kiosk_guardrails_ssl_cert_bytetech_co(); Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON FUNCTION pantry.kiosk_guardrails_ssl_cert_bytetech_co() TO pantry_web_user;
GRANT ALL ON FUNCTION pantry.kiosk_guardrails_ssl_cert_bytetech_co() TO bytedevs;


--
-- Name: FUNCTION awsdms_intercept_ddl(); Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON FUNCTION public.awsdms_intercept_ddl() TO pantry_web_user;


--
-- Name: FUNCTION checkpoint(receiving_start timestamp without time zone, receiving_stop timestamp without time zone, location_id bigint); Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON FUNCTION public.checkpoint(receiving_start timestamp without time zone, receiving_stop timestamp without time zone, location_id bigint) TO pantry_web_user;


--
-- Name: FUNCTION date_round(base_date timestamp with time zone, round_interval interval); Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON FUNCTION public.date_round(base_date timestamp with time zone, round_interval interval) TO pantry_web_user;


--
-- Name: FUNCTION div(numeric, numeric); Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON FUNCTION public.div(numeric, numeric) TO pantry_web_user;


--
-- Name: FUNCTION dowhour(timestamp with time zone); Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON FUNCTION public.dowhour(timestamp with time zone) TO pantry_web_user;


--
-- Name: FUNCTION epoch_round(bigint, round_interval interval); Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON FUNCTION public.epoch_round(bigint, round_interval interval) TO pantry_web_user;


--
-- Name: FUNCTION f_nr_stockout_minutes(ts timestamp with time zone, kiosk_restock_ts timestamp with time zone, hour_start timestamp with time zone, hour_end timestamp with time zone); Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON FUNCTION public.f_nr_stockout_minutes(ts timestamp with time zone, kiosk_restock_ts timestamp with time zone, hour_start timestamp with time zone, hour_end timestamp with time zone) TO pantry_web_user;


--
-- Name: FUNCTION fmt_ts(timestamp with time zone); Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON FUNCTION public.fmt_ts(timestamp with time zone) TO pantry_web_user;


--
-- Name: FUNCTION fmt_ts_mmdd(timestamp with time zone); Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON FUNCTION public.fmt_ts_mmdd(timestamp with time zone) TO pantry_web_user;


--
-- Name: FUNCTION frac(numeric, numeric); Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON FUNCTION public.frac(numeric, numeric) TO pantry_web_user;


--
-- Name: FUNCTION get_sum(a numeric, b numeric); Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON FUNCTION public.get_sum(a numeric, b numeric) TO pantry_web_user;


--
-- Name: FUNCTION hash_to_bigint(hexval character varying); Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON FUNCTION public.hash_to_bigint(hexval character varying) TO pantry_web_user;


--
-- Name: FUNCTION hex_to_int(hexval character varying); Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON FUNCTION public.hex_to_int(hexval character varying) TO pantry_web_user;


--
-- Name: FUNCTION if(boolean, anyelement, anyelement); Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON FUNCTION public.if(boolean, anyelement, anyelement) TO pantry_web_user;


--
-- Name: FUNCTION int_hash(text); Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON FUNCTION public.int_hash(text) TO pantry_web_user;


--
-- Name: FUNCTION interval_hours(interval); Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON FUNCTION public.interval_hours(interval) TO pantry_web_user;


--
-- Name: FUNCTION monthly_infographic_data(yyyy_mm text); Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON FUNCTION public.monthly_infographic_data(yyyy_mm text) TO pantry_web_user;


--
-- Name: FUNCTION path_check(VARIADIC kiosk_path text[]); Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON FUNCTION public.path_check(VARIADIC kiosk_path text[]) TO pantry_web_user;


--
-- Name: FUNCTION path_check_1_2_3(receiving_start timestamp without time zone, receiving_stop timestamp without time zone); Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON FUNCTION public.path_check_1_2_3(receiving_start timestamp without time zone, receiving_stop timestamp without time zone) TO pantry_web_user;


--
-- Name: FUNCTION pct(numeric, numeric); Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON FUNCTION public.pct(numeric, numeric) TO pantry_web_user;


--
-- Name: FUNCTION pick_get_next_delivery(target_date date); Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON FUNCTION public.pick_get_next_delivery(target_date date) TO pantry_web_user;


--
-- Name: FUNCTION pickpack(receiving_start timestamp without time zone, receiving_stop timestamp without time zone, location_id bigint); Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON FUNCTION public.pickpack(receiving_start timestamp without time zone, receiving_stop timestamp without time zone, location_id bigint) TO pantry_web_user;


--
-- Name: FUNCTION receiving(receiving_start timestamp without time zone, receiving_stop timestamp without time zone); Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON FUNCTION public.receiving(receiving_start timestamp without time zone, receiving_stop timestamp without time zone) TO pantry_web_user;


--
-- Name: FUNCTION set_sequence_val_max(schema_name name, table_name name, raise_notice boolean); Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON FUNCTION public.set_sequence_val_max(schema_name name, table_name name, raise_notice boolean) TO pantry_web_user;


--
-- Name: FUNCTION shelf_life_bucket(integer); Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON FUNCTION public.shelf_life_bucket(integer) TO pantry_web_user;


--
-- Name: FUNCTION stockout_hours(text, text); Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON FUNCTION public.stockout_hours(text, text) TO pantry_web_user;


--
-- Name: FUNCTION user_retention_by_month(n integer); Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON FUNCTION public.user_retention_by_month(n integer) TO pantry_web_user;


--
-- Name: FUNCTION user_retention_by_week(n integer); Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON FUNCTION public.user_retention_by_week(n integer) TO pantry_web_user;


--
-- Name: FUNCTION dependency_tree(object_ids oid[]); Type: ACL; Schema: report; Owner: dbservice
--

GRANT ALL ON FUNCTION report.dependency_tree(object_ids oid[]) TO bytedevs;


--
-- Name: FUNCTION dependency_tree(object_names text[]); Type: ACL; Schema: report; Owner: dbservice
--

GRANT ALL ON FUNCTION report.dependency_tree(object_names text[]) TO bytedevs;


--
-- Name: FUNCTION dependency_tree(search_pattern text); Type: ACL; Schema: report; Owner: dbservice
--

GRANT ALL ON FUNCTION report.dependency_tree(search_pattern text) TO bytedevs;


--
-- Name: FUNCTION byte_losses(beginning_date date, ending_date date); Type: ACL; Schema: rptg; Owner: dbservice
--

GRANT ALL ON FUNCTION rptg.byte_losses(beginning_date date, ending_date date) TO bytedevs;


--
-- Name: FUNCTION byte_sales(beginning_date date, ending_date date); Type: ACL; Schema: rptg; Owner: dbservice
--

GRANT ALL ON FUNCTION rptg.byte_sales(beginning_date date, ending_date date) TO bytedevs;


--
-- Name: FUNCTION losses(beginning_date date, ending_date date); Type: ACL; Schema: rptg; Owner: dbservice
--

GRANT ALL ON FUNCTION rptg.losses(beginning_date date, ending_date date) TO bytedevs;


--
-- Name: FUNCTION non_byte_losses(beginning_date date, ending_date date); Type: ACL; Schema: rptg; Owner: dbservice
--

GRANT ALL ON FUNCTION rptg.non_byte_losses(beginning_date date, ending_date date) TO bytedevs;


--
-- Name: FUNCTION non_byte_sales(beginning_date date, ending_date date); Type: ACL; Schema: rptg; Owner: dbservice
--

GRANT ALL ON FUNCTION rptg.non_byte_sales(beginning_date date, ending_date date) TO bytedevs;


--
-- Name: FUNCTION pick_audit(start_date date, end_date date); Type: ACL; Schema: rptg; Owner: dbservice
--

GRANT ALL ON FUNCTION rptg.pick_audit(start_date date, end_date date) TO bytedevs;


--
-- Name: FUNCTION restocks(beginning_date date, ending_date date); Type: ACL; Schema: rptg; Owner: dbservice
--

GRANT ALL ON FUNCTION rptg.restocks(beginning_date date, ending_date date) TO bytedevs;


--
-- Name: FUNCTION sales(beginning_date date, ending_date date); Type: ACL; Schema: rptg; Owner: dbservice
--

GRANT ALL ON FUNCTION rptg.sales(beginning_date date, ending_date date) TO bytedevs;


--
-- Name: FUNCTION spoils(beginning_date date, ending_date date); Type: ACL; Schema: rptg; Owner: dbservice
--

GRANT ALL ON FUNCTION rptg.spoils(beginning_date date, ending_date date) TO bytedevs;


--
-- Name: TABLE warehouse_inventory; Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON TABLE inm.warehouse_inventory TO bytedevs;


--
-- Name: TABLE product; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.product TO pantry_web_user;
GRANT ALL ON TABLE pantry.product TO bytedevs;


--
-- Name: TABLE allocable_inventory; Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON TABLE inm.allocable_inventory TO bytedevs;


--
-- Name: TABLE bringg_delivery; Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON TABLE inm.bringg_delivery TO bytedevs;


--
-- Name: TABLE configuration; Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON TABLE inm.configuration TO bytedevs;


--
-- Name: TABLE kiosk_attribute; Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON TABLE inm.kiosk_attribute TO bytedevs;


--
-- Name: TABLE kiosk_control; Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON TABLE inm.kiosk_control TO bytedevs;


--
-- Name: TABLE kiosk_product_disabled; Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON TABLE inm.kiosk_product_disabled TO bytedevs;


--
-- Name: TABLE pick_allocation; Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON TABLE inm.pick_allocation TO bytedevs;


--
-- Name: TABLE sku_group_attribute; Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON TABLE inm.sku_group_attribute TO bytedevs;


--
-- Name: TABLE kiosk; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.kiosk TO pantry_web_user;
GRANT ALL ON TABLE pantry.kiosk TO bytedevs;


--
-- Name: TABLE label; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.label TO pantry_web_user;
GRANT ALL ON TABLE pantry.label TO bytedevs;


--
-- Name: TABLE "order"; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry."order" TO pantry_web_user;
GRANT ALL ON TABLE pantry."order" TO bytedevs;


--
-- Name: TABLE kiosk_projected_minimum; Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON TABLE inm.kiosk_projected_minimum TO bytedevs;


--
-- Name: TABLE kiosk_projected_stock; Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON TABLE inm.kiosk_projected_stock TO bytedevs;


--
-- Name: TABLE kiosk_projected_stock_sku_level; Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON TABLE inm.kiosk_projected_stock_sku_level TO bytedevs;


--
-- Name: TABLE kiosk_restriction_by_product; Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON TABLE inm.kiosk_restriction_by_product TO bytedevs;


--
-- Name: TABLE kiosk_restriction_by_property; Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON TABLE inm.kiosk_restriction_by_property TO bytedevs;


--
-- Name: TABLE kiosk_restriction_by_sku; Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON TABLE inm.kiosk_restriction_by_sku TO bytedevs;


--
-- Name: TABLE product_property_def; Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON TABLE inm.product_property_def TO bytedevs;


--
-- Name: TABLE kiosk_restriction_list; Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON TABLE inm.kiosk_restriction_list TO bytedevs;


--
-- Name: TABLE kiosk_sku_group_manual_scale; Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON TABLE inm.kiosk_sku_group_manual_scale TO bytedevs;


--
-- Name: TABLE pick_demand; Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON TABLE inm.pick_demand TO bytedevs;


--
-- Name: TABLE pick_inventory; Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON TABLE inm.pick_inventory TO bytedevs;


--
-- Name: TABLE pick_list; Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON TABLE inm.pick_list TO bytedevs;


--
-- Name: TABLE pick_preference_kiosk_sku; Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON TABLE inm.pick_preference_kiosk_sku TO bytedevs;


--
-- Name: TABLE pick_priority_kiosk; Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON TABLE inm.pick_priority_kiosk TO bytedevs;


--
-- Name: TABLE pick_priority_sku; Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON TABLE inm.pick_priority_sku TO bytedevs;


--
-- Name: TABLE pick_rejection; Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON TABLE inm.pick_rejection TO bytedevs;


--
-- Name: TABLE pick_route; Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON TABLE inm.pick_route TO bytedevs;


--
-- Name: TABLE pick_substitution; Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON TABLE inm.pick_substitution TO bytedevs;


--
-- Name: TABLE product_property; Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON TABLE inm.product_property TO bytedevs;


--
-- Name: SEQUENCE product_property_def_id_seq; Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON SEQUENCE inm.product_property_def_id_seq TO bytedevs;


--
-- Name: TABLE sku_def; Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON TABLE inm.sku_def TO bytedevs;


--
-- Name: TABLE sku_group; Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON TABLE inm.sku_group TO bytedevs;


--
-- Name: TABLE sku_group_control; Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON TABLE inm.sku_group_control TO bytedevs;


--
-- Name: TABLE sku_property; Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON TABLE inm.sku_property TO bytedevs;


--
-- Name: TABLE sku_property_def; Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON TABLE inm.sku_property_def TO bytedevs;


--
-- Name: TABLE temp_pick_order; Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON TABLE inm.temp_pick_order TO bytedevs;


--
-- Name: TABLE temp_velocity; Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON TABLE inm.temp_velocity TO bytedevs;


--
-- Name: TABLE all_raw_orders; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.all_raw_orders TO bytedevs;
GRANT ALL ON TABLE public.all_raw_orders TO pantry_web_user;


--
-- Name: TABLE _all_orders; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public._all_orders TO bytedevs;
GRANT ALL ON TABLE public._all_orders TO pantry_web_user;


--
-- Name: TABLE all_orders; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.all_orders TO bytedevs;
GRANT ALL ON TABLE public.all_orders TO pantry_web_user;


--
-- Name: TABLE byte_products_fast; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_products_fast TO pantry_web_user;


--
-- Name: TABLE byte_products; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_products TO pantry_web_user;


--
-- Name: TABLE byte_label_product; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_label_product TO pantry_web_user;


--
-- Name: TABLE byte_orders; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_orders TO bytedevs;
GRANT ALL ON TABLE public.byte_orders TO pantry_web_user;


--
-- Name: TABLE byte_tickets; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_tickets TO bytedevs;
GRANT ALL ON TABLE public.byte_tickets TO pantry_web_user;


--
-- Name: TABLE byte_tickets_12weeks; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_tickets_12weeks TO bytedevs;
GRANT ALL ON TABLE public.byte_tickets_12weeks TO pantry_web_user;


--
-- Name: TABLE byte_epcssold_12weeks; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_epcssold_12weeks TO bytedevs;
GRANT ALL ON TABLE public.byte_epcssold_12weeks TO pantry_web_user;


--
-- Name: TABLE v_kiosk_sale_hourly; Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON TABLE inm.v_kiosk_sale_hourly TO bytedevs;


--
-- Name: TABLE route_stop; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.route_stop TO bytedevs;


--
-- Name: TABLE v_kiosk_demand_plan_ratio; Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON TABLE inm.v_kiosk_demand_plan_ratio TO bytedevs;


--
-- Name: TABLE v_kiosk_sku_enabled; Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON TABLE inm.v_kiosk_sku_enabled TO bytedevs;


--
-- Name: TABLE v_kiosk_sku_group_stock_sale_spoil_history; Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON TABLE inm.v_kiosk_sku_group_stock_sale_spoil_history TO bytedevs;


--
-- Name: TABLE byte_tickets_3months; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_tickets_3months TO bytedevs;
GRANT ALL ON TABLE public.byte_tickets_3months TO pantry_web_user;


--
-- Name: TABLE byte_epcssold_3months; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_epcssold_3months TO bytedevs;
GRANT ALL ON TABLE public.byte_epcssold_3months TO pantry_web_user;


--
-- Name: TABLE v_kiosk_sku_group_velocity_demand_week; Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON TABLE inm.v_kiosk_sku_group_velocity_demand_week TO bytedevs;


--
-- Name: TABLE v_kiosk_sku_velocity; Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON TABLE inm.v_kiosk_sku_velocity TO bytedevs;


--
-- Name: TABLE v_kiosk_sku_group_sku_stats; Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON TABLE inm.v_kiosk_sku_group_sku_stats TO bytedevs;


--
-- Name: TABLE v_warehouse_ordering_rec; Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON TABLE inm.v_warehouse_ordering_rec TO bytedevs;


--
-- Name: TABLE view_sku_sku_group; Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON TABLE inm.view_sku_sku_group TO bytedevs;


--
-- Name: TABLE inm_sku_velocity; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.inm_sku_velocity TO bytedevs;


--
-- Name: TABLE inm_warehouse_sku_enabled; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.inm_warehouse_sku_enabled TO bytedevs;


--
-- Name: TABLE warehouse_ordering; Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON TABLE inm.warehouse_ordering TO bytedevs;


--
-- Name: TABLE allocable_inventory; Type: ACL; Schema: inm_beta; Owner: dbservice
--

GRANT ALL ON TABLE inm_beta.allocable_inventory TO jung;


--
-- Name: TABLE kiosk_control; Type: ACL; Schema: inm_beta; Owner: dbservice
--

GRANT ALL ON TABLE inm_beta.kiosk_control TO jung;


--
-- Name: TABLE kiosk_product_disabled; Type: ACL; Schema: inm_beta; Owner: dbservice
--

GRANT ALL ON TABLE inm_beta.kiosk_product_disabled TO jung;


--
-- Name: TABLE kiosk_restriction_by_product; Type: ACL; Schema: inm_beta; Owner: dbservice
--

GRANT ALL ON TABLE inm_beta.kiosk_restriction_by_product TO jung;


--
-- Name: TABLE kiosk_restriction_by_property; Type: ACL; Schema: inm_beta; Owner: dbservice
--

GRANT ALL ON TABLE inm_beta.kiosk_restriction_by_property TO jung;


--
-- Name: TABLE kiosk_sku_group_manual_scale; Type: ACL; Schema: inm_beta; Owner: dbservice
--

GRANT ALL ON TABLE inm_beta.kiosk_sku_group_manual_scale TO jung;


--
-- Name: TABLE pick_allocation; Type: ACL; Schema: inm_beta; Owner: dbservice
--

GRANT ALL ON TABLE inm_beta.pick_allocation TO jung;


--
-- Name: TABLE pick_demand; Type: ACL; Schema: inm_beta; Owner: dbservice
--

GRANT ALL ON TABLE inm_beta.pick_demand TO jung;


--
-- Name: TABLE pick_inventory; Type: ACL; Schema: inm_beta; Owner: dbservice
--

GRANT ALL ON TABLE inm_beta.pick_inventory TO jung;


--
-- Name: TABLE pick_list; Type: ACL; Schema: inm_beta; Owner: dbservice
--

GRANT ALL ON TABLE inm_beta.pick_list TO jung;


--
-- Name: TABLE pick_preference_kiosk_sku; Type: ACL; Schema: inm_beta; Owner: dbservice
--

GRANT ALL ON TABLE inm_beta.pick_preference_kiosk_sku TO jung;


--
-- Name: TABLE pick_priority_kiosk; Type: ACL; Schema: inm_beta; Owner: dbservice
--

GRANT ALL ON TABLE inm_beta.pick_priority_kiosk TO jung;


--
-- Name: TABLE pick_priority_sku; Type: ACL; Schema: inm_beta; Owner: dbservice
--

GRANT ALL ON TABLE inm_beta.pick_priority_sku TO jung;


--
-- Name: TABLE pick_rejection; Type: ACL; Schema: inm_beta; Owner: dbservice
--

GRANT ALL ON TABLE inm_beta.pick_rejection TO jung;


--
-- Name: TABLE pick_route; Type: ACL; Schema: inm_beta; Owner: dbservice
--

GRANT ALL ON TABLE inm_beta.pick_route TO jung;


--
-- Name: TABLE pick_substitution; Type: ACL; Schema: inm_beta; Owner: dbservice
--

GRANT ALL ON TABLE inm_beta.pick_substitution TO jung;


--
-- Name: TABLE product_property; Type: ACL; Schema: inm_beta; Owner: dbservice
--

GRANT ALL ON TABLE inm_beta.product_property TO jung;


--
-- Name: TABLE sku_group; Type: ACL; Schema: inm_beta; Owner: dbservice
--

GRANT ALL ON TABLE inm_beta.sku_group TO jung;


--
-- Name: TABLE sku_group_control; Type: ACL; Schema: inm_beta; Owner: dbservice
--

GRANT ALL ON TABLE inm_beta.sku_group_control TO jung;


--
-- Name: TABLE warehouse_inventory; Type: ACL; Schema: inm_beta; Owner: dbservice
--

GRANT ALL ON TABLE inm_beta.warehouse_inventory TO jung;


--
-- Name: TABLE facing_category; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.facing_category TO pantry_web_user;
GRANT ALL ON TABLE pantry.facing_category TO bytedevs;


--
-- Name: TABLE card_fact; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.card_fact TO bytedevs;


--
-- Name: SEQUENCE card_fact_id_seq; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON SEQUENCE mixalot.card_fact_id_seq TO bytedevs;


--
-- Name: TABLE card_product_fact; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.card_product_fact TO bytedevs;


--
-- Name: SEQUENCE card_product_fact_id_seq; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON SEQUENCE mixalot.card_product_fact_id_seq TO bytedevs;


--
-- Name: TABLE discount_rule; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.discount_rule TO bytedevs;


--
-- Name: TABLE gsheet_cache; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.gsheet_cache TO bytedevs;


--
-- Name: TABLE gsheets_kiosk_restriction; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.gsheets_kiosk_restriction TO bytedevs;


--
-- Name: TABLE history_order_pipeline; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.history_order_pipeline TO bytedevs;


--
-- Name: SEQUENCE history_order_id_seq; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON SEQUENCE mixalot.history_order_id_seq TO bytedevs;


--
-- Name: TABLE inm_byte_kiosk; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.inm_byte_kiosk TO bytedevs;


--
-- Name: TABLE inm_data; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.inm_data TO bytedevs;


--
-- Name: SEQUENCE inm_data_id_seq; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON SEQUENCE mixalot.inm_data_id_seq TO bytedevs;


--
-- Name: TABLE merchandising_slot_sku_group; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.merchandising_slot_sku_group TO bytedevs;


--
-- Name: TABLE sku_group_def; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.sku_group_def TO bytedevs;


--
-- Name: TABLE sku_group_sku; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.sku_group_sku TO bytedevs;


--
-- Name: TABLE inm_dc_inventory; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.inm_dc_inventory TO bytedevs;


--
-- Name: TABLE inm_demand; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.inm_demand TO bytedevs;


--
-- Name: TABLE inm_gsheets_kiosk_restriction; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.inm_gsheets_kiosk_restriction TO bytedevs;


--
-- Name: TABLE inm_kiosk_restriction_list; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.inm_kiosk_restriction_list TO bytedevs;


--
-- Name: TABLE kiosk_restriction_by_property; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.kiosk_restriction_by_property TO bytedevs;


--
-- Name: TABLE kiosk_restriction_by_sku; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.kiosk_restriction_by_sku TO bytedevs;


--
-- Name: TABLE sku_def; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.sku_def TO bytedevs;


--
-- Name: TABLE sku_property; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.sku_property TO bytedevs;


--
-- Name: TABLE sku_property_def; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.sku_property_def TO bytedevs;


--
-- Name: TABLE inm_kiosk_sku_disabled; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.inm_kiosk_sku_disabled TO bytedevs;


--
-- Name: TABLE inm_sku_enabled; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.inm_sku_enabled TO bytedevs;


--
-- Name: TABLE inm_sku_group_title_to_merchandising_slot; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.inm_sku_group_title_to_merchandising_slot TO bytedevs;


--
-- Name: TABLE kiosk; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.kiosk TO bytedevs;


--
-- Name: TABLE kiosk_contents; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.kiosk_contents TO bytedevs;


--
-- Name: SEQUENCE kiosk_contents_id_seq; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON SEQUENCE mixalot.kiosk_contents_id_seq TO bytedevs;


--
-- Name: TABLE kiosk_fact; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.kiosk_fact TO bytedevs;


--
-- Name: SEQUENCE kiosk_fact_id_seq; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON SEQUENCE mixalot.kiosk_fact_id_seq TO bytedevs;


--
-- Name: TABLE kiosk_restriction; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.kiosk_restriction TO bytedevs;


--
-- Name: TABLE request_log; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT SELECT ON TABLE mixalot.request_log TO requestlogs;
GRANT ALL ON TABLE mixalot.request_log TO bytedevs;


--
-- Name: TABLE kiosk_status; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.kiosk_status TO bytedevs;


--
-- Name: TABLE last_kiosk_status; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.last_kiosk_status TO bytedevs;


--
-- Name: TABLE tmp_unit; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.tmp_unit TO bytedevs;


--
-- Name: SEQUENCE lineitem_id_seq; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON SEQUENCE mixalot.lineitem_id_seq TO bytedevs;


--
-- Name: TABLE log; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.log TO bytedevs;


--
-- Name: SEQUENCE log_id_seq; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON SEQUENCE mixalot.log_id_seq TO bytedevs;


--
-- Name: TABLE merchandising_slot; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.merchandising_slot TO bytedevs;


--
-- Name: TABLE merchandising_slot_def; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.merchandising_slot_def TO bytedevs;


--
-- Name: SEQUENCE merchandising_slot_def_id_seq; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON SEQUENCE mixalot.merchandising_slot_def_id_seq TO bytedevs;


--
-- Name: SEQUENCE merchandising_slot_id_seq; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON SEQUENCE mixalot.merchandising_slot_id_seq TO bytedevs;


--
-- Name: TABLE order_fact; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.order_fact TO bytedevs;


--
-- Name: SEQUENCE order_fact_id_seq; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON SEQUENCE mixalot.order_fact_id_seq TO bytedevs;


--
-- Name: TABLE pgdu_bytes; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.pgdu_bytes TO bytedevs;


--
-- Name: TABLE pgdu; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.pgdu TO bytedevs;


--
-- Name: TABLE pick; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.pick TO bytedevs;


--
-- Name: TABLE pick_preference_kiosk_sku; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.pick_preference_kiosk_sku TO bytedevs;


--
-- Name: TABLE pick_priority_kiosk; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.pick_priority_kiosk TO bytedevs;


--
-- Name: TABLE pick_priority_sku; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.pick_priority_sku TO bytedevs;


--
-- Name: TABLE product_fact; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.product_fact TO bytedevs;


--
-- Name: SEQUENCE product_fact_id_seq; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON SEQUENCE mixalot.product_fact_id_seq TO bytedevs;


--
-- Name: TABLE product_kiosk_fact; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.product_kiosk_fact TO bytedevs;


--
-- Name: SEQUENCE product_kiosk_fact_id_seq; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON SEQUENCE mixalot.product_kiosk_fact_id_seq TO bytedevs;


--
-- Name: TABLE route; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.route TO bytedevs;


--
-- Name: TABLE server; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.server TO bytedevs;


--
-- Name: SEQUENCE server_id_seq; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON SEQUENCE mixalot.server_id_seq TO bytedevs;


--
-- Name: SEQUENCE sku_attribute_def_id_seq; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON SEQUENCE mixalot.sku_attribute_def_id_seq TO bytedevs;


--
-- Name: TABLE sku_group; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.sku_group TO bytedevs;


--
-- Name: SEQUENCE sku_group_def_id_seq; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON SEQUENCE mixalot.sku_group_def_id_seq TO bytedevs;


--
-- Name: SEQUENCE sku_group_id_seq; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON SEQUENCE mixalot.sku_group_id_seq TO bytedevs;


--
-- Name: TABLE sku_group_member; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.sku_group_member TO bytedevs;


--
-- Name: SEQUENCE sku_group_member_id_seq; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON SEQUENCE mixalot.sku_group_member_id_seq TO bytedevs;


--
-- Name: TABLE tally; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.tally TO bytedevs;


--
-- Name: TABLE temp_kiosk_restriction; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.temp_kiosk_restriction TO bytedevs;


--
-- Name: TABLE temp_ms_to_sg; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.temp_ms_to_sg TO bytedevs;


--
-- Name: TABLE temp_sku_group_volume; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.temp_sku_group_volume TO bytedevs;


--
-- Name: TABLE temp_sku_to_skugroup; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.temp_sku_to_skugroup TO bytedevs;


--
-- Name: TABLE temp_test; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.temp_test TO bytedevs;


--
-- Name: SEQUENCE temp_test_id_seq; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON SEQUENCE mixalot.temp_test_id_seq TO bytedevs;


--
-- Name: TABLE test_time; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.test_time TO bytedevs;


--
-- Name: SEQUENCE test_time_id_seq; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON SEQUENCE mixalot.test_time_id_seq TO bytedevs;


--
-- Name: TABLE tmp_discount_applied; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.tmp_discount_applied TO bytedevs;


--
-- Name: SEQUENCE tmp_discount_applied_id_seq; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON SEQUENCE mixalot.tmp_discount_applied_id_seq TO bytedevs;


--
-- Name: TABLE tmp_kiosk_status; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.tmp_kiosk_status TO bytedevs;


--
-- Name: SEQUENCE tmp_kiosk_status_id_seq; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON SEQUENCE mixalot.tmp_kiosk_status_id_seq TO bytedevs;


--
-- Name: TABLE tmp_transact; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.tmp_transact TO bytedevs;


--
-- Name: TABLE v_kiosk_request_log; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.v_kiosk_request_log TO bytedevs;


--
-- Name: TABLE v_kiosk_inventory_log; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.v_kiosk_inventory_log TO bytedevs;


--
-- Name: TABLE v_kiosk_item_log; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.v_kiosk_item_log TO bytedevs;


--
-- Name: TABLE v_kiosk_status_log; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.v_kiosk_status_log TO bytedevs;


--
-- Name: TABLE v_node_kiosk_request_log; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.v_node_kiosk_request_log TO bytedevs;


--
-- Name: TABLE v_node_kiosk_status_log; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.v_node_kiosk_status_log TO bytedevs;


--
-- Name: TABLE warehouse_order_history; Type: ACL; Schema: mixalot; Owner: dbservice
--

GRANT ALL ON TABLE mixalot.warehouse_order_history TO bytedevs;


--
-- Name: TABLE kiosk_status; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.kiosk_status TO pantry_web_user;
GRANT ALL ON TABLE pantry.kiosk_status TO bytedevs;


--
-- Name: TABLE accounting; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.accounting TO pantry_web_user;
GRANT ALL ON TABLE pantry.accounting TO bytedevs;


--
-- Name: SEQUENCE accounting_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.accounting_id_seq TO pantry_web_user;
GRANT ALL ON SEQUENCE pantry.accounting_id_seq TO bytedevs;


--
-- Name: TABLE bad_timestamp; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.bad_timestamp TO pantry_web_user;
GRANT ALL ON TABLE pantry.bad_timestamp TO bytedevs;


--
-- Name: SEQUENCE bad_timestamp_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.bad_timestamp_id_seq TO pantry_web_user;
GRANT ALL ON SEQUENCE pantry.bad_timestamp_id_seq TO bytedevs;


--
-- Name: TABLE campus; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.campus TO pantry_web_user;
GRANT ALL ON TABLE pantry.campus TO bytedevs;


--
-- Name: TABLE campus_assets; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.campus_assets TO pantry_web_user;
GRANT ALL ON TABLE pantry.campus_assets TO bytedevs;


--
-- Name: TABLE campus_attribute; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.campus_attribute TO pantry_web_user;
GRANT ALL ON TABLE pantry.campus_attribute TO bytedevs;


--
-- Name: SEQUENCE campus_attribute_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.campus_attribute_id_seq TO pantry_web_user;


--
-- Name: SEQUENCE campus_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.campus_id_seq TO pantry_web_user;
GRANT ALL ON SEQUENCE pantry.campus_id_seq TO bytedevs;


--
-- Name: TABLE card; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.card TO pantry_web_user;
GRANT ALL ON TABLE pantry.card TO bytedevs;


--
-- Name: SEQUENCE card_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.card_id_seq TO pantry_web_user;
GRANT ALL ON SEQUENCE pantry.card_id_seq TO bytedevs;


--
-- Name: TABLE kiosk_components_history; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.kiosk_components_history TO pantry_web_user;
GRANT ALL ON TABLE pantry.kiosk_components_history TO bytedevs;


--
-- Name: SEQUENCE component_history_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.component_history_id_seq TO pantry_web_user;
GRANT ALL ON SEQUENCE pantry.component_history_id_seq TO bytedevs;


--
-- Name: TABLE contract; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.contract TO pantry_web_user;
GRANT ALL ON TABLE pantry.contract TO bytedevs;


--
-- Name: SEQUENCE contract_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.contract_id_seq TO pantry_web_user;
GRANT ALL ON SEQUENCE pantry.contract_id_seq TO bytedevs;


--
-- Name: TABLE coupon; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.coupon TO pantry_web_user;
GRANT ALL ON TABLE pantry.coupon TO bytedevs;


--
-- Name: SEQUENCE coupon_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.coupon_id_seq TO pantry_web_user;
GRANT ALL ON SEQUENCE pantry.coupon_id_seq TO bytedevs;


--
-- Name: TABLE cron; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.cron TO pantry_web_user;
GRANT ALL ON TABLE pantry.cron TO bytedevs;


--
-- Name: SEQUENCE cron_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.cron_id_seq TO pantry_web_user;
GRANT ALL ON SEQUENCE pantry.cron_id_seq TO bytedevs;


--
-- Name: TABLE currency_symbol; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.currency_symbol TO pantry_web_user;
GRANT ALL ON TABLE pantry.currency_symbol TO bytedevs;


--
-- Name: SEQUENCE currency_symbol_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.currency_symbol_id_seq TO pantry_web_user;


--
-- Name: TABLE current_label_status_365days; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.current_label_status_365days TO pantry_web_user;
GRANT ALL ON TABLE pantry.current_label_status_365days TO bytedevs;


--
-- Name: TABLE dc_inventory; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.dc_inventory TO pantry_web_user;
GRANT ALL ON TABLE pantry.dc_inventory TO bytedevs;


--
-- Name: TABLE delivery_schedule; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.delivery_schedule TO pantry_web_user;
GRANT ALL ON TABLE pantry.delivery_schedule TO bytedevs;


--
-- Name: SEQUENCE delivery_schedule_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.delivery_schedule_id_seq TO pantry_web_user;
GRANT ALL ON SEQUENCE pantry.delivery_schedule_id_seq TO bytedevs;


--
-- Name: TABLE discount; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.discount TO pantry_web_user;
GRANT ALL ON TABLE pantry.discount TO bytedevs;


--
-- Name: TABLE discount_applied; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.discount_applied TO pantry_web_user;
GRANT ALL ON TABLE pantry.discount_applied TO bytedevs;


--
-- Name: SEQUENCE discount_applied_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.discount_applied_id_seq TO pantry_web_user;
GRANT ALL ON SEQUENCE pantry.discount_applied_id_seq TO bytedevs;


--
-- Name: TABLE discount_history; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.discount_history TO pantry_web_user;
GRANT ALL ON TABLE pantry.discount_history TO bytedevs;


--
-- Name: SEQUENCE discount_history_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.discount_history_id_seq TO pantry_web_user;
GRANT ALL ON SEQUENCE pantry.discount_history_id_seq TO bytedevs;


--
-- Name: SEQUENCE discount_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.discount_id_seq TO pantry_web_user;
GRANT ALL ON SEQUENCE pantry.discount_id_seq TO bytedevs;


--
-- Name: TABLE email; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.email TO pantry_web_user;
GRANT ALL ON TABLE pantry.email TO bytedevs;


--
-- Name: SEQUENCE email_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.email_id_seq TO pantry_web_user;
GRANT ALL ON SEQUENCE pantry.email_id_seq TO bytedevs;


--
-- Name: TABLE empty_transaction; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.empty_transaction TO pantry_web_user;
GRANT ALL ON TABLE pantry.empty_transaction TO bytedevs;


--
-- Name: SEQUENCE empty_transaction_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.empty_transaction_id_seq TO pantry_web_user;
GRANT ALL ON SEQUENCE pantry.empty_transaction_id_seq TO bytedevs;


--
-- Name: TABLE event; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.event TO pantry_web_user;
GRANT ALL ON TABLE pantry.event TO bytedevs;


--
-- Name: SEQUENCE event_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.event_id_seq TO pantry_web_user;
GRANT ALL ON SEQUENCE pantry.event_id_seq TO bytedevs;


--
-- Name: SEQUENCE facing_category_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.facing_category_id_seq TO pantry_web_user;
GRANT ALL ON SEQUENCE pantry.facing_category_id_seq TO bytedevs;


--
-- Name: TABLE fee_rates; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.fee_rates TO pantry_web_user;
GRANT ALL ON TABLE pantry.fee_rates TO bytedevs;


--
-- Name: SEQUENCE fee_rates_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.fee_rates_id_seq TO pantry_web_user;
GRANT ALL ON SEQUENCE pantry.fee_rates_id_seq TO bytedevs;


--
-- Name: TABLE feedback; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.feedback TO pantry_web_user;
GRANT ALL ON TABLE pantry.feedback TO bytedevs;


--
-- Name: SEQUENCE feedback_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.feedback_id_seq TO pantry_web_user;
GRANT ALL ON SEQUENCE pantry.feedback_id_seq TO bytedevs;


--
-- Name: TABLE global_attribute_def; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.global_attribute_def TO pantry_web_user;
GRANT ALL ON TABLE pantry.global_attribute_def TO bytedevs;


--
-- Name: SEQUENCE global_attribute_def_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.global_attribute_def_id_seq TO pantry_web_user;


--
-- Name: TABLE "group"; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry."group" TO pantry_web_user;
GRANT ALL ON TABLE pantry."group" TO bytedevs;


--
-- Name: TABLE group_campus; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.group_campus TO pantry_web_user;
GRANT ALL ON TABLE pantry.group_campus TO bytedevs;


--
-- Name: SEQUENCE group_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.group_id_seq TO pantry_web_user;
GRANT ALL ON SEQUENCE pantry.group_id_seq TO bytedevs;


--
-- Name: TABLE history; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.history TO pantry_web_user;
GRANT ALL ON TABLE pantry.history TO bytedevs;


--
-- Name: TABLE history_campus_attribute; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.history_campus_attribute TO pantry_web_user;
GRANT ALL ON TABLE pantry.history_campus_attribute TO bytedevs;


--
-- Name: SEQUENCE history_campus_attribute_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.history_campus_attribute_id_seq TO pantry_web_user;


--
-- Name: TABLE history_epc_order; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.history_epc_order TO pantry_web_user;
GRANT ALL ON TABLE pantry.history_epc_order TO bytedevs;


--
-- Name: SEQUENCE history_epc_order_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.history_epc_order_id_seq TO pantry_web_user;
GRANT ALL ON SEQUENCE pantry.history_epc_order_id_seq TO bytedevs;


--
-- Name: TABLE history_global_attribute_def; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.history_global_attribute_def TO pantry_web_user;
GRANT ALL ON TABLE pantry.history_global_attribute_def TO bytedevs;


--
-- Name: SEQUENCE history_global_attribute_def_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.history_global_attribute_def_id_seq TO pantry_web_user;


--
-- Name: SEQUENCE history_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.history_id_seq TO pantry_web_user;
GRANT ALL ON SEQUENCE pantry.history_id_seq TO bytedevs;


--
-- Name: TABLE history_kiosk_attribute; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.history_kiosk_attribute TO pantry_web_user;
GRANT ALL ON TABLE pantry.history_kiosk_attribute TO bytedevs;


--
-- Name: SEQUENCE history_kiosk_attribute_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.history_kiosk_attribute_id_seq TO pantry_web_user;


--
-- Name: TABLE history_kiosk_device; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.history_kiosk_device TO pantry_web_user;
GRANT ALL ON TABLE pantry.history_kiosk_device TO bytedevs;


--
-- Name: SEQUENCE history_kiosk_device_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.history_kiosk_device_id_seq TO pantry_web_user;


--
-- Name: TABLE history_kiosk_service_version; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.history_kiosk_service_version TO pantry_web_user;
GRANT ALL ON TABLE pantry.history_kiosk_service_version TO bytedevs;


--
-- Name: SEQUENCE history_kiosk_service_version_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.history_kiosk_service_version_id_seq TO pantry_web_user;


--
-- Name: TABLE inventory_history; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.inventory_history TO pantry_web_user;
GRANT ALL ON TABLE pantry.inventory_history TO bytedevs;


--
-- Name: SEQUENCE inventory_history_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.inventory_history_id_seq TO pantry_web_user;
GRANT ALL ON SEQUENCE pantry.inventory_history_id_seq TO bytedevs;


--
-- Name: TABLE inventory_request; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.inventory_request TO pantry_web_user;
GRANT ALL ON TABLE pantry.inventory_request TO bytedevs;


--
-- Name: SEQUENCE inventory_request_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.inventory_request_id_seq TO pantry_web_user;
GRANT ALL ON SEQUENCE pantry.inventory_request_id_seq TO bytedevs;


--
-- Name: TABLE kiosk_attribute; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.kiosk_attribute TO pantry_web_user;
GRANT ALL ON TABLE pantry.kiosk_attribute TO bytedevs;


--
-- Name: SEQUENCE kiosk_attribute_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.kiosk_attribute_id_seq TO pantry_web_user;


--
-- Name: TABLE kiosk_audit_log; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.kiosk_audit_log TO pantry_web_user;
GRANT ALL ON TABLE pantry.kiosk_audit_log TO bytedevs;


--
-- Name: SEQUENCE kiosk_audit_log_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.kiosk_audit_log_id_seq TO pantry_web_user;
GRANT ALL ON SEQUENCE pantry.kiosk_audit_log_id_seq TO bytedevs;


--
-- Name: TABLE kiosk_catalog_downloads; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.kiosk_catalog_downloads TO pantry_web_user;
GRANT ALL ON TABLE pantry.kiosk_catalog_downloads TO bytedevs;


--
-- Name: SEQUENCE kiosk_catalog_downloads_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.kiosk_catalog_downloads_id_seq TO pantry_web_user;
GRANT ALL ON SEQUENCE pantry.kiosk_catalog_downloads_id_seq TO bytedevs;


--
-- Name: SEQUENCE kiosk_cd_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.kiosk_cd_id_seq TO pantry_web_user;
GRANT ALL ON SEQUENCE pantry.kiosk_cd_id_seq TO bytedevs;


--
-- Name: SEQUENCE kiosk_components_history_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.kiosk_components_history_id_seq TO pantry_web_user;
GRANT ALL ON SEQUENCE pantry.kiosk_components_history_id_seq TO bytedevs;


--
-- Name: TABLE kiosk_device; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.kiosk_device TO pantry_web_user;
GRANT ALL ON TABLE pantry.kiosk_device TO bytedevs;


--
-- Name: SEQUENCE kiosk_device_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.kiosk_device_id_seq TO pantry_web_user;


--
-- Name: SEQUENCE kiosk_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.kiosk_id_seq TO pantry_web_user;
GRANT ALL ON SEQUENCE pantry.kiosk_id_seq TO bytedevs;


--
-- Name: TABLE kiosk_par_level; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.kiosk_par_level TO pantry_web_user;
GRANT ALL ON TABLE pantry.kiosk_par_level TO bytedevs;


--
-- Name: TABLE kiosk_service_version; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.kiosk_service_version TO pantry_web_user;
GRANT ALL ON TABLE pantry.kiosk_service_version TO bytedevs;


--
-- Name: SEQUENCE kiosk_status_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.kiosk_status_id_seq TO pantry_web_user;
GRANT ALL ON SEQUENCE pantry.kiosk_status_id_seq TO bytedevs;


--
-- Name: TABLE kiosks_date_non_new; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.kiosks_date_non_new TO pantry_web_user;
GRANT ALL ON TABLE pantry.kiosks_date_non_new TO bytedevs;


--
-- Name: SEQUENCE kiosks_date_non_new_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.kiosks_date_non_new_id_seq TO pantry_web_user;
GRANT ALL ON SEQUENCE pantry.kiosks_date_non_new_id_seq TO bytedevs;


--
-- Name: SEQUENCE label_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.label_id_seq TO pantry_web_user;
GRANT ALL ON SEQUENCE pantry.label_id_seq TO bytedevs;


--
-- Name: TABLE label_order; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.label_order TO pantry_web_user;
GRANT ALL ON TABLE pantry.label_order TO bytedevs;


--
-- Name: SEQUENCE label_order_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.label_order_id_seq TO pantry_web_user;
GRANT ALL ON SEQUENCE pantry.label_order_id_seq TO bytedevs;


--
-- Name: TABLE label_stats; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.label_stats TO pantry_web_user;
GRANT ALL ON TABLE pantry.label_stats TO bytedevs;


--
-- Name: TABLE last_kiosk_status; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.last_kiosk_status TO pantry_web_user;
GRANT ALL ON TABLE pantry.last_kiosk_status TO bytedevs;


--
-- Name: SEQUENCE last_kiosk_status_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.last_kiosk_status_id_seq TO pantry_web_user;
GRANT ALL ON SEQUENCE pantry.last_kiosk_status_id_seq TO bytedevs;


--
-- Name: TABLE manual_adjustment; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.manual_adjustment TO pantry_web_user;
GRANT ALL ON TABLE pantry.manual_adjustment TO bytedevs;


--
-- Name: SEQUENCE manual_adjustment_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.manual_adjustment_id_seq TO pantry_web_user;
GRANT ALL ON SEQUENCE pantry.manual_adjustment_id_seq TO bytedevs;


--
-- Name: TABLE nutrition_filter; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.nutrition_filter TO pantry_web_user;
GRANT ALL ON TABLE pantry.nutrition_filter TO bytedevs;


--
-- Name: SEQUENCE nutrition_filter_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.nutrition_filter_id_seq TO pantry_web_user;
GRANT ALL ON SEQUENCE pantry.nutrition_filter_id_seq TO bytedevs;


--
-- Name: TABLE order_meta; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.order_meta TO pantry_web_user;
GRANT ALL ON TABLE pantry.order_meta TO bytedevs;


--
-- Name: SEQUENCE order_meta_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.order_meta_id_seq TO pantry_web_user;


--
-- Name: TABLE par_history; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.par_history TO pantry_web_user;
GRANT ALL ON TABLE pantry.par_history TO bytedevs;


--
-- Name: SEQUENCE par_history_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.par_history_id_seq TO pantry_web_user;
GRANT ALL ON SEQUENCE pantry.par_history_id_seq TO bytedevs;


--
-- Name: TABLE payment_order; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.payment_order TO pantry_web_user;
GRANT ALL ON TABLE pantry.payment_order TO bytedevs;


--
-- Name: SEQUENCE payment_order_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.payment_order_id_seq TO bytedevs;


--
-- Name: TABLE payment_order_nursing; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.payment_order_nursing TO pantry_web_user;
GRANT ALL ON TABLE pantry.payment_order_nursing TO bytedevs;


--
-- Name: TABLE permission; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.permission TO pantry_web_user;
GRANT ALL ON TABLE pantry.permission TO bytedevs;


--
-- Name: SEQUENCE permission_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.permission_id_seq TO pantry_web_user;
GRANT ALL ON SEQUENCE pantry.permission_id_seq TO bytedevs;


--
-- Name: TABLE permission_mapping; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.permission_mapping TO pantry_web_user;
GRANT ALL ON TABLE pantry.permission_mapping TO bytedevs;


--
-- Name: TABLE pick_list_row; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.pick_list_row TO pantry_web_user;
GRANT ALL ON TABLE pantry.pick_list_row TO bytedevs;


--
-- Name: SEQUENCE pick_list_row_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.pick_list_row_id_seq TO pantry_web_user;
GRANT ALL ON SEQUENCE pantry.pick_list_row_id_seq TO bytedevs;


--
-- Name: SEQUENCE product_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.product_id_seq TO pantry_web_user;
GRANT ALL ON SEQUENCE pantry.product_id_seq TO bytedevs;


--
-- Name: TABLE product_20190507; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.product_20190507 TO bytedevs;


--
-- Name: TABLE product_categories; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.product_categories TO pantry_web_user;
GRANT ALL ON TABLE pantry.product_categories TO bytedevs;


--
-- Name: SEQUENCE product_categories_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.product_categories_id_seq TO pantry_web_user;
GRANT ALL ON SEQUENCE pantry.product_categories_id_seq TO bytedevs;


--
-- Name: TABLE product_history; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.product_history TO pantry_web_user;
GRANT ALL ON TABLE pantry.product_history TO bytedevs;


--
-- Name: SEQUENCE product_history_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.product_history_id_seq TO pantry_web_user;
GRANT ALL ON SEQUENCE pantry.product_history_id_seq TO bytedevs;


--
-- Name: TABLE product_kiosk_price_offset; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.product_kiosk_price_offset TO pantry_web_user;
GRANT ALL ON TABLE pantry.product_kiosk_price_offset TO bytedevs;


--
-- Name: SEQUENCE product_kiosk_price_offset_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.product_kiosk_price_offset_id_seq TO pantry_web_user;
GRANT ALL ON SEQUENCE pantry.product_kiosk_price_offset_id_seq TO bytedevs;


--
-- Name: TABLE product_request; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.product_request TO pantry_web_user;
GRANT ALL ON TABLE pantry.product_request TO bytedevs;


--
-- Name: SEQUENCE product_request_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.product_request_id_seq TO pantry_web_user;
GRANT ALL ON SEQUENCE pantry.product_request_id_seq TO bytedevs;


--
-- Name: TABLE product_stats_by_kiosk; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.product_stats_by_kiosk TO pantry_web_user;
GRANT ALL ON TABLE pantry.product_stats_by_kiosk TO bytedevs;


--
-- Name: TABLE recent_transactions; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.recent_transactions TO pantry_web_user;
GRANT ALL ON TABLE pantry.recent_transactions TO bytedevs;


--
-- Name: TABLE refunds; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.refunds TO pantry_web_user;
GRANT ALL ON TABLE pantry.refunds TO bytedevs;


--
-- Name: TABLE restock_item; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.restock_item TO pantry_web_user;
GRANT ALL ON TABLE pantry.restock_item TO bytedevs;


--
-- Name: SEQUENCE restock_item_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.restock_item_id_seq TO pantry_web_user;
GRANT ALL ON SEQUENCE pantry.restock_item_id_seq TO bytedevs;


--
-- Name: TABLE ro_order; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.ro_order TO pantry_web_user;
GRANT ALL ON TABLE pantry.ro_order TO bytedevs;


--
-- Name: TABLE role; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.role TO pantry_web_user;
GRANT ALL ON TABLE pantry.role TO bytedevs;


--
-- Name: SEQUENCE role_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.role_id_seq TO pantry_web_user;
GRANT ALL ON SEQUENCE pantry.role_id_seq TO bytedevs;


--
-- Name: TABLE role_mapping; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.role_mapping TO pantry_web_user;
GRANT ALL ON TABLE pantry.role_mapping TO bytedevs;


--
-- Name: TABLE running_service; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.running_service TO pantry_web_user;
GRANT ALL ON TABLE pantry.running_service TO bytedevs;


--
-- Name: TABLE spoilage; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.spoilage TO pantry_web_user;
GRANT ALL ON TABLE pantry.spoilage TO bytedevs;


--
-- Name: SEQUENCE spoilage_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.spoilage_id_seq TO pantry_web_user;
GRANT ALL ON SEQUENCE pantry.spoilage_id_seq TO bytedevs;


--
-- Name: TABLE stockout; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.stockout TO pantry_web_user;
GRANT ALL ON TABLE pantry.stockout TO bytedevs;


--
-- Name: SEQUENCE stockout_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.stockout_id_seq TO pantry_web_user;
GRANT ALL ON SEQUENCE pantry.stockout_id_seq TO bytedevs;


--
-- Name: TABLE tag; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.tag TO pantry_web_user;
GRANT ALL ON TABLE pantry.tag TO bytedevs;


--
-- Name: SEQUENCE tag_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.tag_id_seq TO pantry_web_user;
GRANT ALL ON SEQUENCE pantry.tag_id_seq TO bytedevs;


--
-- Name: TABLE temp_kiosk_backup; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.temp_kiosk_backup TO pantry_web_user;
GRANT ALL ON TABLE pantry.temp_kiosk_backup TO bytedevs;


--
-- Name: TABLE temp_product_backup; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.temp_product_backup TO pantry_web_user;
GRANT ALL ON TABLE pantry.temp_product_backup TO bytedevs;


--
-- Name: TABLE temperature_tag_history; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.temperature_tag_history TO pantry_web_user;
GRANT ALL ON TABLE pantry.temperature_tag_history TO bytedevs;


--
-- Name: SEQUENCE temperature_tag_history_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.temperature_tag_history_id_seq TO pantry_web_user;
GRANT ALL ON SEQUENCE pantry.temperature_tag_history_id_seq TO bytedevs;


--
-- Name: TABLE tmp_april23_error_order_fixes; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.tmp_april23_error_order_fixes TO bytedevs;


--
-- Name: TABLE tmp_backup_order_before_05_03_process_will; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.tmp_backup_order_before_05_03_process_will TO bytedevs;


--
-- Name: TABLE tmp_cards_to_update; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.tmp_cards_to_update TO pantry_web_user;
GRANT ALL ON TABLE pantry.tmp_cards_to_update TO bytedevs;


--
-- Name: TABLE tmp_eng_3692; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.tmp_eng_3692 TO pantry_web_user;
GRANT ALL ON TABLE pantry.tmp_eng_3692 TO bytedevs;


--
-- Name: TABLE tmp_eng_495_cards_to_update; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.tmp_eng_495_cards_to_update TO pantry_web_user;
GRANT ALL ON TABLE pantry.tmp_eng_495_cards_to_update TO bytedevs;


--
-- Name: TABLE tmp_march1_rollingback_auths; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.tmp_march1_rollingback_auths TO pantry_web_user;
GRANT ALL ON TABLE pantry.tmp_march1_rollingback_auths TO bytedevs;


--
-- Name: TABLE tmp_may4_error_order_fixes; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.tmp_may4_error_order_fixes TO bytedevs;


--
-- Name: TABLE tmp_may4_pricefinalize_order_fixes; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.tmp_may4_pricefinalize_order_fixes TO bytedevs;


--
-- Name: TABLE tmp_order_eng_1915; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.tmp_order_eng_1915 TO bytedevs;


--
-- Name: TABLE tmp_order_may_6_preapr23; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.tmp_order_may_6_preapr23 TO bytedevs;


--
-- Name: TABLE tmp_order_transaction_id_map; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.tmp_order_transaction_id_map TO bytedevs;


--
-- Name: TABLE tmp_orderstoerror; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.tmp_orderstoerror TO pantry_web_user;
GRANT ALL ON TABLE pantry.tmp_orderstoerror TO bytedevs;


--
-- Name: TABLE tmp_payment_order; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.tmp_payment_order TO bytedevs;


--
-- Name: TABLE tmp_payment_order_with_id; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.tmp_payment_order_with_id TO bytedevs;


--
-- Name: SEQUENCE tmp_payment_order_with_id_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.tmp_payment_order_with_id_id_seq TO bytedevs;


--
-- Name: TABLE tmp_price_finalized_order_ids; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.tmp_price_finalized_order_ids TO bytedevs;


--
-- Name: TABLE tmp_process_order_txt; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.tmp_process_order_txt TO bytedevs;


--
-- Name: TABLE tmp_process_order; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.tmp_process_order TO bytedevs;


--
-- Name: SEQUENCE tmp_process_order_txt_d_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.tmp_process_order_txt_d_seq TO bytedevs;


--
-- Name: TABLE tmp_process_order_vantiv; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.tmp_process_order_vantiv TO bytedevs;


--
-- Name: SEQUENCE tmp_process_order_vantiv_d_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.tmp_process_order_vantiv_d_seq TO bytedevs;


--
-- Name: TABLE tmp_revert_order_status; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.tmp_revert_order_status TO bytedevs;


--
-- Name: TABLE tmp_watcher; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.tmp_watcher TO pantry_web_user;
GRANT ALL ON TABLE pantry.tmp_watcher TO bytedevs;


--
-- Name: TABLE transact_comp; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.transact_comp TO pantry_web_user;
GRANT ALL ON TABLE pantry.transact_comp TO bytedevs;


--
-- Name: SEQUENCE transact_comp_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.transact_comp_id_seq TO pantry_web_user;
GRANT ALL ON SEQUENCE pantry.transact_comp_id_seq TO bytedevs;


--
-- Name: TABLE transact_express; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.transact_express TO pantry_web_user;
GRANT ALL ON TABLE pantry.transact_express TO bytedevs;


--
-- Name: SEQUENCE transact_express_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.transact_express_id_seq TO pantry_web_user;
GRANT ALL ON SEQUENCE pantry.transact_express_id_seq TO bytedevs;


--
-- Name: TABLE transact_fp; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.transact_fp TO pantry_web_user;
GRANT ALL ON TABLE pantry.transact_fp TO bytedevs;


--
-- Name: SEQUENCE transact_fp_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.transact_fp_id_seq TO pantry_web_user;
GRANT ALL ON SEQUENCE pantry.transact_fp_id_seq TO bytedevs;


--
-- Name: TABLE transact_ipc; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry.transact_ipc TO pantry_web_user;
GRANT ALL ON TABLE pantry.transact_ipc TO bytedevs;


--
-- Name: SEQUENCE transact_ipc_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.transact_ipc_id_seq TO pantry_web_user;
GRANT ALL ON SEQUENCE pantry.transact_ipc_id_seq TO bytedevs;


--
-- Name: TABLE "user"; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON TABLE pantry."user" TO pantry_web_user;
GRANT ALL ON TABLE pantry."user" TO bytedevs;


--
-- Name: SEQUENCE user_id_seq; Type: ACL; Schema: pantry; Owner: dbservice
--

GRANT ALL ON SEQUENCE pantry.user_id_seq TO pantry_web_user;
GRANT ALL ON SEQUENCE pantry.user_id_seq TO bytedevs;


--
-- Name: TABLE awsdms_apply_exceptions; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.awsdms_apply_exceptions TO pantry_web_user;


--
-- Name: TABLE awsdms_ddl_audit; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.awsdms_ddl_audit TO pantry_web_user;


--
-- Name: SEQUENCE awsdms_ddl_audit_c_key_seq; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON SEQUENCE public.awsdms_ddl_audit_c_key_seq TO pantry_web_user;


--
-- Name: TABLE awsdms_heartbeat; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.awsdms_heartbeat TO pantry_web_user;


--
-- Name: SEQUENCE awsdms_heartbeat_hb_key_seq; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON SEQUENCE public.awsdms_heartbeat_hb_key_seq TO pantry_web_user;


--
-- Name: TABLE awsdms_history; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.awsdms_history TO pantry_web_user;


--
-- Name: TABLE awsdms_status; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.awsdms_status TO pantry_web_user;


--
-- Name: TABLE awsdms_suspended_tables; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.awsdms_suspended_tables TO pantry_web_user;


--
-- Name: TABLE awsdms_validation_failures_v1; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.awsdms_validation_failures_v1 TO pantry_web_user;


--
-- Name: TABLE byte_tickets_120days; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_tickets_120days TO bytedevs;
GRANT ALL ON TABLE public.byte_tickets_120days TO pantry_web_user;


--
-- Name: TABLE byte_epcssold_120days; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_epcssold_120days TO bytedevs;
GRANT ALL ON TABLE public.byte_epcssold_120days TO pantry_web_user;


--
-- Name: TABLE byte_addicted_users_120days; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_addicted_users_120days TO bytedevs;
GRANT ALL ON TABLE public.byte_addicted_users_120days TO pantry_web_user;


--
-- Name: TABLE iplanner_inventory; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.iplanner_inventory TO pantry_web_user;


--
-- Name: TABLE byte_dc_inventory_history; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_dc_inventory_history TO pantry_web_user;


--
-- Name: TABLE byte_epcssold; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_epcssold TO bytedevs;
GRANT ALL ON TABLE public.byte_epcssold TO pantry_web_user;


--
-- Name: TABLE byte_tickets_10weeks; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_tickets_10weeks TO bytedevs;
GRANT ALL ON TABLE public.byte_tickets_10weeks TO pantry_web_user;


--
-- Name: TABLE byte_epcssold_10weeks; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_epcssold_10weeks TO bytedevs;
GRANT ALL ON TABLE public.byte_epcssold_10weeks TO pantry_web_user;


--
-- Name: TABLE byte_tickets_12months; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_tickets_12months TO bytedevs;
GRANT ALL ON TABLE public.byte_tickets_12months TO pantry_web_user;


--
-- Name: TABLE byte_epcssold_12months; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_epcssold_12months TO bytedevs;
GRANT ALL ON TABLE public.byte_epcssold_12months TO pantry_web_user;


--
-- Name: TABLE byte_tickets_180days; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_tickets_180days TO bytedevs;
GRANT ALL ON TABLE public.byte_tickets_180days TO pantry_web_user;


--
-- Name: TABLE byte_epcssold_180days; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_epcssold_180days TO bytedevs;
GRANT ALL ON TABLE public.byte_epcssold_180days TO pantry_web_user;


--
-- Name: TABLE byte_tickets_1day; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_tickets_1day TO bytedevs;
GRANT ALL ON TABLE public.byte_tickets_1day TO pantry_web_user;


--
-- Name: TABLE byte_epcssold_1day; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_epcssold_1day TO bytedevs;
GRANT ALL ON TABLE public.byte_epcssold_1day TO pantry_web_user;


--
-- Name: TABLE byte_tickets_1month; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_tickets_1month TO bytedevs;
GRANT ALL ON TABLE public.byte_tickets_1month TO pantry_web_user;


--
-- Name: TABLE byte_epcssold_1month; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_epcssold_1month TO bytedevs;
GRANT ALL ON TABLE public.byte_epcssold_1month TO pantry_web_user;


--
-- Name: TABLE byte_tickets_1week; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_tickets_1week TO bytedevs;
GRANT ALL ON TABLE public.byte_tickets_1week TO pantry_web_user;


--
-- Name: TABLE byte_epcssold_1week; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_epcssold_1week TO bytedevs;
GRANT ALL ON TABLE public.byte_epcssold_1week TO pantry_web_user;


--
-- Name: TABLE byte_tickets_1year; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_tickets_1year TO bytedevs;
GRANT ALL ON TABLE public.byte_tickets_1year TO pantry_web_user;


--
-- Name: TABLE byte_epcssold_1year; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_epcssold_1year TO bytedevs;
GRANT ALL ON TABLE public.byte_epcssold_1year TO pantry_web_user;


--
-- Name: TABLE byte_tickets_2015; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_tickets_2015 TO bytedevs;
GRANT ALL ON TABLE public.byte_tickets_2015 TO pantry_web_user;


--
-- Name: TABLE byte_epcssold_2015; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_epcssold_2015 TO bytedevs;
GRANT ALL ON TABLE public.byte_epcssold_2015 TO pantry_web_user;


--
-- Name: TABLE byte_tickets_2016; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_tickets_2016 TO bytedevs;
GRANT ALL ON TABLE public.byte_tickets_2016 TO pantry_web_user;


--
-- Name: TABLE byte_epcssold_2016; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_epcssold_2016 TO bytedevs;
GRANT ALL ON TABLE public.byte_epcssold_2016 TO pantry_web_user;


--
-- Name: TABLE byte_tickets_2017; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_tickets_2017 TO bytedevs;
GRANT ALL ON TABLE public.byte_tickets_2017 TO pantry_web_user;


--
-- Name: TABLE byte_epcssold_2017; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_epcssold_2017 TO bytedevs;
GRANT ALL ON TABLE public.byte_epcssold_2017 TO pantry_web_user;


--
-- Name: TABLE byte_tickets_2days; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_tickets_2days TO bytedevs;
GRANT ALL ON TABLE public.byte_tickets_2days TO pantry_web_user;


--
-- Name: TABLE byte_epcssold_2days; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_epcssold_2days TO bytedevs;
GRANT ALL ON TABLE public.byte_epcssold_2days TO pantry_web_user;


--
-- Name: TABLE byte_tickets_2months; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_tickets_2months TO bytedevs;
GRANT ALL ON TABLE public.byte_tickets_2months TO pantry_web_user;


--
-- Name: TABLE byte_epcssold_2months; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_epcssold_2months TO bytedevs;
GRANT ALL ON TABLE public.byte_epcssold_2months TO pantry_web_user;


--
-- Name: TABLE byte_tickets_2weeks; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_tickets_2weeks TO bytedevs;
GRANT ALL ON TABLE public.byte_tickets_2weeks TO pantry_web_user;


--
-- Name: TABLE byte_epcssold_2weeks; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_epcssold_2weeks TO bytedevs;
GRANT ALL ON TABLE public.byte_epcssold_2weeks TO pantry_web_user;


--
-- Name: TABLE byte_tickets_30days; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_tickets_30days TO bytedevs;
GRANT ALL ON TABLE public.byte_tickets_30days TO pantry_web_user;


--
-- Name: TABLE byte_epcssold_30days; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_epcssold_30days TO bytedevs;
GRANT ALL ON TABLE public.byte_epcssold_30days TO pantry_web_user;


--
-- Name: TABLE byte_tickets_360days; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_tickets_360days TO bytedevs;
GRANT ALL ON TABLE public.byte_tickets_360days TO pantry_web_user;


--
-- Name: TABLE byte_epcssold_360days; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_epcssold_360days TO bytedevs;
GRANT ALL ON TABLE public.byte_epcssold_360days TO pantry_web_user;


--
-- Name: TABLE byte_tickets_365days; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_tickets_365days TO bytedevs;
GRANT ALL ON TABLE public.byte_tickets_365days TO pantry_web_user;


--
-- Name: TABLE byte_epcssold_365days; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_epcssold_365days TO bytedevs;
GRANT ALL ON TABLE public.byte_epcssold_365days TO pantry_web_user;


--
-- Name: TABLE byte_tickets_3days; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_tickets_3days TO bytedevs;
GRANT ALL ON TABLE public.byte_tickets_3days TO pantry_web_user;


--
-- Name: TABLE byte_epcssold_3days; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_epcssold_3days TO bytedevs;
GRANT ALL ON TABLE public.byte_epcssold_3days TO pantry_web_user;


--
-- Name: TABLE byte_tickets_3weeks; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_tickets_3weeks TO bytedevs;
GRANT ALL ON TABLE public.byte_tickets_3weeks TO pantry_web_user;


--
-- Name: TABLE byte_epcssold_3weeks; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_epcssold_3weeks TO bytedevs;
GRANT ALL ON TABLE public.byte_epcssold_3weeks TO pantry_web_user;


--
-- Name: TABLE byte_tickets_45days; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_tickets_45days TO bytedevs;
GRANT ALL ON TABLE public.byte_tickets_45days TO pantry_web_user;


--
-- Name: TABLE byte_epcssold_45days; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_epcssold_45days TO bytedevs;
GRANT ALL ON TABLE public.byte_epcssold_45days TO pantry_web_user;


--
-- Name: TABLE byte_tickets_4days; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_tickets_4days TO bytedevs;
GRANT ALL ON TABLE public.byte_tickets_4days TO pantry_web_user;


--
-- Name: TABLE byte_epcssold_4days; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_epcssold_4days TO bytedevs;
GRANT ALL ON TABLE public.byte_epcssold_4days TO pantry_web_user;


--
-- Name: TABLE byte_tickets_4months; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_tickets_4months TO bytedevs;
GRANT ALL ON TABLE public.byte_tickets_4months TO pantry_web_user;


--
-- Name: TABLE byte_epcssold_4months; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_epcssold_4months TO bytedevs;
GRANT ALL ON TABLE public.byte_epcssold_4months TO pantry_web_user;


--
-- Name: TABLE byte_tickets_4weeks; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_tickets_4weeks TO bytedevs;
GRANT ALL ON TABLE public.byte_tickets_4weeks TO pantry_web_user;


--
-- Name: TABLE byte_epcssold_4weeks; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_epcssold_4weeks TO bytedevs;
GRANT ALL ON TABLE public.byte_epcssold_4weeks TO pantry_web_user;


--
-- Name: TABLE byte_tickets_5days; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_tickets_5days TO bytedevs;
GRANT ALL ON TABLE public.byte_tickets_5days TO pantry_web_user;


--
-- Name: TABLE byte_epcssold_5days; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_epcssold_5days TO bytedevs;
GRANT ALL ON TABLE public.byte_epcssold_5days TO pantry_web_user;


--
-- Name: TABLE byte_tickets_5weeks; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_tickets_5weeks TO bytedevs;
GRANT ALL ON TABLE public.byte_tickets_5weeks TO pantry_web_user;


--
-- Name: TABLE byte_epcssold_5weeks; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_epcssold_5weeks TO bytedevs;
GRANT ALL ON TABLE public.byte_epcssold_5weeks TO pantry_web_user;


--
-- Name: TABLE byte_tickets_60days; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_tickets_60days TO bytedevs;
GRANT ALL ON TABLE public.byte_tickets_60days TO pantry_web_user;


--
-- Name: TABLE byte_epcssold_60days; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_epcssold_60days TO bytedevs;
GRANT ALL ON TABLE public.byte_epcssold_60days TO pantry_web_user;


--
-- Name: TABLE byte_tickets_6days; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_tickets_6days TO bytedevs;
GRANT ALL ON TABLE public.byte_tickets_6days TO pantry_web_user;


--
-- Name: TABLE byte_epcssold_6days; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_epcssold_6days TO bytedevs;
GRANT ALL ON TABLE public.byte_epcssold_6days TO pantry_web_user;


--
-- Name: TABLE byte_tickets_6months; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_tickets_6months TO bytedevs;
GRANT ALL ON TABLE public.byte_tickets_6months TO pantry_web_user;


--
-- Name: TABLE byte_epcssold_6months; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_epcssold_6months TO bytedevs;
GRANT ALL ON TABLE public.byte_epcssold_6months TO pantry_web_user;


--
-- Name: TABLE byte_tickets_6weeks; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_tickets_6weeks TO bytedevs;
GRANT ALL ON TABLE public.byte_tickets_6weeks TO pantry_web_user;


--
-- Name: TABLE byte_epcssold_6weeks; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_epcssold_6weeks TO bytedevs;
GRANT ALL ON TABLE public.byte_epcssold_6weeks TO pantry_web_user;


--
-- Name: TABLE byte_tickets_7days; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_tickets_7days TO bytedevs;
GRANT ALL ON TABLE public.byte_tickets_7days TO pantry_web_user;


--
-- Name: TABLE byte_epcssold_7days; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_epcssold_7days TO bytedevs;
GRANT ALL ON TABLE public.byte_epcssold_7days TO pantry_web_user;


--
-- Name: TABLE byte_tickets_8weeks; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_tickets_8weeks TO bytedevs;
GRANT ALL ON TABLE public.byte_tickets_8weeks TO pantry_web_user;


--
-- Name: TABLE byte_epcssold_8weeks; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_epcssold_8weeks TO bytedevs;
GRANT ALL ON TABLE public.byte_epcssold_8weeks TO pantry_web_user;


--
-- Name: TABLE byte_tickets_90days; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_tickets_90days TO bytedevs;
GRANT ALL ON TABLE public.byte_tickets_90days TO pantry_web_user;


--
-- Name: TABLE byte_epcssold_90days; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_epcssold_90days TO bytedevs;
GRANT ALL ON TABLE public.byte_epcssold_90days TO pantry_web_user;


--
-- Name: TABLE byte_tickets_9months; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_tickets_9months TO bytedevs;
GRANT ALL ON TABLE public.byte_tickets_9months TO pantry_web_user;


--
-- Name: TABLE byte_epcssold_9months; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_epcssold_9months TO bytedevs;
GRANT ALL ON TABLE public.byte_epcssold_9months TO pantry_web_user;


--
-- Name: TABLE byte_epcssold_fast; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_epcssold_fast TO bytedevs;
GRANT ALL ON TABLE public.byte_epcssold_fast TO pantry_web_user;


--
-- Name: TABLE byte_feedback; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_feedback TO bytedevs;
GRANT ALL ON TABLE public.byte_feedback TO pantry_web_user;


--
-- Name: TABLE byte_feedback_monthly; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_feedback_monthly TO bytedevs;
GRANT ALL ON TABLE public.byte_feedback_monthly TO pantry_web_user;


--
-- Name: TABLE byte_feedback_weekly; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_feedback_weekly TO bytedevs;
GRANT ALL ON TABLE public.byte_feedback_weekly TO pantry_web_user;


--
-- Name: TABLE byte_kiosks; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_kiosks TO bytedevs;
GRANT ALL ON TABLE public.byte_kiosks TO pantry_web_user;


--
-- Name: TABLE inventory_current_lots; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.inventory_current_lots TO pantry_web_user;


--
-- Name: TABLE inventory_current; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.inventory_current TO pantry_web_user;


--
-- Name: TABLE byte_inventory_current; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_inventory_current TO bytedevs;
GRANT ALL ON TABLE public.byte_inventory_current TO pantry_web_user;


--
-- Name: TABLE byte_inventory_current_lots; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_inventory_current_lots TO bytedevs;
GRANT ALL ON TABLE public.byte_inventory_current_lots TO pantry_web_user;


--
-- Name: TABLE inventory_history; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.inventory_history TO bytedevs;
GRANT ALL ON TABLE public.inventory_history TO pantry_web_user;


--
-- Name: TABLE byte_inventory_history; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_inventory_history TO bytedevs;
GRANT ALL ON TABLE public.byte_inventory_history TO pantry_web_user;


--
-- Name: TABLE byte_inventory_history_eod; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_inventory_history_eod TO bytedevs;
GRANT ALL ON TABLE public.byte_inventory_history_eod TO pantry_web_user;


--
-- Name: TABLE byte_inventory_history_eod_2wks; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_inventory_history_eod_2wks TO bytedevs;
GRANT ALL ON TABLE public.byte_inventory_history_eod_2wks TO pantry_web_user;


--
-- Name: TABLE byte_kiosks_date_non_new; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_kiosks_date_non_new TO pantry_web_user;


--
-- Name: TABLE byte_restockings; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_restockings TO bytedevs;
GRANT ALL ON TABLE public.byte_restockings TO pantry_web_user;


--
-- Name: TABLE byte_kiosks_by_week; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_kiosks_by_week TO bytedevs;
GRANT ALL ON TABLE public.byte_kiosks_by_week TO pantry_web_user;


--
-- Name: TABLE byte_kiosks_with_perm_subsidy; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_kiosks_with_perm_subsidy TO bytedevs;
GRANT ALL ON TABLE public.byte_kiosks_with_perm_subsidy TO pantry_web_user;


--
-- Name: TABLE byte_kp_grid; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_kp_grid TO pantry_web_user;


--
-- Name: TABLE byte_kp_grid2; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_kp_grid2 TO pantry_web_user;


--
-- Name: TABLE byte_kp_oos; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_kp_oos TO pantry_web_user;


--
-- Name: TABLE byte_kp_oos_avgdowhour; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_kp_oos_avgdowhour TO pantry_web_user;


--
-- Name: TABLE byte_kp_oos_grid; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_kp_oos_grid TO pantry_web_user;


--
-- Name: TABLE byte_kp_sales; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_kp_sales TO pantry_web_user;


--
-- Name: TABLE byte_kp_sales_avgdowhour; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_kp_sales_avgdowhour TO pantry_web_user;


--
-- Name: TABLE byte_kp_sales_first; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_kp_sales_first TO pantry_web_user;


--
-- Name: TABLE byte_kp_sales_grid; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_kp_sales_grid TO pantry_web_user;


--
-- Name: TABLE byte_label_product_fast; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_label_product_fast TO pantry_web_user;


--
-- Name: TABLE byte_product_stats_by_kiosk; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_product_stats_by_kiosk TO bytedevs;
GRANT ALL ON TABLE public.byte_product_stats_by_kiosk TO pantry_web_user;


--
-- Name: TABLE byte_raw_orders; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_raw_orders TO bytedevs;
GRANT ALL ON TABLE public.byte_raw_orders TO pantry_web_user;


--
-- Name: TABLE byte_restockings_labels; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_restockings_labels TO bytedevs;
GRANT ALL ON TABLE public.byte_restockings_labels TO pantry_web_user;


--
-- Name: TABLE byte_sales_by_week; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_sales_by_week TO bytedevs;
GRANT ALL ON TABLE public.byte_sales_by_week TO pantry_web_user;


--
-- Name: TABLE byte_spoilage; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_spoilage TO bytedevs;
GRANT ALL ON TABLE public.byte_spoilage TO pantry_web_user;


--
-- Name: TABLE byte_spoilage_by_category_week_all; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_spoilage_by_category_week_all TO bytedevs;
GRANT ALL ON TABLE public.byte_spoilage_by_category_week_all TO pantry_web_user;


--
-- Name: TABLE byte_spoilage_by_category_week_newold; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_spoilage_by_category_week_newold TO bytedevs;
GRANT ALL ON TABLE public.byte_spoilage_by_category_week_newold TO pantry_web_user;


--
-- Name: TABLE byte_spoilage_by_category_week; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_spoilage_by_category_week TO bytedevs;
GRANT ALL ON TABLE public.byte_spoilage_by_category_week TO pantry_web_user;


--
-- Name: TABLE byte_spoilage_by_category_week_crosstab; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_spoilage_by_category_week_crosstab TO pantry_web_user;


--
-- Name: TABLE byte_spoilage_by_sku_2months; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_spoilage_by_sku_2months TO bytedevs;
GRANT ALL ON TABLE public.byte_spoilage_by_sku_2months TO pantry_web_user;


--
-- Name: TABLE byte_spoilage_by_week; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_spoilage_by_week TO bytedevs;
GRANT ALL ON TABLE public.byte_spoilage_by_week TO pantry_web_user;


--
-- Name: TABLE byte_stockouts; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_stockouts TO bytedevs;
GRANT ALL ON TABLE public.byte_stockouts TO pantry_web_user;


--
-- Name: TABLE byte_stockouts_by_week; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_stockouts_by_week TO bytedevs;
GRANT ALL ON TABLE public.byte_stockouts_by_week TO pantry_web_user;


--
-- Name: TABLE byte_spoilage_stockouts_by_week; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_spoilage_stockouts_by_week TO bytedevs;
GRANT ALL ON TABLE public.byte_spoilage_stockouts_by_week TO pantry_web_user;


--
-- Name: TABLE byte_stockouts_by_category_week_all; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_stockouts_by_category_week_all TO bytedevs;
GRANT ALL ON TABLE public.byte_stockouts_by_category_week_all TO pantry_web_user;


--
-- Name: TABLE byte_stockouts_by_category_week_newold; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_stockouts_by_category_week_newold TO bytedevs;
GRANT ALL ON TABLE public.byte_stockouts_by_category_week_newold TO pantry_web_user;


--
-- Name: TABLE byte_stockouts_by_category_week; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_stockouts_by_category_week TO bytedevs;
GRANT ALL ON TABLE public.byte_stockouts_by_category_week TO pantry_web_user;


--
-- Name: TABLE byte_stockouts_by_category_week_crosstab; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_stockouts_by_category_week_crosstab TO pantry_web_user;


--
-- Name: TABLE byte_tickets_labels; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_tickets_labels TO bytedevs;
GRANT ALL ON TABLE public.byte_tickets_labels TO pantry_web_user;


--
-- Name: TABLE byte_tickets_today; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_tickets_today TO bytedevs;
GRANT ALL ON TABLE public.byte_tickets_today TO pantry_web_user;


--
-- Name: TABLE byte_tickets_yesterday; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_tickets_yesterday TO bytedevs;
GRANT ALL ON TABLE public.byte_tickets_yesterday TO pantry_web_user;


--
-- Name: TABLE byte_users_multiple_fridges; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_users_multiple_fridges TO bytedevs;
GRANT ALL ON TABLE public.byte_users_multiple_fridges TO pantry_web_user;


--
-- Name: TABLE byte_users_products_4months; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.byte_users_products_4months TO bytedevs;
GRANT ALL ON TABLE public.byte_users_products_4months TO pantry_web_user;


--
-- Name: TABLE bytecodelog; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.bytecodelog TO pantry_web_user;


--
-- Name: TABLE campaigns; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.campaigns TO pantry_web_user;


--
-- Name: SEQUENCE campaigns_campaign_id_seq; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON SEQUENCE public.campaigns_campaign_id_seq TO pantry_web_user;


--
-- Name: TABLE cogs_by_category_120d; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.cogs_by_category_120d TO bytedevs;
GRANT ALL ON TABLE public.cogs_by_category_120d TO pantry_web_user;


--
-- Name: TABLE sales_by_category_120d; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.sales_by_category_120d TO bytedevs;
GRANT ALL ON TABLE public.sales_by_category_120d TO pantry_web_user;


--
-- Name: TABLE spoilage_by_category_120d; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.spoilage_by_category_120d TO bytedevs;
GRANT ALL ON TABLE public.spoilage_by_category_120d TO pantry_web_user;


--
-- Name: TABLE category_stats_120d; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.category_stats_120d TO bytedevs;
GRANT ALL ON TABLE public.category_stats_120d TO pantry_web_user;


--
-- Name: TABLE customer_campaigns; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.customer_campaigns TO pantry_web_user;


--
-- Name: TABLE customers; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.customers TO pantry_web_user;


--
-- Name: SEQUENCE customers_customer_id_seq; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON SEQUENCE public.customers_customer_id_seq TO pantry_web_user;


--
-- Name: TABLE dashboard_monthly_stats; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.dashboard_monthly_stats TO bytedevs;
GRANT ALL ON TABLE public.dashboard_monthly_stats TO pantry_web_user;


--
-- Name: TABLE dashboard_weekly_stats; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.dashboard_weekly_stats TO bytedevs;
GRANT ALL ON TABLE public.dashboard_weekly_stats TO pantry_web_user;


--
-- Name: TABLE date_hours_2016; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.date_hours_2016 TO pantry_web_user;


--
-- Name: TABLE lastwk_hrs; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.lastwk_hrs TO pantry_web_user;


--
-- Name: TABLE dowhours; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.dowhours TO pantry_web_user;


--
-- Name: TABLE stockout_avg_kiosk_cat_sales_dowhour; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.stockout_avg_kiosk_cat_sales_dowhour TO bytedevs;
GRANT ALL ON TABLE public.stockout_avg_kiosk_cat_sales_dowhour TO pantry_web_user;


--
-- Name: TABLE stockout_dowhours; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.stockout_dowhours TO bytedevs;
GRANT ALL ON TABLE public.stockout_dowhours TO pantry_web_user;


--
-- Name: TABLE stockout_dowhours_weighted; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.stockout_dowhours_weighted TO bytedevs;
GRANT ALL ON TABLE public.stockout_dowhours_weighted TO pantry_web_user;


--
-- Name: TABLE dbg_stockout_dowhours_weighted; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.dbg_stockout_dowhours_weighted TO bytedevs;
GRANT ALL ON TABLE public.dbg_stockout_dowhours_weighted TO pantry_web_user;


--
-- Name: TABLE dbg_stockout_dowhours_weighted_stats; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.dbg_stockout_dowhours_weighted_stats TO bytedevs;
GRANT ALL ON TABLE public.dbg_stockout_dowhours_weighted_stats TO pantry_web_user;


--
-- Name: TABLE stockout_runs_weighted; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.stockout_runs_weighted TO bytedevs;
GRANT ALL ON TABLE public.stockout_runs_weighted TO pantry_web_user;


--
-- Name: TABLE dbg_stockout_runs_weighted; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.dbg_stockout_runs_weighted TO bytedevs;
GRANT ALL ON TABLE public.dbg_stockout_runs_weighted TO pantry_web_user;


--
-- Name: TABLE stockout_weighted; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.stockout_weighted TO bytedevs;
GRANT ALL ON TABLE public.stockout_weighted TO pantry_web_user;


--
-- Name: TABLE dbg_stockout_weighted; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.dbg_stockout_weighted TO bytedevs;
GRANT ALL ON TABLE public.dbg_stockout_weighted TO pantry_web_user;


--
-- Name: TABLE dbg_stockout_weighted_stats; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.dbg_stockout_weighted_stats TO bytedevs;
GRANT ALL ON TABLE public.dbg_stockout_weighted_stats TO pantry_web_user;


--
-- Name: TABLE dp_epcssold; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.dp_epcssold TO bytedevs;
GRANT ALL ON TABLE public.dp_epcssold TO pantry_web_user;


--
-- Name: TABLE dp_epcssold_2015; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.dp_epcssold_2015 TO bytedevs;
GRANT ALL ON TABLE public.dp_epcssold_2015 TO pantry_web_user;


--
-- Name: TABLE dp_epcssold_2016; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.dp_epcssold_2016 TO bytedevs;
GRANT ALL ON TABLE public.dp_epcssold_2016 TO pantry_web_user;


--
-- Name: TABLE dp_epcssold_2017; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.dp_epcssold_2017 TO bytedevs;
GRANT ALL ON TABLE public.dp_epcssold_2017 TO pantry_web_user;


--
-- Name: TABLE dp_epcssold_4weeks; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.dp_epcssold_4weeks TO bytedevs;
GRANT ALL ON TABLE public.dp_epcssold_4weeks TO pantry_web_user;


--
-- Name: TABLE dp_epcssold_8weeks; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.dp_epcssold_8weeks TO bytedevs;
GRANT ALL ON TABLE public.dp_epcssold_8weeks TO pantry_web_user;


--
-- Name: TABLE dp_inventory_current; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.dp_inventory_current TO bytedevs;
GRANT ALL ON TABLE public.dp_inventory_current TO pantry_web_user;


--
-- Name: TABLE dp_inventory_history; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.dp_inventory_history TO bytedevs;
GRANT ALL ON TABLE public.dp_inventory_history TO pantry_web_user;


--
-- Name: TABLE dp_kiosks; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.dp_kiosks TO bytedevs;
GRANT ALL ON TABLE public.dp_kiosks TO pantry_web_user;


--
-- Name: TABLE dp_products; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.dp_products TO pantry_web_user;


--
-- Name: TABLE dp_spoilage; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.dp_spoilage TO bytedevs;
GRANT ALL ON TABLE public.dp_spoilage TO pantry_web_user;


--
-- Name: TABLE dp_spoilage_2016; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.dp_spoilage_2016 TO bytedevs;
GRANT ALL ON TABLE public.dp_spoilage_2016 TO pantry_web_user;


--
-- Name: TABLE dp_spoilage_2017; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.dp_spoilage_2017 TO bytedevs;
GRANT ALL ON TABLE public.dp_spoilage_2017 TO pantry_web_user;


--
-- Name: TABLE dp_spoilage_4weeks; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.dp_spoilage_4weeks TO bytedevs;
GRANT ALL ON TABLE public.dp_spoilage_4weeks TO pantry_web_user;


--
-- Name: TABLE dp_spoilage_8weeks; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.dp_spoilage_8weeks TO bytedevs;
GRANT ALL ON TABLE public.dp_spoilage_8weeks TO pantry_web_user;


--
-- Name: TABLE dp_spoilage_daily_sold_join; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.dp_spoilage_daily_sold_join TO bytedevs;
GRANT ALL ON TABLE public.dp_spoilage_daily_sold_join TO pantry_web_user;


--
-- Name: TABLE dp_spoilage_daily_kiosk_product_pct; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.dp_spoilage_daily_kiosk_product_pct TO bytedevs;
GRANT ALL ON TABLE public.dp_spoilage_daily_kiosk_product_pct TO pantry_web_user;


--
-- Name: TABLE dp_spoilage_daily_kiosk_pct; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.dp_spoilage_daily_kiosk_pct TO bytedevs;
GRANT ALL ON TABLE public.dp_spoilage_daily_kiosk_pct TO pantry_web_user;


--
-- Name: TABLE dp_spoilage_daily_pct; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.dp_spoilage_daily_pct TO bytedevs;
GRANT ALL ON TABLE public.dp_spoilage_daily_pct TO pantry_web_user;


--
-- Name: TABLE dp_spoilage_daily_product_pct; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.dp_spoilage_daily_product_pct TO bytedevs;
GRANT ALL ON TABLE public.dp_spoilage_daily_product_pct TO pantry_web_user;


--
-- Name: TABLE dp_spoilage_monthly_sold_join; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.dp_spoilage_monthly_sold_join TO bytedevs;
GRANT ALL ON TABLE public.dp_spoilage_monthly_sold_join TO pantry_web_user;


--
-- Name: TABLE dp_spoilage_monthly_calc; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.dp_spoilage_monthly_calc TO bytedevs;
GRANT ALL ON TABLE public.dp_spoilage_monthly_calc TO pantry_web_user;


--
-- Name: TABLE dp_spoilage_monthly_kiosk_product_pct; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.dp_spoilage_monthly_kiosk_product_pct TO bytedevs;
GRANT ALL ON TABLE public.dp_spoilage_monthly_kiosk_product_pct TO pantry_web_user;


--
-- Name: TABLE dp_spoilage_monthly_kiosk_pct; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.dp_spoilage_monthly_kiosk_pct TO bytedevs;
GRANT ALL ON TABLE public.dp_spoilage_monthly_kiosk_pct TO pantry_web_user;


--
-- Name: TABLE dp_spoilage_monthly_pct; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.dp_spoilage_monthly_pct TO bytedevs;
GRANT ALL ON TABLE public.dp_spoilage_monthly_pct TO pantry_web_user;


--
-- Name: TABLE dp_spoilage_monthly_product_pct; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.dp_spoilage_monthly_product_pct TO bytedevs;
GRANT ALL ON TABLE public.dp_spoilage_monthly_product_pct TO pantry_web_user;


--
-- Name: TABLE dp_spoilage_weekly_sold_join; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.dp_spoilage_weekly_sold_join TO bytedevs;
GRANT ALL ON TABLE public.dp_spoilage_weekly_sold_join TO pantry_web_user;


--
-- Name: TABLE dp_spoilage_weekly_kiosk_product_pct; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.dp_spoilage_weekly_kiosk_product_pct TO bytedevs;
GRANT ALL ON TABLE public.dp_spoilage_weekly_kiosk_product_pct TO pantry_web_user;


--
-- Name: TABLE dp_spoilage_weekly_kiosk_pct; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.dp_spoilage_weekly_kiosk_pct TO bytedevs;
GRANT ALL ON TABLE public.dp_spoilage_weekly_kiosk_pct TO pantry_web_user;


--
-- Name: TABLE dp_spoilage_weekly_pct; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.dp_spoilage_weekly_pct TO bytedevs;
GRANT ALL ON TABLE public.dp_spoilage_weekly_pct TO pantry_web_user;


--
-- Name: TABLE dp_spoilage_weekly_product_pct; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.dp_spoilage_weekly_product_pct TO bytedevs;
GRANT ALL ON TABLE public.dp_spoilage_weekly_product_pct TO pantry_web_user;


--
-- Name: TABLE dp_stockouts; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.dp_stockouts TO bytedevs;
GRANT ALL ON TABLE public.dp_stockouts TO pantry_web_user;


--
-- Name: TABLE dp_stockouts_2016; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.dp_stockouts_2016 TO bytedevs;
GRANT ALL ON TABLE public.dp_stockouts_2016 TO pantry_web_user;


--
-- Name: TABLE dp_stockouts_2017; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.dp_stockouts_2017 TO bytedevs;
GRANT ALL ON TABLE public.dp_stockouts_2017 TO pantry_web_user;


--
-- Name: TABLE dp_stockouts_4weeks; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.dp_stockouts_4weeks TO bytedevs;
GRANT ALL ON TABLE public.dp_stockouts_4weeks TO pantry_web_user;


--
-- Name: TABLE dp_stockouts_8weeks; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.dp_stockouts_8weeks TO bytedevs;
GRANT ALL ON TABLE public.dp_stockouts_8weeks TO pantry_web_user;


--
-- Name: TABLE dp_stockouts_weekly_sold_join; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.dp_stockouts_weekly_sold_join TO bytedevs;
GRANT ALL ON TABLE public.dp_stockouts_weekly_sold_join TO pantry_web_user;


--
-- Name: TABLE dp_stockouts_weekly_calc; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.dp_stockouts_weekly_calc TO bytedevs;
GRANT ALL ON TABLE public.dp_stockouts_weekly_calc TO pantry_web_user;


--
-- Name: TABLE dp_stockouts_weekly_kiosk_product_pct; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.dp_stockouts_weekly_kiosk_product_pct TO bytedevs;
GRANT ALL ON TABLE public.dp_stockouts_weekly_kiosk_product_pct TO pantry_web_user;


--
-- Name: TABLE dp_stockouts_weekly_kiosk_pct; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.dp_stockouts_weekly_kiosk_pct TO bytedevs;
GRANT ALL ON TABLE public.dp_stockouts_weekly_kiosk_pct TO pantry_web_user;


--
-- Name: TABLE dp_stockouts_weekly_pct; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.dp_stockouts_weekly_pct TO bytedevs;
GRANT ALL ON TABLE public.dp_stockouts_weekly_pct TO pantry_web_user;


--
-- Name: TABLE dp_stockouts_weekly_product_pct; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.dp_stockouts_weekly_product_pct TO bytedevs;
GRANT ALL ON TABLE public.dp_stockouts_weekly_product_pct TO pantry_web_user;


--
-- Name: TABLE inm_kiosk_weekly_sale; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.inm_kiosk_weekly_sale TO pantry_web_user;


--
-- Name: TABLE int_kiosk_weekly_sale; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.int_kiosk_weekly_sale TO pantry_web_user;


--
-- Name: TABLE kiosk; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.kiosk TO pantry_web_user;


--
-- Name: TABLE kiosk_first_seen; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.kiosk_first_seen TO pantry_web_user;


--
-- Name: SEQUENCE kiosk_id_seq; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON SEQUENCE public.kiosk_id_seq TO pantry_web_user;


--
-- Name: TABLE kiosk_sales_by_dayofweek; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.kiosk_sales_by_dayofweek TO bytedevs;
GRANT ALL ON TABLE public.kiosk_sales_by_dayofweek TO pantry_web_user;


--
-- Name: TABLE kiosk_status; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.kiosk_status TO bytedevs;
GRANT ALL ON TABLE public.kiosk_status TO pantry_web_user;


--
-- Name: TABLE latest_label_records; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.latest_label_records TO pantry_web_user;


--
-- Name: TABLE mkt_camp_20170111_sku_revival_sonoma; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.mkt_camp_20170111_sku_revival_sonoma TO pantry_web_user;


--
-- Name: TABLE mkt_camp_20170123_whats_new_in_kiosk; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.mkt_camp_20170123_whats_new_in_kiosk TO pantry_web_user;


--
-- Name: TABLE "pantry.kiosk"; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public."pantry.kiosk" TO pantry_web_user;


--
-- Name: SEQUENCE "pantry.kiosk_id_seq"; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON SEQUENCE public."pantry.kiosk_id_seq" TO pantry_web_user;


--
-- Name: TABLE sales_by_shelflife_120d; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.sales_by_shelflife_120d TO bytedevs;
GRANT ALL ON TABLE public.sales_by_shelflife_120d TO pantry_web_user;


--
-- Name: TABLE sales_by_shelflife_30d; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.sales_by_shelflife_30d TO bytedevs;
GRANT ALL ON TABLE public.sales_by_shelflife_30d TO pantry_web_user;


--
-- Name: TABLE sales_by_shelflife_45d; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.sales_by_shelflife_45d TO bytedevs;
GRANT ALL ON TABLE public.sales_by_shelflife_45d TO pantry_web_user;


--
-- Name: TABLE spoilage_by_shelflife_120d; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.spoilage_by_shelflife_120d TO bytedevs;
GRANT ALL ON TABLE public.spoilage_by_shelflife_120d TO pantry_web_user;


--
-- Name: TABLE spoilage_by_shelflife_30d; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.spoilage_by_shelflife_30d TO bytedevs;
GRANT ALL ON TABLE public.spoilage_by_shelflife_30d TO pantry_web_user;


--
-- Name: TABLE spoilage_by_shelflife_45d; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.spoilage_by_shelflife_45d TO bytedevs;
GRANT ALL ON TABLE public.spoilage_by_shelflife_45d TO pantry_web_user;


--
-- Name: TABLE spoilagepct_by_shelflife_120d; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.spoilagepct_by_shelflife_120d TO bytedevs;
GRANT ALL ON TABLE public.spoilagepct_by_shelflife_120d TO pantry_web_user;


--
-- Name: TABLE spoilagepct_by_shelflife_30d; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.spoilagepct_by_shelflife_30d TO bytedevs;
GRANT ALL ON TABLE public.spoilagepct_by_shelflife_30d TO pantry_web_user;


--
-- Name: TABLE spoilagepct_by_shelflife_45d; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.spoilagepct_by_shelflife_45d TO bytedevs;
GRANT ALL ON TABLE public.spoilagepct_by_shelflife_45d TO pantry_web_user;


--
-- Name: TABLE sys_activity; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.sys_activity TO pantry_web_user;


--
-- Name: TABLE sys_conninfo; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.sys_conninfo TO pantry_web_user;


--
-- Name: TABLE sys_slow_queries; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.sys_slow_queries TO pantry_web_user;


--
-- Name: TABLE sys_table_sizes; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.sys_table_sizes TO pantry_web_user;


--
-- Name: TABLE sys_uptime; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.sys_uptime TO pantry_web_user;


--
-- Name: TABLE tmp_dormant; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.tmp_dormant TO pantry_web_user;


--
-- Name: TABLE tmp_dormant2; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.tmp_dormant2 TO pantry_web_user;


--
-- Name: TABLE tmp_reboots_log; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.tmp_reboots_log TO pantry_web_user;


--
-- Name: TABLE track_dashboard; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.track_dashboard TO pantry_web_user;


--
-- Name: SEQUENCE track_dashboard_id_seq; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON SEQUENCE public.track_dashboard_id_seq TO pantry_web_user;


--
-- Name: TABLE track_inventory; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.track_inventory TO pantry_web_user;


--
-- Name: SEQUENCE track_inventory_id_seq; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON SEQUENCE public.track_inventory_id_seq TO pantry_web_user;


--
-- Name: TABLE user_retention_10weeks; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.user_retention_10weeks TO pantry_web_user;


--
-- Name: TABLE user_retention_12months; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.user_retention_12months TO pantry_web_user;


--
-- Name: TABLE user_retention_12weeks; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.user_retention_12weeks TO pantry_web_user;


--
-- Name: TABLE user_retention_1month; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.user_retention_1month TO pantry_web_user;


--
-- Name: TABLE user_retention_1week; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.user_retention_1week TO pantry_web_user;


--
-- Name: TABLE user_retention_26weeks; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.user_retention_26weeks TO pantry_web_user;


--
-- Name: TABLE user_retention_2months; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.user_retention_2months TO pantry_web_user;


--
-- Name: TABLE user_retention_2weeks; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.user_retention_2weeks TO pantry_web_user;


--
-- Name: TABLE user_retention_3months; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.user_retention_3months TO pantry_web_user;


--
-- Name: TABLE user_retention_3weeks; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.user_retention_3weeks TO pantry_web_user;


--
-- Name: TABLE user_retention_4months; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.user_retention_4months TO pantry_web_user;


--
-- Name: TABLE user_retention_4weeks; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.user_retention_4weeks TO pantry_web_user;


--
-- Name: TABLE user_retention_52weeks; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.user_retention_52weeks TO pantry_web_user;


--
-- Name: TABLE user_retention_6months; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.user_retention_6months TO pantry_web_user;


--
-- Name: TABLE user_retention_6weeks; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.user_retention_6weeks TO pantry_web_user;


--
-- Name: TABLE user_retention_8weeks; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.user_retention_8weeks TO pantry_web_user;


--
-- Name: TABLE user_retention_9months; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.user_retention_9months TO pantry_web_user;


--
-- Name: TABLE user_retention_tickets; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.user_retention_tickets TO bytedevs;
GRANT ALL ON TABLE public.user_retention_tickets TO pantry_web_user;


--
-- Name: TABLE valid_bytecodes; Type: ACL; Schema: public; Owner: dbservice
--

GRANT ALL ON TABLE public.valid_bytecodes TO pantry_web_user;


--
-- Name: TABLE dependency; Type: ACL; Schema: report; Owner: dbservice
--

GRANT ALL ON TABLE report.dependency TO bytedevs;


--
-- Name: TABLE current_inventory; Type: ACL; Schema: rptg; Owner: dbservice
--

GRANT ALL ON TABLE rptg.current_inventory TO bytedevs;


--
-- Name: TABLE temp_yann_boardq3; Type: ACL; Schema: rptg; Owner: dbservice
--

GRANT ALL ON TABLE rptg.temp_yann_boardq3 TO bytedevs;


--
-- Name: TABLE temp_yann_q1; Type: ACL; Schema: rptg; Owner: dbservice
--

GRANT ALL ON TABLE rptg.temp_yann_q1 TO bytedevs;


--
-- Name: TABLE accounting_bkup_20200204_partial; Type: ACL; Schema: test; Owner: dbservice
--

GRANT ALL ON TABLE test.accounting_bkup_20200204_partial TO bytedevs;


--
-- Name: TABLE accounting_partial_backup_20191101; Type: ACL; Schema: test; Owner: dbservice
--

GRANT ALL ON TABLE test.accounting_partial_backup_20191101 TO bytedevs;


--
-- Name: TABLE accounting_partial_bkup_20200131; Type: ACL; Schema: test; Owner: dbservice
--

GRANT ALL ON TABLE test.accounting_partial_bkup_20200131 TO bytedevs;


--
-- Name: TABLE backup_eng_2669_order; Type: ACL; Schema: test; Owner: dbservice
--

GRANT ALL ON TABLE test.backup_eng_2669_order TO bytedevs;


--
-- Name: TABLE campus_20190605; Type: ACL; Schema: test; Owner: dbservice
--

GRANT ALL ON TABLE test.campus_20190605 TO bytedevs;


--
-- Name: TABLE campus_20190620; Type: ACL; Schema: test; Owner: dbservice
--

GRANT ALL ON TABLE test.campus_20190620 TO bytedevs;


--
-- Name: TABLE cron_broken; Type: ACL; Schema: test; Owner: dbservice
--

GRANT ALL ON TABLE test.cron_broken TO bytedevs;


--
-- Name: TABLE discount_20190614; Type: ACL; Schema: test; Owner: dbservice
--

GRANT ALL ON TABLE test.discount_20190614 TO bytedevs;


--
-- Name: TABLE eng2903; Type: ACL; Schema: test; Owner: dbservice
--

GRANT ALL ON TABLE test.eng2903 TO bytedevs;


--
-- Name: TABLE fee_rate_bkup_20200131; Type: ACL; Schema: test; Owner: dbservice
--

GRANT ALL ON TABLE test.fee_rate_bkup_20200131 TO bytedevs;


--
-- Name: TABLE kiosk; Type: ACL; Schema: test; Owner: dbservice
--

GRANT ALL ON TABLE test.kiosk TO bytedevs;


--
-- Name: TABLE kiosk_20190605; Type: ACL; Schema: test; Owner: dbservice
--

GRANT ALL ON TABLE test.kiosk_20190605 TO bytedevs;


--
-- Name: TABLE kiosk_20190606; Type: ACL; Schema: test; Owner: dbservice
--

GRANT ALL ON TABLE test.kiosk_20190606 TO bytedevs;


--
-- Name: TABLE kiosk_20190611; Type: ACL; Schema: test; Owner: dbservice
--

GRANT ALL ON TABLE test.kiosk_20190611 TO bytedevs;


--
-- Name: TABLE kiosk_20190612; Type: ACL; Schema: test; Owner: dbservice
--

GRANT ALL ON TABLE test.kiosk_20190612 TO bytedevs;


--
-- Name: TABLE kiosk_20190918; Type: ACL; Schema: test; Owner: dbservice
--

GRANT ALL ON TABLE test.kiosk_20190918 TO bytedevs;


--
-- Name: TABLE kiosk_20200304; Type: ACL; Schema: test; Owner: dbservice
--

GRANT ALL ON TABLE test.kiosk_20200304 TO bytedevs;


--
-- Name: TABLE kiosk_bkup_20200204; Type: ACL; Schema: test; Owner: dbservice
--

GRANT ALL ON TABLE test.kiosk_bkup_20200204 TO bytedevs;


--
-- Name: TABLE kiosk_payment_start; Type: ACL; Schema: test; Owner: dbservice
--

GRANT ALL ON TABLE test.kiosk_payment_start TO bytedevs;


--
-- Name: TABLE kiosk_serial_20190916; Type: ACL; Schema: test; Owner: dbservice
--

GRANT ALL ON TABLE test.kiosk_serial_20190916 TO bytedevs;


--
-- Name: TABLE locked_kiosk_by_command; Type: ACL; Schema: test; Owner: dbservice
--

GRANT ALL ON TABLE test.locked_kiosk_by_command TO bytedevs;


--
-- Name: TABLE locked_kiosk_via_pw; Type: ACL; Schema: test; Owner: dbservice
--

GRANT ALL ON TABLE test.locked_kiosk_via_pw TO bytedevs;


--
-- Name: TABLE lost_wall_clock_orders; Type: ACL; Schema: test; Owner: dbservice
--

GRANT ALL ON TABLE test.lost_wall_clock_orders TO bytedevs;


--
-- Name: TABLE november_order; Type: ACL; Schema: test; Owner: dbservice
--

GRANT ALL ON TABLE test.november_order TO bytedevs;


--
-- Name: TABLE order_complimentary_eng_2292; Type: ACL; Schema: test; Owner: dbservice
--

GRANT ALL ON TABLE test.order_complimentary_eng_2292 TO bytedevs;


--
-- Name: TABLE order_epc_pending_sync; Type: ACL; Schema: test; Owner: dbservice
--

GRANT ALL ON TABLE test.order_epc_pending_sync TO bytedevs;


--
-- Name: TABLE order_with_1970_and_2000_dates; Type: ACL; Schema: test; Owner: dbservice
--

GRANT ALL ON TABLE test.order_with_1970_and_2000_dates TO bytedevs;


--
-- Name: TABLE reauth_2019_07_priced_finalized_orders; Type: ACL; Schema: test; Owner: dbservice
--

GRANT ALL ON TABLE test.reauth_2019_07_priced_finalized_orders TO bytedevs;


--
-- Name: TABLE request_log_epc_order; Type: ACL; Schema: test; Owner: dbservice
--

GRANT ALL ON TABLE test.request_log_epc_order TO bytedevs;


--
-- Name: TABLE request_log_order; Type: ACL; Schema: test; Owner: dbservice
--

GRANT ALL ON TABLE test.request_log_order TO bytedevs;


--
-- Name: TABLE request_log_sold_epc; Type: ACL; Schema: test; Owner: dbservice
--

GRANT ALL ON TABLE test.request_log_sold_epc TO bytedevs;


--
-- Name: TABLE temp_pending; Type: ACL; Schema: test; Owner: dbservice
--

GRANT ALL ON TABLE test.temp_pending TO bytedevs;


--
-- Name: TABLE transactions_pending_sync; Type: ACL; Schema: test; Owner: dbservice
--

GRANT ALL ON TABLE test.transactions_pending_sync TO bytedevs;


--
-- Name: SEQUENCE transactions_pending_sync_id_seq; Type: ACL; Schema: test; Owner: dbservice
--

GRANT ALL ON SEQUENCE test.transactions_pending_sync_id_seq TO bytedevs;


--
-- Name: TABLE vantiv_20190801; Type: ACL; Schema: test; Owner: dbservice
--

GRANT ALL ON TABLE test.vantiv_20190801 TO bytedevs;


--
-- Name: TABLE vantiv_20190801b; Type: ACL; Schema: test; Owner: dbservice
--

GRANT ALL ON TABLE test.vantiv_20190801b TO bytedevs;


--
-- Name: DEFAULT PRIVILEGES FOR FUNCTIONS; Type: DEFAULT ACL; Schema: inm; Owner: dbservice
--

ALTER DEFAULT PRIVILEGES FOR ROLE dbservice IN SCHEMA inm REVOKE ALL ON FUNCTIONS  FROM PUBLIC;
ALTER DEFAULT PRIVILEGES FOR ROLE dbservice IN SCHEMA inm REVOKE ALL ON FUNCTIONS  FROM dbservice;
ALTER DEFAULT PRIVILEGES FOR ROLE dbservice IN SCHEMA inm GRANT ALL ON FUNCTIONS  TO bytedevs;


--
-- Name: DEFAULT PRIVILEGES FOR TABLES; Type: DEFAULT ACL; Schema: inm; Owner: dbservice
--

ALTER DEFAULT PRIVILEGES FOR ROLE dbservice IN SCHEMA inm REVOKE ALL ON TABLES  FROM dbservice;
ALTER DEFAULT PRIVILEGES FOR ROLE dbservice IN SCHEMA inm GRANT ALL ON TABLES  TO bytedevs;


--
-- Name: DEFAULT PRIVILEGES FOR TABLES; Type: DEFAULT ACL; Schema: inm_beta; Owner: dbservice
--

ALTER DEFAULT PRIVILEGES FOR ROLE dbservice IN SCHEMA inm_beta REVOKE ALL ON TABLES  FROM dbservice;
ALTER DEFAULT PRIVILEGES FOR ROLE dbservice IN SCHEMA inm_beta GRANT ALL ON TABLES  TO jung;


--
-- Name: DEFAULT PRIVILEGES FOR FUNCTIONS; Type: DEFAULT ACL; Schema: mixalot; Owner: dbservice
--

ALTER DEFAULT PRIVILEGES FOR ROLE dbservice IN SCHEMA mixalot REVOKE ALL ON FUNCTIONS  FROM PUBLIC;
ALTER DEFAULT PRIVILEGES FOR ROLE dbservice IN SCHEMA mixalot REVOKE ALL ON FUNCTIONS  FROM dbservice;
ALTER DEFAULT PRIVILEGES FOR ROLE dbservice IN SCHEMA mixalot GRANT ALL ON FUNCTIONS  TO bytedevs;


--
-- Name: DEFAULT PRIVILEGES FOR TABLES; Type: DEFAULT ACL; Schema: mixalot; Owner: dbservice
--

ALTER DEFAULT PRIVILEGES FOR ROLE dbservice IN SCHEMA mixalot REVOKE ALL ON TABLES  FROM dbservice;
ALTER DEFAULT PRIVILEGES FOR ROLE dbservice IN SCHEMA mixalot GRANT ALL ON TABLES  TO bytedevs;


--
-- Name: DEFAULT PRIVILEGES FOR SEQUENCES; Type: DEFAULT ACL; Schema: pantry; Owner: dbservice
--

ALTER DEFAULT PRIVILEGES FOR ROLE dbservice IN SCHEMA pantry REVOKE ALL ON SEQUENCES  FROM dbservice;
ALTER DEFAULT PRIVILEGES FOR ROLE dbservice IN SCHEMA pantry GRANT ALL ON SEQUENCES  TO pantry_web_user;


--
-- Name: DEFAULT PRIVILEGES FOR FUNCTIONS; Type: DEFAULT ACL; Schema: pantry; Owner: dbservice
--

ALTER DEFAULT PRIVILEGES FOR ROLE dbservice IN SCHEMA pantry REVOKE ALL ON FUNCTIONS  FROM PUBLIC;
ALTER DEFAULT PRIVILEGES FOR ROLE dbservice IN SCHEMA pantry REVOKE ALL ON FUNCTIONS  FROM dbservice;
ALTER DEFAULT PRIVILEGES FOR ROLE dbservice IN SCHEMA pantry GRANT ALL ON FUNCTIONS  TO pantry_web_user;
ALTER DEFAULT PRIVILEGES FOR ROLE dbservice IN SCHEMA pantry GRANT ALL ON FUNCTIONS  TO bytedevs;


--
-- Name: DEFAULT PRIVILEGES FOR TABLES; Type: DEFAULT ACL; Schema: pantry; Owner: dbservice
--

ALTER DEFAULT PRIVILEGES FOR ROLE dbservice IN SCHEMA pantry REVOKE ALL ON TABLES  FROM dbservice;
ALTER DEFAULT PRIVILEGES FOR ROLE dbservice IN SCHEMA pantry GRANT ALL ON TABLES  TO pantry_web_user;
ALTER DEFAULT PRIVILEGES FOR ROLE dbservice IN SCHEMA pantry GRANT ALL ON TABLES  TO bytedevs;


--
-- Name: DEFAULT PRIVILEGES FOR FUNCTIONS; Type: DEFAULT ACL; Schema: public; Owner: dbservice
--

ALTER DEFAULT PRIVILEGES FOR ROLE dbservice IN SCHEMA public REVOKE ALL ON FUNCTIONS  FROM PUBLIC;
ALTER DEFAULT PRIVILEGES FOR ROLE dbservice IN SCHEMA public REVOKE ALL ON FUNCTIONS  FROM dbservice;
ALTER DEFAULT PRIVILEGES FOR ROLE dbservice IN SCHEMA public GRANT ALL ON FUNCTIONS  TO bytedevs;


--
-- Name: DEFAULT PRIVILEGES FOR TABLES; Type: DEFAULT ACL; Schema: public; Owner: dbservice
--

ALTER DEFAULT PRIVILEGES FOR ROLE dbservice IN SCHEMA public REVOKE ALL ON TABLES  FROM dbservice;
ALTER DEFAULT PRIVILEGES FOR ROLE dbservice IN SCHEMA public GRANT ALL ON TABLES  TO bytedevs;


--
-- Name: DEFAULT PRIVILEGES FOR FUNCTIONS; Type: DEFAULT ACL; Schema: report; Owner: dbservice
--

ALTER DEFAULT PRIVILEGES FOR ROLE dbservice IN SCHEMA report REVOKE ALL ON FUNCTIONS  FROM PUBLIC;
ALTER DEFAULT PRIVILEGES FOR ROLE dbservice IN SCHEMA report REVOKE ALL ON FUNCTIONS  FROM dbservice;
ALTER DEFAULT PRIVILEGES FOR ROLE dbservice IN SCHEMA report GRANT ALL ON FUNCTIONS  TO bytedevs;


--
-- Name: DEFAULT PRIVILEGES FOR TABLES; Type: DEFAULT ACL; Schema: report; Owner: dbservice
--

ALTER DEFAULT PRIVILEGES FOR ROLE dbservice IN SCHEMA report REVOKE ALL ON TABLES  FROM dbservice;
ALTER DEFAULT PRIVILEGES FOR ROLE dbservice IN SCHEMA report GRANT ALL ON TABLES  TO bytedevs;


--
-- Name: DEFAULT PRIVILEGES FOR FUNCTIONS; Type: DEFAULT ACL; Schema: rptg; Owner: dbservice
--

ALTER DEFAULT PRIVILEGES FOR ROLE dbservice IN SCHEMA rptg REVOKE ALL ON FUNCTIONS  FROM PUBLIC;
ALTER DEFAULT PRIVILEGES FOR ROLE dbservice IN SCHEMA rptg REVOKE ALL ON FUNCTIONS  FROM dbservice;
ALTER DEFAULT PRIVILEGES FOR ROLE dbservice IN SCHEMA rptg GRANT ALL ON FUNCTIONS  TO bytedevs;


--
-- Name: DEFAULT PRIVILEGES FOR TABLES; Type: DEFAULT ACL; Schema: rptg; Owner: dbservice
--

ALTER DEFAULT PRIVILEGES FOR ROLE dbservice IN SCHEMA rptg REVOKE ALL ON TABLES  FROM dbservice;
ALTER DEFAULT PRIVILEGES FOR ROLE dbservice IN SCHEMA rptg GRANT ALL ON TABLES  TO bytedevs;


--
-- Name: DEFAULT PRIVILEGES FOR FUNCTIONS; Type: DEFAULT ACL; Schema: test; Owner: dbservice
--

ALTER DEFAULT PRIVILEGES FOR ROLE dbservice IN SCHEMA test REVOKE ALL ON FUNCTIONS  FROM PUBLIC;
ALTER DEFAULT PRIVILEGES FOR ROLE dbservice IN SCHEMA test REVOKE ALL ON FUNCTIONS  FROM dbservice;
ALTER DEFAULT PRIVILEGES FOR ROLE dbservice IN SCHEMA test GRANT ALL ON FUNCTIONS  TO bytedevs;


--
-- Name: DEFAULT PRIVILEGES FOR TABLES; Type: DEFAULT ACL; Schema: test; Owner: dbservice
--

ALTER DEFAULT PRIVILEGES FOR ROLE dbservice IN SCHEMA test REVOKE ALL ON TABLES  FROM dbservice;
ALTER DEFAULT PRIVILEGES FOR ROLE dbservice IN SCHEMA test GRANT ALL ON TABLES  TO bytedevs;


--
-- PostgreSQL database dump complete
--

Done with file for IOT Read $d number of lines
%!(EXTRA int=20267)--
-- PostgreSQL database dump
--

-- Dumped from database version 10.6
-- Dumped by pg_dump version 12.4

SET statement_timeout = 0;
false SET
HERE false SET
HERE map[statement_timeout:SET statement_timeout = 0;]
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SELECT pg_catalog.set_config('search_path', '', false);
SELECT pg_catalog.set_config('search_path', '', false);
SET check_function_bodies = false;
SET xmloption = content;
SET client_min_messages = warning;
SET row_security = off;

--
-- Name: aws_dms; Type: SCHEMA; Schema: -; Owner: erpuser
--

CREATE SCHEMA aws_dms;


ALTER SCHEMA aws_dms OWNER TO erpuser;

--
-- Name: campus_87; Type: SCHEMA; Schema: -; Owner: erpuser
--

CREATE SCHEMA campus_87;


ALTER SCHEMA campus_87 OWNER TO erpuser;

--
-- Name: dw; Type: SCHEMA; Schema: -; Owner: muriel
--

CREATE SCHEMA dw;


ALTER SCHEMA dw OWNER TO muriel;

--
-- Name: erp; Type: SCHEMA; Schema: -; Owner: erpuser
--

CREATE SCHEMA erp;


ALTER SCHEMA erp OWNER TO erpuser;

--
-- Name: erp_backup; Type: SCHEMA; Schema: -; Owner: erpuser
--

CREATE SCHEMA erp_backup;


ALTER SCHEMA erp_backup OWNER TO erpuser;

--
-- Name: erp_test; Type: SCHEMA; Schema: -; Owner: erpuser
--

CREATE SCHEMA erp_test;


ALTER SCHEMA erp_test OWNER TO erpuser;

--
-- Name: fnrenames; Type: SCHEMA; Schema: -; Owner: erpuser
--

CREATE SCHEMA fnrenames;


ALTER SCHEMA fnrenames OWNER TO erpuser;

--
-- Name: inm; Type: SCHEMA; Schema: -; Owner: erpuser
--

CREATE SCHEMA inm;


ALTER SCHEMA inm OWNER TO erpuser;

--
-- Name: inm_restore_0625; Type: SCHEMA; Schema: -; Owner: erpuser
--

CREATE SCHEMA inm_restore_0625;


ALTER SCHEMA inm_restore_0625 OWNER TO erpuser;

--
-- Name: inm_test; Type: SCHEMA; Schema: -; Owner: erpuser
--

CREATE SCHEMA inm_test;


ALTER SCHEMA inm_test OWNER TO erpuser;

--
-- Name: migration; Type: SCHEMA; Schema: -; Owner: erpuser
--

CREATE SCHEMA migration;


ALTER SCHEMA migration OWNER TO erpuser;

--
-- Name: mixalot; Type: SCHEMA; Schema: -; Owner: erpuser
--

CREATE SCHEMA mixalot;


ALTER SCHEMA mixalot OWNER TO erpuser;

--
-- Name: pantry; Type: SCHEMA; Schema: -; Owner: erpuser
--

CREATE SCHEMA pantry;


ALTER SCHEMA pantry OWNER TO erpuser;

--
-- Name: test; Type: SCHEMA; Schema: -; Owner: erpuser
--

CREATE SCHEMA test;


ALTER SCHEMA test OWNER TO erpuser;

--
-- Name: type; Type: SCHEMA; Schema: -; Owner: erpuser
--

CREATE SCHEMA type;


ALTER SCHEMA type OWNER TO erpuser;

--
-- Name: util; Type: SCHEMA; Schema: -; Owner: erpuser
--

CREATE SCHEMA util;


ALTER SCHEMA util OWNER TO erpuser;

--
-- Name: dow; Type: DOMAIN; Schema: type; Owner: erpuser
--

CREATE DOMAIN type.dow AS smallint
	CONSTRAINT dow_check CHECK (((VALUE >= 0) AND (VALUE <= 6)));


ALTER DOMAIN type.dow OWNER TO erpuser;

--
-- Name: email; Type: DOMAIN; Schema: type; Owner: erpuser
--

CREATE DOMAIN type.email AS text
	CONSTRAINT email_check CHECK (((length(VALUE) <= 100) AND (VALUE ~ '^\w+@[0-9a-zA-Z_]+?\.[a-zA-Z]{2,3}$'::text)));


ALTER DOMAIN type.email OWNER TO erpuser;

--
-- Name: money_max_10k; Type: DOMAIN; Schema: type; Owner: erpuser
--

CREATE DOMAIN type.money_max_10k AS numeric(6,2);


ALTER DOMAIN type.money_max_10k OWNER TO erpuser;

--
-- Name: money_max_1k; Type: DOMAIN; Schema: type; Owner: erpuser
--

CREATE DOMAIN type.money_max_1k AS numeric(5,2);


ALTER DOMAIN type.money_max_1k OWNER TO erpuser;

--
-- Name: money_max_1m; Type: DOMAIN; Schema: type; Owner: erpuser
--

CREATE DOMAIN type.money_max_1m AS numeric(8,2);


ALTER DOMAIN type.money_max_1m OWNER TO erpuser;

--
-- Name: phone; Type: DOMAIN; Schema: type; Owner: erpuser
--

CREATE DOMAIN type.phone AS text
	CONSTRAINT phone_check CHECK ((length(VALUE) <= 40));


ALTER DOMAIN type.phone OWNER TO erpuser;

--
-- Name: tag_applied_by; Type: DOMAIN; Schema: type; Owner: erpuser
--

CREATE DOMAIN type.tag_applied_by AS text
	CONSTRAINT tag_applied_by_check CHECK ((VALUE = ANY (ARRAY['V'::text, 'W'::text])));


ALTER DOMAIN type.tag_applied_by OWNER TO erpuser;

--
-- Name: tag_delivery_option; Type: DOMAIN; Schema: type; Owner: erpuser
--

CREATE DOMAIN type.tag_delivery_option AS text
	CONSTRAINT tag_delivery_option_check CHECK ((VALUE = ANY (ARRAY['M'::text, 'P'::text])));


ALTER DOMAIN type.tag_delivery_option OWNER TO erpuser;

--
-- Name: text100; Type: DOMAIN; Schema: type; Owner: erpuser
--

CREATE DOMAIN type.text100 AS text
	CONSTRAINT text100_check CHECK ((length(VALUE) <= 100));


ALTER DOMAIN type.text100 OWNER TO erpuser;

--
-- Name: text10k; Type: DOMAIN; Schema: type; Owner: erpuser
--

CREATE DOMAIN type.text10k AS text
	CONSTRAINT text10k_check CHECK ((length(VALUE) <= 10000));


ALTER DOMAIN type.text10k OWNER TO erpuser;

--
-- Name: text1k; Type: DOMAIN; Schema: type; Owner: erpuser
--

CREATE DOMAIN type.text1k AS text
	CONSTRAINT text1k_check CHECK ((length(VALUE) <= 1000));


ALTER DOMAIN type.text1k OWNER TO erpuser;

--
-- Name: text200; Type: DOMAIN; Schema: type; Owner: erpuser
--

CREATE DOMAIN type.text200 AS text
	CONSTRAINT text200_check CHECK ((length(VALUE) <= 200));


ALTER DOMAIN type.text200 OWNER TO erpuser;

--
-- Name: text2k; Type: DOMAIN; Schema: type; Owner: erpuser
--

CREATE DOMAIN type.text2k AS text
	CONSTRAINT text2k_check CHECK ((length(VALUE) <= 2000));


ALTER DOMAIN type.text2k OWNER TO erpuser;

--
-- Name: text40; Type: DOMAIN; Schema: type; Owner: erpuser
--

CREATE DOMAIN type.text40 AS text
	CONSTRAINT text40_check CHECK ((length(VALUE) <= 100));


ALTER DOMAIN type.text40 OWNER TO erpuser;

--
-- Name: text400; Type: DOMAIN; Schema: type; Owner: erpuser
--

CREATE DOMAIN type.text400 AS text
	CONSTRAINT text400_check CHECK ((length(VALUE) <= 400));


ALTER DOMAIN type.text400 OWNER TO erpuser;

--
-- Name: text4k; Type: DOMAIN; Schema: type; Owner: erpuser
--

CREATE DOMAIN type.text4k AS text
	CONSTRAINT text4k_check CHECK ((length(VALUE) <= 4000));


ALTER DOMAIN type.text4k OWNER TO erpuser;

--
-- Name: text_name; Type: DOMAIN; Schema: type; Owner: erpuser
--

CREATE DOMAIN type.text_name AS text
	CONSTRAINT text_name_check CHECK ((length(VALUE) <= 500));


ALTER DOMAIN type.text_name OWNER TO erpuser;

--
-- Name: zero_or_one; Type: DOMAIN; Schema: type; Owner: erpuser
--

CREATE DOMAIN type.zero_or_one AS smallint
	CONSTRAINT zero_or_one_check CHECK (((VALUE >= 0) AND (VALUE <= 1)));


ALTER DOMAIN type.zero_or_one OWNER TO erpuser;

--
-- Name: byte_losses(date, date); Type: FUNCTION; Schema: dw; Owner: muriel
--

CREATE FUNCTION dw.byte_losses(beginning_date date, ending_date date) RETURNS TABLE(epc character varying, kiosk_id bigint, product_id bigint, time_updated timestamp with time zone, cost numeric, price numeric)
    LANGUAGE plpgsql
    AS $$
    DECLARE
        BYTE_CAMPUS INTEGER := 87;
    BEGIN
        RETURN QUERY
        /*
        The following query is used to get non free kiosks and free kiosks lost. SEE
        ENG-708. Non free kiosks losses = lost items. Since lost items are always counted as sold
        for free kiosks, Free kiosks losses = 0.

        Alterations from ENG-1922
        - remove product_campus_id filter
        */
        SELECT epc_ as epc,
            kiosk_id_ as kiosk_id,
            product_id_ as product_id,
            time_updated_ as time_updated,
            cost_ as cost,
            price_ as price
            FROM dw.losses(beginning_date, ending_date) gl
            JOIN pantry.kiosk k
            ON gl.kiosk_id_ = k.id
            --- Get discount for the entire kiosk, not a specific product.
            --- product_id needs to be NULL
            LEFT JOIN pantry.discount d
            ON k.id = d.kiosk_id
            AND d.product_id IS NULL
            WHERE (value != 100 OR value IS NULL)
            AND enable_reporting_ = 1
            AND kiosk_campus_id_ = BYTE_CAMPUS;
    END;
$$;


ALTER FUNCTION dw.byte_losses(beginning_date date, ending_date date) OWNER TO muriel;

--
-- Name: FUNCTION byte_losses(beginning_date date, ending_date date); Type: COMMENT; Schema: dw; Owner: muriel
--

COMMENT ON FUNCTION dw.byte_losses(beginning_date date, ending_date date) IS 'returns campus 87 losses';


--
-- Name: byte_restocks(date, date); Type: FUNCTION; Schema: dw; Owner: erpuser
--

CREATE FUNCTION dw.byte_restocks(beginning_date date, ending_date date) RETURNS TABLE(epc character varying, kiosk_id bigint, product_id bigint, time_added timestamp with time zone, cost numeric, price numeric)
    LANGUAGE plpgsql
    AS $$
    DECLARE
        BYTE_CAMPUS INTEGER := 87;
    BEGIN
        RETURN QUERY
        /*
        The following query is used to get byte kiosks restocks.
        */
        SELECT epc_ as epc,
            kiosk_id_ as kiosk_id,
            product_id_ as product_id,
            time_added_ as time_added,
            cost_ as cost,
            price_ as price
            FROM dw.restocks(beginning_date, ending_date)
            WHERE kiosk_campus_id_ = BYTE_CAMPUS
            AND enable_reporting_ = 1;
    END;
$$;


ALTER FUNCTION dw.byte_restocks(beginning_date date, ending_date date) OWNER TO erpuser;

--
-- Name: byte_sales(date, date); Type: FUNCTION; Schema: dw; Owner: muriel
--

CREATE FUNCTION dw.byte_sales(beginning_date date, ending_date date) RETURNS TABLE(epc character varying, order_id character varying, kiosk_id bigint, product_id bigint, time_bought timestamp with time zone, cost numeric, price numeric)
    LANGUAGE plpgsql
    AS $$
    DECLARE
        BYTE_CAMPUS INTEGER := 87;
    BEGIN
        RETURN QUERY
        /*
        The following query is used to get all non free kiosks and free kiosks sales. SEE
        ENG-708. Byte kiosks sales = non free kiosks sale + free kiosk sales + free kiosk losses.

        Alterations from ENG-1922
        - remove product_campus_id filter
        */
        SELECT epc_ as epc,
            order_id_ as order_id,
            kiosk_id_ as kiosk_id,
            product_id_ as product_id,
            time_bought_ as time_bought,
            cost_ as cost,
            price_ as price
            --- This subquery is used to get the sum price of sold items in free kiosks
            FROM (SELECT epc_,
                order_id_,
                kiosk_id_,
                product_id_,
                time_bought_,
                cost_,
                price_
                FROM dw.sales(beginning_date, ending_date)  gs
                JOIN pantry.kiosk k
                ON gs.kiosk_id_ = k.id
                --- Get discount for the entire kiosk, not a specific product.
                --- product_id needs to be NULL
                LEFT JOIN pantry.discount d
                ON k.id = d.kiosk_id
                AND d.product_id IS NULL
                WHERE value = 100
                AND enable_reporting_ = 1
                AND kiosk_campus_id_ = BYTE_CAMPUS
            UNION
            --- This subquery is used to get all lost items in free kiosks
            SELECT epc_,
                NULL as order_id_,
                kiosk_id_,
                product_id_,
                time_updated_ as time_bought_,
                cost_ ,
                price_
                FROM dw.losses(beginning_date, ending_date)  gl
                JOIN pantry.kiosk k
                ON gl.kiosk_id_ = k.id
                --- Get discount for the entire kiosk, not a specific product.
                --- product_id needs to be NULL
                LEFT JOIN pantry.discount d
                ON k.id = d.kiosk_id
                AND d.product_id IS NULL
                WHERE value = 100
                AND enable_reporting_ = 1
                AND kiosk_campus_id_ = BYTE_CAMPUS
            UNION
            --- This subquery is used to get all sold items in non-free kiosks
            SELECT epc_,
                order_id_,
                kiosk_id_,
                product_id_,
                time_bought_,
                cost_,
                price_
                FROM dw.sales(beginning_date, ending_date)  gs
                JOIN pantry.kiosk k
                ON gs.kiosk_id_ = k.id
                --- Get discount for the entire kiosk, not a specific product.
                --- product_id needs to be NULL
                LEFT JOIN pantry.discount d
                ON k.id = d.kiosk_id
                AND d.product_id IS NULL
                WHERE (value != 100 OR value IS NULL)
                AND enable_reporting_ = 1
                AND kiosk_campus_id_ = BYTE_CAMPUS
            ) as all_kiosk_sale;
    END;
$$;


ALTER FUNCTION dw.byte_sales(beginning_date date, ending_date date) OWNER TO muriel;

--
-- Name: FUNCTION byte_sales(beginning_date date, ending_date date); Type: COMMENT; Schema: dw; Owner: muriel
--

COMMENT ON FUNCTION dw.byte_sales(beginning_date date, ending_date date) IS 'returns campus 87 sales';


--
-- Name: byte_spoils(date, date); Type: FUNCTION; Schema: dw; Owner: erpuser
--

CREATE FUNCTION dw.byte_spoils(beginning_date date, ending_date date) RETURNS TABLE(epc character varying, kiosk_id bigint, product_id bigint, time_updated timestamp with time zone, cost numeric, price numeric)
    LANGUAGE plpgsql
    AS $$
    DECLARE
        BYTE_CAMPUS INTEGER := 87;
    BEGIN
        RETURN QUERY
/*
The following query is used to get byte kiosks spoils.
*/
SELECT epc_ as epc,
    kiosk_id_ as kiosk_id,
    product_id_ as product_id,
    time_updated_ as time_updated,
    cost_ as cost,
    price_ as price
    FROM dw.spoils(beginning_date, ending_date) gl
    WHERE kiosk_campus_id_ = BYTE_CAMPUS
    AND enable_reporting_ = 1;
 END;
$$;


ALTER FUNCTION dw.byte_spoils(beginning_date date, ending_date date) OWNER TO erpuser;

--
-- Name: FUNCTION byte_spoils(beginning_date date, ending_date date); Type: COMMENT; Schema: dw; Owner: erpuser
--

COMMENT ON FUNCTION dw.byte_spoils(beginning_date date, ending_date date) IS 'returns campus 87 spoils';


--
-- Name: calculate_prorated_fee(numeric, date, date); Type: FUNCTION; Schema: dw; Owner: erpuser
--

CREATE FUNCTION dw.calculate_prorated_fee(fee numeric, month_date date, deployment_date date) RETURNS TABLE(prorated_fee numeric)
    LANGUAGE plpgsql
    AS $$
    BEGIN
        RETURN QUERY
        --- This function is used to calculate prorated monthly fees if month_date =
        --- deployment_date. Otherwise, it returns fee.
        SELECT CASE WHEN date_trunc('month', month_date) = date_trunc('month', deployment_date)
            THEN ROUND(
                (
                    --- prorated fee = number of days live * daily fee
                    --- Number of days live = number of days in month - deployment day + 1
                    (   --- number days in month
                        (DATE_PART('days', DATE_TRUNC('month', month_date)
                            + '1 MONTH - 1 DAY'::INTERVAL))
                        --- deployment day
                        -  (EXTRACT(DAY FROM deployment_date))
                        + 1
                    )
                    *
                    --- daily fee = monthly fee / number of days in month
                    (
                         fee
                         /
                         --number of days in month
                         DATE_PART('days', DATE_TRUNC('month', month_date)
                            + '1 MONTH - 1 DAY'::INTERVAL)
                    )
                )::numeric, 2)
             ELSE fee
             END AS prorated_fee;
    END;
$$;


ALTER FUNCTION dw.calculate_prorated_fee(fee numeric, month_date date, deployment_date date) OWNER TO erpuser;

--
-- Name: clear_daily_kiosk_sku_summary(date, date); Type: FUNCTION; Schema: dw; Owner: muriel
--

CREATE FUNCTION dw.clear_daily_kiosk_sku_summary(beginning_date date, ending_date date) RETURNS void
    LANGUAGE plpgsql
    AS $$
    BEGIN
    --- Delete record for given range
    DELETE FROM dw.fact_daily_kiosk_sku_summary 
    WHERE date_id >= TO_CHAR(beginning_date, 'YYYYMMDD')::int 
    AND date_id <= TO_CHAR(ending_date, 'YYYYMMDD')::int ;
END;
$$;


ALTER FUNCTION dw.clear_daily_kiosk_sku_summary(beginning_date date, ending_date date) OWNER TO muriel;

--
-- Name: FUNCTION clear_daily_kiosk_sku_summary(beginning_date date, ending_date date); Type: COMMENT; Schema: dw; Owner: muriel
--

COMMENT ON FUNCTION dw.clear_daily_kiosk_sku_summary(beginning_date date, ending_date date) IS 'clears dw.fact_daily_kiosk_sku_summary';


--
-- Name: clear_fact_monthly_kiosk_summary(date); Type: FUNCTION; Schema: dw; Owner: erpuser
--

CREATE FUNCTION dw.clear_fact_monthly_kiosk_summary(month_date date) RETURNS void
    LANGUAGE plpgsql
    AS $$
    BEGIN
    --- Delete record for specified month
    DELETE FROM dw.fact_monthly_kiosk_summary 
    WHERE date_id = TO_CHAR(date_trunc('month', month_date ), 'YYYYMMDD')::int;
END;
$$;


ALTER FUNCTION dw.clear_fact_monthly_kiosk_summary(month_date date) OWNER TO erpuser;

--
-- Name: FUNCTION clear_fact_monthly_kiosk_summary(month_date date); Type: COMMENT; Schema: dw; Owner: erpuser
--

COMMENT ON FUNCTION dw.clear_fact_monthly_kiosk_summary(month_date date) IS 'clears dw.fact_monthly_kiosk_summary';


--
-- Name: export_consolidated_remittance(date); Type: FUNCTION; Schema: dw; Owner: erpuser
--

CREATE FUNCTION dw.export_consolidated_remittance(month_date date) RETURNS TABLE(campus_title character varying, campus_id bigint, name character varying, email character varying, number_of_kiosks bigint, client_type text, sales_list_price numeric, sales_after_discount numeric, complimentary numeric, freedom_pay numeric, credit_card numeric, monthly_lease numeric, connectivity_fee numeric, payment_processing_fee numeric, tag_fee numeric, tags_got integer, tag_price numeric, net_remittance numeric, net_total numeric, manual_adjustment numeric, fees_before_tags numeric, details text)
    LANGUAGE plpgsql
    AS $$
    BEGIN
        RETURN QUERY
        SELECT campus_remittance.campus_title,
            campus_remittance.campus_id,
            campus_remittance.name,
            campus_remittance.email,
            campus_remittance.number_of_kiosks,
            campus_remittance.client_type,
            COALESCE(campus_remittance.sales_list_price, 0) as sales_list_price,
            COALESCE(campus_remittance.sales_after_discount, 0) as sales_after_discount,
            COALESCE(campus_remittance.complimentary, 0) as complimentary,
            COALESCE(campus_remittance.freedom_pay, 0) as freedom_pay,
            COALESCE(campus_remittance.credit_card, 0) as credit_card,
            COALESCE(campus_remittance.monthly_lease, 0) as monthly_lease,
            COALESCE(campus_remittance.connectivity_fee, 0) as connectivity_fee,
            COALESCE(campus_remittance.payment_processing_fee, 0) as payment_processing_fee,
            COALESCE(campus_remittance.tag_fee, 0) as tag_fee,
            COALESCE(campus_remittance.tags_got, 0) as tags_got,
            COALESCE(campus_remittance.tag_price, 0) as tag_price,
            COALESCE(campus_remittance.net_remittance, 0) as net_remittance,
            COALESCE(campus_remittance.net_total, 0) as net_total,
            COALESCE(campus_remittance.manual_adjustment, 0) as manual_adjustment,
            COALESCE(campus_remittance.connectivity_fee, 0)
                + COALESCE(campus_remittance.payment_processing_fee, 0)
                + COALESCE(campus_remittance.monthly_lease, 0) as fees_before_tags,
            campus_remittance.details
            FROM (SELECT c.campus_title,
                c.campus_id,
                r.name,
                r.email,
                r.number_of_kiosks,
                r.client_type,
                r.sales_after_discount,
                r.sales_list_price,
                r.complimentary,
                r.freedom_pay,
                r.credit_card,
                r.monthly_lease,
                r.connectivity_fee,
                r.payment_processing_fee,
                --- new tag fee
                COALESCE(new_tags_obtained.total_price, 0) as tag_fee,
                COALESCE(new_tags_obtained.amount_total, 0)  as tags_got,
                r.tag_price,
                r.credit_card
                    - r.monthly_lease
                    - r.connectivity_fee
                    - r.payment_processing_fee
                    - COALESCE(new_tags_obtained.total_price, 0)
                    + r.manual_adjustment  as net_remittance,
                r.credit_card
                    - r.monthly_lease
                    - r.connectivity_fee
                    - r.payment_processing_fee
                    - COALESCE(new_tags_obtained.total_price, 0)
                    + r.manual_adjustment
                    + r.complimentary
                    + r.freedom_pay as net_total,
                r.manual_adjustment,
                r.details
                FROM (SELECT id as campus_id,
                    title as campus_title
                    FROM pantry.campus
                ) c
                LEFT JOIN (SELECT er.campus_title,
                    er.campus_id,
                    er.name,
                    er.email,
                    count(er.kiosk_id) as number_of_kiosks,
                    STRING_AGG(er.kiosk_id::text, ', ') as kiosk_id,
                    STRING_AGG(distinct(er.client_type), ', ') as client_type,
                    sum(er.credit_card) as credit_card,
                    sum(er.sales_after_discount) as sales_after_discount,
                    sum(er.sales_list_price) as sales_list_price,
                    sum(er.complimentary) as complimentary,
                    sum(er.freedom_pay) as freedom_pay,
                    sum(er.monthly_lease) as monthly_lease,
                    sum(er.connectivity_fee) as connectivity_fee,
                    sum(er.payment_processing_fee) as payment_processing_fee,
                    --- Per our meeting from https://bytetechnology.atlassian.net/browse/ENG-2291,
                    --- we decided to take the max tag_price for each campus.
                    --- All kiosks are supposed to have the same tag_price within
                    --- a campus, but that's not the case due to data entry errors.
                    max(er.tag_price) as tag_price,
                    sum(er.manual_adjustment) as manual_adjustment,
                    STRING_AGG(er.details, ' | ') as details
                    FROM dw.export_remittance(month_date) er
                    GROUP BY er.name, er.campus_id, er.campus_title, er.email
                ) r
                ON r.campus_id = c.campus_id
                LEFT JOIN
                --- Get the tag pricing / number of tags obtained
                --- for each campus using new Tags UI
                (WITH consolidated_tag_price AS
                (SELECT implicit_price.campus_id, implicit_price.tag_type,
                    COALESCE(explicit_price.price, implicit_price.price) price
                    FROM (SELECT c.id campus_id, tag_type, tp.price
                    FROM pantry.campus c, erp.tag_price tp
                    WHERE tp.campus_id = 0) implicit_price
                LEFT JOIN
                (SELECT c.id campus_id, tp.tag_type, tp.price
                   FROM pantry.campus c
                   JOIN erp.tag_price tp ON tp.campus_id = c.id) explicit_price
                   ON explicit_price.campus_id = implicit_price.campus_id
                   AND explicit_price.tag_type = implicit_price.tag_type)
                SELECT SUM(tag_order.amount)::int AS amount_total,
                   p.campus_id,
                   SUM(tag_order.amount * tp.price) AS total_price
                   FROM erp.tag_order
                   LEFT JOIN erp.tag_type tt ON tt.id = tag_order.tag_type_id
                   JOIN pantry.product p ON tag_order.product_id = p.id
                   JOIN pantry.campus c ON p.campus_id = c.id
                   JOIN consolidated_tag_price tp ON tt.type = tp.tag_type
                   AND tp.campus_id = p.campus_id
                WHERE status = 'fulfilled'
                AND process_ts >=  date_trunc('month', month_date::date)
                AND process_ts <  date_trunc('month', month_date::date + INTERVAL '1 month')
                GROUP BY p.campus_id
                ) AS new_tags_obtained
                ON new_tags_obtained.campus_id = c.campus_id
            ) as campus_remittance
            WHERE campus_remittance.sales_after_discount > 0 OR
            campus_remittance.complimentary > 0 OR
            campus_remittance.freedom_pay > 0 OR
            campus_remittance.credit_card > 0 OR
            campus_remittance.monthly_lease > 0 OR
            campus_remittance.connectivity_fee > 0 OR
            campus_remittance.payment_processing_fee > 0 OR
            campus_remittance.tag_fee > 0 OR
            campus_remittance.tags_got > 0 OR
            campus_remittance.tag_price > 0 OR
            campus_remittance.net_remittance > 0 OR
            campus_remittance.net_total > 0 OR
            campus_remittance.manual_adjustment > 0 OR
            campus_remittance.number_of_kiosks > 0
            ORDER BY campus_remittance.campus_id;
    END;
$$;


ALTER FUNCTION dw.export_consolidated_remittance(month_date date) OWNER TO erpuser;

--
-- Name: export_feedback(date, date); Type: FUNCTION; Schema: dw; Owner: erpuser
--

CREATE FUNCTION dw.export_feedback(beginning_date date, ending_date date) RETURNS TABLE(order_id character varying, created timestamp with time zone, first_name character varying, last_name character varying, amount_list_price numeric, amount_paid numeric, campus_id bigint, kiosk_id bigint, kiosk_title character varying, geo character varying, message character varying, rate bigint, taste bigint, freshness bigint, variety bigint, value bigint, product_id_list text, product_title_list text)
    LANGUAGE plpgsql
    AS $$
    BEGIN
        RETURN QUERY
        --- This query is used to get feedback for a given date range.
        --- The originial query is found
        --- https://github.com/PantryLabs/PantryWeb/blob/8bc2c5281de13cabfc2ad73fcec837d162bbb8b3/models/feedback.js#L55
        --- SEE ENG-1989
        SELECT o.order_id,
            to_timestamp(o.created) as created,
            c.first_name,
            c.last_name,
            o.amount_list_price,
            o.amount_paid,
            k.campus_id,
            k.id as kiosk_id,
            k.title as kiosk_title,
            k.geo,
            f.message,
            f.rate,
            COALESCE(f.taste, 0) as taste,
            COALESCE(f.freshness, 0) as freshness,
            COALESCE(f.variety, 0) as variety,
            COALESCE(f.value, 0) as value,
            STRING_AGG(p.id::text, '; ') product_id_list,
            STRING_AGG(p.title, '; ') product_title_list
            FROM pantry.feedback f
            JOIN pantry.order o ON o.order_id = f.order_id
            JOIN pantry.card c ON c.hash = o.card_hash
            JOIN pantry.kiosk k ON o.kiosk_id = k.id
            JOIN pantry.label l ON l.order_id = o.order_id
            JOIN pantry.product p ON p.id = l.product_id
            WHERE o.created BETWEEN extract('EPOCH' FROM (beginning_date)::timestamp WITH TIME ZONE)::BIGINT
                AND extract('EPOCH' FROM (ending_date + INTERVAL '1 day')::timestamp WITH TIME ZONE)::BIGINT
                 - 1
            GROUP BY o.created, k.campus_id, c.first_name, c.last_name, o.order_id, o.amount_list_price,
            o.amount_paid, k.id, k.title, k.geo, f.message, f.rate, f.taste, f.freshness, f.variety, f.value
            ORDER BY o.created DESC;
    END;
$$;


ALTER FUNCTION dw.export_feedback(beginning_date date, ending_date date) OWNER TO erpuser;

--
-- Name: FUNCTION export_feedback(beginning_date date, ending_date date); Type: COMMENT; Schema: dw; Owner: erpuser
--

COMMENT ON FUNCTION dw.export_feedback(beginning_date date, ending_date date) IS 'returns feedback info';


--
-- Name: export_kiosk_performance(date, date); Type: FUNCTION; Schema: dw; Owner: erpuser
--

CREATE FUNCTION dw.export_kiosk_performance(beginning_date date, ending_date date) RETURNS TABLE(kiosk_id bigint, kiosk_title character varying, campus_id bigint, campus_title character varying, geo character varying, client_name character varying, byte_discount character varying, subsidy_info character varying, subscription_amount numeric, amount_list_price numeric, credit_card numeric, food_cost numeric, spoilage numeric, losses numeric, margin numeric, deliveries numeric)
    LANGUAGE plpgsql
    AS $$
    BEGIN
        RETURN QUERY
        --- This query is used to give kiosk information for the given date range
        SELECT fd.kiosk_id,
            k.title as kiosk_title,
            k.campus_id,
            c.title as campus_title,
            k.geo,
            k.client_name,
            k.byte_discount,
            k.subsidy_info,
            k.subscription_amount,
            sum(sales_amt) as amount_list_price,
            sum(ip_commerce) as credit_card,
            sum(cost_amt) as food_cost,
            sum(spoils_amt) as spoilage,
            sum(losses_amt) as losses,
            k.subscription_amount + sum(sales_amt) - sum(cost_amt) - sum(spoils_amt) - sum(losses_amt)
                as margin,
            sum(deliv.deliveries) as deliveries
            FROM pantry.kiosk k
            JOIN dw.fact_daily_kiosk_sku_summary fd
            ON fd.kiosk_id = k.id
            JOIN pantry.campus c
            ON c.id = k.campus_id
            --- This subquery is used to get the number of deliveries for the given day
            LEFT JOIN (SELECT (TO_CHAR(route_date_time, 'YYYYMMDD'))::int as date_id,
                location_number,
                count(*) as deliveries
                FROM mixalot.route_stop rs
                WHERE route_date_time::date >= beginning_date
                AND route_date_time::date <= ending_date
                GROUP BY (TO_CHAR(route_date_time, 'YYYYMMDD'))::int, location_number
            ) as deliv
            ON fd.date_id = deliv.date_id
            AND fd.kiosk_id = deliv.location_number
            JOIN dw.dim_date as dd
            ON dd.date_id = fd.date_id
            WHERE as_date >= beginning_date
            AND as_date <= ending_date
            GROUP BY fd.kiosk_id, kiosk_title, k.campus_id, k.geo, k.client_name,
            k.subscription_amount, c.title, k.byte_discount, k.subsidy_info;
    END;
$$;


ALTER FUNCTION dw.export_kiosk_performance(beginning_date date, ending_date date) OWNER TO erpuser;

--
-- Name: export_kiosk_status(bigint); Type: FUNCTION; Schema: dw; Owner: erpuser
--

CREATE FUNCTION dw.export_kiosk_status(kiosk_number bigint) RETURNS TABLE(kiosk_id_ bigint, geo_ character varying, kiosk_temperature_ numeric, kiosk_temperature_count_ smallint, kiosk_temperature_source_ character varying, temperature_tags_ character varying, kit_temperature_ numeric, power_ integer, battery_level_ smallint, rfid_0_ integer, rfid_1_ integer, rfid_2_ integer, rfid_3_ integer, rfid_4_ integer, rfid_5_ integer, rfid_6_ integer, rfid_7_ integer, modem_signal_percentage_ smallint, modem_signal_type_ character varying, ip_ character varying, time_ timestamp with time zone)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
    --- This query is used to get the last 3 months worth of status.
    --- This original query is found here
    --- https://github.com/PantryLabs/PantryWeb/blob/8bc2c5281de13cabfc2ad73fcec837d162bbb8b3/models/kiosk-export.js#L10
    SELECT ks.kiosk_id as kiosk_id_ ,
        k.geo as geo_,
        ks.kiosk_temperature as kiosk_temperature_,
        ks.kiosk_temperature_count as kiosk_temperature_count_,
        ks.kiosk_temperature_source as kiosk_temperature_source_,
        ks.temperature_tags as temperature_tags_,
        ks.kit_temperature as kit_temperature_,
        ks.power as power_,
        ks.battery_level as battery_level_,
        ks.rfid_0 as rfid_0_,
        ks.rfid_1 as rfid_1_,
        ks.rfid_2 as rfid_2_,
        ks.rfid_3 as rfid_3_,
        ks.rfid_4 as rfid_4_,
        ks.rfid_5 as rfid_5_,
        ks.rfid_6 as rfid_6_,
        ks.rfid_7 as rfid_7_,
        ks.modem_signal_percentage as modem_signal_percentage_,
        ks.modem_signal_type as modem_signal_type_,
        ks.ip as ip_,
        to_timestamp(ks.time)::TIMESTAMP WITH TIME ZONE as time_
        FROM pantry.kiosk_status ks
        JOIN pantry.kiosk k ON k.id = ks.kiosk_id
        WHERE ks.kiosk_id = kiosk_number
        AND ks.time >= extract('EPOCH' FROM (now()::date - INTERVAL '3 months')::timestamp WITH TIME
        ZONE)::BIGINT
        ORDER BY ks.time DESC;
END;
$$;


ALTER FUNCTION dw.export_kiosk_status(kiosk_number bigint) OWNER TO erpuser;

--
-- Name: FUNCTION export_kiosk_status(kiosk_number bigint); Type: COMMENT; Schema: dw; Owner: erpuser
--

COMMENT ON FUNCTION dw.export_kiosk_status(kiosk_number bigint) IS 'returns kiosk status info';


--
-- Name: export_licensee_fee(date); Type: FUNCTION; Schema: dw; Owner: erpuser
--

CREATE FUNCTION dw.export_licensee_fee(month_date date) RETURNS TABLE(kiosk_id bigint, kiosk_title character varying, campus_id bigint, campus_title character varying, deployment_date date, fee_plan_name text, licensing_subscription_fee numeric, tag_price numeric, payment_processing_rate character varying, connectivity_fee numeric, prepaid_number_of_months bigint, prepaid_until character varying)
    LANGUAGE plpgsql
    AS $$
    BEGIN
        RETURN QUERY
        --- This query is used to get licensee fee summary
        --- SEE ENG-2103
        SELECT mk.kiosk_id,
            k.title as kiosk_title,
            k.campus_id,
            c.title as campus_title,
            to_timestamp(k.deployment_time)::date as deployment_date,
            mk.fee_plan_name,
            mk.licensing_subscription_fee,
            mk.tag_price,
            mk.payment_processing_rate,
            mk.connectivity_fee,
            mk.prepaid_number_of_months,
            mk.prepaid_until
            FROM dw.fact_monthly_kiosk_summary mk
            JOIN pantry.kiosk k
            ON mk.kiosk_id = k.id
            JOIN pantry.campus c
            ON c.id = k.campus_id
            WHERE mk.date_id = TO_CHAR(date_trunc('month', month_date ), 'YYYYMMDD')::int
            ORDER BY mk.kiosk_id;
    END;
$$;


ALTER FUNCTION dw.export_licensee_fee(month_date date) OWNER TO erpuser;

--
-- Name: export_losses(date, date); Type: FUNCTION; Schema: dw; Owner: erpuser
--

CREATE FUNCTION dw.export_losses(beginning_date date, ending_date date) RETURNS TABLE(as_date date, campus_id integer, campus_title character varying, kiosk_id bigint, kiosk_title character varying, product_id bigint, product_title character varying, menu_category character varying, product_group character varying, product_cost numeric, losses_qty integer, losses_cost numeric)
    LANGUAGE plpgsql
    AS $$
    BEGIN
        RETURN QUERY
        --- This query returns losses for the selected dates
        SELECT dd.as_date,
        fd.campus_id,
        c.title as campus_title,
        fd.kiosk_id,
        k.title as kiosk_title,
        fd.product_id,
        p.title as product_title,
        p.consumer_category as menu_category,
        p.fc_title as product_group,
        --- Cost is the current product cost
        p.cost as product_cost,
        fd.losses_qty,
        --- losses_amt is (product cost at the time of purchase) * (losses quantity).
        --- Note that losses_amt might not always equal (current product cost) * (losses quantity)
        --- if the product cost was different at the time of purchase.
        fd.losses_amt as losses_cost
        FROM dw.fact_daily_kiosk_sku_summary fd
        JOIN pantry.product p
        ON p.id = fd.product_id
        JOIN pantry.kiosk k
        ON k.id = fd.kiosk_id
        JOIN dw.dim_date dd
        ON dd.date_id = fd.date_id
        JOIN pantry.campus c
        ON c.id = fd.campus_id
        WHERE fd.losses_qty > 0
        AND dd.as_date >= beginning_date
        AND dd.as_date <= ending_date;
    END;
$$;


ALTER FUNCTION dw.export_losses(beginning_date date, ending_date date) OWNER TO erpuser;

--
-- Name: export_remittance(date); Type: FUNCTION; Schema: dw; Owner: erpuser
--

CREATE FUNCTION dw.export_remittance(month_date date) RETURNS TABLE(name character varying, email character varying, account_type text, kiosk_id bigint, kiosk_title character varying, campus_id bigint, campus_title character varying, deployment_time timestamp with time zone, payment_start timestamp with time zone, client_type text, sales_after_discount numeric, sales_list_price numeric, credit_card numeric, monthly_lease numeric, connectivity_fee numeric, payment_processing_fee numeric, manual_adjustment numeric, prepaid_until character varying, freedom_pay numeric, complimentary numeric, tag_price numeric, details text)
    LANGUAGE plpgsql
    AS $$
    BEGIN
        RETURN QUERY
        --- This query is used to get remittance info by kiosk
        SELECT g.name,
            u.email,
            fee_plan_name as account_type,
            mk.kiosk_id,
            k.title as kiosk_title,
            k.campus_id,
            c.title as campus_title,
            to_timestamp(k.deployment_time) deployment_time,
            to_timestamp(k.payment_start) payment_start,
            CASE WHEN a.prepaid = 0
                    THEN 'Monthly'
                WHEN prepaid > 0
                    THEN 'Pre-paid'
                END as client_type,
            mk.sales_after_discount,
            mk.sales_list_price,
            mk.credit_card,
            mk.monthly_lease as monthly_lease,
            mk.connectivity_fee,
            mk.payment_processing_fee,
            mk.manual_adjustment,
            mk.prepaid_until,
            mk.freedom_pay,
            mk.complimentary,
            mk.tag_price,
            mk.details
            FROM dw.fact_monthly_kiosk_summary mk
            LEFT JOIN pantry.group_campus gc
            ON gc.campus_id = mk.campus_id
            LEFT JOIN pantry.group g
            ON gc.group_id = g.id
            LEFT JOIN pantry.kiosk k
            ON k.id = mk.kiosk_id
            LEFT JOIN pantry.campus c
            ON c.id = k.campus_id
            JOIN dw.dim_date dd
            ON dd.date_id = mk.date_id
            -- The following subquery is used to get users' info.
            -- Because there are duplicated users per each first_name, last_name, role_id, group_id
            --- combination, we filter for the most recent user created with the highest role.
            LEFT JOIN (SELECT ranked_duplicated_users.name,
                user_id,
                ranked_duplicated_users.email,
                group_id
                -- Use the window function to group duplicate user names (partition by g.name)
                -- and rank them by descending role_id and descending date_registered
                FROM (SELECT g.name,
                    u.group_id,
                    u.id user_id,
                    u.email,
                    u.role_id,
                    u.date_registered,
                    rank() over (partition by g.name order by u.role_id desc,
                        u.date_registered desc) r
                    FROM pantry.user u
                    JOIN pantry.group g
                    on concat(u.first_name, ' ', u.last_name) = g.name AND g.id = u.group_id
                ) as ranked_duplicated_users
                -- filter out all but the top rank
                where r = 1
            ) u
            ON u.name = g.name
            AND gc.group_id = u.group_id
            LEFT JOIN pantry.accounting a
            ON a.kiosk_id = mk.kiosk_id
            AND TO_CHAR(date_trunc('month', as_date) + interval '1' day, 'YYYY-MM-fmDD') = a.date
            WHERE gc.owner = 1
            AND mk.date_id = TO_CHAR(date_trunc('month', month_date::date)::date, 'YYYYMMDD')::int
            GROUP BY g.name, fee_plan_name, mk.kiosk_id, k.title, k.campus_id, k.payment_start,
            mk.credit_card, mk.monthly_lease, mk.connectivity_fee, mk.payment_processing_fee,
            mk.manual_adjustment, a.prepaid, k.deployment_time, c.title, u.email,
            mk.sales_after_discount, mk.sales_list_price, mk.freedom_pay, mk.complimentary,
            mk.prepaid_until, mk.tag_price, mk.details
            ORDER BY name;
    END;
$$;


ALTER FUNCTION dw.export_remittance(month_date date) OWNER TO erpuser;

--
-- Name: export_spoilage(date, date); Type: FUNCTION; Schema: dw; Owner: erpuser
--

CREATE FUNCTION dw.export_spoilage(beginning_date date, ending_date date) RETURNS TABLE(as_date date, campus_id integer, campus_title character varying, kiosk_id bigint, kiosk_title character varying, product_id bigint, product_title character varying, menu_category character varying, product_group character varying, product_cost numeric, spoils_qty integer, spoilage_cost numeric)
    LANGUAGE plpgsql
    AS $$
    BEGIN
        RETURN QUERY
        --- This query returns spoilage for the selected dates
        SELECT dd.as_date,
            fd.campus_id,
            c.title as campus_title,
            fd.kiosk_id,
            k.title as kiosk_title,
            fd.product_id,
            p.title as product_title,
            p.consumer_category as menu_category,
            p.fc_title as product_group,
            --- Cost is the current product cost
            p.cost as product_cost,
            fd.spoils_qty,
            --- spoils_amt is (product cost at the time of purchase) * (spoils quantity).
            --- Note that spoils_amt might not always equal (current product cost) * (spoils quantity)
            --- if the product cost was different at the time of purchase.
            fd.spoils_amt as spoilage_cost
            FROM dw.fact_daily_kiosk_sku_summary fd
            JOIN pantry.product p
            ON p.id = fd.product_id
            JOIN pantry.kiosk k
            ON k.id = fd.kiosk_id
            JOIN dw.dim_date dd
            ON dd.date_id = fd.date_id
            JOIN pantry.campus c
            ON c.id = fd.campus_id
            WHERE fd.spoils_qty > 0
            AND dd.as_date >= beginning_date
            AND dd.as_date <= ending_date;
    END;
$$;


ALTER FUNCTION dw.export_spoilage(beginning_date date, ending_date date) OWNER TO erpuser;

--
-- Name: export_transaction(timestamp without time zone, timestamp without time zone, character varying); Type: FUNCTION; Schema: dw; Owner: erpuser
--

CREATE FUNCTION dw.export_transaction(beginning_date timestamp without time zone, ending_date timestamp without time zone, time_zone character varying) RETURNS TABLE(order_id character varying, date_time timestamp with time zone, state character varying, campus_title character varying, campus_id bigint, client_name character varying, kiosk_title character varying, kiosk_id bigint, uid bigint, email character varying, customer_first_name character varying, customer_last_name character varying, vendor character varying, product_tile character varying, sku bigint, menu_category character varying, product_group character varying, qty bigint, total_list_price numeric, price_after_discounts numeric, total_price_after_discounts numeric, total_coupon_value numeric, total_cost numeric, margin numeric, credit_card text, credit_card_number text, approval_code character varying, geo character varying, coupon_code character varying, coupon_campaign character varying, time_door_closed bigint, time_door_opened bigint)
    LANGUAGE plpgsql
    AS $_$
    BEGIN
        RETURN QUERY
        --- This query returns a list of transactions for the selected date range
        SELECT o.order_id,
            to_timestamp(o.created) as date_time,
            case when o.status = 'Declined' then 'Declined' else o.state end as state,
            c.title as campus_title,
            k.campus_id,
            k.client_name as client_name,
            k.title as kiosk_title,
            o.kiosk_id,
            ca.id as uid,
            o.email,
            o.first_name as customer_first_name,
            o.last_name as customer_last_name,
            p.vendor,
            p.title as product_tile,
            l.product_id as sku,
            COALESCE(
                p.consumer_category,
                STRING_AGG(DISTINCT p_tags.pc_categories, ',')
            ) as menu_category,
            COALESCE(
                p.fc_title,
                STRING_AGG(DISTINCT p_tags.tag_names, ',')
            ) as product_group,
            count(l.epc) as qty,
            sum(COALESCE(ph.price, p.price,0)) as total_list_price,
            --- Price after discount = l.price - discounts
            --- Set price to zero if it is negative.
            GREATEST(COALESCE((l.price),0) - COALESCE((CASE WHEN real_discount != 0 AND real_discount
                IS NOT NULL THEN real_discount ELSE  flat_discount END), 0), 0) as
                price_after_discounts,
            --- Total price after discount. For example, if more than 1 of the item was purchased
            --- Set total to zero if it is negative.
            GREATEST(COALESCE(sum(l.price),0) - COALESCE(sum(CASE WHEN real_discount != 0 AND real_discount
                IS NOT NULL THEN real_discount ELSE  flat_discount END), 0), 0) as
                total_after_discounts,
            --- Total $ coupon value
            COALESCE(sum(CASE WHEN real_discount != 0 AND real_discount
                IS NOT NULL THEN real_discount ELSE  flat_discount END), 0) as total_coupon_value,
            (l.cost * count(l.epc)) as total_cost,
            sum(COALESCE(ph.price, p.price,0)) - (l.cost * count(l.epc)) as margin,
            CASE WHEN payment_system = 'IPCommerce' OR payment_system =  'Express'
                THEN 'Y' ELSE 'N' END as credit_card,
            RIGHT(ca.number, 4) as credit_card_number,
            o.approval_code as approval_code,
            k.geo,
            o.coupon as coupon_code,
            co.campaign as coupon_campaign,
            o.time_door_closed,
            o.time_door_opened
            FROM pantry.order o
            LEFT JOIN pantry.label l ON l.order_id = o.order_id
            LEFT JOIN pantry.kiosk k ON k.id = o.kiosk_id
            LEFT JOIN pantry.campus c ON c.id = k.campus_id
            LEFT JOIN pantry.card ca ON ca.hash = o.card_hash
            LEFT JOIN pantry.product p ON p.id = l.product_id
            LEFT JOIN pantry.coupon co ON co.id = o.coupon_id
            LEFT JOIN pantry.product_history ph ON ph.product_id = p.id
                AND o.created >= ph.start_time AND (ph.end_time IS NULL OR o.created < ph.end_time)
            LEFT JOIN (
                SELECT p.id, 
                STRING_AGG(DISTINCT pc.cat_name, ',') AS pc_categories,
                STRING_AGG(DISTINCT t.tag, ',') as tag_names
                FROM pantry.product p 
                JOIN pantry.tag t ON t.id::text=any(string_to_array(p.categories, ','))
                JOIN pantry.product_categories pc ON string_to_array(pc.tags, ',') && string_to_array(p.categories, ',')
                GROUP BY p.id
            ) p_tags ON p_tags.id = p.id
            WHERE to_timestamp(o.created) AT TIME ZONE time_zone >= beginning_date
            AND to_timestamp(o.created) AT TIME ZONE time_zone <= ending_date
            GROUP BY o.order_id, k.id, c.title, ca.id, p.id, l.product_id, l.cost,
            co.campaign, l.price, co.real_discount, co.flat_discount,
            p_tags.pc_categories, p_tags.tag_names;
    END;
$_$;


ALTER FUNCTION dw.export_transaction(beginning_date timestamp without time zone, ending_date timestamp without time zone, time_zone character varying) OWNER TO erpuser;

--
-- Name: export_unconsolidated_remittance(date); Type: FUNCTION; Schema: dw; Owner: erpuser
--

CREATE FUNCTION dw.export_unconsolidated_remittance(month_date date) RETURNS TABLE(campus_title character varying, campus_id bigint, kiosk_id bigint, kiosk_title character varying, client_type text, deployment_date date, sales_after_discount numeric, sales_list_price numeric, credit_card numeric, freedom_pay numeric, complimentary numeric, monthly_lease numeric, connectivity_fee numeric, payment_processing_fee numeric, manual_adjustment numeric, details text, prepaid_until character varying, fees_before_tags numeric, net_total_before_tags numeric)
    LANGUAGE plpgsql
    AS $$
    BEGIN
        RETURN QUERY
        SELECT r.campus_title,
            r.campus_id,
            r.kiosk_id,
            r.kiosk_title,
            r.client_type,
            deployment_time::date as deployment_date,
            r.sales_after_discount,
            r.sales_list_price,
            r.credit_card,
            r.freedom_pay,
            r.complimentary,
            r.monthly_lease,
            r.connectivity_fee,
            r.payment_processing_fee,
            r.manual_adjustment,
            r.details,
            r.prepaid_until,
            r.connectivity_fee + r.payment_processing_fee + r.monthly_lease  as fees_before_tags,
            r.credit_card - r.connectivity_fee - r.payment_processing_fee - r.monthly_lease
                + r.manual_adjustment + r.freedom_pay + r.complimentary
                as net_total_before_tags
            FROM dw.export_remittance(month_date) r;
    END;
$$;


ALTER FUNCTION dw.export_unconsolidated_remittance(month_date date) OWNER TO erpuser;

--
-- Name: insert_hb_stat_in_daily_byte_foods_summary(date, date); Type: FUNCTION; Schema: dw; Owner: erpuser
--

CREATE FUNCTION dw.insert_hb_stat_in_daily_byte_foods_summary(beginning_date date, ending_date date) RETURNS void
    LANGUAGE plpgsql
    AS $$
    BEGIN
        INSERT INTO dw.fact_daily_byte_foods_summary(
            date_id,
            fridge_uptime,
            major_fridge_outages)
        (/* A fridge's heart beat is recorded in pantry.status every 10 minutes. In a day, each
        kiosk should have a total of 144 heart beats. If a kiosk has 126 heart beats or less, it's
        considered a major outage. This query is used to calculate Byte Foods fridges major outages
        per day and kiosk uptime.
        Kiosk uptime  = total heart beats / (number of kiosks * 144)
        */
        SELECT (TO_CHAR(datee, 'YYYYMMDD'))::int as date_id,
            sum(heart_beat) / ( (count(DISTINCT kiosk_id)) * 144 ) as fridge_uptime,
            sum(if(heart_beat < (126), 1, 0)) as major_fridge_outages
            --- This subquery is used to get the number of heart beats per kiosk
            FROM (SELECT date as datee,
                kiosk_id,
                count(DISTINCT ts_10min) as heart_beat
                FROM kiosk_status
                JOIN pantry.kiosk
                ON kiosk.id = kiosk_status.kiosk_id
                WHERE ts_10min::date >= beginning_date
                AND ts_10min::date <= ending_date
                AND kiosk.campus_id = 87
                AND kiosk.enable_reporting = 1
                GROUP BY kiosk_status.date, kiosk_status.kiosk_id
            ) as byte_heart_beat_by_kiosk
            GROUP BY datee
        )
        ON CONFLICT (date_id) DO UPDATE
        SET (fridge_uptime, major_fridge_outages) =
        (excluded.fridge_uptime, excluded.major_fridge_outages);
    END;
$$;


ALTER FUNCTION dw.insert_hb_stat_in_daily_byte_foods_summary(beginning_date date, ending_date date) OWNER TO erpuser;

--
-- Name: FUNCTION insert_hb_stat_in_daily_byte_foods_summary(beginning_date date, ending_date date); Type: COMMENT; Schema: dw; Owner: erpuser
--

COMMENT ON FUNCTION dw.insert_hb_stat_in_daily_byte_foods_summary(beginning_date date, ending_date date) IS 'inserts heart beat info in dw.fact_daily_byte_foods_summary';


--
-- Name: insert_in_monthly_kiosk_summary(date); Type: FUNCTION; Schema: dw; Owner: muriel
--

CREATE FUNCTION dw.insert_in_monthly_kiosk_summary(month_date date) RETURNS void
    LANGUAGE plpgsql
    AS $_$
    BEGIN
        INSERT INTO dw.fact_monthly_kiosk_summary(
            campus_id,
            kiosk_id,
            date_id,
            fee_plan_name,
            prepaid_number_of_months,
            prepaid_until,
            licensing_subscription_fee,
            tag_price,
            payment_processing_rate,
            sales_list_price,
            sales_after_discount,
            food_cost,
            credit_card ,
            freedom_pay,
            complimentary,
            monthly_lease,
            payment_processing_fee,
            connectivity_fee,
            manual_adjustment,
            details
        )
        (SELECT distinct monthly_report.campus_id,
            monthly_report.kiosk_id,
            monthly_report.date_id,
            monthly_report.fee_plan_name,
            monthly_report.prepaid_number_of_months,
            monthly_report.prepaid_until,
            monthly_report.licensing_subscription_fee,
            monthly_report.tag_price,
            monthly_report.payment_processing_rate,
            monthly_report.sales_list_price,
            monthly_report.sales_after_discount,
            monthly_report.food_cost,
            monthly_report.credit_card ,
            monthly_report.freedom_pay,
            monthly_report.complimentary,
            monthly_report.monthly_lease,
            monthly_report.payment_processing_fee,
            monthly_report.connectivity_fee,
            monthly_report.manual_adjustment,
            monthly_report.details
            FROM (SELECT
                kiosks.campus_id,
                kiosks.kiosk_id,
                TO_CHAR(date_trunc('month', month_date::date)::date, 'YYYYMMDD')::int AS date_id,
                fee_plan_name,
                prepaid_number_of_months,
                prepaid_until,
                licensing_subscription_fee,
                tag_price,
                payment_processing_rate,
                COALESCE(amount_list_price, 0) as sales_list_price,
                COALESCE(sales_after_discount, 0) as sales_after_discount,
                COALESCE(food_cost, 0) as food_cost,
                COALESCE(ip_commerce, 0) as credit_card ,
                COALESCE(freedom_pay, 0) as freedom_pay,
                COALESCE(complimentary, 0) as complimentary,
                COALESCE(monthly_lease, 0) as monthly_lease,
                COALESCE(ROUND((ip_commerce * fee_ipc)::numeric, 2), 0) as payment_processing_fee,
                COALESCE(connectivity, 0) as connectivity_fee,
                COALESCE(manual_adjustment, 0) as manual_adjustment,
                details
                --- Get all kiosks
                FROM (SELECT id as kiosk_id,
                    campus_id
                    FROM pantry.kiosk
                ) as kiosks
                --- The following query is used to get sales totals from the daily fact table at
                --- a kiosk level
                LEFT JOIN (SELECT campus_id,
                    kiosk_id,
                    SUM(sales_amt) as amount_list_price,
                    SUM(cost_amt) as food_cost,
                    SUM(ip_commerce) as ip_commerce,
                    SUM(freedom_pay)  as freedom_pay,
                    SUM(complimentary) as complimentary,
                    SUM(sales_after_discount) as sales_after_discount
                    FROM dw.fact_daily_kiosk_sku_summary daily
                    JOIN dw.dim_date as dd
                    ON dd.date_id = daily.date_id
                    WHERE as_date >= date_trunc('month', month_date::date)::date
                    AND as_date <= (date_trunc('month', month_date::date) + interval '1 month'
                        -  interval '1 day' )::date
                    GROUP BY kiosk_id, campus_id
                ) as amount_list_price
                ON kiosks.kiosk_id = amount_list_price.kiosk_id
                --- The following subquery is used to get manual adjustments at a kiosk level
                LEFT JOIN (SELECT kiosk_id,
                    campus_id,
                    sum(sum) as manual_adjustment,
                    --- A list of all manual adjustments along with the reasons and kiosk
                    STRING_AGG( CASE WHEN sum IS NOT NULL
                        THEN CONCAT(
                            --- Add a $ in front of the sum. If it's a negative number, add the
                            --- sign after the "-"
                            CASE WHEN SIGN(SUM) = 1
                                THEN CONCAT('$', SUM)
                                WHEN SIGN(SUM) = -1
                                THEN CONCAT('-$', -SUM)
                                END,
                            ' ',
                            reason,
                            ' (for kiosk "', k.title, '")') END
                        , ' | ' ) as details
                    FROM pantry.manual_adjustment ma
                    JOIN pantry.kiosk k
                    ON ma.kiosk_id = k.id
                    --- date in pantry.manual_adjustment is not an actual date. It’s a period
                    --- accounting numbers were calculated for with format: "YYYY-MM-H".
                    --- H can be either "1" for the first half of month and "2" for the entire month
                    WHERE date = TO_CHAR(date_trunc('month', month_date::date) + interval '1' day,
                        'YYYY-MM-fmDD')
                    AND ma.archived = 0
                    GROUP BY campus_id, kiosk_id
                ) as manual_adjust
                ON manual_adjust.kiosk_id = kiosks.kiosk_id
                --- The following subquery is used to get the monthly_lease and connectivity
                --- at a kiosk level for all kiosks that were deployed before or at
                --- the remittance month.
                LEFT JOIN (SELECT deployed_kiosks.kiosk_id,
                    deployed_kiosks.campus_id,
                    COALESCE(monthly_lease, 0) as monthly_lease,
                    COALESCE(connectivity, 0) as connectivity
                    --- ALl kiosks deployed at or before the remittance month
                    FROM (SELECT id as kiosk_id,
                        campus_id
                        FROM pantry.kiosk
                        WHERE to_timestamp(deployment_time)::date <=
                        --- the last day of the given month
                        (date_trunc('month', month_date) + interval '1 month'
                            - interval '1 day')::date
                    ) as deployed_kiosks
                    LEFT JOIN (SELECT kiosk_id,
                        campus_id,
                        monthly_lease,
                        connectivity
                        FROM (SELECT a.campus_id,
                            kiosk_id,
                            --- If prepaid = 0, get the monthly_lease. Prepaid represents the amount
                            --- of months  already paid for at the time. If prepaid is greater than
                            --- 1, then the client pays $0 for the given month. The monthly_lease
                            --- obtained from dw.calculate_prorated_fee returns fee_lease if the
                            --- deployment_time != the current month, otherwise, it calculates
                            --- and returns the prorated fee based on deployment_time.
                            (SELECT prorated_fee FROM dw.calculate_prorated_fee(fee_lease,
                                month_date, to_timestamp(k.deployment_time)::date))
                                as monthly_lease,
                            --- If the deployment date was this month, prorate the connectivity fee,
                            --- if not, give the normal fee
                            (SELECT prorated_fee FROM dw.calculate_prorated_fee(fee_connectivity,
                                month_date, to_timestamp(k.deployment_time)::date))
                                as connectivity
                            FROM pantry.accounting a
                            JOIN pantry.fee_rates r
                            ON a.current_fee = r.id
                            AND a.prepaid = 0
                            JOIN pantry.kiosk k
                            ON k.id = a.kiosk_id
                            WHERE a.date = TO_CHAR(date_trunc('month', month_date::date) +
                                interval '1' day, 'YYYY-MM-fmDD')
                        ) as fee_lease
                    ) as all_lease
                    ON all_lease.kiosk_id = deployed_kiosks.kiosk_id
                ) as lease
                ON lease.kiosk_id = kiosks.kiosk_id
                --- The following subquery is used to get other kiosk related fees and info
                LEFT JOIN (SELECT kiosk_id,
                    a.campus_id,
                    r.name as fee_plan_name,
                    a.prepaid as prepaid_number_of_months,
                    --- licensing_subscription_fee is the set regular licensing fee for each kiosk.
                    --- This is different from monthly_lease which is the re-calculated licensing
                    --- fee for a given month. This means that the monhtly_lease
                    --- can be different for any two given months while the
                    --- licensing_subscription_fee is set.
                    fee_lease as licensing_subscription_fee,
                    r.fee_tags as tag_price,
                    CONCAT(ROUND(fee_ipc * 100, 2), '%') as payment_processing_rate,
                    --- prepaid_until = month_date + the number of months left
                    --- a.prepaid represents the number of months paid in advance, including the
                    --- current month.
                    CASE WHEN a.prepaid = 0
                        THEN '_'
                        ELSE TO_CHAR((month_date + (a.prepaid - 1 || ' MONTH')::INTERVAL),
                            'MM/DD/YYYY')
                        END as prepaid_until,
                    fee_ipc
                    FROM pantry.accounting a
                    JOIN pantry.fee_rates r
                    ON a.current_fee = r.id
                    LEFT JOIN pantry.kiosk k
                    ON a.kiosk_id = k.id
                    --- date in pantry.accounting is not an actual date. It’s a period accounting
                    --- numbers  were calculated for with format: "YYYY-MM-H".
                    --- H can be either "1" for the first half of month and "2" for the entire month
                    WHERE a.date = TO_CHAR(date_trunc('month', month_date::date)
                        + interval '1' day, 'YYYY-MM-fmDD')
                    GROUP BY a.campus_id, kiosk_id, r.name, a.prepaid, a.prepaid_day, fee_lease,
                        r.fee_tags, fee_ipc,
                        to_timestamp(k.deployment_time)::date
                ) as charge
                ON kiosks.kiosk_id = charge.kiosk_id
            ) as monthly_report
            WHERE licensing_subscription_fee > 0 OR
            tag_price > 0 OR
            sales_list_price > 0 OR
            sales_after_discount > 0 OR
            food_cost > 0 OR
            credit_card > 0 OR
            freedom_pay > 0 OR
            complimentary > 0 OR
            monthly_lease > 0 OR
            payment_processing_fee > 0 OR
            connectivity_fee > 0 OR
            manual_adjustment > 0
        )
        ON CONFLICT (campus_id, kiosk_id, date_id) DO UPDATE
        SET (sales_list_price,
            sales_after_discount,
            food_cost,
            credit_card ,
            freedom_pay,
            complimentary,
            monthly_lease,
            payment_processing_fee,
            connectivity_fee,
            manual_adjustment,
            fee_plan_name,
            prepaid_number_of_months,
            prepaid_until,
            licensing_subscription_fee,
            tag_price,
            payment_processing_rate,
            details
        ) = (excluded.sales_list_price,
            excluded.sales_after_discount,
            excluded.food_cost,
            excluded.credit_card ,
            excluded.freedom_pay,
            excluded.complimentary,
            excluded.monthly_lease,
            excluded.payment_processing_fee,
            excluded.connectivity_fee,
            excluded.manual_adjustment,
            excluded.fee_plan_name,
            excluded.prepaid_number_of_months,
            excluded.prepaid_until,
            excluded.licensing_subscription_fee,
            excluded.tag_price,
            excluded.payment_processing_rate,
            excluded.details);
    END;
$_$;


ALTER FUNCTION dw.insert_in_monthly_kiosk_summary(month_date date) OWNER TO muriel;

--
-- Name: FUNCTION insert_in_monthly_kiosk_summary(month_date date); Type: COMMENT; Schema: dw; Owner: muriel
--

COMMENT ON FUNCTION dw.insert_in_monthly_kiosk_summary(month_date date) IS 'inserts key metrics in dw.fact_monthly_kiosk_summary';


--
-- Name: insert_inv_snapshot_in_daily_byte_foods_summary(date, date); Type: FUNCTION; Schema: dw; Owner: erpuser
--

CREATE FUNCTION dw.insert_inv_snapshot_in_daily_byte_foods_summary(beginning_date date, ending_date date) RETURNS void
    LANGUAGE plpgsql
    AS $$
    BEGIN
        INSERT INTO dw.fact_daily_byte_foods_summary(
            date_id,
            inventory_units,
            inventory_amt_list,
            inventory_kiosks,
            avg_inventory_units,
            avg_inventory_dollar)
        (/* This query is used to get inventory info for all byte foods fridges at 10 am. This
        includes:
            - a count of all items
            - the total price of all items
            - the number of kiosks involved
            - the average amount of items per kiosk
            - the average amount list price per kiosk */
        SELECT date_id,
            sum(qty) as inventory_units,
            sum(total_price) as inventory_amt_list,
            count(distinct(kiosk_id)) as inventory_kiosks,
            sum(qty) / count(distinct(kiosk_id)) as avg_inventory_units,
            ROUND (sum(total_price) / count(distinct(kiosk_id)), 2) as avg_inventory_dollar
            FROM (SELECT (TO_CHAR(to_timestamp(time)::date, 'YYYYMMDD'))::int as date_id,
                kiosk_id,
                qty,
                (qty * price) as total_price
                FROM pantry.inventory_history ih
                JOIN pantry.kiosk k ON k.id = ih.kiosk_id
                JOIN pantry.product p ON ih.product_id = p.id
                WHERE to_timestamp(time)::date >= beginning_date
                AND to_timestamp(time)::date <= ending_date
                AND extract(hour from to_timestamp(ih.time))= '10'
                AND k.campus_id = 87
                AND k.enable_reporting = 1
                ORDER BY ih.kiosk_id, ih.product_id
            ) as inv
            GROUP BY date_id
        )
        ON CONFLICT (date_id) DO UPDATE
        SET (inventory_units, inventory_amt_list, inventory_kiosks, avg_inventory_units, avg_inventory_dollar) =
        (excluded.inventory_units, excluded.inventory_amt_list, excluded.inventory_kiosks,
        excluded.avg_inventory_units, excluded.avg_inventory_dollar);
    END;
$$;


ALTER FUNCTION dw.insert_inv_snapshot_in_daily_byte_foods_summary(beginning_date date, ending_date date) OWNER TO erpuser;

--
-- Name: FUNCTION insert_inv_snapshot_in_daily_byte_foods_summary(beginning_date date, ending_date date); Type: COMMENT; Schema: dw; Owner: erpuser
--

COMMENT ON FUNCTION dw.insert_inv_snapshot_in_daily_byte_foods_summary(beginning_date date, ending_date date) IS 'inserts 10am inventory snapshot in dw.fact_daily_byte_foods_summary';


--
-- Name: insert_losses_in_daily_kiosk_sku_summary(date, date); Type: FUNCTION; Schema: dw; Owner: muriel
--

CREATE FUNCTION dw.insert_losses_in_daily_kiosk_sku_summary(beginning_date date, ending_date date) RETURNS void
    LANGUAGE plpgsql
    AS $$
    BEGIN
     INSERT INTO dw.fact_daily_kiosk_sku_summary(
        campus_id,
        kiosk_id,
        product_id,
        date_id,
        losses_qty,
        losses_amt
        )
        (--- Byte losses
        SELECT campus_id,
            kiosk_id,
            product_id,
            (TO_CHAR(time_updated, 'YYYYMMDD'))::int AS date_id,
            COUNT(*) AS losses_qty,
            SUM(cost) AS losses_amt
            FROM dw.byte_losses(beginning_date, ending_date) bl
            LEFT JOIN pantry.kiosk k
            ON bl.kiosk_id = k.id
            GROUP BY kiosk_id, product_id, date_id, campus_id
        UNION ALL
        --- Non-Byte losses
         SELECT campus_id,
            kiosk_id,
            product_id,
            (TO_CHAR(time_updated, 'YYYYMMDD'))::int AS date_id,
            COUNT(*) AS losses_qty,
            SUM(cost) AS losses_amt
            FROM dw.non_byte_losses(beginning_date, ending_date) bl
            LEFT JOIN pantry.kiosk k
            ON bl.kiosk_id = k.id
            GROUP BY kiosk_id, product_id, date_id, campus_id
        )
        ON CONFLICT (campus_id, product_id, kiosk_id, date_id) DO UPDATE
        SET (losses_qty, losses_amt) =
        (excluded.losses_qty, excluded.losses_amt);
END;
$$;


ALTER FUNCTION dw.insert_losses_in_daily_kiosk_sku_summary(beginning_date date, ending_date date) OWNER TO muriel;

--
-- Name: FUNCTION insert_losses_in_daily_kiosk_sku_summary(beginning_date date, ending_date date); Type: COMMENT; Schema: dw; Owner: muriel
--

COMMENT ON FUNCTION dw.insert_losses_in_daily_kiosk_sku_summary(beginning_date date, ending_date date) IS 'inserts losses in dw.fact_daily_kiosk_sku_summary';


--
-- Name: insert_sales_after_discount_in_daily_kiosk_sku_summary(date, date); Type: FUNCTION; Schema: dw; Owner: erpuser
--

CREATE FUNCTION dw.insert_sales_after_discount_in_daily_kiosk_sku_summary(beginning_date date, ending_date date) RETURNS void
    LANGUAGE plpgsql
    AS $_$
    BEGIN
        INSERT INTO dw.fact_daily_kiosk_sku_summary(
            campus_id,
            kiosk_id,
            product_id,
            date_id,
            ip_commerce,
            freedom_pay,
            card_smith,
            complimentary,
            sales_after_discount
        )
        (SELECT campus_id,
            kiosk_id,
            product_id,
            date_id,
            sum(ipcommerce) as ipcommerce,
            sum(freedomPay) as freedomPay,
            sum(CardSmith) as cardSmith,
            sum(Complimentary) as complimentary,
            sum(sales_after_discount) as sales_after_discount
            FROM (SELECT  kiosk_campus_id as campus_id,
                kiosk_id,
                product_id,
                date_id,
                CASE WHEN payment_system = 'IPCommerce' OR payment_system =  'Express'
                    THEN sum(price) END as ipcommerce,
                CASE WHEN payment_system = 'FreedomPay'
                    THEN sum(price) END as freedomPay,
                CASE WHEN payment_system = 'CardSmith'
                    THEN sum(price) END as cardSmith,
                CASE WHEN payment_system = 'Complimentary' OR payment_system = 'Nursing'
                    THEN sum(price) END as complimentary,
                CASE WHEN payment_system = 'Complimentary'
                    OR payment_system =  'Express'
                    OR payment_system = 'FreedomPay'
                    OR payment_system = 'CardSmith'
                    OR payment_system = 'Nursing'
                    THEN sum(price) END as sales_after_discount
                --- The following subquery is used to get the total amount of $ customers paid. Unlike
                --- sales_amount_list_price, which is the price tag on an item, this query factors in all discounts
                --- and coupons applied to a sale. The price on the label table already includes all
                --- coupons. Discounts need to be subtracted from the total label.price.
                --- In addition, this query only filters for order states
                --- ('Placed', 'Processed' ,'Refunded' ) and label status 'sold' OR order state 'PriceFinalized'
                --- and payment_system  'Complimentary'. The reason is because
                --- those are the only orders that generated a payment. Amount_list_price on the other
                --- hand, includes other states regardless of if we received a payment or not.
                --- Also see ENG-1922 and
                --- https://docs.google.com/presentation/d/1A9xYMop8u1NR6O5DmcYK8asauV9R-0eiXNiyKpUb6dQ/edit#slide=id.p
                FROM (SELECT (TO_CHAR(date_, 'YYYYMMDD'))::int AS date_id,
                    kiosk_id,
                    product_id,
                    kiosk_campus_id,
                    payment_system,

                    -- make sure price after discount is at least zero
                    GREATEST(
                      COALESCE(sum(price),0) - COALESCE(sum(CASE WHEN real_discount != 0 AND real_discount
                        IS NOT NULL THEN real_discount ELSE  flat_discount END), 0),
                      0)
                      AS price

                    FROM (SELECT payment_system,
                        to_timestamp(created)::date as date_,
                        COALESCE(l.cost) as cost,
                        COALESCE(l.price) as price,
                        l.kiosk_id,
                        l.product_id,
                        k.campus_id as kiosk_campus_id,
                        k.enable_reporting,
                        co.real_discount,
                        co.flat_discount
                        FROM pantry.label l
                        JOIN pantry.kiosk k
                        ON k.id = l.kiosk_id
                        JOIN pantry.product p
                        ON p.id = l.product_id
                        JOIN pantry.order o
                        ON o.order_id = l.order_id
                        LEFT JOIN pantry.coupon co
                        ON co.id = o.coupon_id
                        --- Between the first second of the month and the last second of the month
                        WHERE created BETWEEN extract('EPOCH' FROM (beginning_date::date))::BIGINT
                        AND extract('EPOCH' FROM (ending_date::date + interval '1 day'))::BIGINT - 1
                        AND o.state in ('Processed', 'Refunded')
                        AND l.status = 'sold'
                   )  as amount_paid_without_discount
                    GROUP BY payment_system, kiosk_id, product_id, kiosk_campus_id, date_id
                ) as amount_paid_with_discounts
                GROUP BY kiosk_campus_id, kiosk_id, product_id, date_id, payment_system
            ) as sum_amount_paid
            GROUP BY campus_id, kiosk_id, product_id, date_id
        )
        ON CONFLICT (campus_id, product_id, kiosk_id, date_id) DO UPDATE
        SET (ip_commerce,
            freedom_pay,
        card_smith,
        complimentary,
        sales_after_discount
        ) = (
        excluded.ip_commerce,
        excluded.freedom_pay,
        excluded.card_smith,
        excluded.complimentary,
        excluded.sales_after_discount);
    END;
$_$;


ALTER FUNCTION dw.insert_sales_after_discount_in_daily_kiosk_sku_summary(beginning_date date, ending_date date) OWNER TO erpuser;

--
-- Name: FUNCTION insert_sales_after_discount_in_daily_kiosk_sku_summary(beginning_date date, ending_date date); Type: COMMENT; Schema: dw; Owner: erpuser
--

COMMENT ON FUNCTION dw.insert_sales_after_discount_in_daily_kiosk_sku_summary(beginning_date date, ending_date date) IS 'inserts sales after discount in dw.fact_daily_kiosk_sku_summary';


--
-- Name: insert_sales_daily_byte_foods_summary(date, date); Type: FUNCTION; Schema: dw; Owner: erpuser
--

CREATE FUNCTION dw.insert_sales_daily_byte_foods_summary(beginning_date date, ending_date date) RETURNS void
    LANGUAGE plpgsql
    AS $$
    BEGIN
        INSERT INTO dw.fact_daily_byte_foods_summary(
            date_id,
            active_byte_customers,
            active_skus,
            active_brands,
            active_cards,
            active_usernames,
            active_emails,
            orders,
            orders_w_email)
        (SELECT (TO_CHAR(time_bought::date, 'YYYYMMDD'))::int  as date_id,
            count(DISTINCT client_name) as active_byte_customers,
            count(DISTINCT s.product_id) as active_skus,
            count(DISTINCT p.vendor) as active_brands,
            count(DISTINCT card_hash) as active_cards,
            count(DISTINCT (concat("left"(btrim(o.first_name::text), 1), '.', btrim(o.last_name::text)))) as
                active_usernames,
            count(DISTINCT email) as active_emails,
            count(DISTINCT s.order_id) as orders,
            count(DISTINCT(CASE WHEN o.email IS NULL OR o.email::text = ''::text
                THEN ''::character varying
                ELSE o.order_id
                END)) as orders_w_email
            FROM dw.byte_sales(beginning_date, ending_date) s
            LEFT JOIN pantry.kiosk k
            ON s.kiosk_id = k.id
            LEFT JOIN pantry.order o
            ON o.order_id = s.order_id
            LEFT JOIN pantry.product p
            ON p.id = s.product_id
            GROUP BY (TO_CHAR(time_bought::date, 'YYYYMMDD'))::int
        )
        ON CONFLICT (date_id) DO UPDATE
        SET (active_byte_customers, active_skus, active_brands, active_cards,
        active_usernames, active_emails, orders, orders_w_email) =
        (excluded.active_byte_customers, excluded.active_skus, excluded.active_brands,
        excluded.active_cards, excluded.active_usernames, excluded.active_emails, excluded.orders,
        excluded.orders_w_email);
    END;
$$;


ALTER FUNCTION dw.insert_sales_daily_byte_foods_summary(beginning_date date, ending_date date) OWNER TO erpuser;

--
-- Name: FUNCTION insert_sales_daily_byte_foods_summary(beginning_date date, ending_date date); Type: COMMENT; Schema: dw; Owner: erpuser
--

COMMENT ON FUNCTION dw.insert_sales_daily_byte_foods_summary(beginning_date date, ending_date date) IS 'inserts sales in dw.fact_daily_byte_foods_summary';


--
-- Name: insert_sales_in_daily_kiosk_sku_summary(date, date); Type: FUNCTION; Schema: dw; Owner: muriel
--

CREATE FUNCTION dw.insert_sales_in_daily_kiosk_sku_summary(beginning_date date, ending_date date) RETURNS void
    LANGUAGE plpgsql
    AS $$
    BEGIN
    INSERT INTO dw.fact_daily_kiosk_sku_summary(
        campus_id,
        kiosk_id,
        product_id,
        date_id,
        sales_qty,
        sales_amt,
        cost_amt,
        gross_margin_amt)
        (--- Byte sales
        SELECT campus_id,
            kiosk_id,
            product_id,
            (TO_CHAR(time_bought, 'YYYYMMDD'))::int AS date_id,
            COUNT(*) AS sales_qty,
            SUM(price) AS sales_amt,
            SUM(cost) AS cost_amt,
            SUM(price) - SUM(cost) AS gross_margin_amt
            FROM dw.byte_sales(beginning_date, ending_date) s
            LEFT JOIN pantry.kiosk k
            ON s.kiosk_id = k.id
            GROUP BY kiosk_id, product_id, date_id, campus_id
        UNION ALL
        --- Non-Byte sales
         SELECT campus_id,
            kiosk_id,
            product_id,
            (TO_CHAR(time_bought, 'YYYYMMDD'))::int AS date_id,
            COUNT(*) AS sales_qty,
            SUM(price) AS sales_amt,
            SUM(cost) AS cost_amt,
            SUM(price) - SUM(cost) AS gross_margin_amt
            FROM dw.non_byte_sales(beginning_date, ending_date) s
            LEFT JOIN pantry.kiosk k
            ON s.kiosk_id = k.id
            GROUP BY kiosk_id, product_id, date_id, campus_id
        )
        ON CONFLICT (campus_id, product_id, kiosk_id, date_id) DO UPDATE
        SET (sales_qty, sales_amt, cost_amt, gross_margin_amt) =
        (excluded.sales_qty, excluded.sales_amt, excluded.cost_amt, excluded.gross_margin_amt);
END;
$$;


ALTER FUNCTION dw.insert_sales_in_daily_kiosk_sku_summary(beginning_date date, ending_date date) OWNER TO muriel;

--
-- Name: FUNCTION insert_sales_in_daily_kiosk_sku_summary(beginning_date date, ending_date date); Type: COMMENT; Schema: dw; Owner: muriel
--

COMMENT ON FUNCTION dw.insert_sales_in_daily_kiosk_sku_summary(beginning_date date, ending_date date) IS 'inserts sales in dw.fact_daily_kiosk_sku_summary';


--
-- Name: insert_sales_monthly_byte_foods_summary(date); Type: FUNCTION; Schema: dw; Owner: erpuser
--

CREATE FUNCTION dw.insert_sales_monthly_byte_foods_summary(month_date date) RETURNS void
    LANGUAGE plpgsql
    AS $$
    BEGIN
        INSERT INTO dw.fact_monthly_byte_foods_summary(
            year_month,
            active_byte_customers,
            active_skus,
            active_brands,
            active_cards,
            active_usernames,
            active_emails,
            orders,
            orders_w_email)
        (SELECT (CONCAT( extract(year from time_bought),  to_char(time_bought,'MM')))::int   as month_year,
            count(DISTINCT client_name) as active_byte_customers,
            count(DISTINCT s.product_id) as active_skus,
            count(DISTINCT p.vendor) as active_brands,
            count(DISTINCT card_hash) as active_cards,
            count(DISTINCT (concat("left"(btrim(o.first_name::text), 1), '.', btrim(o.last_name::text)))) as
                active_usernames,
            count(DISTINCT email) as active_emails,
            count(DISTINCT s.order_id) as orders,
            count(DISTINCT(CASE WHEN o.email IS NULL OR o.email::text = ''::text
                THEN ''::character varying
                ELSE o.order_id
                END)) as orders_w_email
            FROM dw.byte_sales(date_trunc('month', month_date::date)::date, (date_trunc('month',
                month_date::date) + interval '1 month' -  interval '1 day' )::date ) s
            LEFT JOIN pantry.kiosk k
            ON s.kiosk_id = k.id
            LEFT JOIN pantry.order o
            ON o.order_id = s.order_id
            LEFT JOIN pantry.product p
            ON p.id = s.product_id
            LEFT JOIN pantry.feedback f
            ON f.order_id = o.order_id
            GROUP BY (CONCAT( extract(year from time_bought),  to_char(time_bought,'MM')))::int
        )
        ON CONFLICT (year_month) DO UPDATE
        SET (active_byte_customers, active_skus, active_brands, active_cards,
        active_usernames, active_emails, orders, orders_w_email) =
        (excluded.active_byte_customers, excluded.active_skus, excluded.active_brands,
        excluded.active_cards, excluded.active_usernames, excluded.active_emails, excluded.orders,
        excluded.orders_w_email);
    END;
$$;


ALTER FUNCTION dw.insert_sales_monthly_byte_foods_summary(month_date date) OWNER TO erpuser;

--
-- Name: insert_spoils_in_daily_kiosk_sku_summary(date, date); Type: FUNCTION; Schema: dw; Owner: muriel
--

CREATE FUNCTION dw.insert_spoils_in_daily_kiosk_sku_summary(beginning_date date, ending_date date) RETURNS void
    LANGUAGE plpgsql
    AS $$
    BEGIN
    INSERT INTO dw.fact_daily_kiosk_sku_summary(
        campus_id,
        kiosk_id,
        product_id,
        date_id,
        spoils_qty,
        spoils_amt
        )
    (--- Byte spoilage
        SELECT campus_id,
            kiosk_id,
            product_id,
            (TO_CHAR(time_updated, 'YYYYMMDD'))::int AS date_id,
            COUNT(*) AS spoils_qty,
            SUM(cost) AS spoils_amt
            FROM dw.byte_spoils(beginning_date, ending_date) s
            LEFT JOIN pantry.kiosk k
            ON s.kiosk_id = k.id
            GROUP BY kiosk_id, product_id, date_id, campus_id
        UNION ALL
        --- Non-Byte spoilage
         SELECT campus_id,
            kiosk_id,
            product_id,
            (TO_CHAR(time_updated, 'YYYYMMDD'))::int AS date_id,
            COUNT(*) AS spoils_qty,
            SUM(cost) AS spoils_amt
            FROM dw.non_byte_spoils(beginning_date, ending_date) s
            LEFT JOIN pantry.kiosk k
            ON s.kiosk_id = k.id
            GROUP BY kiosk_id, product_id, date_id, campus_id
        )
        ON CONFLICT (campus_id, product_id, kiosk_id, date_id) DO UPDATE
        SET (spoils_qty, spoils_amt) =
        (excluded.spoils_qty, excluded.spoils_amt);
END;
$$;


ALTER FUNCTION dw.insert_spoils_in_daily_kiosk_sku_summary(beginning_date date, ending_date date) OWNER TO muriel;

--
-- Name: FUNCTION insert_spoils_in_daily_kiosk_sku_summary(beginning_date date, ending_date date); Type: COMMENT; Schema: dw; Owner: muriel
--

COMMENT ON FUNCTION dw.insert_spoils_in_daily_kiosk_sku_summary(beginning_date date, ending_date date) IS 'inserts spoils in dw.fact_daily_kiosk_sku_summary';


--
-- Name: insert_stock_in_daily_kiosk_sku_summary(date, date); Type: FUNCTION; Schema: dw; Owner: erpuser
--

CREATE FUNCTION dw.insert_stock_in_daily_kiosk_sku_summary(beginning_date date, ending_date date) RETURNS void
    LANGUAGE plpgsql
    AS $$
    DECLARE
    --- NEEDS TO BE CHANGED if the frequency of running inventory_history.js changes 
--- See https://github.com/PantryLabs/Utilities/blob/develop/cron/scripts.crontab
    INVENTORY_HISTORY_FREQUENCY integer := 24;
    BEGIN
    INSERT INTO dw.fact_daily_kiosk_sku_summary(
        campus_id,
        kiosk_id,
        product_id,
        date_id,
        stocked_percent
        )
   (--- This query is used to get the stocked percentage of of a product in a particular kiosk.
 --- Inventory history is recorded every hour so there’s a total of 24 readings a day.
 --- The stocked percentage is calculated by counting the number of times an item
 --- appeared in a kiosk, and dividing that number by INVENTORY_HISTORY_FREQUENCY.
 SELECT k.campus_id,
kiosk_id, 
product_id, 
(TO_CHAR(to_timestamp(time), 'YYYYMMDD'))::int AS date_id,
round(count(*)::numeric/INVENTORY_HISTORY_FREQUENCY::numeric, 2) as stocked_percent
FROM pantry.inventory_history ih
JOIN pantry.product p ON p.id = ih.product_id
JOIN pantry.kiosk k ON k.id = ih.kiosk_id
WHERE to_timestamp(time)::date >= beginning_date
AND to_timestamp(time)::date <= ending_date
GROUP BY (TO_CHAR(to_timestamp(time), 'YYYYMMDD'))::int, kiosk_id, product_id, k.campus_id  
        )
        ON CONFLICT (campus_id, kiosk_id, product_id, date_id) DO UPDATE
        SET stocked_percent = excluded.stocked_percent;
END;
$$;


ALTER FUNCTION dw.insert_stock_in_daily_kiosk_sku_summary(beginning_date date, ending_date date) OWNER TO erpuser;

--
-- Name: FUNCTION insert_stock_in_daily_kiosk_sku_summary(beginning_date date, ending_date date); Type: COMMENT; Schema: dw; Owner: erpuser
--

COMMENT ON FUNCTION dw.insert_stock_in_daily_kiosk_sku_summary(beginning_date date, ending_date date) IS 'inserts stock ins in dw.fact_daily_kiosk_sku_summary';


--
-- Name: losses(date, date); Type: FUNCTION; Schema: dw; Owner: muriel
--

CREATE FUNCTION dw.losses(beginning_date date, ending_date date) RETURNS TABLE(epc_ character varying, kiosk_id_ bigint, product_id_ bigint, time_updated_ timestamp with time zone, cost_ numeric, price_ numeric, kiosk_campus_id_ bigint, product_campus_id_ bigint, enable_reporting_ bigint)
    LANGUAGE plpgsql
    AS $$
    BEGIN
        RETURN QUERY
        /*
        For a given time window W1 (e.g. from beginning_date through ending_date) and an extended time
        window W2, with W1 being a subset of W2 (e.g. W1 +1 and -1 month from beginning_date through
        ending_date)
        Loss: count of unique epc's which have at least one out label record within W1 and have no sale,
        spoil, or inventory records within W2.
        An out label record has no order id and has a LABEL STATUS of 'out' or 'sold'. For an out label record
        to be within the time window W1, the label update time needs to be within W1.
        For specification details, see these related tickets:
        * ENG-834: Art's logic, the origin for this function
        * ENG-1922: Add label state lost; Restrict order state from the sales subquery
        */
        SELECT epc as epc_,
            kiosk_id as kiosk_id_,
            product_id as product_id_,
            time_updated as time_updated_,
            cost as cost_,
            price as price_,
            kiosk_campus_id as kiosk_campus_id_,
            product_campus_id as product_campus_id_,
            enable_reporting as enable_reporting_
            FROM (SELECT unique_epcs.epc,
                to_timestamp(all_epc_data.time_updated) as time_updated,
                cost,
                price,
                kiosk_id,
                product_id,
                kiosk_campus_id,
                product_campus_id,
                enable_reporting
                --- There are duplicated EPCs. This subquery selects the most recent distinct out EPC
                FROM(SELECT epc,
                    max(time_updated) as time_updated
                    FROM pantry.label l
                    JOIN pantry.kiosk k
                    ON k.id = l.kiosk_id
                    JOIN pantry.product p
                    ON p.id = l.product_id
                    WHERE to_timestamp(time_updated)::date >= beginning_date
                    AND to_timestamp(time_updated)::date <= ending_date
                    AND l.status in ('out', 'lost')
                    AND l.order_id IS NULL
                    GROUP BY epc
                ) as unique_epcs
                /*
                This subquery is used to get the price and cost values for the distinct EPCs we selected
                in the subquery above.
                */
                LEFT JOIN (SELECT epc,
                    l.product_id,
                    l.time_updated as time_updated,
                    --- Get the cost from label, if NULL, get cost from product_history, if NULL get cost
                    --- from product, if NULL get 0. label has the most accurate cost info for
                    --- the specific epc, then product_history, then product.
                    COALESCE(l.cost, ph.cost, p.cost,0) as cost,
                    --- Get the price from product_history, if NULL, get price from label, if NULL get price
                    --- from product, if NULL get 0. product_history has the most accurate price info for
                    --- that time, then label, then product.
                    COALESCE(ph.price, l.price, p.price,0) as price,
                    l.kiosk_id,
                    k.campus_id as kiosk_campus_id,
                    p.campus_id as product_campus_id,
                    k.enable_reporting
                    FROM pantry.label l
                    JOIN pantry.kiosk k
                    ON k.id = l.kiosk_id
                    JOIN pantry.product p
                    ON p.id = l.product_id
                    LEFT JOIN pantry.product_history ph ON ph.product_id = p.id
                    AND l.time_updated >= ph.start_time AND (ph.end_time IS NULL OR l.time_updated <
                    ph.end_time)
                    WHERE to_timestamp(time_updated)::date >= beginning_date
                    AND to_timestamp(time_updated)::date <= ending_date
                    AND l.status in ('out', 'lost')
                    AND l.order_id IS NULL
                ) as all_epc_data
                ON unique_epcs.epc = all_epc_data.epc
                AND unique_epcs.time_updated = all_epc_data.time_updated
            ) as lost_data
            /*
            This subquery is used to eliminate any EPCs that were sold in W2
            (View first comment above to get details on W2)
            */
            WHERE EPC NOT IN (SELECT epc
                FROM pantry.label l
                JOIN pantry.kiosk k
                ON k.id = l.kiosk_id
                JOIN pantry.product p
                ON p.id = l.product_id
                JOIN pantry.order o
                ON o.order_id = l.order_id
                WHERE to_timestamp(created)::date >= (SELECT beginning_date::date - INTERVAL '1 month')
                AND to_timestamp(created)::date <= (SELECT ending_date::date + INTERVAL '1 month')
                AND o.state in ('Placed', 'Processed', 'Refunded', 'Adjusted', 'Declined', 'Error')
                AND l.status = 'sold'
                AND l.order_id NOT LIKE 'RE%'
                AND l.order_id IS NOT NULL)
            /*
            This subquery is used to eliminate any EPCs that were spoiled in W2
            (View first comment above to get details on W2)
            */
            AND EPC NOT IN (SELECT epc
                FROM pantry.label l
                JOIN pantry.kiosk k
                ON k.id = l.kiosk_id
                JOIN pantry.product p
                ON p.id = l.product_id
                JOIN pantry.order o
                ON o.order_id = l.order_id
                WHERE to_timestamp(created)::date >= (SELECT beginning_date::date - INTERVAL '1 month')
                AND to_timestamp(created)::date <= (SELECT ending_date::date + INTERVAL '1 month')
                AND l.status in ('out', 'lost')
                AND l.order_id LIKE 'RE%')
            /*
            This subquery is used to eliminate any EPCs that are currently in the kiosk
            */
            AND EPC NOT IN (SELECT epc
                FROM pantry.label l
                JOIN pantry.kiosk k
                ON k.id = l.kiosk_id
                JOIN pantry.product p
                ON p.id = l.product_id
                AND l.status = 'ok'
                AND l.order_id IS NULL);
    END;
$$;


ALTER FUNCTION dw.losses(beginning_date date, ending_date date) OWNER TO muriel;

--
-- Name: FUNCTION losses(beginning_date date, ending_date date); Type: COMMENT; Schema: dw; Owner: muriel
--

COMMENT ON FUNCTION dw.losses(beginning_date date, ending_date date) IS 'returns losses';


--
-- Name: non_byte_losses(date, date); Type: FUNCTION; Schema: dw; Owner: muriel
--

CREATE FUNCTION dw.non_byte_losses(beginning_date date, ending_date date) RETURNS TABLE(epc character varying, kiosk_id bigint, product_id bigint, time_updated timestamp with time zone, cost numeric, price numeric)
    LANGUAGE plpgsql
    AS $$
    DECLARE
        BYTE_CAMPUS INTEGER := 87;
    BEGIN
        RETURN QUERY
        /*
        The following query is used to get non byte kiosks losses. SEE ENG-1272 and ENG-2199. 
        We remove free kiosks losses from the the total loss since free kiosks losses are 
        considered sales. 
        */
        SELECT epc_ as epc,
            kiosk_id_ as kiosk_id,
            product_id_ as product_id,
            time_updated_ as time_updated,
            cost_ as cost,
            price_ as price
            FROM dw.losses(beginning_date, ending_date) gl
            JOIN pantry.kiosk k
            ON k.id = gl.kiosk_id_
            --- Get discount for the entire kiosk, not a specific product.
            --- product_id needs to be NULL
            LEFT JOIN pantry.discount d
            ON k.id = d.kiosk_id
            AND d.product_id IS NULL
            WHERE (value != 100 OR value IS NULL)
            AND kiosk_campus_id_ != BYTE_CAMPUS;
    END;
$$;


ALTER FUNCTION dw.non_byte_losses(beginning_date date, ending_date date) OWNER TO muriel;

--
-- Name: FUNCTION non_byte_losses(beginning_date date, ending_date date); Type: COMMENT; Schema: dw; Owner: muriel
--

COMMENT ON FUNCTION dw.non_byte_losses(beginning_date date, ending_date date) IS 'returns non campus 87 losses';


--
-- Name: non_byte_restocks(date, date); Type: FUNCTION; Schema: dw; Owner: erpuser
--

CREATE FUNCTION dw.non_byte_restocks(beginning_date date, ending_date date) RETURNS TABLE(epc character varying, kiosk_id bigint, product_id bigint, time_added timestamp with time zone, cost numeric, price numeric)
    LANGUAGE plpgsql
    AS $$
    DECLARE
        BYTE_CAMPUS INTEGER := 87;
    BEGIN
        RETURN QUERY
        /*
        The following query is used to get non byte kiosks restocks.
        */
        SELECT epc_ as epc,
            kiosk_id_ as kiosk_id,
            product_id_ as product_id,
            time_added_ as time_added,
            cost_ as cost,
            price_ as price
            FROM dw.restocks(beginning_date, ending_date)
            WHERE kiosk_campus_id_ != BYTE_CAMPUS;
    END;
$$;


ALTER FUNCTION dw.non_byte_restocks(beginning_date date, ending_date date) OWNER TO erpuser;

--
-- Name: non_byte_sales(date, date); Type: FUNCTION; Schema: dw; Owner: muriel
--

CREATE FUNCTION dw.non_byte_sales(beginning_date date, ending_date date) RETURNS TABLE(epc character varying, order_id character varying, kiosk_id bigint, product_id bigint, time_bought timestamp with time zone, cost numeric, price numeric)
    LANGUAGE plpgsql
    AS $$
    DECLARE
        BYTE_CAMPUS INTEGER := 87;
    BEGIN
        RETURN QUERY
        /*
        The following query is used to get all non byte kiosks sales. Sales =
        non free kiosks sale + free kiosk sales + free kiosk losses.
        SEE ENG-2199
        */
        SELECT epc_ as epc,
            order_id_ as order_id,
            kiosk_id_ as kiosk_id,
            product_id_ as product_id,
            time_bought_ as time_bought,
            cost_ as cost,
            price_ as price
            --- This subquery is used to get the sum price of sold items in free kiosks
            FROM (SELECT epc_,
                order_id_,
                kiosk_id_,
                product_id_,
                time_bought_,
                cost_,
                price_
                FROM dw.sales(beginning_date, ending_date)  gs
                JOIN pantry.kiosk k
                ON gs.kiosk_id_ = k.id
                --- Get discount for the entire kiosk, not a specific product.
                --- product_id needs to be NULL
                LEFT JOIN pantry.discount d
                ON k.id = d.kiosk_id
                AND d.product_id IS NULL
                WHERE value = 100
                AND kiosk_campus_id_ != BYTE_CAMPUS
            UNION
            --- This subquery is used to get all lost items in free kiosks
            SELECT epc_,
                NULL as order_id_,
                kiosk_id_,
                product_id_,
                time_updated_ as time_bought_,
                cost_ ,
                price_
                FROM dw.losses(beginning_date, ending_date)  gl
                JOIN pantry.kiosk k
                ON gl.kiosk_id_ = k.id
                --- Get discount for the entire kiosk, not a specific product.
                --- product_id needs to be NULL
                LEFT JOIN pantry.discount d
                ON k.id = d.kiosk_id
                AND d.product_id IS NULL
                WHERE value = 100
                AND kiosk_campus_id_ != BYTE_CAMPUS
            UNION
            --- This subquery is used to get all sold items in non-free kiosks
            SELECT epc_,
                order_id_,
                kiosk_id_,
                product_id_,
                time_bought_,
                cost_,
                price_
                FROM dw.sales(beginning_date, ending_date)  gs
                JOIN pantry.kiosk k
                ON gs.kiosk_id_ = k.id
                --- Get discount for the entire kiosk, not a specific product.
                --- product_id needs to be NULL
                LEFT JOIN pantry.discount d
                ON k.id = d.kiosk_id
                AND d.product_id IS NULL
                WHERE (value != 100 OR value IS NULL)
                AND kiosk_campus_id_ != BYTE_CAMPUS
            ) as all_kiosk_sale;
    END;
$$;


ALTER FUNCTION dw.non_byte_sales(beginning_date date, ending_date date) OWNER TO muriel;

--
-- Name: FUNCTION non_byte_sales(beginning_date date, ending_date date); Type: COMMENT; Schema: dw; Owner: muriel
--

COMMENT ON FUNCTION dw.non_byte_sales(beginning_date date, ending_date date) IS 'returns non campus 87 sales';


--
-- Name: non_byte_spoils(date, date); Type: FUNCTION; Schema: dw; Owner: erpuser
--

CREATE FUNCTION dw.non_byte_spoils(beginning_date date, ending_date date) RETURNS TABLE(epc character varying, kiosk_id bigint, product_id bigint, time_updated timestamp with time zone, cost numeric, price numeric)
    LANGUAGE plpgsql
    AS $$
    DECLARE
        BYTE_CAMPUS INTEGER := 87;
    BEGIN
        RETURN QUERY
/*
The following query is used to get non byte kiosks spoils.
*/
SELECT epc_ as epc,
    kiosk_id_ as kiosk_id,
    product_id_ as product_id,
    time_updated_ as time_updated,
    cost_ as cost,
    price_ as price
    FROM dw.spoils(beginning_date, ending_date) gl
    WHERE kiosk_campus_id_ != BYTE_CAMPUS;
 END;
$$;


ALTER FUNCTION dw.non_byte_spoils(beginning_date date, ending_date date) OWNER TO erpuser;

--
-- Name: FUNCTION non_byte_spoils(beginning_date date, ending_date date); Type: COMMENT; Schema: dw; Owner: erpuser
--

COMMENT ON FUNCTION dw.non_byte_spoils(beginning_date date, ending_date date) IS 'returns non campus 87 spoils';


--
-- Name: refresh_daily_byte_foods_summary(date, date); Type: FUNCTION; Schema: dw; Owner: erpuser
--

CREATE FUNCTION dw.refresh_daily_byte_foods_summary(beginning_date date, ending_date date) RETURNS void
    LANGUAGE plpgsql
    AS $$
    BEGIN
        PERFORM dw.insert_inv_snapshot_in_daily_byte_foods_summary(beginning_date, ending_date);
        PERFORM dw.insert_hb_stat_in_daily_byte_foods_summary(beginning_date, ending_date);
        PERFORM dw.insert_sales_daily_byte_foods_summary(beginning_date, ending_date);
    END;
$$;


ALTER FUNCTION dw.refresh_daily_byte_foods_summary(beginning_date date, ending_date date) OWNER TO erpuser;

--
-- Name: FUNCTION refresh_daily_byte_foods_summary(beginning_date date, ending_date date); Type: COMMENT; Schema: dw; Owner: erpuser
--

COMMENT ON FUNCTION dw.refresh_daily_byte_foods_summary(beginning_date date, ending_date date) IS 'updates dw.fact_daily_byte_foods_summary';


--
-- Name: refresh_daily_kiosk_sku_summary(date, date); Type: FUNCTION; Schema: dw; Owner: muriel
--

CREATE FUNCTION dw.refresh_daily_kiosk_sku_summary(beginning_date date, ending_date date) RETURNS void
    LANGUAGE plpgsql
    AS $$
    BEGIN
    PERFORM dw.refresh_dim_product();
    PERFORM dw.refresh_dim_kiosk();
    PERFORM dw.clear_daily_kiosk_sku_summary(beginning_date, ending_date);
    PERFORM dw.insert_sales_in_daily_kiosk_sku_summary(beginning_date, ending_date);
    PERFORM dw.insert_spoils_in_daily_kiosk_sku_summary(beginning_date, ending_date);
    PERFORM dw.insert_losses_in_daily_kiosk_sku_summary(beginning_date, ending_date);
    PERFORM dw.insert_stock_in_daily_kiosk_sku_summary(beginning_date, ending_date);
    PERFORM dw.insert_sales_after_discount_in_daily_kiosk_sku_summary(beginning_date, ending_date);
END;
$$;


ALTER FUNCTION dw.refresh_daily_kiosk_sku_summary(beginning_date date, ending_date date) OWNER TO muriel;

--
-- Name: FUNCTION refresh_daily_kiosk_sku_summary(beginning_date date, ending_date date); Type: COMMENT; Schema: dw; Owner: muriel
--

COMMENT ON FUNCTION dw.refresh_daily_kiosk_sku_summary(beginning_date date, ending_date date) IS 'updates dw.fact_daily_kiosk_sku_summary';


--
-- Name: refresh_dim_kiosk(); Type: FUNCTION; Schema: dw; Owner: muriel
--

CREATE FUNCTION dw.refresh_dim_kiosk() RETURNS void
    LANGUAGE plpgsql
    AS $$
    BEGIN
        --- Refresh kiosks
        INSERT INTO dw.dim_kiosk (id,
            campus_id,
            client_name,
            title,
            geo,
            location_type,
            enable_reporting,
            archived)
            (SELECT k.id,
                k.campus_id,
                c.name as client_name,
                k.title,
                k.geo,
                k.location_type,
                k.enable_reporting,
                k.archived
                FROM erp.kiosk k
                LEFT JOIN erp.client c
                ON k.client_id = c.id
            )
            ON CONFLICT (id) DO UPDATE
            SET (campus_id, client_name, title, geo, location_type, enable_reporting, archived) =
                (excluded.campus_id, excluded.client_name, excluded.title, excluded.geo,
                excluded.location_type, excluded.enable_reporting, excluded.archived);
        
        END;
$$;


ALTER FUNCTION dw.refresh_dim_kiosk() OWNER TO muriel;

--
-- Name: FUNCTION refresh_dim_kiosk(); Type: COMMENT; Schema: dw; Owner: muriel
--

COMMENT ON FUNCTION dw.refresh_dim_kiosk() IS 'updates dw.dim_kiosk';


--
-- Name: refresh_dim_product(); Type: FUNCTION; Schema: dw; Owner: muriel
--

CREATE FUNCTION dw.refresh_dim_product() RETURNS void
    LANGUAGE plpgsql
    AS $$
    BEGIN
         --- Refresh products
        INSERT INTO dw.dim_product (id,
            campus_id,
            title,
            fc_title,
            consumer_category,
            archived)
            (SELECT p.id,
                p.campus_id,
                pa.title,
                p.fc_title,
                p.consumer_category,
                p.archived
                FROM pantry.product p
                LEFT JOIN erp.product_asset pa
                ON p.id = pa.product_id
            )
            ON CONFLICT (id) DO UPDATE
            SET (campus_id, title, fc_title, consumer_category, archived) =
                (excluded.campus_id, excluded.title, excluded.fc_title, excluded.consumer_category, excluded.archived);       
        END;
$$;


ALTER FUNCTION dw.refresh_dim_product() OWNER TO muriel;

--
-- Name: FUNCTION refresh_dim_product(); Type: COMMENT; Schema: dw; Owner: muriel
--

COMMENT ON FUNCTION dw.refresh_dim_product() IS 'updates dw.dim_product';


--
-- Name: refresh_monthly_byte_foods_summary(date); Type: FUNCTION; Schema: dw; Owner: erpuser
--

CREATE FUNCTION dw.refresh_monthly_byte_foods_summary(month_date date) RETURNS void
    LANGUAGE plpgsql
    AS $$
    BEGIN
        PERFORM dw.insert_sales_monthly_byte_foods_summary(month_date);
    END;
$$;


ALTER FUNCTION dw.refresh_monthly_byte_foods_summary(month_date date) OWNER TO erpuser;

--
-- Name: refresh_monthly_kiosk_summary(date); Type: FUNCTION; Schema: dw; Owner: erpuser
--

CREATE FUNCTION dw.refresh_monthly_kiosk_summary(month_date date) RETURNS void
    LANGUAGE plpgsql
    AS $$
    BEGIN
    PERFORM dw.clear_fact_monthly_kiosk_summary(month_date);
    PERFORM dw.insert_in_monthly_kiosk_summary(month_date);
END;
$$;


ALTER FUNCTION dw.refresh_monthly_kiosk_summary(month_date date) OWNER TO erpuser;

--
-- Name: FUNCTION refresh_monthly_kiosk_summary(month_date date); Type: COMMENT; Schema: dw; Owner: erpuser
--

COMMENT ON FUNCTION dw.refresh_monthly_kiosk_summary(month_date date) IS 'updates dw.fact_monthly_kiosk_summary';


--
-- Name: restocks(date, date); Type: FUNCTION; Schema: dw; Owner: muriel
--

CREATE FUNCTION dw.restocks(beginning_date date, ending_date date) RETURNS TABLE(epc_ character varying, kiosk_id_ bigint, product_id_ bigint, time_added_ timestamp with time zone, cost_ numeric, price_ numeric, kiosk_campus_id_ bigint, product_campus_id_ bigint, enable_reporting_ bigint)
    LANGUAGE plpgsql
    AS $$
BEGIN
/*
Restock is a count of unique epcs based on time_created. If there are duplicate epc,
use the most recently added.
*/

	RETURN QUERY
		SELECT epc AS epc_,
			kiosk_id AS kiosk_id_,
			product_id AS product_id_,
			time_added AS time_added_,
			cost AS cost_,
			price AS price_,
			k.campus_id kiosk_campus_id_,
			p.campus_id product_campus_id_,
			k.enable_reporting AS enable_reporting_

		-- Use a window function to group duplicate epc and rank them by time_added,
		-- then pick the latest one within each group (r = 1).
		FROM (SELECT *
					FROM (SELECT epc,
									kiosk_id,
									product_id,
									to_timestamp(time_added) AS time_added,
									rank() OVER (PARTITION BY epc ORDER BY time_added DESC) r
								FROM pantry.label
								WHERE to_timestamp(time_added) BETWEEN beginning_date AND ending_date
					) ranked_items
					WHERE r = 1) restocked_item
					 JOIN pantry.product p ON restocked_item.product_id = p.id
					 JOIN pantry.kiosk k ON restocked_item.kiosk_id = k.id;
END;
$$;


ALTER FUNCTION dw.restocks(beginning_date date, ending_date date) OWNER TO muriel;

--
-- Name: FUNCTION restocks(beginning_date date, ending_date date); Type: COMMENT; Schema: dw; Owner: muriel
--

COMMENT ON FUNCTION dw.restocks(beginning_date date, ending_date date) IS 'returns restocks';


--
-- Name: sales(date, date); Type: FUNCTION; Schema: dw; Owner: muriel
--

CREATE FUNCTION dw.sales(beginning_date date, ending_date date) RETURNS TABLE(epc_ character varying, order_id_ character varying, kiosk_id_ bigint, product_id_ bigint, time_bought_ timestamp with time zone, cost_ numeric, price_ numeric, kiosk_campus_id_ bigint, product_campus_id_ bigint, enable_reporting_ bigint)
    LANGUAGE plpgsql
    AS $$
    BEGIN
        RETURN QUERY
        /*
        For a given time window W1 (e.g. from beginning_date through ending_date) and an extended time
        window W2, with W1 being a subset of W2 (e.g. W1 +1 and -1 month from beginning_date through
        ending_date)
        Sale(amount_list_price): count of epc’s which have at least one sale label record within W1.
        A sale(amount_list_price) label record has an order id which does not start with RE and has an
        ORDER STATE of Placed, Processed, Refunded, Adjusted, Declined, Error and a LABEL STATUS of sold
      
        For specification details, see these related tickets:
        * ENG-834: Art's logic, the origin for this function
        * ENG-1922: Include duplicated EPCs; Restrict order state
        */
            SELECT epc as epc_,
                order_id as order_id_,
                kiosk_id as kiosk_id_,
                product_id as product_id_,
                to_timestamp(time_bought) as time_bought_,
                cost as cost_,
                price as price_,
                kiosk_campus_id as kiosk_campus_id_,
                product_campus_id as product_campus_id_,
                enable_reporting as enable_reporting_
                FROM  (SELECT epc,
                    l.product_id,
                    l.order_id,
                    o.created as time_bought,
                    --- Get the cost from label, if NULL, get cost from product_history, if NULL get cost
                    --- from product, if NULL get 0. label has the most accurate cost info for
                    --- the specific epc, then product_history, then product.
                    COALESCE(l.cost, ph.cost, p.cost,0) as cost,
                    --- Get the price from product_history, if NULL, get price
                    --- from product, if NULL get 0. product_history has the most accurate price info for
                    --- that time then product.
                    COALESCE(ph.price, p.price,0) as price,
                    l.kiosk_id,
                    k.campus_id as kiosk_campus_id,
                    p.campus_id as product_campus_id,
                    k.enable_reporting
                    FROM pantry.label l
                    JOIN pantry.kiosk k
                    ON k.id = l.kiosk_id
                    JOIN pantry.product p
                    ON p.id = l.product_id
                    JOIN pantry.order o
                    ON o.order_id = l.order_id
                    LEFT JOIN pantry.product_history ph ON ph.product_id = p.id
                    AND o.created >= ph.start_time AND (ph.end_time IS NULL OR o.created <
                    ph.end_time)
                    WHERE to_timestamp(created)::date >= beginning_date
                    AND to_timestamp(created)::date <= ending_date
                    AND o.state in ('Placed', 'Processed', 'Refunded', 'Adjusted', 'Declined', 'Error')
                    AND l.status = 'sold'
                    AND l.order_id NOT LIKE 'RE%'
                    AND l.order_id IS NOT NULL
                ) as all_epc_data;
    END;
$$;


ALTER FUNCTION dw.sales(beginning_date date, ending_date date) OWNER TO muriel;

--
-- Name: FUNCTION sales(beginning_date date, ending_date date); Type: COMMENT; Schema: dw; Owner: muriel
--

COMMENT ON FUNCTION dw.sales(beginning_date date, ending_date date) IS 'returns sales';


--
-- Name: spoils(date, date); Type: FUNCTION; Schema: dw; Owner: muriel
--

CREATE FUNCTION dw.spoils(beginning_date date, ending_date date) RETURNS TABLE(epc_ character varying, order_id_ character varying, kiosk_id_ bigint, product_id_ bigint, time_updated_ timestamp with time zone, cost_ numeric, price_ numeric, kiosk_campus_id_ bigint, product_campus_id_ bigint, enable_reporting_ bigint)
    LANGUAGE plpgsql
    AS $$
begin
    return query
        /*
        For a given time window W1 (e.g. from beginning_date through ending_date) and an extended time
        window W2, with W1 being a subset of W2 (e.g. W1 +1 and -1 month from beginning_date through
        ending_date)
        Spoil: count of unique epc’s which have at least one spoil label record within W1 and have no
        sale record within W2.
        A spoil label record has an order id which starts with RE and has an out or lost LABEL STATUS.
        For a spoil label record to be within time window W1, the order creation time needs to be within W1.
        * ENG-834: Art's logic, the origin for this function
        * ENG-1922: Add label state lost; Restrict order state from the sales subquery

        NOTE: `to_timestamp(o.created)::date` date casting needed to remove time portion for whole day comparision,
        otherwise result will ignore records created on ending_date because datetime>date.
        */
        select l.epc, l.order_id, l.kiosk_id, l.product_id, to_timestamp(l.time_updated),
               coalesce(l.cost, ph.cost, p.cost, 0) as cost,
               coalesce(ph.price, l.price, p.price, 0) as price,
               k.campus_id, p.campus_id, k.enable_reporting
        from
            -- spoils may have duplicates so use rank() to get the latest updated item within duplicate epc's
            (select epc, o.order_id, o.kiosk_id, product_id, time_updated, price, cost,
                    rank() over(partition by epc order by time_updated desc) as latest_time_update_rank
             from
                  pantry.label l
                      join pantry.order o on l.order_id = o.order_id
                  where to_timestamp(o.created)::date between beginning_date and ending_date
                      and o.order_id > 'RE'
                      and l.status in ('out', 'lost')
            ) l

            left join
                -- sold items to be excluded
                (select epc from pantry.label l
                    join pantry.order o on l.order_id = o.order_id
                 where to_timestamp(created)::date between beginning_date - interval '1 months'
                   and ending_date + interval '1 months'
                   and l.status='sold'
                )sold_items on l.epc = sold_items.epc

                join pantry.product p on p.id = l.product_id

                join pantry.order o on l.order_id = o.order_id

                -- get the actual price at order time
                left join pantry.product_history ph on ph.product_id = p.id
                  and o.created >= ph.start_time AND (ph.end_time is null or o.created < ph.end_time)

                join pantry.kiosk k on l.kiosk_id = k.id

        where sold_items.epc is null and l.latest_time_update_rank = 1;
end;
$$;


ALTER FUNCTION dw.spoils(beginning_date date, ending_date date) OWNER TO muriel;

--
-- Name: FUNCTION spoils(beginning_date date, ending_date date); Type: COMMENT; Schema: dw; Owner: muriel
--

COMMENT ON FUNCTION dw.spoils(beginning_date date, ending_date date) IS 'returns spoils';


--
-- Name: stockout(date, date, bigint); Type: FUNCTION; Schema: dw; Owner: erpuser
--

CREATE FUNCTION dw.stockout(beginning_date date, ending_date date, kiosk_number bigint) RETURNS TABLE(kiosk_id bigint, kiosk_title character varying, campus_id bigint, product_id bigint, product_title character varying, sales bigint, spoils bigint, losses bigint, stockout_percent numeric)
    LANGUAGE plpgsql
    AS $$
   DECLARE
       DATE_DIFFERENCE bigint := ending_date - beginning_date + 1 ;
   BEGIN
     -- force Postgres to use indexes if available
     SET enable_seqscan TO false;
       RETURN QUERY
       SELECT all_kiosk_product.kiosk_id,
           all_kiosk_product.kiosk_title,
           all_kiosk_product.k_campus_id,
           all_kiosk_product.product_id,
           all_kiosk_product.product_title,
           coalesce(stockouts.sales_qty, 0) as sales,
           coalesce(stockouts.spoils_qty, 0) as spoils,
           coalesce(stockouts.losses_qty, 0) as losses,
           --- IF NULL, than it's a 100% stockout
           coalesce(stockouts.stockout_percent, 100.00) as stockout_percent
           --- This subquery is used to get a complete list of all products for the chosen kiosk's campus
           FROM (SELECT k.id as kiosk_id,
               k.title as kiosk_title,
               k.campus_id as k_campus_id,
               p.id as product_id,
               p.title as product_title,
               p.campus_id as p_campus_id
               FROM pantry.kiosk k
               CROSS JOIN pantry.product p
               WHERE k.campus_id = p.campus_id
               AND k.id = kiosk_number
           ) as all_kiosk_product
           --- This subquery is used to calculate the stockout_percent from the stocked_percent.
           --- stockout_percent = number of days selected - total stocked_percent
           --- stocked_percent is the percentage at which a given item was present in a given kiosk
           --- for a given day.
           --- dw.fact_daily_kiosk_sku_summary only contains non NULL stocked_percent values for
           --- items that were stocked. If an item was not stocked at all for a given day,
           --- dw.fact_daily_kiosk_sku_summary.stocked_percent will contain a NULL value. For this
           --- reason, we turn any NULL values to 0.
           LEFT JOIN( SELECT fd.kiosk_id,
               fd.product_id,
               fd.campus_id,
               sum(fd.sales_qty) as sales_qty,
               sum(fd.spoils_qty) as spoils_qty,
               sum(fd.losses_qty) as losses_qty,
               DATE_DIFFERENCE - sum(coalesce(stocked_percent,0)) as stockout_percent
               FROM dw.fact_daily_kiosk_sku_summary fd
               JOIN dw.dim_date dd
               ON dd.date_id = fd.date_id
               WHERE as_date >= beginning_date
               AND as_date <= ending_date
               AND fd.kiosk_id = kiosk_number
               GROUP by fd.kiosk_id, fd.product_id, fd.campus_id
            ) as stockouts
            ON all_kiosk_product.kiosk_id = stockouts.kiosk_id
            AND all_kiosk_product.product_id = stockouts.product_id
            ORDER BY coalesce(stockouts.stockout_percent, 100.00);
   END;
$$;


ALTER FUNCTION dw.stockout(beginning_date date, ending_date date, kiosk_number bigint) OWNER TO erpuser;

--
-- Name: parse_address(text); Type: FUNCTION; Schema: erp; Owner: erpuser
--

CREATE FUNCTION erp.parse_address(address_str text) RETURNS TABLE(address1 text, address2 text, city text, state text, zip text)
    LANGUAGE plpgsql
    AS $$
  /*
      Purpose - parse address fields from an address string
      Input -
        address_str: address string
  
      Return -
        address1, address2, city, state, zip
      */

declare
  address_fields text[5];
  remainder text;
begin
  address_fields = string_to_array(address_str, ',', null);

  -- trim leading and trailing spaces
  for i in 1..4 loop
      address_fields[i] = trim(address_fields[i]);
      address_fields[i] = trim(address_fields[i], chr(160));
  end loop;

  -- format: 123 Maple Street, San Francisco CA 94965
  if address_fields[3] is null
  then
    remainder = address_fields[2];
    zip = regexp_replace(remainder, '^.* ', '');
    remainder = trim(substring(remainder from 1 for length(remainder) - length(zip)));
    state = regexp_replace(remainder, '^.* ', '');
    city = trim(substring(remainder from 1 for length(remainder) - length(state)));
    address2 = '';
    address1 = address_fields[1];

    -- format: 123 Maple Street, San Francisco, CA 94965
    -- if there is no address2, then insert '' into address2 and shift the rest of address_fields down
  elseif address_fields[4] is null then
    zip = split_part(trim(address_fields[3]), ' ', 2);
    state = split_part(trim(address_fields[3]), ' ', 1);
    city = address_fields[2];
    address2 = '';
    address1 = address_fields[1];

    -- has address2: 123 Maple Street, Apartment A, San Francisco, CA 94965
  else
    -- split address_fields[4] into address_fields[4] and address_fields[5] to handle 'state zip'
    zip = split_part(trim(address_fields[4]), ' ', 2);
    state = split_part(trim(address_fields[4]), ' ', 1);
    city = address_fields[3];
    address2 = address_fields[2];
    address1 = address_fields[1];

  end if;

  return query
    select address1, address2, city, state, zip;
    -- select coalesce(address1, ''), coalesce(address2, ''), coalesce(city, ''),  coalesce(state, ''), coalesce(zip, '');
end;

$$;


ALTER FUNCTION erp.parse_address(address_str text) OWNER TO erpuser;

--
-- Name: parse_phone(text); Type: FUNCTION; Schema: erp; Owner: erpuser
--

CREATE FUNCTION erp.parse_phone(text_to_parse text) RETURNS TABLE(phone text)
    LANGUAGE plpgsql
    AS $$
  /*
    Purpose - Return the first phone number from an contact_phone field in pantry.kiosk string with embedded phones.
    Input -
      s: string with embedded phone

    Return -
      phone: general phone number
      mobile: mobile phone number
    */

declare
  s text;
  parsed_phone text default null;

begin
  s = regexp_replace(text_to_parse, '\D', '', 'g');
  if length(s) >= 10
  then
    parsed_phone = substring(s, 1, 10);
  end if;
  return query
    select parsed_phone;
end;

$$;


ALTER FUNCTION erp.parse_phone(text_to_parse text) OWNER TO erpuser;

--
-- Name: reverse_sync_kiosk(); Type: FUNCTION; Schema: erp; Owner: erpuser
--

CREATE FUNCTION erp.reverse_sync_kiosk() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
declare
  FORWARD_SYNC varchar(100) := 'sync';
  REVERSE_SYNC varchar(100) := 'reverse_sync';
  SKIP_SYNC_PARAM_NAME varchar(100) := 'pantry.kiosk.skip_sync';
  _skip_trigger boolean;
  _record_id integer;

  _last_inventory bigint;
  _last_status bigint;

  /*
  Insert/update/delete pantry.kiosk when erp.kiosk and related tables are changed

  This code works in conjunction with erp.sync_kiosk. To prevent infinite sync cycle, it does the following:
  1. Set SKIP_SYNC_PARAM_NAME transaction scope param to disable the sync for the transaction.
  2. Skip the reverse sync if changes are unnecessary (new record = existing record).
  */

begin
  -- calculate skip trigger flag
  _skip_trigger = (coalesce(current_setting(SKIP_SYNC_PARAM_NAME, true), '') = REVERSE_SYNC);

  if _skip_trigger
  then
    -- skip reverse sync
    -- (don't do  a reverse sync because changes were caused by a forward sync)
    return null;
  else
    -- do reverse sync
    -- disable the forward sync
    set local pantry.kiosk.skip_sync = FORWARD_SYNC;

    if tg_op in ('UPDATE', 'INSERT') then
      -- Calculate record id.
      -- Triggered record may have either `id` or `kiosk_id` as the primary key.
      -- Either case, assign its value to _record_id
      _record_id = null;
      begin
        _record_id = new.id;
      exception
        when undefined_column then
          _record_id = new.kiosk_id;
      end;

      -- compute last_inventory and last_update
      select max(time) from pantry.last_kiosk_status where kiosk_id = _record_id into _last_status;
      select max(time) from pantry.inventory_history where kiosk_id = _record_id into _last_inventory;

    end if;

    case
      when tg_op = 'UPDATE' then

        -- Triggered record may have either `id` or `kiosk_id` as the primary key.
        -- Either case, assign its value to _record_id
        _record_id = null;
        begin
          _record_id = new.id;
        exception
          when undefined_column then
            _record_id = new.kiosk_id;
        end;
        update pantry.kiosk k
        set (campus_id, serial, title, address, location_x, location_y, gcm_id, app_vname, app_vcode, archived,
             creation_time, deployment_time, last_update, client_name, last_status, last_inventory, kiosk_name,
             payment_start, payment_stop, features, sales_tax, default_fee_plan, timezone, estd_num_users, tags,
             publicly_accessible, cardkey_required, delivery_insns, fridge_loc_info, contact_first_name,
             contact_last_name, contact_email, contact_phone, accounting_email, byte_discount, subsidy_info,
             subsidy_notes, max_subscription, delivery_window_mon, delivery_window_tue, delivery_window_wed,
             delivery_window_thu, delivery_window_fri, delivery_window_sat, delivery_window_sun, notes, components,
             email_receipt_subject, ops_team_notes, geo, server_url, subscription_amount, enable_reporting,
             enable_monitoring, employees_num, kiosk_restrictions)
          =
          (vk.campus_id, vk.serial, vk.title, vk.address, vk.location_x, vk.location_y, vk.gcm_id, vk.app_vname,
           vk.app_vcode, vk.archived, vk.creation_time, vk.deployment_time, vk.last_update, vk.client_name,
           greatest(_last_status, vk.last_status),
           greatest(_last_inventory, vk.last_inventory),
           vk.kiosk_name, vk.payment_start, vk.payment_stop, vk.features,
           vk.sales_tax, vk.default_fee_plan, vk.timezone, vk.estd_num_users, vk.tags, vk.publicly_accessible,
           vk.cardkey_required, vk.delivery_insns, vk.fridge_loc_info, vk.contact_first_name, vk.contact_last_name,
           vk.contact_email, vk.contact_phone, vk.accounting_email, vk.byte_discount, vk.subsidy_info,
           vk.subsidy_notes, vk.max_subscription, vk.delivery_window_mon, vk.delivery_window_tue,
           vk.delivery_window_wed, vk.delivery_window_thu, vk.delivery_window_fri, vk.delivery_window_sat,
           vk.delivery_window_sun, vk.notes, vk.components, vk.email_receipt_subject, vk.ops_team_notes, vk.geo,
           vk.server_url, vk.subscription_amount, vk.enable_reporting, vk.enable_monitoring, vk.employees_num,
           vk.kiosk_restrictions)
        from (select * from erp.kiosk_classic_view where id=_record_id) vk
        where k.id=vk.id;

        -- fixme remove logging when done
        insert into test.kiosk_log(id, update_count) values(_record_id, 1)
          on conflict(id) do
            update set update_count = test.kiosk_log.update_count + 1, ts = current_timestamp;

        return new;

      when tg_op = 'INSERT' then
        -- erp.kiosk_classic_view contains the pantry.kiosk equivalent version of kiosk
        -- data of erp.kiosk and related tables
        insert into pantry.kiosk select * from erp.kiosk_classic_view where id = _record_id;

        -- fixme remove logging when done
        insert into test.kiosk_log(id, update_count) values(_record_id, 1)
        on conflict(id) do
          update set update_count = test.kiosk_log.update_count + 1, ts = current_timestamp;

        return new;

      when tg_op = 'DELETE' then
        delete from pantry.kiosk where id = old.id;
        return old;
      end case;
  end if;
end;
$$;


ALTER FUNCTION erp.reverse_sync_kiosk() OWNER TO erpuser;

--
-- Name: sync_kiosk(); Type: FUNCTION; Schema: erp; Owner: erpuser
--

CREATE FUNCTION erp.sync_kiosk() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
  -- Insert/update/delete erp.kiosk and related tables when a pantry.kiosk record is changed

declare
  _client_id integer;
  _client_name text;
  _address_id integer;

  _address1 text;
  _address2 text;
  _city text;
  _state text;
  _zip text;
  _phone text;
  _email type.email;
  _industry integer;
  _location_type integer := -1;

  _payment_start_date date;
  _payment_stop_date date;

  _general_contact_type integer;
  _general_contact_id integer;
  _accounting_contact_type integer;
  _accounting_contact_id integer;

  _note_type integer;

  BYTE_CAMPUS INTEGER := 87;

  _record_exists boolean;
  _target_record record;

begin
  -- 1 Prepare relational data for erp.kiosk and related tables based on the triggered pantry.kiosk record
  -- this task consists of looking up existing or inserting a new relational record to support the triggered
  -- pantry.kiosk record, for example, adding a new client record.
  if tg_op in  ('INSERT', 'UPDATE')
    then

      select exists(select 1 from erp.kiosk where id = new.id) into _record_exists ;

      -- There are many existing client_name = Byte kiosk with bad addresses. Overwrite these with the correct info.
      -- This code is needed for all such kiosk records until after the data have gone through a two way sync cycle
      -- and correction applied.
      if new.client_name = 'Byte'
        then
          new.address = '101 Glacier Point, San Rafael, CA 94901';
          new.contact_first_name = 'Megan';
          new.contact_last_name = 'Mokri';
          new.contact_email = 'megan@bytefoods.co';
          new.accounting_email = 'same';
          new.location_x = 37.950262;
          new.location_y = -122.489975;
      end if;

      -- look up contact type
      select id into _general_contact_type from erp.global_attribute_def where name = 'contact_type' and value = 'general';
      select id into _accounting_contact_type from erp.global_attribute_def where name = 'contact_type' and value = 'accounting';

      -- prepare address
      select address1, address2, city, state, zip from erp.parse_address(new.address)
                                                    into _address1, _address2, _city, _state, _zip;
      -- look up address id
      select address.id into _address_id from erp.address
      where address1 = _address1 and address2 = _address2 and city = _city and state = _state and zip = _zip;

      -- if there is no client name, use address
      _client_name = coalesce(new.client_name, 'Address: ' || new.address);

      -- lookup client industry
      select coalesce(ga.id, -1) into _industry
      from erp.client_industry ci
             left join (select * from erp.global_attribute_def ga where ga.name = 'industry') ga
                       on ci.industry = ga.value
      where ci.client_name = new.client_name;
      if _industry is null
        then _industry = -1;
      end if;

      -- insert into reference tables: client, address, contact

      -- insert client if not exists
      insert into erp.client(name, employees_num, industry)
        values(_client_name, new.employees_num, _industry)
        on conflict(name) do nothing;

      -- look up client id
      select id into _client_id from erp.client c where c.name = _client_name;

      -- insert address
      insert into erp.address(client_id, address1, address2, city, state, zip, location_x, location_y, timezone)
        values(_client_id, _address1, _address2, _city, _state, _zip, new.location_x, new.location_y, new.timezone)
        returning id into _address_id;

      -- insert contact
      select phone into _phone from erp.parse_phone(new.contact_phone);

      -- only use new.contact_email if it is compatitble with _email whose type is type.email
      begin
        _email = new.contact_email;
        exception
          when others then _email = null;
      end;

      -- insert general contact for kiosk contact
      insert into erp.contact(client_id, first_name, last_name, email, phone, contact_type)
        values(_client_id, new.contact_first_name, new.contact_last_name, _email, _phone, _general_contact_type)
        on conflict do nothing;

      -- if this is also an accounting contact, insert an accounting contact record
      if new.accounting_email = 'same'
        then
          insert into erp.contact(client_id, first_name, last_name, email, phone, contact_type)
            values(_client_id, new.contact_first_name, new.contact_last_name,
                   _email, _phone, _accounting_contact_type)
            on conflict do nothing;
      end if;

      -- look up client id
      select id into _client_id from erp.client where name = _client_name;

      -- look up general contact_id
      select contact.id into _general_contact_id from erp.contact
        where first_name = new.contact_first_name and last_name = new.contact_last_name
          and contact_type = _general_contact_type;

      -- look up accounting contact_id
      select contact.id into _accounting_contact_id from erp.contact
        where first_name = new.contact_first_name and last_name = new.contact_last_name
          and contact_type = _accounting_contact_type;

      if new.payment_start is null or new.payment_start = 0
        then _payment_start_date = null;
        else _payment_start_date = to_timestamp(new.payment_start)::date;
      end if;

      if new.payment_stop is null or new.payment_stop = 0
        then _payment_stop_date = null;
        else _payment_stop_date = to_timestamp(new.payment_stop)::date;
      end if;
  end if;

  -- 2 Insert erp.kiosk and relational records
  case
    when tg_op = 'INSERT' and not _record_exists
      then
        -- insert kiosk
        insert into erp.kiosk(id, campus_id, serial, client_id, title, name, geo, address_id, publicly_accessible,
                              location_type, estd_num_users, enable_reporting, creation_time, deployment_time,
                              deployment_status_id, bank, archived)
        values (new.id, new.campus_id, new.serial, _client_id,
                new.title, new.kiosk_name, new.geo, _address_id, new.publicly_accessible, _location_type,
                new.estd_num_users, new.enable_reporting, new.creation_time, new.deployment_time,
                0, 0, new.archived);

        -- insert hardware_software
        insert into erp.hardware_software(kiosk_id, gcm_id, app_vname, app_vcode, features, components,
                                          server_url, peekaboo_url, email_receipt_subject)
        values(new.id, new.gcm_id, new.app_vname, new.app_vcode, new.features, new.components, new.server_url,
               '', new.email_receipt_subject);

        -- insert kiosk_accounting
        insert into erp.kiosk_accounting(kiosk_id, start_date, payment_start, payment_stop, sales_tax,
                                         default_fee_plan, byte_discount, subsidy_info, max_subscription,
                                         subscription_amount, setup_fee, subsidy_notes)
        values (new.id,
                null, -- start_date,
                _payment_start_date, _payment_stop_date, new.sales_tax, new.default_fee_plan, new.byte_discount,
                new.subsidy_info, new.max_subscription, new.subscription_amount,
                null, -- new.setup_fee,
                new.subsidy_notes);

        -- insert location notes
        if new.fridge_loc_info is not null and new.fridge_loc_info <> ''
        then
          select id into _note_type from erp.global_attribute_def where name = 'note_type' and value = 'Location';
          insert into erp.kiosk_note(kiosk_id, note_type, content)
          values(new.id, _note_type, new.fridge_loc_info);
        end if;

        -- insert Delivery Instruction notes
        if new.delivery_insns is not null and new.delivery_insns <> ''
        then
          select id into _note_type from erp.global_attribute_def where name = 'note_type' and value = 'Delivery Instruction';
          insert into erp.kiosk_note(kiosk_id, note_type, content)
          values(new.id, _note_type, new.delivery_insns);
        end if;

        -- insert OPS notes
        if new.ops_team_notes is not null and new.ops_team_notes <> ''
        then
          select id into _note_type from erp.global_attribute_def where name = 'note_type' and value = 'OPS';
          insert into erp.kiosk_note(kiosk_id, note_type, content)
          values(new.id, _note_type, new.ops_team_notes);
        end if;

        -- insert kiosk status
        insert into erp.kiosk_status(kiosk_id, last_update, last_status, last_inventory)
        values(new.id, new.last_update, new.last_status, new.last_inventory);

        -- insert kiosk_contact
        if _general_contact_id is not null
        then
          insert into erp.kiosk_contact(kiosk_id, contact_id) values(new.id, _general_contact_id)
          on conflict do nothing;
        end if;

        -- insert inm.kiosk_control for Byte campus INM operation
        if new.campus_id = BYTE_CAMPUS then
          insert into inm.kiosk_control(kiosk_id) values(new.id)
            on conflict do nothing;
        end if;

    -- 3. Update erp.kiosk and relational records
    when tg_op = 'UPDATE' or (tg_op = 'INSERT' and _record_exists) then
      update erp.kiosk
      set
        (id, campus_id, serial, client_id, title, name, geo, address_id, publicly_accessible,
         location_type, estd_num_users, enable_reporting, creation_time, deployment_time,
         deployment_status_id, bank, archived)
          =
          (new.id, new.campus_id, new.serial, _client_id,
           new.title, new.kiosk_name, new.geo, _address_id, new.publicly_accessible, _location_type,
           new.estd_num_users, new.enable_reporting, new.creation_time, new.deployment_time,
           0, 0, new.archived)
      where id = new.id;

      update erp.hardware_software
      set
        (gcm_id, app_vname, app_vcode, features, components,
         server_url, peekaboo_url, email_receipt_subject)
          =
          (new.gcm_id, new.app_vname, new.app_vcode, new.features, new.components, new.server_url,
           '', new.email_receipt_subject)
      where kiosk_id=new.id;

      update erp.kiosk_accounting
      set
        (start_date, payment_start, payment_stop, sales_tax, default_fee_plan, byte_discount,
         subsidy_info, max_subscription, subscription_amount, setup_fee, subsidy_notes)
          =
          (null, _payment_start_date, _payment_stop_date, new.sales_tax, new.default_fee_plan, new.byte_discount,
           new.subsidy_info, new.max_subscription, new.subscription_amount, null, new.subsidy_notes)
      where kiosk_id=new.id;

      update erp.kiosk_status
      set
        (last_update, last_status, last_inventory)
          =
          (new.last_update, new.last_status, new.last_inventory)
      where kiosk_id=new.id;

    when tg_op = 'DELETE'
      then
        delete from erp.kiosk where id = old.id;
        delete from erp.hardware_software where kiosk_id = old.id;
        delete from erp.kiosk_accounting where kiosk_id = old.id;
        delete from erp.kiosk_status where kiosk_id = old.id;
        delete from erp.kiosk_contact where kiosk_id = old.id;
        delete from erp.kiosk_note where kiosk_id = old.id;
    end case;

  -- 4. return the appropriate record (new or old) so that changes to pantry.product can be carried out
  if tg_op in ('INSERT', 'UPDATE')
    then return new;
    else return old;
  end if;

end;

$$;


ALTER FUNCTION erp.sync_kiosk() OWNER TO erpuser;

--
-- Name: sync_kiosk_reference(); Type: FUNCTION; Schema: erp; Owner: erpuser
--

CREATE FUNCTION erp.sync_kiosk_reference() RETURNS trigger
    LANGUAGE plpgsql
    AS $_$
  /*

Required: populated erp.global_attribute_def, erp.client_industry
Prepare kiosk reference:

  erp.client
  erp.address
  erp.contact

*/

declare
  i smallint;
  address_fields text[5];
  _client_id integer;
  _client_name text;
  _address_id integer;

  _address1 text;
  _address2 text;
  _city text;
  _state text;
  _zip text;
  _phone text;
  _email text;
  _kiosk_name text;
  _industry integer;
  _location_type_string text;
  _location_type integer;

  _general_contact_type integer;
  _accounting_contact_type integer;
  _accounting_contact_id integer;
  _airport_location_type integer;
  _apartment_location_type integer;
  _gym_location_type integer;
  _higher_education_location_type integer;
  _hospital_location_type integer;
  _hotel_location_type integer;
  _k_12_education_location_type integer;
  _other_location_type integer;
  _workplace_location_type integer;

begin
  -- look up contact type
  select id into _general_contact_type from erp.global_attribute_def where name = 'contact_type' and value = 'general';
  select id into _accounting_contact_type from erp.global_attribute_def where name = 'contact_type' and value = 'accounting';

  -- look up location type
  select id into _airport_location_type from erp.global_attribute_def where name = 'location_type' and value = 'Airport';
  select id into _apartment_location_type from erp.global_attribute_def where name = 'location_type' and value = 'Apartment';
  select id into _gym_location_type from erp.global_attribute_def where name = 'location_type' and value = 'Gym';
  select id into _higher_education_location_type from erp.global_attribute_def where name = 'location_type' and value = 'Higher Education';
  select id into _hospital_location_type from erp.global_attribute_def where name = 'location_type' and value = 'Hospital';
  select id into _hotel_location_type from erp.global_attribute_def where name = 'location_type' and value = 'Hotel';
  select id into _k_12_education_location_type from erp.global_attribute_def where name = 'location_type' and value = 'K-12 Education';
  select id into _other_location_type from erp.global_attribute_def where name = 'location_type' and value = 'Other';
  select id into _workplace_location_type from erp.global_attribute_def where name = 'location_type' and value = 'Workplace';

  if tg_op in ('INSERT', 'UPDATE')
    then
      -- 1. import kiosk and client

      -- prepare addresses
      -- there are many client_name=Byte kiosk with bad addresses
      -- there are many client_name=Byte kiosk with bad addresses
      if new.client_name = 'Byte'
        then
          new.address = '101 Glacier Point, San Rafael, CA 94901';
          new.contact_first_name = 'Megan';
          new.contact_last_name = 'Mokri';
          new.contact_email = 'megan@bytefoods.co';
          new.accounting_email = 'same';
          new.location_x = 37.950262;
          new.location_y = -122.489975;
      end if;

      -- prepare address
      select address1, address2, city, state, zip from erp.parse_address(new.address)
        into _address1, _address2, _city, _state, _zip;

      -- if there is no client name, use address
      _client_name = coalesce(new.client_name, 'Address: ' || new.address);

      select coalesce(ga.id, -1) into _industry
      from erp.client_industry ci
             left join (select * from erp.global_attribute_def ga where ga.name = 'industry') ga
                       on ci.industry = ga.value
      where ci.client_name = new.client_name;
      if _industry is null then
        _industry = -1;
      end if;

      -- insert client
      insert into erp.client(name, employees_num, industry)
        values(_client_name, new.employees_num, _industry)
        on conflict(name) do nothing;

      -- look up client id
      select id into _client_id from erp.client c where c.name = _client_name;

      -- insert address
      insert into erp.address(client_id, address1, address2, city, state, zip, location_x, location_y, timezone)
      values(_client_id, _address1, _address2, _city, _state, _zip, new.location_x, new.location_y, new.timezone)
      on conflict(address1) do
        update set
          (client_id, address1, address2, city, state, zip, location_x, location_y, timezone)
            =
          (_client_id,
          coalesce(_address1, erp.address.address1),
          coalesce(_address2, erp.address.address2),
          coalesce(_city, erp.address.city),
          coalesce(_state, erp.address.state),
          coalesce(_zip, erp.address.zip),
          coalesce(new.location_x, erp.address.location_x),
          coalesce(new.location_y, erp.address.location_y),
          coalesce(new.timezone, erp.address.timezone))
        returning id into _address_id;

      -- insert contact
      select phone into _phone from erp.parse_phone(new.contact_phone);

      if new.contact_email ~ '^\w+@[0-9a-zA-Z_]+?\.[0-9a-zA-Z]{2,3}$'
      then _email = new.contact_email;
      else _email = null;
      end if;

      -- insert general contact for kiosk contact
      insert into erp.contact(client_id, first_name, last_name, email, phone, contact_type)
      values(_client_id, new.contact_first_name, new.contact_last_name, _email, _phone, _general_contact_type)
      on conflict do nothing;

      -- if this is also an accounting contact, insert an accounting contact record
      if new.accounting_email = 'same'
      then insert into erp.contact(client_id, first_name, last_name, email, phone, contact_type)
           values(_client_id, new.contact_first_name, new.contact_last_name, _email, _phone, _accounting_contact_type)
           on conflict do nothing;
      end if;

    -- don't insert or update pantry.kiosk - let sync_kiosk does that
    return null;
  end if;
end;

$_$;


ALTER FUNCTION erp.sync_kiosk_reference() OWNER TO erpuser;

--
-- Name: sync_kiosk_tables(); Type: FUNCTION; Schema: erp; Owner: erpuser
--

CREATE FUNCTION erp.sync_kiosk_tables() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
  /*

Required: populated erp.global_attribute_def, erp.client_industry
Prepare kiosk reference:

  erp.client
  erp.address
  erp.contact

*/

declare
  i smallint;
  address_fields text[5];
  _client_id integer;
  _client_name text;
  _address_id integer;

  _address1 text;
  _address2 text;
  _city text;
  _state text;
  _zip text;
  _phone text;
  _email text;
  _kiosk_name text;
  _industry integer;
  _location_type_string text;
  _location_type integer;

  _payment_start_date date;
  _payment_stop_date date;

  _general_contact_type integer;
  _general_contact_id integer;
  _accounting_contact_type integer;
  _accounting_contact_id integer;
  _airport_location_type integer;
  _apartment_location_type integer;
  _gym_location_type integer;
  _higher_education_location_type integer;
  _hospital_location_type integer;
  _hotel_location_type integer;
  _k_12_education_location_type integer;
  _other_location_type integer;
  _workplace_location_type integer;

begin
  -- look up contact type
  select id into _general_contact_type from erp.global_attribute_def where name = 'contact_type' and value = 'general';
  select id into _accounting_contact_type from erp.global_attribute_def where name = 'contact_type' and value = 'accounting';

  -- look up location type
  select id into _airport_location_type from erp.global_attribute_def where name = 'location_type' and value = 'Airport';
  select id into _apartment_location_type from erp.global_attribute_def where name = 'location_type' and value = 'Apartment';
  select id into _gym_location_type from erp.global_attribute_def where name = 'location_type' and value = 'Gym';
  select id into _higher_education_location_type from erp.global_attribute_def where name = 'location_type' and value = 'Higher Education';
  select id into _hospital_location_type from erp.global_attribute_def where name = 'location_type' and value = 'Hospital';
  select id into _hotel_location_type from erp.global_attribute_def where name = 'location_type' and value = 'Hotel';
  select id into _k_12_education_location_type from erp.global_attribute_def where name = 'location_type' and value = 'K-12 Education';
  select id into _other_location_type from erp.global_attribute_def where name = 'location_type' and value = 'Other';
  select id into _workplace_location_type from erp.global_attribute_def where name = 'location_type' and value = 'Workplace';

  if tg_op in  ('INSERT', 'UPDATE')
    then
      -- prepare addresses
      select address1, address2, city, state, zip from erp.parse_address(new.address)
                                                       into _address1, _address2, _city, _state, _zip;
      -- look up address id
      select address.id into _address_id from erp.address
      where address1 = _address1 and address2 = _address2 and city = _city and state = _state and zip = _zip;

      -- if there is no client name, use address
      _client_name = coalesce(new.client_name, 'Address: ' || new.address);

      -- look up client id
      select id into _client_id from erp.client where name = _client_name;

      -- look up general contact_id
      select contact.id into _general_contact_id from erp.contact
      where first_name = new.contact_first_name and last_name = new.contact_last_name and contact_type = _general_contact_type;

      -- look up accounting contact_id
      select contact.id into _accounting_contact_id from erp.contact
      where first_name = new.contact_first_name and last_name = new.contact_last_name and contact_type = _accounting_contact_type;

      -- current kiosk_name is not correct. Set name as concat of 'KID' and kiosk_id.
      _kiosk_name = 'KID' || new.id;

      if new.payment_start is null or new.payment_start = 0
        then _payment_start_date = null;
        else _payment_start_date = to_timestamp(new.payment_start)::date;
      end if;

      if new.payment_stop is null or new.payment_stop = 0
      then _payment_stop_date = null;
      else _payment_stop_date = to_timestamp(new.payment_stop)::date;
      end if;

  end if;

  if tg_op = 'INSERT'
    then
      -- insert kiosk
      insert into erp.kiosk(id, campus_id, serial, client_id, title, name, geo, address_id, publicly_accessible,
                            location_type, estd_num_users, enable_reporting, creation_time, deployment_time,
                            deployment_status_id, bank, archived)
        values (new.id, new.campus_id, new.serial,
                _client_id,
                new.title, _kiosk_name, new.geo, _address_id, new.publicly_accessible,
                _location_type,
                new.estd_num_users, new.enable_reporting, new.creation_time, new.deployment_time,
        --deployment_status_id
                0,
        --	new.bank,
                0,
                new.archived);

      -- insert hardware_software
      insert into erp.hardware_software(kiosk_id, gcm_id, app_vname, app_vcode, features, components, server_url, peekaboo_url, email_receipt_subject)
        values(new.id, new.gcm_id, new.app_vname, new.app_vcode, new.features, new.components, new.server_url,
               '', --new.peekaboo_url,
               new.email_receipt_subject);
               
      -- insert kiosk_accounting
      insert into erp.kiosk_accounting(kiosk_id, start_date, payment_start, payment_stop, sales_tax, default_fee_plan,
                                       byte_discount, subsidy_info, max_subscription, subscription_amount, setup_fee, subsidy_notes)
        values (new.id,
                null, -- start_date,
                _payment_start_date, _payment_stop_date, new.sales_tax, new.default_fee_plan, new.byte_discount,
                new.subsidy_info, new.max_subscription, new.subscription_amount,
                null, -- new.setup_fee,
                new.subsidy_notes);
        
      return new;

  elseif tg_op = 'DELETE'
    then
      delete from erp.kiosk where id = old.id;
      delete from erp.hardware_software where kiosk_id = old.id;
      delete from erp.kiosk_accounting where kiosk_id = old.id;
      return old;
  end if;
end;

$$;


ALTER FUNCTION erp.sync_kiosk_tables() OWNER TO erpuser;

--
-- Name: sync_product(); Type: FUNCTION; Schema: erp; Owner: erpuser
--

CREATE FUNCTION erp.sync_product() RETURNS trigger
    LANGUAGE plpgsql
    AS $$

  /*
  Insert/update/delete erp.product and related tables according to tg_op value, except for when insert conflict, then
update erp.product and related tables instead. This exception happens if syncing table and synced tables were not
in sync (for example, aws dms was disabled)

  This code works in conjunction with erp.reverse_sync_product. To prevent infinite sync cycle, it does the following:
  1. Use erp.product.skip_trigger transaction scope parameter to signal when either a sync or reverse sync
    is in progress to prevent a sync to initiate reverse sync an vice versa
  2. Check if the new record already exists and therefore no changes is needed and sync should be skipped

  */

declare
  FORWARD_SYNC varchar(100) := 'sync';
  REVERSE_SYNC varchar(100) := 'reverse_sync';
  SKIP_SYNC_PARAM_NAME varchar(100) := 'pantry.product.skip_sync';

  _record_exists boolean;
  _target_record record;
  _insync boolean;
  _skip_trigger boolean;

  _sku_group_id integer;
  _consumer_category_id integer;

begin
  -- Calculate the flag which indicate if the sync should be skipped
  _skip_trigger = (coalesce(current_setting(SKIP_SYNC_PARAM_NAME, true), '') = FORWARD_SYNC);

  -- calculate sync status of the triggered record
  if tg_op in ('INSERT', 'UPDATE')
    then
      select * from pantry.product where id = new.id into _target_record;

      -- is the new version of record the same as the current record
      _insync = (_target_record = new);
    -- tg_op is 'DELETE'
    else
      _insync = false;
  end if;

  -- Process the trigger according to record sync state and skip trigger param
  if _insync
    -- record is already in sync, so return null to cancel any subsequent trigger processing
    then return null;

    -- record is not in sync, so process the current trigger
    else
      -- Disable the reverse sync
      set local pantry.product.skip_sync = REVERSE_SYNC;

      if not _skip_trigger
        then
          if tg_op in ('INSERT', 'UPDATE')
            then
              select id from erp.sku_group where fc_title = new.fc_title into _sku_group_id;
              select exists(select 1 from pantry.product where id = new.id) into _record_exists;
              select id from erp.product_category_def
                where name = 'consumer' and value = new.consumer_category
                into _consumer_category_id;
            end if;

          -- insert data if trigger is insert and product does not exists
          case
            when tg_op = 'INSERT' and not _record_exists then
              insert into erp.product(id, brand, campus_id, sku_group_id, fc_title, archived, last_update)
              values(new.id, new.vendor, new.campus_id, _sku_group_id, new.fc_title, new.archived, new.last_update);

              insert into erp.product_asset(product_id, title, description, tiny_description, short_description, medium_description, long_description, image, image_time)
              values (new.id, new.title, new.description, new.tiny_description, new.short_description, new.medium_description, new.long_description, new.image, new.image_time);

              insert into erp.product_pricing(product_id,price,cost,ws_case_cost,pricing_tier,taxable)
              values(new.id,new.price,new.cost,new.ws_case_cost,new.pricing_tier,new.taxable);

              insert into erp.product_nutrition(product_id,total_cal,num_servings,calories,proteins,sugar,carbohydrates,fat,ingredients,shelf_time)
              values(new.id,new.total_cal,new.num_servings,new.calories,new.proteins,new.sugar,new.carbohydrates,new.fat,new.ingredients,new.shelf_time);

              -- for each attribute in comma separated allergens, look up corresponding property id
              -- and insert a product_id, property_id in the product_property table
              insert into erp.product_property(product_id, property_id)
                select new.id, def.id
                  from (select unnest(string_to_array(new.allergens, ','))::int a_id) allergen_list
                         join pantry.tag t on allergen_list.a_id = t.id
                         join erp.product_property_def def on t.tag = def.value
                    on conflict do nothing;

              -- write consumer_category to erp.product related table
              if _consumer_category_id is not null
                then insert into erp.product_category(product_id, category_id) values(new.id, _consumer_category_id);
              end if;

              -- Write categories to erp.product related table
              -- erp.classic_product_category_tag contains tagging used by the tablet for product filtering
              -- overwrite erp.classic_product_category_tag with new tags
              delete from erp.classic_product_category_tag where product_id = new.id;
              insert into erp.classic_product_category_tag(product_id, tag_id)
                select new.id, tags.tag_id
                  from (select unnest(string_to_array(new.categories, ','))::int as tag_id) tags
                    on conflict do nothing;

              insert into erp.product_handling(product_id,width_space,height_space,depth_space,slotted_width,kiosk_ship_qty,
                                               ws_case_size,tag_volume,tag_delivery_option,tag_applied_by,pick_station)
              values(new.id,new.width_space,new.height_space,new.depth_space,new.slotted_width,new.kiosk_ship_qty,
                     new.ws_case_size,new.tag_volume,new.delivery_option,new.tag_applied_by,new.pick_station);

              insert into erp.product_sourcing(product_id,vendor,source) values(new.id,new.vendor,new.source);

            -- update data if either trigger is insert or if product exits
            when tg_op = 'UPDATE' or (tg_op = 'INSERT' and _record_exists) then
              update erp.product
              set brand=new.vendor, campus_id=new.campus_id, sku_group_id=_sku_group_id,
                fc_title=new.fc_title, archived=new.archived, last_update=new.last_update
              where id = new.id;

              update erp.product_asset
              set title=new.title, description=new.description, tiny_description=new.tiny_description,
                short_description=new.short_description, medium_description=new.medium_description,
                long_description=new.long_description, image=new.image, image_time=new.image_time
              where product_id = new.id;

              update erp.product_pricing
              set price=new.price,cost=new.cost,ws_case_cost=new.ws_case_cost,pricing_tier=new.pricing_tier,taxable=new.taxable
              where product_id=new.id;

              update erp.product_nutrition
              set total_cal=new.total_cal,num_servings=new.num_servings,calories=new.calories,proteins=new.proteins,
                sugar=new.sugar,carbohydrates=new.carbohydrates,fat=new.fat,ingredients=new.ingredients,
                shelf_time=new.shelf_time where product_id=new.id;

              -- First delete all the corresponding property product_property for the product_id = new.id
              -- Then for each attribute in comma separated allergens, look up corresponding property id
              -- and insert a product_id, property_id in the product_property table
              delete from erp.product_property where product_id=new.id;

              insert into erp.product_property(product_id, property_id)
              select new.id, def.id
              from (select unnest(string_to_array(new.allergens, ','))::int a_id) allergen_list
                     join pantry.tag t on allergen_list.a_id = t.id
                     join erp.product_property_def def on t.tag = def.value
              on conflict do nothing;

              -- upsert consumer category by deleting existing then inserting new
              -- remove existing consumer categery
              delete from erp.product_category where product_id = new.id
                and category_id in (select id from erp.product_category_def where name = 'consumer');
              -- insert new consumer category only if it exists
              if _consumer_category_id is not null
                then insert into erp.product_category(product_id, category_id) values(new.id, _consumer_category_id);
              end if;

              -- write updated categories to erp.product related table.
              -- erp.classic_product_category_tag contains tagging used by the tablet for product filtering
              -- overwrite erp.classic_product_category_tag with new tags
              delete from erp.classic_product_category_tag where product_id = new.id;
              insert into erp.classic_product_category_tag(product_id, tag_id)
              select new.id, tags.tag_id
                from (select unnest(string_to_array(new.categories, ','))::int as tag_id) tags
                  on conflict do nothing;

              update erp.product_handling
              set width_space=new.width_space,height_space=new.height_space,depth_space=new.depth_space,
                slotted_width=new.slotted_width,kiosk_ship_qty=new.kiosk_ship_qty,ws_case_size=new.ws_case_size,
                tag_volume=new.tag_volume,tag_delivery_option=new.delivery_option,tag_applied_by=new.tag_applied_by,
                pick_station=new.pick_station
              where product_id=new.id;

              update erp.product_sourcing set vendor=new.vendor,source=new.source where product_id=new.id;

            when tg_op = 'DELETE' then
              delete from erp.product where id = old.id;
              delete from erp.product_asset where product_id=old.id;
              delete from erp.product_pricing where product_id=old.id;
              delete from erp.product_nutrition where product_id=old.id;
              delete from erp.product_property where product_id=old.id;
              delete from erp.product_handling where product_id=old.id;
              delete from erp.product_sourcing where product_id=old.id;
              delete from erp.product_category where product_id=old.id;
              delete from erp.classic_product_category_tag where product_id=old.id;
          end case;
      end if; -- not skip trigger ?

      -- return the appropriate record (new or old) so that changes to pantry.product can be carried out
      if tg_op in ('INSERT', 'UPDATE')
        then return new;
        else return old;
      end if;

  end if; -- in sync?
end;
$$;


ALTER FUNCTION erp.sync_product() OWNER TO erpuser;

--
-- Name: fn_ro_order_update_full_price(character varying); Type: FUNCTION; Schema: erp_test; Owner: erpuser
--

CREATE FUNCTION erp_test.fn_ro_order_update_full_price(orderid character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
  rfp NUMERIC(11,2);
  fp NUMERIC(11,2);
  tc bigint;
  orderid varchar(135);
BEGIN

  rfp = (
    SELECT
      CASE WHEN (o.state <> 'NonTrans')
             THEN
             COALESCE(SUM(l.price), 0)

        END
    FROM pantry.label l
           JOIN pantry.order o ON o.order_id = l.order_id
    GROUP BY o.state
  ),

    fp = (
    SELECT
      CASE WHEN (o.state <> 'NonTrans')
             THEN
             COALESCE(SUM(l.price), 0)
           ELSE
             0
        END
    FROM pantry.label l
           JOIN pantry.order o ON o.order_id = l.order_id
           JOIN pantry.kiosk k ON k.id = o.kiosk_id
           JOIN pantry.product p ON p.id = l.product_id
           JOIN pantry.group_campus gc1 ON gc1.campus_id = k.campus_id AND gc1.owner = 1
           JOIN pantry.group_campus gc2 ON gc2.campus_id = p.campus_id AND gc2.owner = 1
    WHERE l.order_id = orderId
      AND gc1.group_id = gc2.group_id
    GROUP BY o.state
  ),
    tc = (SELECT date_part('epoch',CURRENT_TIMESTAMP)::int);

  UPDATE pantry.ro_order
  SET
    real_full_price = rfp, full_price = fp, created = tc
  WHERE ro_order.order_id = orderId;
END

$$;


ALTER FUNCTION erp_test.fn_ro_order_update_full_price(orderid character varying) OWNER TO erpuser;

--
-- Name: parse_address(text); Type: FUNCTION; Schema: erp_test; Owner: erpuser
--

CREATE FUNCTION erp_test.parse_address(address_str text) RETURNS TABLE(address1 text, address2 text, city text, state text, zip text)
    LANGUAGE plpgsql
    AS $$
  /*
    Purpose - parse address fields from an address string
    Input -
      address_str: address string

    Return -
      address1, address2, city, state, zip
    */

declare
  address_fields text[5];
  remainder text;
begin
  address_fields = string_to_array(address_str, ',', null);

  -- trim leading and trailing spaces
  for i in 1..4 loop
      address_fields[i] = trim(address_fields[i]);
      address_fields[i] = trim(address_fields[i], chr(160));
  end loop;

  -- format: 123 Maple Street, San Francisco CA 94965
  if address_fields[3] is null
  then
    remainder = address_fields[2];
    zip = regexp_replace(remainder, '^.* ', '');
    remainder = trim(substring(remainder from 1 for length(remainder) - length(zip)));
    state = regexp_replace(remainder, '^.* ', '');
    city = trim(substring(remainder from 1 for length(remainder) - length(state)));
    address2 = '';
    address1 = address_fields[1];

    -- format: 123 Maple Street, San Francisco, CA 94965
    -- if there is no address2, then insert '' into address2 and shift the rest of address_fields down
  elseif address_fields[4] is null then
    zip = split_part(trim(address_fields[3]), ' ', 2);
    state = split_part(trim(address_fields[3]), ' ', 1);
    city = address_fields[2];
    address2 = '';
    address1 = address_fields[1];

    -- has address2: 123 Maple Street, Apartment A, San Francisco, CA 94965
  else
    -- split address_fields[4] into address_fields[4] and address_fields[5] to handle 'state zip'
    zip = split_part(trim(address_fields[4]), ' ', 2);
    state = split_part(trim(address_fields[4]), ' ', 1);
    city = address_fields[3];
    address2 = address_fields[2];
    address1 = address_fields[1];

  end if;

  return query
    select address1, address2, city, state, zip;
  -- select coalesce(address1, ''), coalesce(address2, ''), coalesce(city, ''),  coalesce(state, ''), coalesce(zip, '');
end;

$$;


ALTER FUNCTION erp_test.parse_address(address_str text) OWNER TO erpuser;

--
-- Name: parse_phone(text); Type: FUNCTION; Schema: erp_test; Owner: erpuser
--

CREATE FUNCTION erp_test.parse_phone(text_to_parse text) RETURNS TABLE(phone text)
    LANGUAGE plpgsql
    AS $$
  /*
    Purpose - Return the first phone number from an contact_phone field in pantry.kiosk string with embedded phones.
    Input -
      s: string with embedded phone

    Return -
      phone: general phone number
      mobile: mobile phone number
    */

declare
  s text;
  parsed_phone text default null;

begin
  s = regexp_replace(text_to_parse, '\D', '', 'g');
  if length(s) >= 10
  then
    parsed_phone = substring(s, 1, 10);
  end if;
  return query
    select parsed_phone;
end;

$$;


ALTER FUNCTION erp_test.parse_phone(text_to_parse text) OWNER TO erpuser;

--
-- Name: reverse_sync_kiosk(); Type: FUNCTION; Schema: erp_test; Owner: erpuser
--

CREATE FUNCTION erp_test.reverse_sync_kiosk() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
declare
  _skip_trigger boolean;
  _record_id integer;

  /*
  Insert/update/delete pantry.kiosk when a record in erp_test.kiosk or related tables is changed.

  This code works in conjunction with erp_test.sync_kiosk. To prevent infinite sync cycle, it
  uses erp_test.kiosk.skip_forward_sync_trigger transaction scope parameter to signal when it starts
     to prevent a forward sync to run.

  */
begin
  _skip_trigger = (coalesce(current_setting('erp_test.kiosk.skip_reverse_trigger', true), '') = 'true');

  if _skip_trigger
  then
    -- skip reverse sync because _skip_trigger flag is on
    -- (don't do  a reverse sync erp_to_pantry because the changes originated from pantry_to_erp sync)
    return null;
  else
    -- do reverse sync
    -- set transaction scope var to indicate that forward trigger should be skipped as no additional changes needed
    set local erp_test.kiosk.skip_forward_trigger='true';

    case
      when tg_op = 'UPDATE' then

        -- Triggered record may have either `id` or `kiosk_id` as the primary key.
        -- Either case, assign its value to _record_id
        _record_id = null;
        begin
          _record_id = new.id;
        exception
          when undefined_column then
            _record_id = new.kiosk_id;
        end;
        update pantry.kiosk k
        set (campus_id, serial, title, address, location_x, location_y, gcm_id, app_vname, app_vcode, archived,
             creation_time, deployment_time, last_update, client_name, last_status, last_inventory, kiosk_name,
             payment_start, payment_stop, features, sales_tax, default_fee_plan, timezone, estd_num_users, tags,
             publicly_accessible, cardkey_required, delivery_insns, fridge_loc_info, contact_first_name,
             contact_last_name, contact_email, contact_phone, accounting_email, byte_discount, subsidy_info,
             subsidy_notes, max_subscription, delivery_window_mon, delivery_window_tue, delivery_window_wed,
             delivery_window_thu, delivery_window_fri, delivery_window_sat, delivery_window_sun, notes, components,
             email_receipt_subject, ops_team_notes, geo, server_url, subscription_amount, enable_reporting,
             enable_monitoring, employees_num, kiosk_restrictions)
              =
            (vk.campus_id, vk.serial, vk.title, vk.address, vk.location_x, vk.location_y, vk.gcm_id, vk.app_vname,
             vk.app_vcode, vk.archived, vk.creation_time, vk.deployment_time, vk.last_update, vk.client_name,
             vk.last_status, vk.last_inventory, vk.kiosk_name, vk.payment_start, vk.payment_stop, vk.features,
             vk.sales_tax, vk.default_fee_plan, vk.timezone, vk.estd_num_users, vk.tags, vk.publicly_accessible,
             vk.cardkey_required, vk.delivery_insns, vk.fridge_loc_info, vk.contact_first_name, vk.contact_last_name,
             vk.contact_email, vk.contact_phone, vk.accounting_email, vk.byte_discount, vk.subsidy_info,
             vk.subsidy_notes, vk.max_subscription, vk.delivery_window_mon, vk.delivery_window_tue,
             vk.delivery_window_wed, vk.delivery_window_thu, vk.delivery_window_fri, vk.delivery_window_sat,
             vk.delivery_window_sun, vk.notes, vk.components, vk.email_receipt_subject, vk.ops_team_notes, vk.geo,
             vk.server_url, vk.subscription_amount, vk.enable_reporting, vk.enable_monitoring, vk.employees_num,
             vk.kiosk_restrictions)
        from (select * from erp_test.kiosk_classic_view where id=_record_id) vk
        where k.id=vk.id;
        return new;

      when tg_op = 'INSERT' then
        -- erp_test.kiosk_classic_view contains the pantry.kiosk equivalent version of kiosk
        -- data of erp_test.kiosk and related tables
        insert into pantry.temp_kiosk select * from erp_test.kiosk_classic_view where id = _record_id;
        return new;

      when tg_op = 'DELETE' then
        delete from pantry.kiosk where id = old.id;
        return old;
      end case;
  end if;
end;
$$;


ALTER FUNCTION erp_test.reverse_sync_kiosk() OWNER TO erpuser;

--
-- Name: sync_kiosk(); Type: FUNCTION; Schema: erp_test; Owner: erpuser
--

CREATE FUNCTION erp_test.sync_kiosk() RETURNS trigger
    LANGUAGE plpgsql
    AS $_$
  /*
  Insert/update/delete erp_test.kiosk and related tables when a pantry.kiosk record is changed

  This code works in conjunction with erp_test.reverse_sync_kiosk. To prevent infinite sync cycle, it does the following:
  1. Use erp_test.kiosk.skip_reverse_trigger transaction scope parameter to signal when it starts
     to prevent a reverse sync to run.
  2. Check if the new record already exists and therefore no changes is needed and the sync should be skipped.

  */

declare
  _client_id integer;
  _client_name text;
  _address_id integer;

  _address1 text;
  _address2 text;
  _city text;
  _state text;
  _zip text;
  _phone text;
  _email text;
  _industry integer;
  _location_type integer := -1;

  _payment_start_date date;
  _payment_stop_date date;

  _general_contact_type integer;
  _general_contact_id integer;
  _accounting_contact_type integer;
  _accounting_contact_id integer;

  _note_type integer;

  -- sync control variables
  _record_exists BOOLEAN;
  _target_record record;
  _insync BOOLEAN;
  _skip_trigger boolean;

begin
  -- 1. Analyze overall trigger and record states

  -- transaction scope parameter
  _skip_trigger = (coalesce(current_setting('erp_test.kiosk.skip_forward_trigger', true), '') = 'true');

  -- calculate sync status of the triggered record
  if tg_op in ('INSERT', 'UPDATE')
  then
    select * from pantry.temp_kiosk where id = new.id into _target_record;

    -- is the new version of record the same as the current record?
    _insync = (_target_record = new);
  else
    _insync = false;
  end if;

  -- 2. Process the trigger according to the overall trigger and record states
  if _skip_trigger or _insync
  then
    -- don't process the current trigger because either _skip_trigger is set, or the record is already in sync
    return null;
  else
    -- record is not in sync, so process the current trigger

    -- 2.1 Disable reverse trigger
    -- set transaction scope var to disable the reverse trigger, otherwise this change will
    -- needlessly trigger the reverse trigger and start an infinite cycle of data sync
    set local erp_test.kiosk.skip_reverse_trigger='true';

    -- 2.2 Prepare relational data for erp_test.kiosk and related tables based on the triggered pantry.kiosk record
    -- this task consists of looking up existing or inserting a new relational record to support the triggered
    -- pantry.kiosk record, for example, adding a new client record.
    if tg_op in  ('INSERT', 'UPDATE')
      then
        select exists(select 1 from erp_test.kiosk where id = new.id) into _record_exists ;

        -- There are many existing client_name=Byte kiosk with bad addresses. Overwrite these with the correct info.
        -- This code is needed for all such kiosk records until after the data have gone through a two way sync cycle
        -- and correction applied.
        if new.client_name = 'Byte'
          then
            new.address = '101 Glacier Point, San Rafael, CA 94901';
            new.contact_first_name = 'Megan';
            new.contact_last_name = 'Mokri';
            new.contact_email = 'megan@bytefoods.co';
            new.accounting_email = 'same';
            new.location_x = 37.950262;
            new.location_y = -122.489975;
        end if;

        -- look up contact type
        select id into _general_contact_type from erp_test.global_attribute_def where name = 'contact_type' and value = 'general';
        select id into _accounting_contact_type from erp_test.global_attribute_def where name = 'contact_type' and value = 'accounting';

        -- prepare address
        select address1, address2, city, state, zip from erp_test.parse_address(new.address)
          into _address1, _address2, _city, _state, _zip;
        -- look up address id
        select address.id into _address_id from erp_test.address
        where address1 = _address1 and address2 = _address2 and city = _city and state = _state and zip = _zip;

        -- if there is no client name, use address
        _client_name = coalesce(new.client_name, 'Address: ' || new.address);

        -- lookup client industry
        select coalesce(ga.id, -1) into _industry
        from erp_test.client_industry ci
               left join (select * from erp_test.global_attribute_def ga where ga.name = 'industry') ga
                         on ci.industry = ga.value
        where ci.client_name = new.client_name;
        if _industry is null then
          _industry = -1;
        end if;

        -- insert into reference tables: client, address, contact

        -- insert client if not exists
        insert into erp_test.client(name, employees_num, industry)
          values(_client_name, new.employees_num, _industry)
          on conflict(name) do nothing;

        -- look up client id
        select id into _client_id from erp_test.client c where c.name = _client_name;

        -- insert address
        insert into erp_test.address(client_id, address1, address2, city, state, zip, location_x, location_y, timezone)
        values(_client_id, _address1, _address2, _city, _state, _zip, new.location_x, new.location_y, new.timezone)
        on conflict(address1) do
          update set
            (client_id, address1, address2, city, state, zip, location_x, location_y, timezone)
              =
                (_client_id,
                 coalesce(_address1, erp_test.address.address1),
                 coalesce(_address2, erp_test.address.address2),
                 coalesce(_city, erp_test.address.city),
                 coalesce(_state, erp_test.address.state),
                 coalesce(_zip, erp_test.address.zip),
                 coalesce(new.location_x, erp_test.address.location_x),
                 coalesce(new.location_y, erp_test.address.location_y),
                 coalesce(new.timezone, erp_test.address.timezone))
          returning id into _address_id;

        -- insert contact
        select phone into _phone from erp_test.parse_phone(new.contact_phone);

        if new.contact_email ~ '^\w+@[0-9a-zA-Z_]+?\.[0-9a-zA-Z]{2,3}$'
        then _email = new.contact_email;
        else _email = null;
        end if;

        -- insert general contact for kiosk contact
        insert into erp_test.contact(client_id, first_name, last_name, email, phone, contact_type)
        values(_client_id, new.contact_first_name, new.contact_last_name, _email, _phone, _general_contact_type)
        on conflict do nothing;

        -- if this is also an accounting contact, insert an accounting contact record
        if new.accounting_email = 'same'
        then insert into erp_test.contact(client_id, first_name, last_name, email, phone, contact_type)
        values(_client_id, new.contact_first_name, new.contact_last_name, _email, _phone, _accounting_contact_type)
        on conflict do nothing;
        end if;

        -- look up client id
        select id into _client_id from erp_test.client where name = _client_name;

        -- look up general contact_id
        select contact.id into _general_contact_id from erp_test.contact
        where first_name = new.contact_first_name and last_name = new.contact_last_name and contact_type = _general_contact_type;

        -- look up accounting contact_id
        select contact.id into _accounting_contact_id from erp_test.contact
        where first_name = new.contact_first_name and last_name = new.contact_last_name and contact_type = _accounting_contact_type;

        if new.payment_start is null or new.payment_start = 0
          then _payment_start_date = null;
          else _payment_start_date = to_timestamp(new.payment_start)::date;
        end if;

        if new.payment_stop is null or new.payment_stop = 0
        then _payment_stop_date = null;
        else _payment_stop_date = to_timestamp(new.payment_stop)::date;
        end if;
    end if;


    -- 2.3 Insert erp_test.kiosk and relational records
    case
      when tg_op = 'INSERT' and not _record_exists
        then
          -- insert kiosk
          insert into erp_test.kiosk(id, campus_id, serial, client_id, title, name, geo, address_id, publicly_accessible,
                                location_type, estd_num_users, enable_reporting, creation_time, deployment_time,
                                deployment_status_id, bank, archived)
            values (new.id, new.campus_id, new.serial, _client_id,
                    new.title, new.kiosk_name, new.geo, _address_id, new.publicly_accessible, _location_type,
                    new.estd_num_users, new.enable_reporting, new.creation_time, new.deployment_time,
                    0, 0, new.archived);

          -- insert hardware_software
          insert into erp_test.hardware_software(kiosk_id, gcm_id, app_vname, app_vcode, features, components,
                                                 server_url, peekaboo_url, email_receipt_subject)
            values(new.id, new.gcm_id, new.app_vname, new.app_vcode, new.features, new.components, new.server_url,
                   '', new.email_receipt_subject);

          -- insert kiosk_accounting
          insert into erp_test.kiosk_accounting(kiosk_id, start_date, payment_start, payment_stop, sales_tax,
                                                default_fee_plan, byte_discount, subsidy_info, max_subscription,
                                                subscription_amount, setup_fee, subsidy_notes)
            values (new.id,
                    null, -- start_date,
                    _payment_start_date, _payment_stop_date, new.sales_tax, new.default_fee_plan, new.byte_discount,
                    new.subsidy_info, new.max_subscription, new.subscription_amount,
                    null, -- new.setup_fee,
                    new.subsidy_notes);

          -- insert location notes
          if new.fridge_loc_info is not null and new.fridge_loc_info <> ''
          then
            select id into _note_type from erp_test.global_attribute_def where name = 'note_type' and value = 'Location';
            insert into erp_test.kiosk_note(kiosk_id, note_type, content)
            values(new.id, _note_type, new.fridge_loc_info);
          end if;

          -- insert Delivery Instruction notes
          if new.delivery_insns is not null and new.delivery_insns <> ''
          then
            select id into _note_type from erp_test.global_attribute_def where name = 'note_type' and value = 'Delivery Instruction';
            insert into erp_test.kiosk_note(kiosk_id, note_type, content)
            values(new.id, _note_type, new.delivery_insns);
          end if;

          -- insert OPS notes
          if new.ops_team_notes is not null and new.ops_team_notes <> ''
          then
            select id into _note_type from erp_test.global_attribute_def where name = 'note_type' and value = 'OPS';
            insert into erp_test.kiosk_note(kiosk_id, note_type, content)
              values(new.id, _note_type, new.ops_team_notes);
          end if;

          -- insert kiosk status
          insert into erp_test.kiosk_status(kiosk_id, last_update, last_status, last_inventory)
            values(new.id, new.last_update, new.last_status, new.last_inventory);

          -- insert kiosk_contact
          if _general_contact_id is not null
            then
              insert into erp_test.kiosk_contact(kiosk_id, contact_id) values(new.id, _general_contact_id)
                on conflict do nothing;
          end if;

          return new;

      -- 2.4 Update erp_test.kiosk and relational records
      when tg_op = 'UPDATE' or (tg_op = 'INSERT' and _record_exists) then
        update erp_test.kiosk
          set
              (id, campus_id, serial, client_id, title, name, geo, address_id, publicly_accessible,
               location_type, estd_num_users, enable_reporting, creation_time, deployment_time,
               deployment_status_id, bank, archived)
            =
              (new.id, new.campus_id, new.serial, _client_id,
               new.title, new.kiosk_name, new.geo, _address_id, new.publicly_accessible, _location_type,
               new.estd_num_users, new.enable_reporting, new.creation_time, new.deployment_time,
               0, 0, new.archived)
            where id = new.id;

        update erp_test.hardware_software
          set
              (gcm_id, app_vname, app_vcode, features, components,
               server_url, peekaboo_url, email_receipt_subject)
            =
                (new.gcm_id, new.app_vname, new.app_vcode, new.features, new.components, new.server_url,
                 '', new.email_receipt_subject)
            where kiosk_id=new.id;

        update erp_test.kiosk_accounting
          set
              (start_date, payment_start, payment_stop, sales_tax, default_fee_plan, byte_discount,
               subsidy_info, max_subscription, subscription_amount, setup_fee, subsidy_notes)
            =
              (null, _payment_start_date, _payment_stop_date, new.sales_tax, new.default_fee_plan, new.byte_discount,
             new.subsidy_info, new.max_subscription, new.subscription_amount, null, new.subsidy_notes)
            where kiosk_id=new.id;

        update erp_test.kiosk_status
          set
              (last_update, last_status, last_inventory)
            =
              (new.last_update, new.last_status, new.last_inventory)
            where kiosk_id=new.id;

        return new;

      -- fixme delete other foreign relation tables refering to this kiosk_id
      when tg_op = 'DELETE'
        then
          delete from erp_test.kiosk where id = old.id;
          delete from erp_test.hardware_software where kiosk_id = old.id;
          delete from erp_test.kiosk_accounting where kiosk_id = old.id;
          delete from erp_test.kiosk_note where kiosk_id = old.id;
          delete from erp_test.kiosk_status where kiosk_id = old.id;
          delete from erp_test.kiosk_contact where kiosk_id = old.id;
          delete from erp_test.kiosk_note where kiosk_id = old.id;
          return old;
      end case;
  end if; -- _skip_trigger or _insync
end;

$_$;


ALTER FUNCTION erp_test.sync_kiosk() OWNER TO erpuser;

--
-- Name: sync_kiosk_reference(); Type: FUNCTION; Schema: erp_test; Owner: erpuser
--

CREATE FUNCTION erp_test.sync_kiosk_reference() RETURNS trigger
    LANGUAGE plpgsql
    AS $_$
  /*

Required: populated erp.global_attribute_def, erp.client_industry
Prepare kiosk reference:

  erp.client
  erp.address
  erp.contact

*/

declare
  i smallint;
  address_fields text[5];
  _client_id integer;
  _client_name text;
  _address_id integer;

  _address1 text;
  _address2 text;
  _city text;
  _state text;
  _zip text;
  _phone text;
  _email text;
  _kiosk_name text;
  _industry integer;
  _location_type_string text;
  _location_type integer;

  _general_contact_type integer;
  _accounting_contact_type integer;
  _accounting_contact_id integer;
  _airport_location_type integer;
  _apartment_location_type integer;
  _gym_location_type integer;
  _higher_education_location_type integer;
  _hospital_location_type integer;
  _hotel_location_type integer;
  _k_12_education_location_type integer;
  _other_location_type integer;
  _workplace_location_type integer;

begin
  -- look up contact type
  select id into _general_contact_type from erp.global_attribute_def where name = 'contact_type' and value = 'general';
  select id into _accounting_contact_type from erp.global_attribute_def where name = 'contact_type' and value = 'accounting';

  -- look up location type
  select id into _airport_location_type from erp.global_attribute_def where name = 'location_type' and value = 'Airport';
  select id into _apartment_location_type from erp.global_attribute_def where name = 'location_type' and value = 'Apartment';
  select id into _gym_location_type from erp.global_attribute_def where name = 'location_type' and value = 'Gym';
  select id into _higher_education_location_type from erp.global_attribute_def where name = 'location_type' and value = 'Higher Education';
  select id into _hospital_location_type from erp.global_attribute_def where name = 'location_type' and value = 'Hospital';
  select id into _hotel_location_type from erp.global_attribute_def where name = 'location_type' and value = 'Hotel';
  select id into _k_12_education_location_type from erp.global_attribute_def where name = 'location_type' and value = 'K-12 Education';
  select id into _other_location_type from erp.global_attribute_def where name = 'location_type' and value = 'Other';
  select id into _workplace_location_type from erp.global_attribute_def where name = 'location_type' and value = 'Workplace';

  if tg_op in ('INSERT', 'UPDATE')
    then
      -- 1. import kiosk and client

      -- prepare addresses
      -- there are many client_name=Byte kiosk with bad addresses
      -- there are many client_name=Byte kiosk with bad addresses
      if new.client_name = 'Byte'
        then
          new.address = '101 Glacier Point, San Rafael, CA 94901';
          new.contact_first_name = 'Megan';
          new.contact_last_name = 'Mokri';
          new.contact_email = 'megan@bytefoods.co';
          new.accounting_email = 'same';
          new.location_x = 37.950262;
          new.location_y = -122.489975;

      end if;

      select address1, address2, city, state, zip from erp.parse_address(new.address)
        into _address1, _address2, _city, _state, _zip;

      -- if there is no client name, use address
      _client_name = coalesce(new.client_name, 'Address: ' || new.address);

      select coalesce(ga.id, -1) into _industry
      from erp.client_industry ci
             left join (select * from erp.global_attribute_def ga where ga.name = 'industry') ga
                       on ci.industry = ga.value
      where ci.client_name = new.client_name;
      if _industry is null then
        _industry = -1;
      end if;

      -- insert client
      insert into erp_test.client(name, employees_num, industry)
        values(_client_name, new.employees_num, _industry)
        on conflict(name) do nothing;

      -- look up client id
      select id into _client_id from erp_test.client c where c.name = _client_name;

      -- insert address
      insert into erp_test.address(client_id, address1, address2, city, state, zip, location_x, location_y, timezone)
      values(_client_id, _address1, _address2, _city, _state, _zip, new.location_x, new.location_y, new.timezone)
      on conflict(address1) do
        update set
          (client_id, address1, address2, city, state, zip, location_x, location_y, timezone)
            =
          (_client_id,
          coalesce(_address1, erp_test.address.address1),
          coalesce(_address2, erp_test.address.address2),
          coalesce(_city, erp_test.address.city),
          coalesce(_state, erp_test.address.state),
          coalesce(_zip, erp_test.address.zip),
          coalesce(new.location_x, erp_test.address.location_x),
          coalesce(new.location_y, erp_test.address.location_y),
          coalesce(new.timezone, erp_test.address.timezone))
        returning id into _address_id;

      -- insert contact
      select phone into _phone from erp.parse_phone(new.contact_phone);

      if new.contact_email ~ '^\w+@[0-9a-zA-Z_]+?\.[0-9a-zA-Z]{2,3}$'
      then _email = new.contact_email;
      else _email = null;
      end if;

      -- insert general contact for kiosk contact
      insert into erp_test.contact(client_id, first_name, last_name, email, phone, contact_type)
      values(_client_id, new.contact_first_name, new.contact_last_name, _email, _phone, _general_contact_type)
      on conflict do nothing;

      -- if this is also an accounting contact, insert an accounting contact record
      if new.accounting_email = 'same'
      then insert into erp_test.contact(client_id, first_name, last_name, email, phone, contact_type)
           values(_client_id, new.contact_first_name, new.contact_last_name, _email, _phone, _accounting_contact_type)
           on conflict do nothing;
      end if;
    return new;
  end if;
end;

$_$;


ALTER FUNCTION erp_test.sync_kiosk_reference() OWNER TO erpuser;

--
-- Name: sync_product(); Type: FUNCTION; Schema: erp_test; Owner: erpuser
--

CREATE FUNCTION erp_test.sync_product() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
declare
  _sku_group_id integer;
  _product_exists BOOLEAN;
  _target_record record;
  _insync BOOLEAN;
  _skip_trigger boolean;
  _consumer_category_id integer;

  /*
  Insert/update/delete erp_test.product and related tables according to tg_op value, except for when insert conflict, then
update erp_test.product and related tables instead. This exception happens if syncing table and synced tables were not
in sync (for example, aws dms was disabled)

  This code works in conjunction with erp_test.reverse_sync_product. To prevent infinite sync cycle, it does the following:
  1. Use erp_test.product.skip_trigger transaction scope parameter to signal when either a sync or reverse sync
    is in progress to prevent a sync to initiate reverse sync an vice versa
  2. Check if the new record already exists and therefore no changes is needed and sync should be skipped

  */

begin
  -- check for transaction scope skip trigger flag from run-time configuration parameters
  _skip_trigger = (coalesce(current_setting('erp_test.product.skip_forward_trigger', true), '') = 'true');

  -- calculate sync status of the triggered record
  if tg_op in ('INSERT', 'UPDATE')
  then
    select * from pantry.product where id = new.id into _target_record;

    -- is the new version of record the same as the current record
    _insync = (_target_record = new);
  else
    _insync = false;
  end if;

  if _skip_trigger -- or _insync
  then
    -- don't process the current trigger because either _skip_trigger is set, or the record is already in sync
    return null;
  else
    -- record is not in sync, and _skip_trigger is false, so disable other triggers for current transaction and
    -- process the current trigger

    -- transaction scope variable to skip reverse trigger
    set local erp_test.product.skip_reverse_trigger='true';

    if tg_op in ('INSERT', 'UPDATE')
    then
      select id from erp_test.sku_group where fc_title = new.fc_title into _sku_group_id;
      select into _product_exists exists(select 1 from erp_test.product where id = new.id);
      select into _consumer_category_id id from product_category_def where name = 'consumer' and value = new.consumer_category;
    end if;

    -- insert data if trigger is insert and product does not exists
    case when tg_op = 'INSERT' and not _product_exists
      then
        -- check if product already exists
        select into _product_exists True from erp_test.product where id = new.id;

        insert into erp_test.product(id, brand, campus_id, sku_group_id, fc_title, archived, last_update)
        values(new.id, new.vendor, new.campus_id, _sku_group_id, new.fc_title, new.archived, new.last_update);

        insert into erp_test.product_asset(product_id, title, description, tiny_description, short_description, medium_description, long_description, image_time)
        values (new.id, new.title, new.description, new.tiny_description, new.short_description, new.medium_description, new.long_description, new.image_time);

        insert into erp_test.product_pricing(product_id,price,cost,ws_case_cost,pricing_tier,taxable)
        values(new.id,new.price,new.cost,new.ws_case_cost,new.pricing_tier,new.taxable);

        insert into erp_test.product_nutrition(product_id,total_cal,num_servings,calories,proteins,sugar,carbohydrates,fat,ingredients,shelf_time)
        values(new.id,new.total_cal,new.num_servings,new.calories,new.proteins,new.sugar,new.carbohydrates,new.fat,new.ingredients,new.shelf_time);

        -- for each attribute in semicolon separated attribute_names, look up corresponding property id
        -- and insert a product_id, property_id in the product_property table
        insert into erp_test.product_property(product_id, property_id)
          select p.id, def.id from
            (select id, unnest(string_to_array(attribute_names, ';')) attrib
             from pantry.product) p
              join erp_test.product_property_def def
                   on p.attrib = def.value and p.id = new.id
          on conflict do nothing;

        insert into erp_test.product_category(product_id, category_id) values(new.id, _consumer_category_id);

        insert into erp_test.product_handling(product_id,width_space,height_space,depth_space,slotted_width,kiosk_ship_qty,
                                         ws_case_size,tag_volume,tag_delivery_option,tag_applied_by,pick_station)
        values(new.id,new.width_space,new.height_space,new.depth_space,new.slotted_width,new.kiosk_ship_qty,
               new.ws_case_size,new.tag_volume,new.delivery_option,new.tag_applied_by,new.pick_station);

        insert into erp_test.product_sourcing(product_id,vendor,source) values(new.id,new.vendor,new.source);

        return new;

      -- update data if either trigger is insert or if product exits
      when tg_op = 'UPDATE' or (tg_op = 'INSERT' and _product_exists) then
        update erp_test.product
        set brand=new.vendor, campus_id=new.campus_id, sku_group_id=_sku_group_id,
            fc_title=new.fc_title, archived=new.archived, last_update=new.last_update
        where id = new.id;

        update erp_test.product_asset
        set title=new.title, description=new.description, tiny_description=new.tiny_description,
            short_description=new.short_description, medium_description=new.medium_description,
            long_description=new.long_description, image_time=new.image_time
        where product_id = new.id;

        update erp_test.product_pricing
        set price=new.price,cost=new.cost,ws_case_cost=new.ws_case_cost,pricing_tier=new.pricing_tier,taxable=new.taxable
        where product_id=new.id;

        update erp_test.product_nutrition
        set total_cal=new.total_cal,num_servings=new.num_servings,calories=new.calories,proteins=new.proteins,
            sugar=new.sugar,carbohydrates=new.carbohydrates,fat=new.fat,ingredients=new.ingredients,
            shelf_time=new.shelf_time where product_id=new.id;

        -- First delete all the corresponding property product_property for the product_id = new.id
        -- Then for each attribute in semicolon separated attribute_names, look up corresponding property id
        -- and insert a product_id, property_id in the product_property table
        delete from erp_test.product_property where product_id=new.id;
        insert into erp_test.product_property(product_id, property_id)
        select p.id, def.id from
          (select id, unnest(string_to_array(attribute_names, ';')) attrib
           from pantry.product) p
            join erp_test.product_property_def def
                 on p.attrib = def.value and p.id = new.id;

        -- update consumer category
        -- use `insert...on conflict update` in case there was no existing consumer category record
        insert into erp_test.product_category(product_id, category_id) values(new.id, _consumer_category_id)
          on conflict(product_id, category_id) do update set category_id = _consumer_category_id;

        update erp_test.product_handling
        set width_space=new.width_space,height_space=new.height_space,depth_space=new.depth_space,
            slotted_width=new.slotted_width,kiosk_ship_qty=new.kiosk_ship_qty,ws_case_size=new.ws_case_size,
            tag_volume=new.tag_volume,tag_delivery_option=new.delivery_option,tag_applied_by=new.tag_applied_by,
            pick_station=new.pick_station
        where product_id=new.id;

        update erp_test.product_sourcing set vendor=new.vendor,source=new.source where product_id=new.id;

        return new;

      when tg_op = 'DELETE' then
        delete from erp_test.product where id = old.id;
        delete from erp_test.product_asset where product_id=old.id;
        delete from erp_test.product_pricing where product_id=old.id;
        delete from erp_test.product_nutrition where product_id=old.id;
        delete from erp_test.product_property where product_id=old.id;
        delete from erp_test.product_handling where product_id=old.id;
        delete from erp_test.product_sourcing where product_id=old.id;
        return old;
      end case;
  end if;
end;
$$;


ALTER FUNCTION erp_test.sync_product() OWNER TO erpuser;

--
-- Name: test(integer); Type: FUNCTION; Schema: erp_test; Owner: erpuser
--

CREATE FUNCTION erp_test.test(_id integer) RETURNS TABLE(twice integer)
    LANGUAGE plpgsql
    AS $$
  /*
    Purpose - Return the first phone number from an contact_phone field in pantry.kiosk string with embedded phones.
    Input -
      s: string with embedded phone

    Return -
      phone: general phone number
      mobile: mobile phone number
    */

declare
  cid integer;
  kid integer;

begin
  cid = (select campus_id from erp.kiosk where id = _id),
  kid = (_id);
  return query
    select cid + kid;
end;

$$;


ALTER FUNCTION erp_test.test(_id integer) OWNER TO erpuser;

--
-- Name: parse_address(text); Type: FUNCTION; Schema: fnrenames; Owner: erpuser
--

CREATE FUNCTION fnrenames.parse_address(address_str text) RETURNS TABLE(address1 text, address2 text, city text, state text, zip text)
    LANGUAGE plpgsql
    AS $$
  /*
    Purpose - parse address fields from an address string
    Input -
      address_str: address string

    Return -
      address1, address2, city, state, zip
    */

declare
  address_fields text[5];
  remainder text;
begin
  address_fields = string_to_array(address_str, ',', null);

  -- trim leading and trailing spaces
  for i in 1..4 loop
      address_fields[i] = trim(address_fields[i]);
      address_fields[i] = trim(address_fields[i], chr(160));
  end loop;

  -- format: 123 Maple Street, San Francisco CA 94965
  if address_fields[3] is null
  then
    remainder = address_fields[2];
    zip = regexp_replace(remainder, '^.* ', '');
    remainder = trim(substring(remainder from 1 for length(remainder) - length(zip)));
    state = regexp_replace(remainder, '^.* ', '');
    city = trim(substring(remainder from 1 for length(remainder) - length(state)));
    address2 = '';
    address1 = address_fields[1];

    -- format: 123 Maple Street, San Francisco, CA 94965
    -- if there is no address2, then insert '' into address2 and shift the rest of address_fields down
  elseif address_fields[4] is null then
    zip = split_part(trim(address_fields[3]), ' ', 2);
    state = split_part(trim(address_fields[3]), ' ', 1);
    city = address_fields[2];
    address2 = '';
    address1 = address_fields[1];

    -- has address2: 123 Maple Street, Apartment A, San Francisco, CA 94965
  else
    -- split address_fields[4] into address_fields[4] and address_fields[5] to handle 'state zip'
    zip = split_part(trim(address_fields[4]), ' ', 2);
    state = split_part(trim(address_fields[4]), ' ', 1);
    city = address_fields[3];
    address2 = address_fields[2];
    address1 = address_fields[1];

  end if;

  return query
    select address1, address2, city, state, zip;
    -- select coalesce(address1, ''), coalesce(address2, ''), coalesce(city, ''),  coalesce(state, ''), coalesce(zip, '');
end;

$$;


ALTER FUNCTION fnrenames.parse_address(address_str text) OWNER TO erpuser;

--
-- Name: parse_phone(text); Type: FUNCTION; Schema: fnrenames; Owner: erpuser
--

CREATE FUNCTION fnrenames.parse_phone(text_to_parse text) RETURNS TABLE(phone text)
    LANGUAGE plpgsql
    AS $$
  /*
    Purpose - Return the first phone number from an contact_phone field in pantry.kiosk string with embedded phones.
    Input -
      s: string with embedded phone

    Return -
      phone: general phone number
      mobile: mobile phone number
    */

declare
  s text;
  parsed_phone text default null;

begin
  s = regexp_replace(text_to_parse, '\D', '', 'g');
  if length(s) >= 10
  then
    parsed_phone = substring(s, 1, 10);
  end if;
  return query
    select parsed_phone;
end;

$$;


ALTER FUNCTION fnrenames.parse_phone(text_to_parse text) OWNER TO erpuser;

--
-- Name: pg_create_logical_replication_slot(name, name, boolean); Type: FUNCTION; Schema: fnrenames; Owner: erpuser
--

CREATE FUNCTION fnrenames.pg_create_logical_replication_slot(slot_name name, plugin name, temporary boolean DEFAULT false, OUT slot_name name, OUT xlog_position pg_lsn) RETURNS record
    LANGUAGE sql
    AS $$
   SELECT slot_name::NAME, lsn::pg_lsn FROM pg_catalog.pg_create_logical_replication_slot(slot_name, plugin,
   temporary); $$;


ALTER FUNCTION fnrenames.pg_create_logical_replication_slot(slot_name name, plugin name, temporary boolean, OUT slot_name name, OUT xlog_position pg_lsn) OWNER TO erpuser;

--
-- Name: pg_current_xlog_flush_location(); Type: FUNCTION; Schema: fnrenames; Owner: erpuser
--

CREATE FUNCTION fnrenames.pg_current_xlog_flush_location() RETURNS pg_lsn
    LANGUAGE sql
    AS $$
   SELECT pg_current_wal_flush_lsn(); $$;


ALTER FUNCTION fnrenames.pg_current_xlog_flush_location() OWNER TO erpuser;

--
-- Name: pg_current_xlog_insert_location(); Type: FUNCTION; Schema: fnrenames; Owner: erpuser
--

CREATE FUNCTION fnrenames.pg_current_xlog_insert_location() RETURNS pg_lsn
    LANGUAGE sql
    AS $$
   SELECT pg_current_wal_insert_lsn(); $$;


ALTER FUNCTION fnrenames.pg_current_xlog_insert_location() OWNER TO erpuser;

--
-- Name: pg_current_xlog_location(); Type: FUNCTION; Schema: fnrenames; Owner: erpuser
--

CREATE FUNCTION fnrenames.pg_current_xlog_location() RETURNS pg_lsn
    LANGUAGE sql
    AS $$
   SELECT pg_current_wal_lsn(); $$;


ALTER FUNCTION fnrenames.pg_current_xlog_location() OWNER TO erpuser;

--
-- Name: pg_is_xlog_replay_paused(); Type: FUNCTION; Schema: fnrenames; Owner: erpuser
--

CREATE FUNCTION fnrenames.pg_is_xlog_replay_paused() RETURNS boolean
    LANGUAGE sql
    AS $$
   SELECT pg_is_wal_replay_paused(); $$;


ALTER FUNCTION fnrenames.pg_is_xlog_replay_paused() OWNER TO erpuser;

--
-- Name: pg_last_xlog_receive_location(); Type: FUNCTION; Schema: fnrenames; Owner: erpuser
--

CREATE FUNCTION fnrenames.pg_last_xlog_receive_location() RETURNS pg_lsn
    LANGUAGE sql
    AS $$
   SELECT pg_last_wal_receive_lsn(); $$;


ALTER FUNCTION fnrenames.pg_last_xlog_receive_location() OWNER TO erpuser;

--
-- Name: pg_last_xlog_replay_location(); Type: FUNCTION; Schema: fnrenames; Owner: erpuser
--

CREATE FUNCTION fnrenames.pg_last_xlog_replay_location() RETURNS pg_lsn
    LANGUAGE sql
    AS $$
   SELECT pg_last_wal_replay_lsn(); $$;


ALTER FUNCTION fnrenames.pg_last_xlog_replay_location() OWNER TO erpuser;

--
-- Name: pg_switch_xlog(); Type: FUNCTION; Schema: fnrenames; Owner: erpuser
--

CREATE FUNCTION fnrenames.pg_switch_xlog() RETURNS pg_lsn
    LANGUAGE sql
    AS $$
   SELECT pg_switch_wal(); $$;


ALTER FUNCTION fnrenames.pg_switch_xlog() OWNER TO erpuser;

--
-- Name: pg_xlog_location_diff(pg_lsn, pg_lsn); Type: FUNCTION; Schema: fnrenames; Owner: erpuser
--

CREATE FUNCTION fnrenames.pg_xlog_location_diff(lsn1 pg_lsn, lsn2 pg_lsn) RETURNS numeric
    LANGUAGE sql
    AS $$
   SELECT pg_wal_lsn_diff(lsn1, lsn2); $$;


ALTER FUNCTION fnrenames.pg_xlog_location_diff(lsn1 pg_lsn, lsn2 pg_lsn) OWNER TO erpuser;

--
-- Name: pg_xlog_replay_pause(); Type: FUNCTION; Schema: fnrenames; Owner: erpuser
--

CREATE FUNCTION fnrenames.pg_xlog_replay_pause() RETURNS void
    LANGUAGE sql
    AS $$
   SELECT pg_wal_replay_pause(); $$;


ALTER FUNCTION fnrenames.pg_xlog_replay_pause() OWNER TO erpuser;

--
-- Name: pg_xlog_replay_resume(); Type: FUNCTION; Schema: fnrenames; Owner: erpuser
--

CREATE FUNCTION fnrenames.pg_xlog_replay_resume() RETURNS void
    LANGUAGE sql
    AS $$
   SELECT pg_wal_replay_resume(); $$;


ALTER FUNCTION fnrenames.pg_xlog_replay_resume() OWNER TO erpuser;

--
-- Name: pg_xlogfile_name(pg_lsn); Type: FUNCTION; Schema: fnrenames; Owner: erpuser
--

CREATE FUNCTION fnrenames.pg_xlogfile_name(lsn pg_lsn) RETURNS text
    LANGUAGE sql
    AS $$
   SELECT pg_walfile_name(lsn); $$;


ALTER FUNCTION fnrenames.pg_xlogfile_name(lsn pg_lsn) OWNER TO erpuser;

--
-- Name: pg_xlogfile_name_offset(pg_lsn); Type: FUNCTION; Schema: fnrenames; Owner: erpuser
--

CREATE FUNCTION fnrenames.pg_xlogfile_name_offset(lsn pg_lsn, OUT text, OUT integer) RETURNS record
    LANGUAGE sql
    AS $$
   SELECT pg_walfile_name_offset(lsn); $$;


ALTER FUNCTION fnrenames.pg_xlogfile_name_offset(lsn pg_lsn, OUT text, OUT integer) OWNER TO erpuser;

--
-- Name: some_f(character varying); Type: FUNCTION; Schema: fnrenames; Owner: erpuser
--

CREATE FUNCTION fnrenames.some_f(param character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$

BEGIN
      EXECUTE 'select id FROM ' || quote_ident(param);
END;
$$;


ALTER FUNCTION fnrenames.some_f(param character varying) OWNER TO erpuser;

--
-- Name: f_kiosk_sku_group_sku_pick_stats(timestamp with time zone); Type: FUNCTION; Schema: inm; Owner: erpuser
--

CREATE FUNCTION inm.f_kiosk_sku_group_sku_pick_stats(pick_time timestamp with time zone) RETURNS TABLE(kiosk_id integer, sku_group character varying, sku_group_id integer, sku integer, kiosk_on_route integer, kiosk_sku_enabled integer, kiosk_priority integer, sku_priority integer, sku_group_demand_week integer, kiosk_demand_plan_ratio numeric, sku_group_inventory_qty integer, sku_inventory_actual_qty integer, sku_group_inventory_actual_qty integer, sku_group_min_qty integer, sku_group_order_qty integer, sku_group_allocation_total integer, sku_allocation_qty integer, fleet_sku_group_order_total integer, fleet_sku_group_allocation_total integer, fleet_sku_allocation_total integer, warehouse_sku_inventory_stickered integer, warehouse_sku_inventory_unstickered integer, warehouse_sku_group_inventory_stickered integer, warehouse_sku_group_inventory_unstickered integer, substituted character varying, substituted_qty character varying, substituting character varying, substituting_qty character varying, sku_rejection integer, sku_preference_velocity numeric, sku_preference_normalized integer)
    LANGUAGE plpgsql
    AS $$
begin
  -- author: Art
  -- summarize allocation factors and results
  return query
    -- TODO: improve inventory actual computation
    select k.kiosk_id::int kiosk_id,
      p.sku_group sku_group,
      sg.sku_group_id sku_group_id,
      p.sku::int sku,
      coalesce(pr.on_route, 0) kiosk_on_route,
      coalesce(kpd.enabled, 1) kiosk_sku_enabled,
      coalesce(ppk.priority, 100) kiosk_priority,
      coalesce(pps.priority, 100) sku_priority,
      coalesce(pgo.demand_week, 0) sku_group_demand_week,
      coalesce(kdpr.kiosk_demand_plan_ratio, 0) kiosk_demand_plan_ratio,
      coalesce(pi.inventory_qty, 0) sku_group_inventory_qty,
      coalesce(l.stock_count, 0)::int sku_inventory_actual_qty,
      coalesce(sum(l.stock_count) over (partition by sg.sku_group, k.kiosk_id), 0)::int
        sku_group_inventory_actual_qty,
      coalesce(sga.sku_group_min_qty, 0) sku_group_min_qty,
      coalesce(pd.order_qty, 0) sku_group_order_qty,
      coalesce(sum(pa.allocation_qty) over (partition by sg.sku_group, k.kiosk_id), 0)::int sku_group_allocation_total,
      coalesce(pa.allocation_qty, 0) sku_allocation_qty,
      coalesce((sum(pd.order_qty) over (partition by sg.sku_group))/(count(p.sku)
        over (partition by sg.sku_group, k.kiosk_id)), 0)::int fleet_sku_group_order_total,
      coalesce(sum(pa.allocation_qty) over (partition by sg.sku_group), 0)::int fleet_sku_group_allocation_total,
      coalesce(sum(pa.allocation_qty) over (partition by p.sku), 0)::int fleet_sku_allocation_total,
      coalesce(wi.inventory_stickered, 0) warehouse_sku_inventory_stickered,
      coalesce(wi.inventory_unstickered, 0) warehouse_sku_inventory_unstickered,
      coalesce(sum(wi.inventory_stickered) over (partition by sg.sku_group, k.kiosk_id), 0)::int
        warehouse_sku_group_inventory_stickered,
      coalesce(sum(wi.inventory_unstickered) over (partition by sg.sku_group, k.kiosk_id), 0)::int
        warehouse_sku_group_inventory_unstickered,
      ps.substituted::varchar substituted,
      ps.substituted_qty::varchar substituted_qty,
      ps2.substituting::varchar substituting,
      ps2.substituting_qty::varchar substituting_qty,
      coalesce(pre.rejection, 0)::int sku_rejection,
      ksv.preference sku_preference_velocity,
      ppks.preference::int sku_preference_normalized
    from (
      select k.id as kiosk_id
      from pantry.kiosk k
      where k.campus_id=87
      and k.archived=0
    ) k

           cross join (
        select p.fc_title sku_group,
          p.id sku
        from pantry.product p
        where p.campus_id=87
        and p.archived=0
        and p.fc_title is not null
        and p.fc_title!='N/A'
      ) p

           left join (
        select sg.fc_title sku_group,
          sg.id sku_group_id
        from inm.sku_group sg
      ) sg on p.sku_group=sg.sku_group

           left join (
        select pr.kiosk_id kiosk_id,
          1 on_route
        from inm.pick_route pr
        where pr.pick_date=pick_time::date
      ) pr on k.kiosk_id=pr.kiosk_id

           left join (
        -- warehouse inventory
        select wi.product_id sku,
              wi.units_per_case*wi.stickered_cases+wi.stickered_units inventory_stickered,
              wi.units_per_case*wi.unstickered_cases+wi.unstickered_units inventory_unstickered
        from inm.warehouse_inventory wi
        where wi.inventory_date=pick_time::date
      ) wi on p.sku=wi.sku

           left join (
        --  demand_week
        select pgo.kiosk_id kiosk_id,
          pgo.fc_title sku_group,
          pgo.week_qty demand_week
        from inm.pick_get_order(pick_time::date+interval '21 hours', pick_time::date+interval '43 hours') pgo
      ) pgo on k.kiosk_id=pgo.kiosk_id and p.sku_group=pgo.sku_group

           left join (
        -- kiosk inventory
        select pi.kiosk_id kiosk_id,
          pi.sku_group_id sku_group_id,
          pi.qty inventory_qty
        from inm.pick_inventory pi
        where pi.pick_date=pick_time::date
      ) pi on k.kiosk_id=pi.kiosk_id and sg.sku_group_id=pi.sku_group_id

           left join (
        -- order
        select pd.kiosk_id kiosk_id,
          pd.sku_group_id sku_group_id,
          pd.qty order_qty
        from inm.pick_demand pd
        where pd.pick_date=pick_time::date
      ) pd on k.kiosk_id=pd.kiosk_id and sg.sku_group_id=pd.sku_group_id

           left join (
        -- allocation
        select pa.kiosk_id kiosk_id,
          pa.sku_id sku,
          pa.qty allocation_qty
        from inm.pick_allocation pa
        where pa.pick_date=pick_time::date
      ) pa on k.kiosk_id=pa.kiosk_id and p.sku=pa.sku

           left join (
        select ppk.kiosk_id kiosk_id,
          ppk.priority priority
        from inm.pick_priority_kiosk ppk
      ) ppk on k.kiosk_id=ppk.kiosk_id

           left join (
        select pps.sku_id sku,
          pps.priority priority
        from inm.pick_priority_sku pps
      ) pps on p.sku=pps.sku

           left join (
        select kpd.kiosk_id kiosk_id,
          kpd.product_id sku,
          case when kpd.product_id is not null then 0
               else 1
            end as enabled
        from inm.kiosk_product_disabled kpd
      ) kpd on k.kiosk_id=kpd.kiosk_id and p.sku=kpd.sku

           left join (
        select l.kiosk_id as kiosk_id,
          p.fc_title as sku_group,
          l.product_id as sku,
          count(*) as stock_count
        from pantry.label l
               left join pantry.product p
                         on l.product_id=p.id
        where to_timestamp(time_added) < pick_time
        and to_timestamp(time_updated) > pick_time
        and p.campus_id=87
        and p.archived=0
        and p.fc_title is not null
        and p.fc_title!='N/A'
        group by l.kiosk_id,
          p.fc_title,
          l.product_id
      ) l on k.kiosk_id=l.kiosk_id and p.sku=l.sku

           left join (
        select ps.substituting_sku_group_id sku_group_id,
          string_agg(ps.substituted_sku_group_id::text, ',' order by ps.substituted_sku_group_id asc) substituted,
          string_agg(ps.qty::text, ',' order by ps.substituted_sku_group_id) substituted_qty
        from inm.pick_substitution ps
        where ps.pick_date=pick_time::date
        group by ps.substituting_sku_group_id
      ) ps on sg.sku_group_id=ps.sku_group_id

           left join (
        select ps.substituted_sku_group_id sku_group_id,
          string_agg(ps.substituting_sku_group_id::text, ',' order by ps.substituting_sku_group_id asc) substituting,
          string_agg(ps.qty::text, ',' order by ps.substituting_sku_group_id) substituting_qty
        from inm.pick_substitution ps
        where ps.pick_date=pick_time::date
        group by ps.substituted_sku_group_id
      ) ps2 on sg.sku_group_id=ps2.sku_group_id

           left join (
        select pre.kiosk_id kiosk_id,
          pre.item_id  sku,
          count(pre.reason) as rejection
        from inm.pick_rejection pre
        where pre.pick_date=pick_time::date
        and item_type = 'sku_id'
        group by pre.kiosk_id,
          pre.item_id
      ) pre on k.kiosk_id=pre.kiosk_id and p.sku=pre.sku

           left join (
        select ksv.kiosk_id kiosk_id,
          ksv.sku sku,
          ksv.preference preference
        from inm.v_kiosk_sku_velocity ksv
      ) ksv on k.kiosk_id=ksv.kiosk_id and p.sku=ksv.sku

           left join (
        select ppks.kiosk_id kiosk_id,
          ppks.sku_id sku,
          ppks.preference preference
        from mixalot.pick_preference_kiosk_sku ppks
      ) ppks on k.kiosk_id=ppks.kiosk_id and p.sku=ppks.sku

           left join (
        select sga.id as sku_group_id,
          sga.minimum_kiosk_qty as sku_group_min_qty
        from inm.sku_group_attribute sga
      ) sga on sg.sku_group_id=sga.sku_group_id

           left join (
        select kdpr.kiosk_id kiosk_id,
          case when extract(dow from pick_time)=0 then d0_plan_demand_ratio
               when extract(dow from pick_time)=1 then d1_plan_demand_ratio
               when extract(dow from pick_time)=2 then d2_plan_demand_ratio
               when extract(dow from pick_time)=3 then d3_plan_demand_ratio
               when extract(dow from pick_time)=4 then d4_plan_demand_ratio
               else 0
            end kiosk_demand_plan_ratio
        from inm.v_kiosk_demand_plan_ratio kdpr
      ) kdpr on k.kiosk_id=kdpr.kiosk_id

    order by k.kiosk_id asc,
      p.sku_group asc,
      p.sku asc;

end;

$$;


ALTER FUNCTION inm.f_kiosk_sku_group_sku_pick_stats(pick_time timestamp with time zone) OWNER TO erpuser;

--
-- Name: FUNCTION f_kiosk_sku_group_sku_pick_stats(pick_time timestamp with time zone); Type: COMMENT; Schema: inm; Owner: erpuser
--

COMMENT ON FUNCTION inm.f_kiosk_sku_group_sku_pick_stats(pick_time timestamp with time zone) IS 'summarize allocation settings, input, and results';


--
-- Name: get_pull_date(timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: inm; Owner: erpuser
--

CREATE FUNCTION inm.get_pull_date(plan_window_start timestamp with time zone, plan_window_stop timestamp with time zone) RETURNS TABLE(kiosk_id integer, delivery_date date, pull_date date)
    LANGUAGE plpgsql
    AS $$
  /*
  pull_date is target expiration date for the restocker to remove food from the kiosk.
  The later the pull_date, the more food get removed. Unnecessarily late pull_dates
  cause higher spoilage.

  This function computes normal_pull_date and enhanced_pull_date, then return enhanced_pull_date
  if available, otherwise normal_pull_date.

  normal_pull_date is the day before the next delivery, meaning at restock time, all food expires
  before the next delivery date is removed.

  enhanced_pull_date looks at past sales by day of the week for the kiosk, and set the pull_date
  to the last business day for the kiosk before the normal_pull_date.

  For a typical kiosk with last delivery of the week on Wednesday or Thursday and no business on
  the weekend, enhanced_pull_date will prevent food that are OK up to the end of Friday in the
  kiosk to be sold, which otherwise would be removed by normal_pull_date because they would
  expire on the weekend.
  */

begin
  set timezone to 'US/Pacific';
  return query
    with
      -- delivery date
      dd as
        (select t.kiosk_id, t.delivery_date_time as delivery_dt from
          (select location_number as kiosk_id, rs.route_date_time as delivery_date_time,
                  dense_rank() over (partition by location_number order by rs.route_date_time) as r
           from mixalot.route_stop rs
           where rs.route_date_time >= plan_window_start -- routes starting at plan window start
             and rs.route_date_time <= plan_window_stop
             and location_number > 0) t
         where r = 1),

      -- normal pull date
      npd as
      (select t.kiosk_id,
              t.delivery_date_time - interval '1 days' as pull_date,
              extract(dow from t.delivery_date_time) as dow
        from
          (select location_number as kiosk_id, rs.route_date_time as delivery_date_time,
                  dense_rank() over (partition by location_number order by rs.route_date_time) as r
           from mixalot.route_stop rs
           where rs.route_date_time >= plan_window_start -- routes starting at plan window start
             and location_number > 0) t
         where r = 2),

      -- possible enhanced pull dates - start with next 7 days before narrowing down to the best day
      pepd as
        (select d as pull_date, extract(dow from d) as dow
          from (select generate_series(plan_window_start,
            plan_window_start::timestamp + interval '6 days', interval '1 days')::date as d) dates),

      -- sales_history - kiosk and dow with sales
      sales_history as
        (select v.kiosk_id, v.dow
          from inm.v_kiosk_sale_hourly v
          group by 1, 2
          having sum(units_sold_normalized) >= 0.05),

      -- kiosk_id, delivery_date, enhanced_pull_date
      epd as
        (select dd.kiosk_id, dd.delivery_dt,
             max(pepd.pull_date) as pull_date
          from dd
            join npd on dd.kiosk_id = npd.kiosk_id
            left join sales_history on dd.kiosk_id = sales_history.kiosk_id
            left join pepd on sales_history.dow = pepd.dow
          where
            pepd.pull_date > dd.delivery_dt and pepd.pull_date < npd.pull_date
            group by 1,2)

  -- return kiosk_id, delivery_date, the best pull date
  select dd.kiosk_id,
         dd.delivery_dt::date,
         coalesce(epd.pull_date, npd.pull_date::date) as pull_date
    from dd
      join npd on dd.kiosk_id = npd.kiosk_id
      left join epd on dd.kiosk_id = epd.kiosk_id;
end;

$$;


ALTER FUNCTION inm.get_pull_date(plan_window_start timestamp with time zone, plan_window_stop timestamp with time zone) OWNER TO erpuser;

--
-- Name: FUNCTION get_pull_date(plan_window_start timestamp with time zone, plan_window_stop timestamp with time zone); Type: COMMENT; Schema: inm; Owner: erpuser
--

COMMENT ON FUNCTION inm.get_pull_date(plan_window_start timestamp with time zone, plan_window_stop timestamp with time zone) IS 'return pull_date per kiosk per pick window';


--
-- Name: get_spoilage_pull_list(); Type: FUNCTION; Schema: inm; Owner: erpuser
--

CREATE FUNCTION inm.get_spoilage_pull_list() RETURNS TABLE(category character varying, kiosk_id bigint, kiosk_title character varying, product_id bigint, product_tile character varying, epc character varying)
    LANGUAGE plpgsql
    AS $$
BEGIN
        RETURN QUERY
/*
This query is used to identify items that will spoil before the next delivery.
This function does not use kiosk id as an input.
It return expected spoilage for the whole Byte fleet.
A spoiled item uses the following
criteria:
if ( skuShelfLife <= 7 days ) {
if ( skuEpcDateAdded + kioskNextDelvieryDate > skuShelfLife )
{Show in pull list (red);}
}
else if ( skuShelfLife > 7 days && skuShelfLife <= 30 days ){
if ( skuEpcDateAdded + kioskNextDelvieryDate > skuShelfLife )
{Show in check list (yellow);}
}
SEE ENG-555
*/
        SELECT CASE WHEN shelf_time <= 7 THEN 'SPOILAGE RED'::varchar ELSE 'SPOILAGE YELLOW'::varchar END as category,
            l.kiosk_id as kiosk_id,
            k.title as kiosk_title,
            l.product_id as product_id,
            p.title as product_tile,
            l.epc as epc
            FROM pantry.label l
            JOIN pantry.product p ON l.product_id = p.id
            JOIN pantry.kiosk k ON l.kiosk_id = k.id
            --- Get next delivery date
            JOIN (select location_number,
                min(route_date_time) as next_delivery_date
                FROM mixalot.route_stop
                WHERE route_date_time::date > now()::date
                GROUP BY location_number
            ) as next_delivery
            ON l.kiosk_id = next_delivery.location_number
            WHERE l.status = 'ok'
            AND k.archived = 0
            AND k.campus_id = 87
            AND p.campus_id = 87
            AND (
                    (
                        shelf_time <= 7
                        AND
                        (next_delivery.next_delivery_date::date - to_timestamp(l.time_added)::date) > p.shelf_time
                    )
                    OR
                    (
                        shelf_time > 7
                        AND shelf_time <= 30
                        AND
                        (next_delivery.next_delivery_date::date - to_timestamp(l.time_added)::date) > p.shelf_time
                    )
                )
            ORDER BY kiosk_id, category;
    END;
$$;


ALTER FUNCTION inm.get_spoilage_pull_list() OWNER TO erpuser;

--
-- Name: FUNCTION get_spoilage_pull_list(); Type: COMMENT; Schema: inm; Owner: erpuser
--

COMMENT ON FUNCTION inm.get_spoilage_pull_list() IS 'return items that will spoil before the next delivery';


--
-- Name: pick_check_duplicate_stop(); Type: FUNCTION; Schema: inm; Owner: erpuser
--

CREATE FUNCTION inm.pick_check_duplicate_stop() RETURNS TABLE(kiosk_id integer, driver_name character varying, order_number character varying, route_date_time timestamp with time zone)
    LANGUAGE plpgsql
    AS $$
  /*
    Purpose: return duplicate stops present in table route_stop for route stop from present day forward
    */
begin
  set timezone to 'US/Pacific';
  return query
    select s.location_number, s.driver_name, s.order_number, s.route_date_time

    from mixalot.route_stop s
       join
          -- duplicate stops
         (select rs.route_date_time, rs.location_number, count(*) from mixalot.route_stop rs
          where rs.route_date_time::date >= current_date and location_number <> -1
          group by 1,2 having count(*) > 1) d
       on s.location_number=d.location_number and s.route_date_time=d.route_date_time;
end;

$$;


ALTER FUNCTION inm.pick_check_duplicate_stop() OWNER TO erpuser;

--
-- Name: pick_check_restriction(date); Type: FUNCTION; Schema: inm; Owner: erpuser
--

CREATE FUNCTION inm.pick_check_restriction(_pick_date date) RETURNS TABLE(kiosk_id integer, product_id integer)
    LANGUAGE plpgsql
    AS $$

/*
Purpose: return restricted products found in allocation. An empty set means no restricted products are allocated for any kiosk.
*/

begin
	return query
		select a.kiosk_id, a.sku_id
			from (select * from inm.pick_allocation a where a.pick_date = _pick_date) a
				join inm.kiosk_product_disabled d on a.kiosk_id = d.kiosk_id and a.sku_id = d.product_id;
end;

$$;


ALTER FUNCTION inm.pick_check_restriction(_pick_date date) OWNER TO erpuser;

--
-- Name: pick_get_delivery_schedule(date); Type: FUNCTION; Schema: inm; Owner: erpuser
--

CREATE FUNCTION inm.pick_get_delivery_schedule(pick_date date) RETURNS TABLE(driver_name character varying, route_date_time timestamp with time zone, kiosk_id integer, kiosk_title character varying, address character varying, delivery_order integer)
    LANGUAGE plpgsql
    AS $$
declare
		latest_import_ts timestamp;
		pst_plan_window_start_str text;
		plan_window_start timestamp with time zone;
	 	plan_window_stop timestamp with time zone;

/*
Purpose: return INM delivery schedule for a pick date.
Input
	target_date: pick_date
Return
	Data to generate the drivers sheets
*/
begin
	if pick_date is not null
		then
			-- compose US/Pacific start window timestamp string
			pst_plan_window_start_str = cast(pick_date as text) || ' 13:00 -8';
			select into plan_window_start cast(pst_plan_window_start_str as timestamp with time zone);
			plan_window_stop = plan_window_start + interval '22 hours';

		-- fixme: remove when obsolete
		-- backward compat with run pick using inm gsheets with plan window imported into mixalot.inm_data
		else
			select max(import_ts) from mixalot.inm_data into latest_import_ts;
			select i.route_date from mixalot.inm_data i
				where import_ts = latest_import_ts and data_type = 'Plan Window Start'
				into plan_window_start;
			select i.route_date from mixalot.inm_data i
				where import_ts = latest_import_ts and data_type = 'Plan Window Stop'
				into plan_window_stop;
		end if;

	return query
		select rs.driver_name, rs.route_date_time, location_number kiosk_id, k.title kiosk_title, k.address, rs.stop_number delivery_order
			from mixalot.route_stop rs join pantry.kiosk k on rs.location_number = k.id
			where rs.route_date_time between plan_window_start and plan_window_stop;
end;

$$;


ALTER FUNCTION inm.pick_get_delivery_schedule(pick_date date) OWNER TO erpuser;

--
-- Name: pick_get_demand_weekly_by_velocity(); Type: FUNCTION; Schema: inm; Owner: erpuser
--

CREATE FUNCTION inm.pick_get_demand_weekly_by_velocity() RETURNS TABLE(kiosk_id bigint, sku_group_id integer, fc_title text, kc_start_level numeric, kc_min_level numeric, kc_manual_multiplier numeric, sgc_default_level numeric, sgc_scale numeric, ksms_scale numeric, ws_live bigint, velocity_demand numeric, demand_weekly numeric)
    LANGUAGE plpgsql
    AS $$

/*
revision date: 2019-01-09
purpose: return inm weekly demand by velocity
*/

begin
	return query
		select cast(dwwom.kiosk_id as bigint),
			dwwom.sku_group_id,
			dwwom.sku_group,
			dwwom.kc_start_level,
			dwwom.kc_min_level,
			dwwom.kc_manual_multiplier,
			dwwom.sgc_default_level,
			dwwom.sgc_scale,
			dwwom.ksms_scale,
			dwwom.ws_live,
			dwwom.preference_count,

			case when dwwom.ws_live < 4
			then greatest(dwwom.start_count, dwwom.preference_count)
			else greatest(dwwom.min_count, dwwom.preference_count)
			end as wk_demand

		from inm.pick_get_demand_weekly_wo_min() dwwom;
end;

$$;


ALTER FUNCTION inm.pick_get_demand_weekly_by_velocity() OWNER TO erpuser;

--
-- Name: pick_get_demand_weekly_wo_min(); Type: FUNCTION; Schema: inm; Owner: erpuser
--

CREATE FUNCTION inm.pick_get_demand_weekly_wo_min() RETURNS TABLE(kiosk_id integer, sku_group_id integer, sku_group text, sample_size bigint, preference numeric, ws_avg numeric, ws_std numeric, ws_live bigint, kc_start_level numeric, kc_min_level numeric, kc_manual_multiplier numeric, sgc_default_level numeric, sgc_scale numeric, ksms_scale numeric, start_count numeric, min_count numeric, scaled_preference numeric, scaled_preference_total numeric, preference_count numeric)
    LANGUAGE plpgsql
    AS $$
  /*
    revision date: 2019-01-09
    author: Art
    purpose: return inm_beta weekly demand without min by velocity
    */

begin
  return query
    select kc.kiosk_id as kiosk_id,
      sg.id as sku_group_id,
      cast(sg.fc_title as text) as sku_group,
      coalesce(dwwom.sample_size, 0) as sample_size, -- dwwom missing some records for archived/old kiosks
      coalesce(dwwom.preference, 0.00) as preference, -- dwwom missing some records for archived/old kiosks
      max(coalesce(dwwom.ws_avg, 0.00)) over (partition by kc.kiosk_id) as ws_avg, --dwwom missing some records for archived/old kiosks
      max(coalesce(dwwom.ws_std, 0.00)) over (partition by kc.kiosk_id) as ws_std, --dwwom missing some records for archived/old kiosks
      max(coalesce(dwwom.ws_live, 0)) over (partition by kc.kiosk_id) as ws_live, -- dwwom missing some records for archived/old kiosks
      kc.start_level as kc_start_level,
      kc.min_level as kc_min_level,
      kc.manual_multiplier as kc_manual_multiplier,
      sgc.default_level as sgc_default_level,
      sgc.scale as sgc_scale,
      coalesce(ksms.scale, 1.00) as ksms_scale,
      round(kc.start_level*kc.manual_multiplier*sgc.scale*coalesce(ksms.scale, 1.00)*sgc.scale*sgc.default_level, 2)
        as start_count,
      round(kc.min_level*kc.manual_multiplier*sgc.scale*coalesce(ksms.scale, 1.00)*sgc.scale*sgc.default_level, 2)
        as min_count,
      round(coalesce(dwwom.preference, 0.00)*kc.manual_multiplier*sgc.scale*coalesce(ksms.scale, 1.00), 2)
        as scaled_preference,
      round(sum(coalesce(dwwom.preference, 0.00)*kc.manual_multiplier*sgc.scale*coalesce(ksms.scale, 1.00))
        over (partition by kc.kiosk_id), 2) as scaled_preference_total,
      round(coalesce(dwwom.ws_avg + dwwom.ws_std, 0.00)
              * (coalesce(dwwom.preference, 0.00)*kc.manual_multiplier*sgc.scale
                   *coalesce(ksms.scale, 1.00)
                   / greatest(0.01, sum(coalesce(dwwom.preference, 0.00)*kc.manual_multiplier*sgc.scale*coalesce(ksms.scale, 1.00))
                     over (partition by kc.kiosk_id))), 2) as preference_count
    from inm.sku_group sg
           cross join inm.kiosk_control kc
           left join inm.kiosk_sku_group_manual_scale ksms on ksms.kiosk_id=kc.kiosk_id and ksms.sku_group_id=sg.id
           left join inm.sku_group_control sgc on sgc.sku_group_id = sg.id
           left join
      (select t4.kiosk_id,
         t4.sku_group,
         t4.sample_size,
         t4.dt_avg,
         t4.dt_std,
         t4.w_departure_time,
         t4.preference,
         t6.ws_avg,
         t6.ws_std,
         t6.ws_live
      from (
        select t3.kiosk_id,
          t3.sku_group,
          count(t3.purchase_index) as sample_size,
          round((avg(t3.departure_time))::numeric, 2) as dt_avg,
          coalesce(round((stddev(t3.departure_time))::numeric, 2), 0) as dt_std,
          round(sum(t3.departure_time*t3.w)/sum(t3.w)::numeric, 2) as w_departure_time,
          least(round(1.00/(sum(t3.departure_time*t3.w)/sum(t3.w))::numeric, 2), 0.20) as preference
        from (
          select *,
            greatest(coalesce(round((t2.time_sold - greatest(t2.last_sale, t2.time_stocked))::numeric/3600, 2), 50.00), 1.00)
              as departure_time,
            0 as qty_sold,
            1 as w
          from (
            select *,
              lag(t1.time_sold, 1) over (partition by t1.kiosk_id, t1.sku_group order by t1.time_sold)
                as last_sale,
              lag(t1.purchase_index, 1) over (partition by t1.kiosk_id, t1.sku_group order by t1.time_sold)
                as last_purchase_index
            from (
              select k.kiosk_id,
                p.sku_group,
                l.time_stocked,
                l.time_sold,
                l.purchase_index
              from (
                select k.id as kiosk_id
                from pantry.kiosk k
                where k.campus_id=87
                and k.archived=0
              ) k
                     cross join (
                  select distinct fc_title as sku_group
                  from pantry.product p
                  where p.campus_id=87
                  and p.archived=0
                  and p.fc_title is not null
                  and p.fc_title!='n/a'
                  order by p.fc_title asc
                ) p
                     left outer join (
                  select l.kiosk_id as kiosk_id,
                    p.fc_title as sku_group,
                    l.time_created as time_stocked,
                    l.time_updated as time_sold,
                    row_number() over (partition by l.kiosk_id order by l.time_updated) as purchase_index
                  from pantry.label l
                         join pantry.product p on l.product_id=p.id
                  where l.kiosk_id is not null
                  and l.status='sold'
                  and to_timestamp(l.time_updated) at time zone 'us/pacific' > date_trunc('week', current_timestamp)
                                                                                 - interval '24 weeks'
                  and p.campus_id=87
                  and p.archived=0
                  and p.fc_title is not null
                ) l on k.kiosk_id=l.kiosk_id and p.sku_group=l.sku_group
              order by k.kiosk_id, p.sku_group, l.purchase_index
            ) t1
          ) t2
        ) t3
        group by t3.kiosk_id, t3.sku_group
      ) t4
             join
        -- get sale average and standard diviation
          (select t5.kiosk_id, round(avg(units_sold), 2) ws_avg, round(stddev(units_sold), 2) ws_std, count(units_sold) ws_live
          from (
            -- get units sold per week over last 3 month
            select concat(kk.kiosk_id::character varying(4), ' ', kk.woy) as key,
              kk.kiosk_id,
              kk.woy,
              ss.units_sold
            from (
              select k.id as kiosk_id,
                generate_series(1, 52) as woy
              from pantry.kiosk k
              where k.campus_id = 87 and k.archived = 0) kk
                   left join (
                select s.kiosk_id,
                  date_part('week'::text, s.ts) as woy,
                  count(*) as units_sold
                from byte_epcssold_3months s
                group by s.kiosk_id, (date_part('week'::text, s.ts))) ss
                     on kk.kiosk_id = ss.kiosk_id and kk.woy::double precision = ss.woy
            order by ss.kiosk_id, ss.woy) t5
          group by t5.kiosk_id
          order by t5.kiosk_id asc
          ) t6 on t4.kiosk_id=t6.kiosk_id) dwwom on dwwom.kiosk_id = kc.kiosk_id and dwwom.sku_group = sg.fc_title;


end;

$$;


ALTER FUNCTION inm.pick_get_demand_weekly_wo_min() OWNER TO erpuser;

--
-- Name: FUNCTION pick_get_demand_weekly_wo_min(); Type: COMMENT; Schema: inm; Owner: erpuser
--

COMMENT ON FUNCTION inm.pick_get_demand_weekly_wo_min() IS 'return inm_beta weekly demand without min by velocity';


--
-- Name: pick_get_order(timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: inm; Owner: erpuser
--

CREATE FUNCTION inm.pick_get_order(start_ts timestamp with time zone, end_ts timestamp with time zone) RETURNS TABLE(kiosk_id integer, route_date_time timestamp with time zone, sku_group_id integer, fc_title text, week_qty integer, plan_qty integer)
    LANGUAGE plpgsql ROWS 10000
    AS $$
  /*
    purpose - return inm order for the next sale period which is the time between the deliveries of this pick and the next pick
    comment - why go through this function and not call pick_get_order_with_velocity(start_date, end_date) directly? there are 2 reasons:
      1. we can replace pick_get_order_with_velocity with a newer fucntion here and not having to change the client code to test the new function.
      2. pick_get_order_with_velocity returns richer data that can be used for troubleshooting which is not necessary for production.
    
    input -
      start_ts: plan window start date time with time zone
      end_ts: plan window end date time with time zone
    return -
      kiosk_id: together with route_date_time is unique for the plan window
      route_date_time: route starting date time
      fc_title: sku group name
      plan_qty: order quantity for the above fc_title for the next sale period
    */

declare latest_import_ts_for_pick_window timestamp with time zone;
begin
	return query
		-- seletively comment to use week order calc or between delivery order calc

		-- sales ratio
		-- select osr.kiosk_id, osr.route_date_time, osr.sku_group_id, osr.fc_title, osr.week_demand_qty, cast(osr.plan_order_qty as integer) from inm.hh_sales_ratio(start_ts, end_ts) osr;

		-- with sales ratio and velocity
		select distinct ov.kiosk_id, ov.route_date_time, ov.sku_group_id, ov.fc_title,
			cast(ceiling(ov.week_demand_qty) as integer), cast(ceiling(ov.plan_order_qty) as integer)
			from inm.pick_get_order_with_velocity(start_ts, end_ts) ov;

end;

$$;


ALTER FUNCTION inm.pick_get_order(start_ts timestamp with time zone, end_ts timestamp with time zone) OWNER TO erpuser;

--
-- Name: pick_get_order_with_velocity(timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: inm; Owner: erpuser
--

CREATE FUNCTION inm.pick_get_order_with_velocity(start_ts timestamp with time zone, end_ts timestamp with time zone) RETURNS TABLE(kiosk_id integer, route_date_time timestamp with time zone, sku_group_id integer, fc_title text, week_demand_qty numeric, plan_demand_qty numeric, plan_order_qty numeric)
    LANGUAGE plpgsql
    AS $$
	/*
  Purpose - return INM order based on sales ratio for pick sales period (time between deliveries)
  Input -
    start_ts: plan window start date time with time zone
    end_ts: plan window end date time with time zone
  Return -
    kiosk_id: together with route_date_time is unique for the plan window
    route_date_time: route starting date time
    fc_title: sku group name
    week_demand_qty: demand based on once a week delivery (without minimum)
    plan_demand_qty: demand based on sales ratio for pick sales period (without minimum)
    plan_order_qty: order based on sales ratio for pick sales period
  */
declare overstock_multiplier numeric;

begin
	select c.value into overstock_multiplier from inm.configuration c where c.setting = 'overstock_multiplier';

	return query
		--  Given
		--		sales period = time between this pick delivery and next pick delivery (may be changed to pick times in the future)
		--		inm.demand_weekly = week demand
		--		sr.sales_ratio = sale ratio for this sum items sold for pick sales period for the last 4 weeks vs items sold for the last 4 weeks
		-- 	if item is restricted (inm_qty=0), then set demand to 0.
		--  else
		--		if item doesn't exist in the kiosk (inv.count is null), set its inv count to 0
		-- 		order_before_min_max = overstock_multiplier * sr.sales_ratio * inm.demand_weekly - inv.count
		-- 		final_order = min + order_before_min_max, capped by max as defined for each sku group

		select sr.kiosk_id, sr.route_date_time, sga.id, dwbv.fc_title, dwbv.demand_weekly as week_demand_qty,
					 cast(overstock_multiplier * sr.sales_ratio * dwbv.demand_weekly as numeric (8,2)) plan_demand_qty,
					 case
						 -- restricted item if demand_weekly is 0 or kiosk_sku_group manual scale is zero
						 when dwbv.demand_weekly = 0 or ksms.scale = 0.0 then 0
						 else
							 ceiling(
								 -- change minimum is 0 (don't remove from a kiosk)
									 least(greatest(least(overstock_multiplier * sr.sales_ratio * dwbv.demand_weekly, dwbv.demand_weekly) + sga.minimum_kiosk_qty - coalesce(inv.count, 0),
																	0) /* change negative demand to 0 */
										 , sga.maximum_kiosk_qty))
						 end as plan_order_qty -- end case

		from inm.pick_get_sales_period_ratio(start_ts, end_ts) sr

					 join inm.pick_get_demand_weekly_by_velocity() dwbv
								on sr.kiosk_id = dwbv.kiosk_id

					 join inm.sku_group_attribute sga
								on sga.title = dwbv.fc_title
					 left join inm.kiosk_projected_stock inv
										 on dwbv.kiosk_id = inv.kiosk_id and dwbv.fc_title = inv.fc_title
					 left join inm.kiosk_sku_group_manual_scale ksms
										 on sr.kiosk_id = ksms.kiosk_id and sga.id = ksms.sku_group_id;
end;
$$;


ALTER FUNCTION inm.pick_get_order_with_velocity(start_ts timestamp with time zone, end_ts timestamp with time zone) OWNER TO erpuser;

--
-- Name: pick_get_plan_kiosk(date); Type: FUNCTION; Schema: inm; Owner: erpuser
--

CREATE FUNCTION inm.pick_get_plan_kiosk(pick_date date) RETURNS TABLE(kiosk_id integer, route_date_time timestamp with time zone, driver_name character varying, location_name character varying, next_delivery_ts timestamp with time zone, time_to_next_delivery interval, days_to_next_delivery double precision, delivery_order bigint)
    LANGUAGE plpgsql
    AS $$

declare
	pst_plan_window_start_str text;
	plan_window_start timestamp with time zone;
	plan_window_stop timestamp with time zone;
/*
purpose: return inm plan kiosks for a pick date.
*/

begin
	-- compose us/pacific start window timestamp string
	pst_plan_window_start_str = cast(pick_date as text) || ' 13:00 -8';

	select into plan_window_start cast(pst_plan_window_start_str as timestamp with time zone);
	plan_window_stop = plan_window_start + interval '22 hours';
	return query
		select * from inm.pick_get_plan_kiosk(plan_window_start, plan_window_stop);
end;

$$;


ALTER FUNCTION inm.pick_get_plan_kiosk(pick_date date) OWNER TO erpuser;

--
-- Name: pick_get_plan_kiosk(timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: inm; Owner: erpuser
--

CREATE FUNCTION inm.pick_get_plan_kiosk(plan_window_start timestamp with time zone, plan_window_stop timestamp with time zone) RETURNS TABLE(kiosk_id integer, route_date_time timestamp with time zone, driver_name character varying, location_name character varying, next_delivery_ts timestamp with time zone, time_to_next_delivery interval, days_to_next_delivery double precision, delivery_order bigint)
    LANGUAGE plpgsql
    AS $$

/*
purpose: return inm plan kiosks for a pick window.
*/

begin
	return query
		select * from inm.pick_get_plan_kiosk_optimo(plan_window_start, plan_window_stop);
end;

$$;


ALTER FUNCTION inm.pick_get_plan_kiosk(plan_window_start timestamp with time zone, plan_window_stop timestamp with time zone) OWNER TO erpuser;

--
-- Name: pick_get_plan_kiosk_disabled_product(date); Type: FUNCTION; Schema: inm; Owner: erpuser
--

CREATE FUNCTION inm.pick_get_plan_kiosk_disabled_product(pick_date date) RETURNS TABLE(kiosk_id bigint, product_id bigint)
    LANGUAGE plpgsql
    AS $$
  /*
    purpose: return disabled products for kiosks on the pick for a pick date.
    */

begin
	return query
		select dp.kiosk_id, dp.product_id
		from inm.pick_get_plan_kiosk(pick_date) pk
			join inm.kiosk_product_disabled dp on pk.kiosk_id = dp.kiosk_id;
end;

$$;


ALTER FUNCTION inm.pick_get_plan_kiosk_disabled_product(pick_date date) OWNER TO erpuser;

--
-- Name: pick_get_plan_kiosk_optimo(timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: inm; Owner: erpuser
--

CREATE FUNCTION inm.pick_get_plan_kiosk_optimo(plan_window_start timestamp with time zone, plan_window_stop timestamp with time zone) RETURNS TABLE(kiosk_id integer, route_date_time timestamp with time zone, driver_name character varying, location_name character varying, next_delivery_ts timestamp with time zone, time_to_next_delivery interval, days_to_next_delivery double precision, delivery_order bigint)
    LANGUAGE plpgsql
    AS $$

/*
purpose: return inm plan kiosks for a pick window.
*/

begin
	return query
		select ds.kiosk_id, ds.route_date_time, ds.driver_name, ds.location_name, ps.next_delivery_ts,
		ps.next_delivery_ts - ds.route_date_time as time_to_next_delivery,
		  case
		  	when ps.next_delivery_ts - ds.route_date_time between interval '12 hours' and interval '24 hours' then 1
			else extract(day from ps.next_delivery_ts - ds.route_date_time)
			end as days_to_next_delivery,
		  row_number() over (order by ds.route_date_time asc) as delivery_order


		from
		-- kiosk_id, delivery_date
		(select t.kiosk_id, t.route_date_time, t.driver_name, t.location_name from
			(select location_number as kiosk_id, rs.route_date_time, rs.driver_name, rs.location_name,
				rank() over (partition by location_number, rs.route_date_time order by rs.route_date_time) as r
				from mixalot.route_stop rs
				where rs.route_date_time >= plan_window_start -- look at routes starting at plan winddow start
				and location_number > 0) t
				where r = 1) ds

		left join
		-- kiosk_id, pull_date
		(select t.kiosk_id, t.route_date_time next_delivery_ts from
			(select location_number as kiosk_id, rs.route_date_time,
				rank() over (partition by location_number order by rs.route_date_time) as r
				from mixalot.route_stop rs
				where rs.route_date_time >= plan_window_start -- look at routes starting at plan window start
				and location_number > 0) t
				where r = 2) ps

			on ds.kiosk_id = ps.kiosk_id
			join pantry.kiosk k on ds.kiosk_id = k.id
			where ds.route_date_time between plan_window_start and plan_window_stop
			and k.campus_id= 87;
end;

$$;


ALTER FUNCTION inm.pick_get_plan_kiosk_optimo(plan_window_start timestamp with time zone, plan_window_stop timestamp with time zone) OWNER TO erpuser;

--
-- Name: pick_get_plan_kiosk_projected_stock(timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: inm; Owner: erpuser
--

CREATE FUNCTION inm.pick_get_plan_kiosk_projected_stock(plan_window_start timestamp with time zone, plan_window_stop timestamp with time zone) RETURNS TABLE(kiosk_id integer, fc_title character varying, qty integer)
    LANGUAGE plpgsql COST 1000 ROWS 10000
    AS $$

  /*
    purpose: return projected stock for plan kiosks for a pick window.
    */

begin
	return query
		select pk.kiosk_id, kps.fc_title, cast(kps.count as integer) from inm.pick_get_plan_kiosk(plan_window_start, plan_window_stop) pk
		join inm.kiosk_projected_stock kps on pk.kiosk_id = kps.kiosk_id;
end;

$$;


ALTER FUNCTION inm.pick_get_plan_kiosk_projected_stock(plan_window_start timestamp with time zone, plan_window_stop timestamp with time zone) OWNER TO erpuser;

--
-- Name: pick_get_sales_period_ratio(timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: inm; Owner: erpuser
--

CREATE FUNCTION inm.pick_get_sales_period_ratio(start_ts timestamp with time zone, end_ts timestamp with time zone) RETURNS TABLE(kiosk_id integer, route_date_time timestamp with time zone, sales_ratio numeric)
    LANGUAGE plpgsql ROWS 10000
    AS $$

  /*
  Purpose - return INM the ratio of the next sale period(time between the deliveries of this pick and the next pick) vs sales for the week using 12 week history
  Input -
    start_ts: plan window start date time with time zone
    end_ts: plan window end date time with time zone
  Return -
    kiosk_id: together with route_date_time is unique for the plan window
    route_date_time: route starting date time
    fc_title: sku group name
    plan_qty: order quantity for the above fc_title for the next sale period
  */

  -- FIX ME:
  -- handle missing past data
  -- check kid with multiple deliveries
begin
  return query
    select scheduled_kiosks.kiosk_id, scheduled_kiosks.route_date_time, coalesce(existing_kiosk_with_sales_ratio.ratio, 1.0/3.0)
    from inm.pick_get_plan_kiosk(start_ts, end_ts) scheduled_kiosks -- all the kiosks on route
           left join -- kiosks with sales history
      (
        select whole_12_weeks.kiosk_id, whole_12_weeks.route_date_time,
               case when whole_12_weeks.qty < 5 then 1.0/3.0 -- new kiosk, assume period sale is 1/3 of total week
                    else cast(period_12_weeks.qty as decimal)/cast(whole_12_weeks.qty as decimal)
                 end ratio
        from
          -- count of sales for the whole previous 4 weeks
          (select pk.kiosk_id, pk.route_date_time, count(*) qty
           from inm.pick_get_plan_kiosk(start_ts, end_ts) pk
                  join pantry.label l on pk.kiosk_id=l.kiosk_id
           where l.status in ('sold') -- 20190213 changed from ('out', 'sold')
             and to_timestamp(l.time_updated) between
               pk.next_delivery_ts - interval '91 days'
             and pk.next_delivery_ts - interval '7 days'
           group by 1, 2
          ) whole_12_weeks

            join

          -- count of sales for the sales peiod of previous 4 weeks
            (
              select pk.kiosk_id, pk.route_date_time, count(*) qty
              from inm.pick_get_plan_kiosk(start_ts, end_ts) pk
                     join pantry.label l on pk.kiosk_id=l.kiosk_id
              where l.status in ('sold') and  -- 20190213 changed from ('out', 'sold')
                (
                    to_timestamp(l.time_updated) between now() - interval '7 days'  + interval '4 hours' and pk.next_delivery_ts - interval '7 days'  + interval '4 hours' or
                    to_timestamp(l.time_updated) between now() - interval '14 days' + interval '4 hours' and pk.next_delivery_ts - interval '14 days' + interval '4 hours' or
                    to_timestamp(l.time_updated) between now() - interval '21 days' + interval '4 hours' and pk.next_delivery_ts - interval '21 days' + interval '4 hours' or
                    to_timestamp(l.time_updated) between now() - interval '28 days' + interval '4 hours' and pk.next_delivery_ts - interval '28 days' + interval '4 hours' or

                    to_timestamp(l.time_updated) between now() - interval '35 days' + interval '4 hours' and pk.next_delivery_ts - interval '35 days' + interval '4 hours' or
                    to_timestamp(l.time_updated) between now() - interval '42 days' + interval '4 hours' and pk.next_delivery_ts - interval '42 days' + interval '4 hours' or
                    to_timestamp(l.time_updated) between now() - interval '49 days' + interval '4 hours' and pk.next_delivery_ts - interval '49 days' + interval '4 hours' or
                    to_timestamp(l.time_updated) between now() - interval '56 days' + interval '4 hours' and pk.next_delivery_ts - interval '56 days' + interval '4 hours' or

                    to_timestamp(l.time_updated) between now() - interval '63 days' + interval '4 hours' and pk.next_delivery_ts - interval '63 days' + interval '4 hours' or
                    to_timestamp(l.time_updated) between now() - interval '70 days' + interval '4 hours' and pk.next_delivery_ts - interval '70 days' + interval '4 hours' or
                    to_timestamp(l.time_updated) between now() - interval '77 days' + interval '4 hours' and pk.next_delivery_ts - interval '77 days' + interval '4 hours' or
                    to_timestamp(l.time_updated) between now() - interval '84 days' + interval '4 hours' and pk.next_delivery_ts - interval '84 days' + interval '4 hours'
                  -- 									 to_timestamp(l.time_updated) between pk.route_date_time - interval '7 days'  + interval '4 hours' and pk.next_delivery_ts - interval '7 days'  + interval '4 hours' or
                  -- 									 to_timestamp(l.time_updated) between pk.route_date_time - interval '14 days' + interval '4 hours' and pk.next_delivery_ts - interval '14 days' + interval '4 hours' or
                  -- 									 to_timestamp(l.time_updated) between pk.route_date_time - interval '21 days' + interval '4 hours' and pk.next_delivery_ts - interval '21 days' + interval '4 hours' or
                  -- 									 to_timestamp(l.time_updated) between pk.route_date_time - interval '28 days' + interval '4 hours' and pk.next_delivery_ts - interval '28 days' + interval '4 hours' or
                  --
                  -- 									 to_timestamp(l.time_updated) between pk.route_date_time - interval '35 days' + interval '4 hours' and pk.next_delivery_ts - interval '35 days' + interval '4 hours' or
                  -- 									 to_timestamp(l.time_updated) between pk.route_date_time - interval '42 days' + interval '4 hours' and pk.next_delivery_ts - interval '42 days' + interval '4 hours' or
                  -- 									 to_timestamp(l.time_updated) between pk.route_date_time - interval '49 days' + interval '4 hours' and pk.next_delivery_ts - interval '49 days' + interval '4 hours' or
                  -- 									 to_timestamp(l.time_updated) between pk.route_date_time - interval '56 days' + interval '4 hours' and pk.next_delivery_ts - interval '56 days' + interval '4 hours' or
                  --
                  -- 									 to_timestamp(l.time_updated) between pk.route_date_time - interval '63 days' + interval '4 hours' and pk.next_delivery_ts - interval '63 days' + interval '4 hours' or
                  -- 									 to_timestamp(l.time_updated) between pk.route_date_time - interval '70 days' + interval '4 hours' and pk.next_delivery_ts - interval '70 days' + interval '4 hours' or
                  -- 									 to_timestamp(l.time_updated) between pk.route_date_time - interval '77 days' + interval '4 hours' and pk.next_delivery_ts - interval '77 days' + interval '4 hours' or
                  -- 									 to_timestamp(l.time_updated) between pk.route_date_time - interval '84 days' + interval '4 hours' and pk.next_delivery_ts - interval '84 days' + interval '4 hours'
                  )
              group by 1, 2
            ) period_12_weeks

          on whole_12_weeks.kiosk_id = period_12_weeks.kiosk_id
      ) existing_kiosk_with_sales_ratio

                     on scheduled_kiosks.kiosk_id = existing_kiosk_with_sales_ratio.kiosk_id and scheduled_kiosks.route_date_time = existing_kiosk_with_sales_ratio.route_date_time;

end;

$$;


ALTER FUNCTION inm.pick_get_sales_period_ratio(start_ts timestamp with time zone, end_ts timestamp with time zone) OWNER TO erpuser;

--
-- Name: pick_get_summary(date); Type: FUNCTION; Schema: inm; Owner: erpuser
--

CREATE FUNCTION inm.pick_get_summary(target_date date) RETURNS TABLE(property text, name text, value text)
    LANGUAGE plpgsql
    AS $$

/*
returns pick summary for a given date.
*/

declare
	pick_tickets_generated integer;
	-- one-based arrays of 3 numbers, 1 for target date and 2 for the same weekday one and two weeks ago
	ticket integer array;
	demand integer array;
	allocation integer array;
	property text;
	name text;
	value text;
	total integer;
	result_row record;
	kiosks_added text;
	kiosks_removed text;
	percentage integer;

begin

	for i in 0..2 loop
 		select count(*) from inm.pick_route where pick_date = target_date - 7*i  into total;
		ticket[i+1] = total; -- convert to one-based index
		select sum(qty) from inm.pick_demand where pick_date = target_date - 7*i into total;
		demand[i+1] = total;
		select sum(qty) from inm.pick_allocation where pick_date = target_date - 7*i into total;
		allocation[i+1] = total;
   	end loop;

	select array_to_string(array_agg(cast (kiosk_id as varchar) order by kiosk_id), ',') from inm.pick_route
		where pick_date = target_date and kiosk_id not in
			(select kiosk_id from inm.pick_route where pick_date = target_date - 7)
	into kiosks_added;

	select array_to_string(array_agg(cast (kiosk_id as varchar) order by kiosk_id), ',') from inm.pick_route
		where pick_date = target_date - 7  and kiosk_id not in
			(select kiosk_id from inm.pick_route where pick_date = target_date)
	into kiosks_removed;

	property = 'stats';
	name = 'pick tickets today/ -7 days/ -14 days: ';
	value = ticket[1] || '/' || ticket[2] || '/' || ticket[3];
	return query select property, name, value;

	property = 'stats';
	name = 'demand qty today/ -7 days/ -14 days: ';
	value = coalesce(demand[1], 0) || '/' || coalesce(demand[2],0) || '/' || coalesce(demand[3],0);
	return query select property, name, value;

	property = 'stats';
	name = 'allocation qty today/ -7 days/ -14 days: ';
	value = coalesce(allocation[1], 0) || '/' || coalesce(allocation[2], 0) || '/' || coalesce(allocation[3], 0);
	return query select property, name, value;

	property = 'stats';
	name = 'kiosks added';
	value = kiosks_added;
	return query select property, name, value;

	property = 'stats';
	name = 'kiosks removed';
	value = kiosks_removed;
	return query select property, name, value;

end

$$;


ALTER FUNCTION inm.pick_get_summary(target_date date) OWNER TO erpuser;

--
-- Name: pick_get_ticket(date); Type: FUNCTION; Schema: inm; Owner: erpuser
--

CREATE FUNCTION inm.pick_get_ticket(target_date date) RETURNS TABLE(pick_station bigint, vendor character varying, item_code bigint, item_name character varying, site_code bigint, site_name character varying, proposed_supply integer, total_pick_qty bigint, total_pick_sku integer, driver_name character varying, route_date date, route_time time without time zone, route_date_time timestamp without time zone, route_number character varying, restrictions text, address character varying, pull_date date, delivery_order integer, pick_order smallint)
    LANGUAGE plpgsql
    AS $$
declare
  pst_plan_window_start_str text;
  latest_import_ts timestamp;
  plan_window_start timestamp;
  plan_window_stop timestamp;
begin
  /*
  Return pick ticket records
  Last modified 2019-02-28: get pick_order from allocable inventory instead of inm_data
   */

  if target_date is not null
    then
      -- compose US/Pacific start window timestamp string
      pst_plan_window_start_str = cast(target_date as text) || ' 13:00 -8';
      select into plan_window_start cast(pst_plan_window_start_str as timestamp with time zone);
      plan_window_stop = plan_window_start + interval '22 hours';

      -- fixme: remove when obsolete
      -- backward compat with run pick using inm gsheets with plan window imported into mixalot.inm_data
    else
      select max(import_ts) from mixalot.inm_data into latest_import_ts;
      select i.route_date from mixalot.inm_data i
      where import_ts = latest_import_ts and data_type = 'Plan Window Start'
        into plan_window_start;
      select i.route_date from mixalot.inm_data i
      where import_ts = latest_import_ts and data_type = 'Plan Window Stop'
        into plan_window_stop;
      target_date = plan_window_start::date;
    end if;

  return query
    select
      p.pick_station, p.vendor, p.id, p.title ItemName,
      k.id sitecode, k.title sitename, a.qty proposed_supply,
      sum(a.qty) over(partition by k.id, route.route_date) total_pick_qty,
      -1 total_pick_sku, route.driver_name DriverName,
      route.route_date RouteDate, route.route_time RouteTime,
      route.route_date + route.route_time route_date_time, route.route_number,
      r.restrictions,
      k.address,
      pd.pull_date,
      cast(route.delivery_order as integer),
      spo.pick_order
    from inm.pick_allocation a
           left join pantry.kiosk k on a.kiosk_id = k.id
           left join inm.kiosk_restriction_list r on k.id = r.kiosk_id
           join pantry.product p on a.sku_id = p.id
           join inm.pick_route route on a.pick_date=route.pick_date and a.route_date = route.route_date and a.kiosk_id = route.kiosk_id
           left join inm.get_pull_date(plan_window_start, plan_window_stop) pd on a.kiosk_id = pd.kiosk_id

           --  old: use mixalot.inm_data
           -- left join mixalot.sku_pick_order(latest_import_ts) spo on p.id = spo.sku_id

          left join
            (select a.product_id, a.pick_order from inm.allocable_inventory a where inventory_date = target_date) spo on p.id=spo.product_id

    where k.campus_id = 87
      and a.pick_date = target_date;
end

$$;


ALTER FUNCTION inm.pick_get_ticket(target_date date) OWNER TO erpuser;

--
-- Name: pick_submit(date, integer, integer); Type: FUNCTION; Schema: inm; Owner: erpuser
--

CREATE FUNCTION inm.pick_submit(target_date date, overwrite integer DEFAULT 0, wait_time_seconds integer DEFAULT 300, OUT submit_status text) RETURNS text
    LANGUAGE plpgsql
    AS $$

/*
purpose - submit a pick with task_option controlling how to deal with conflict.

input -
  target_date: pick date
  overwrite: 0 or 1. if 1, overwrite old pick.
  timeout_seconds: minimum amount of time the task can be in status = "started" before it's considered timed out
return -
  submitted_status:
  	submitted - pick submitted.
	started - a pick already in progress for target date.
	ready - a completed pick already existed (and overwrite=0)
*/

declare
	_status text;

begin
	-- delete existing pick for target date if overwrite=1
	if overwrite = 1
		then delete from inm.pick_list where pick_date = target_date;
	-- delete failed and timed out items
	else
		delete from inm.pick_list p
			-- where (pick_date = target_date and create_ts + wait_time_seconds < now())
			where (pick_date = target_date
				   	and extract(epoch from now() - create_ts) > timeout_seconds)
				or status = 'failed';
	end if;

	-- remaining pick_list entry for target date is a pick that is in progress and should not be deleted
	select status
		from inm.pick_list where pick_date = target_date
		into _status;

	if _status is null
		then insert into inm.pick_list(pick_date, timeout_seconds) values(target_date, wait_time_seconds);
		submit_status = 'submitted';
	else submit_status = _status;
	end if;
end;

$$;


ALTER FUNCTION inm.pick_submit(target_date date, overwrite integer, wait_time_seconds integer, OUT submit_status text) OWNER TO erpuser;

--
-- Name: get_pull_date(timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: inm_test; Owner: erpuser
--

CREATE FUNCTION inm_test.get_pull_date(plan_window_start timestamp with time zone, plan_window_stop timestamp with time zone) RETURNS TABLE(kiosk_id integer, delivery_date date, pull_date date)
    LANGUAGE plpgsql
    AS $$
  /*
  pull_date is target expiration date for the restocker to remove food from the kiosk.
  The later the pull_date, the more food get removed. Unnecessarily late pull_dates
  cause higher spoilage.

  This function computes normal_pull_date and enhanced_pull_date, then return enhanced_pull_date
  if available, otherwise normal_pull_date.

  normal_pull_date is the day before the next delivery, meaning at restock time, all food expires
  before the next delivery date is removed.

  enhanced_pull_date looks at past sales by day of the week for the kiosk, and set the pull_date
  to the last business day for the kiosk before the normal_pull_date.

  For a typical kiosk with last delivery of the week on Wednesday or Thursday and no business on
  the weekend, enhanced_pull_date will prevent food that are OK up to the end of Friday in the
  kiosk to be sold, which otherwise would be removed by normal_pull_date because they would
  expire on the weekend.
  */

begin
  set timezone to 'US/Pacific';
  return query
    with
      -- delivery date
      dd as
        (select t.kiosk_id, t.delivery_date_time as delivery_dt from
          (select location_number as kiosk_id, rs.route_date_time as delivery_date_time,
                  dense_rank() over (partition by location_number order by rs.route_date_time) as r
           from mixalot.route_stop rs
           where rs.route_date_time >= plan_window_start -- routes starting at plan window start
             and rs.route_date_time <= plan_window_stop
             and location_number > 0) t
         where r = 1),

      -- normal pull date
      npd as
      (select t.kiosk_id,
              t.delivery_date_time - interval '1 days' as pull_date,
              extract(dow from t.delivery_date_time) as dow
        from
          (select location_number as kiosk_id, rs.route_date_time as delivery_date_time,
                  dense_rank() over (partition by location_number order by rs.route_date_time) as r
           from mixalot.route_stop rs
           where rs.route_date_time >= plan_window_start -- routes starting at plan window start
             and location_number > 0) t
         where r = 2),

      -- possible enhanced pull dates - start with next 7 days before narrowing down to the best day
      pepd as
        (select d as pull_date, extract(dow from d) as dow
          from (select generate_series(plan_window_start,
            plan_window_start::timestamp + interval '6 days', interval '1 days')::date as d) dates),

      -- sales_history - kiosk and dow with sales
      sales_history as
        (select v.kiosk_id, v.dow
          from inm.v_kiosk_sale_hourly v
          group by 1, 2
          having sum(units_sold_normalized) >= 0.05),

      -- kiosk_id, delivery_date, enhanced_pull_date
      epd as
        (select dd.kiosk_id, dd.delivery_dt,
             max(pepd.pull_date) as pull_date
          from dd
            join npd on dd.kiosk_id = npd.kiosk_id
            left join sales_history on dd.kiosk_id = sales_history.kiosk_id
            left join pepd on sales_history.dow = pepd.dow
          where
            pepd.pull_date > dd.delivery_dt and pepd.pull_date < npd.pull_date
            group by 1,2)

  -- return kiosk_id, delivery_date, the best pull date
  select dd.kiosk_id, 
         dd.delivery_dt::date, 
         coalesce(epd.pull_date, npd.pull_date::date) as pull_date
    from dd
      join npd on dd.kiosk_id = npd.kiosk_id
      left join epd on dd.kiosk_id = epd.kiosk_id;
end;

$$;


ALTER FUNCTION inm_test.get_pull_date(plan_window_start timestamp with time zone, plan_window_stop timestamp with time zone) OWNER TO erpuser;

--
-- Name: get_pull_date_enhanced(timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: inm_test; Owner: erpuser
--

CREATE FUNCTION inm_test.get_pull_date_enhanced(plan_window_start timestamp with time zone, plan_window_stop timestamp with time zone) RETURNS TABLE(kiosk_id integer, delivery_date date, pull_date date)
    LANGUAGE plpgsql
    AS $$
  /*
    Purpose: return INM pull date aka next delivery date
    Note: this used to be part of mixalot.plan_kiosk, but due to unreliable time portion of route_stop.route_date_time,
    this pull_date function is created to restrict the result to date portion of the data which is accurate and sufficient
    because pull_date doesn't need accurate time unlike mixalot.plan_kiosk.
    */
begin
  return query
    select ds.kiosk_id, ds.delivery_date_time::date, ps.pull_date_time::date
    from
      -- kiosk_id, delivery_date
      (select t.kiosk_id, t.delivery_date_time
       from (select location_number                                                        as kiosk_id,
                    rs.route_date_time                                                     as delivery_date_time,
                    rank() over (partition by location_number order by rs.route_date_time) as r
             from mixalot.route_stop rs
             where rs.route_date_time >= plan_window_start -- look at routes starting at plan winddow start
               and location_number > 0) t
       where r = 1) ds

    left join
    (select o.kiosk_id                                             kiosk_id,
              --o.pull_date_time as pull_date_time_old,
              if(o.os = 0, o.pull_date_time,
                 (o.pull_date_time - interval '1 day' * (o.os + 1))) pull_date_time
              --if(o.os=0, o.os, o.os+1) as offset

       -- what is this o table?
       from (
              select nd.kiosk_id,
                     nd.pull_date_time,
                     nd.pull_dow,
                     nd.pull_dow - os.os                                                     as pull_dow_os,
                     mod((7 + nd.pull_dow - os.os)::integer, 7)                              as pull_dow_os_mod,
                     os.os,
                     ks.kiosk_sale_daily                                                     as kiosk_sale_daily,
                     row_number()
                         over (partition by nd.kiosk_id order by (nd.pull_dow - os.os) desc) as row_number

              -- next delivery date
              from (
                     select t.kiosk_id,
                            t.delivery_date_time - interval '1 day'                        pull_date_time,
                            EXTRACT(DOW from (t.delivery_date_time - interval '1 day')) as pull_dow
                     from (
                            select location_number                                                     as kiosk_id,
                                   rs.route_date_time::date                                            as delivery_date_time,
                                   dense_rank()
                                       over (partition by location_number order by rs.route_date_time::date) as r
                            from mixalot.route_stop rs
                            where rs.route_date_time >= plan_window_start -- look at routes starting at plan window start
                              and location_number > 0) t
                     where r = 2
                   ) nd

                     cross join (
                select generate_series as os
                from generate_series(0, 6)
              ) os
                     left join (
                select vksh.kiosk_id, vksh.dow, sum(vksh.units_sold_normalized) as kiosk_sale_daily
                from inm.v_kiosk_sale_hourly vksh
                group by vksh.kiosk_id, vksh.dow
              ) ks
                               on nd.kiosk_id = ks.kiosk_id and
                                  mod((7 + nd.pull_dow - os.os)::integer, 7) = ks.dow
              where ks.kiosk_sale_daily >= 0.05
              order by nd.kiosk_id asc, (nd.pull_dow - os.os) desc
            ) o

       where o.row_number = 1) ps
        -- kiosk_id, pull_date
        -- 			(select t.kiosk_id, t.delivery_date_time - interval '1 day' pull_date_time from
        -- 				(select location_number as kiosk_id, rs.route_date_time::date as delivery_date_time,
        -- 					rank() over (partition by location_number order by rs.route_date_time) as r
        -- 					from mixalot.route_stop rs
        -- 					where rs.route_date_time >= plan_window_start -- look at routes starting at plan window start
        -- 					and location_number > 0) t
        -- 					where r = 2) ps

      on ds.kiosk_id = ps.kiosk_id
        join pantry.kiosk k on ds.kiosk_id = k.id
    where ds.delivery_date_time between plan_window_start and plan_window_stop
      and k.campus_id = 87;
end;

$$;


ALTER FUNCTION inm_test.get_pull_date_enhanced(plan_window_start timestamp with time zone, plan_window_stop timestamp with time zone) OWNER TO erpuser;

--
-- Name: pick_get_delivery_schedule(date); Type: FUNCTION; Schema: inm_test; Owner: erpuser
--

CREATE FUNCTION inm_test.pick_get_delivery_schedule(pick_date date) RETURNS TABLE(driver_name character varying, route_date_time timestamp with time zone, kiosk_id integer, kiosk_title character varying, address character varying, delivery_order integer)
    LANGUAGE plpgsql
    AS $$
declare
  latest_import_ts timestamp;
  pst_plan_window_start_str text;
  plan_window_start timestamp with time zone;
  plan_window_stop timestamp with time zone;

  /*
  Purpose: return INM delivery schedule for a pick date.
  Input
    target_date: pick_date
  Return
    Data to generate the drivers sheets
  */
begin
    -- compose US/Pacific start window timestamp string
    pst_plan_window_start_str = cast(pick_date as text) || ' 13:00 -8';
    select into plan_window_start cast(pst_plan_window_start_str as timestamp with time zone);
    plan_window_stop = plan_window_start + interval '22 hours';

    -- fixme: remove when obsolete
    -- backward compat with run pick using inm gsheets with plan window imported into mixalot.inm_data

  return query
    select rs.driver_name, rs.route_date_time, location_number kiosk_id, k.title kiosk_title, k.address, rs.stop_number delivery_order
    from mixalot.route_stop rs join pantry.kiosk k on rs.location_number = k.id
    where rs.route_date_time between plan_window_start and plan_window_stop;
end;

$$;


ALTER FUNCTION inm_test.pick_get_delivery_schedule(pick_date date) OWNER TO erpuser;

--
-- Name: sales_ratio_debug(timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: inm_test; Owner: erpuser
--

CREATE FUNCTION inm_test.sales_ratio_debug(start_ts timestamp with time zone, end_ts timestamp with time zone) RETURNS TABLE(kiosk_id integer, route_date_time timestamp with time zone, sales_ratio numeric, whole_qty bigint, period_qty bigint)
    LANGUAGE plpgsql ROWS 10000
    AS $$
  /*
    Purpose - return INM the ratio of the next sale period(time between the deliveries of this pick and the next pick) vs sales for the week using 12 week history
    Input -
      start_ts: plan window start date time with time zone
      end_ts: plan window end date time with time zone
    Return -
      kiosk_id: together with route_date_time is unique for the plan window
      route_date_time: route starting date time
      fc_title: sku group name
      plan_qty: order quantity for the above fc_title for the next sale period
    */

  -- FIX ME:
  -- handle missing past data
  -- check kid with multiple deliveries
begin
  return query
    select scheduled_kiosks.kiosk_id, scheduled_kiosks.route_date_time, coalesce(existing_kiosk_with_sales_ratio.ratio, 1.0/3.0),
           existing_kiosk_with_sales_ratio.whole_qty, existing_kiosk_with_sales_ratio.period_qty
    from inm.pick_get_plan_kiosk(start_ts, end_ts) scheduled_kiosks -- all the kiosks on route
           left join -- kiosks with sales history
      (
        select whole_12_weeks.kiosk_id, whole_12_weeks.route_date_time,
               case when whole_12_weeks.qty < 5 then 1.0/3.0 -- new kiosk, assume period sale is 1/3 of total week
                    else cast(period_12_weeks.qty as decimal)/cast(whole_12_weeks.qty as decimal)
                 end ratio, whole_12_weeks.qty whole_qty, period_12_weeks.qty period_qty
        from
          -- count of sales for the whole previous 12 weeks
          (select pk.kiosk_id, pk.route_date_time, count(*) qty
           from inm.pick_get_plan_kiosk(start_ts, end_ts) pk
                  join pantry.label l on pk.kiosk_id=l.kiosk_id
           where l.status in ('out', 'sold')
             and to_timestamp(l.time_updated) between
               pk.next_delivery_ts - interval '91 days'
             and pk.next_delivery_ts - interval '7 days'
           group by 1, 2
          ) whole_12_weeks

            join

          -- count of sales for the sales peiod of previous 4 weeks
            (
              select pk.kiosk_id, pk.route_date_time, count(*) qty
              from inm.pick_get_plan_kiosk(start_ts, end_ts) pk
                     join pantry.label l on pk.kiosk_id=l.kiosk_id
              where l.status in ('out', 'sold') and
                (
                    to_timestamp(l.time_updated) between pk.route_date_time - interval '7 days' + interval '4 hours' and pk.next_delivery_ts - interval '7 days'  + interval '4 hours' or
                    to_timestamp(l.time_updated) between pk.route_date_time - interval '14 days'  + interval '4 hours' and pk.next_delivery_ts - interval '14 days'  + interval '4 hours' or
                    to_timestamp(l.time_updated) between pk.route_date_time - interval '21 days'  + interval '4 hours' and pk.next_delivery_ts - interval '21 days'  + interval '4 hours' or
                    to_timestamp(l.time_updated) between pk.route_date_time - interval '28 days'  + interval '4 hours' and pk.next_delivery_ts - interval '28 days' + interval '4 hours' or

                    to_timestamp(l.time_updated) between pk.route_date_time - interval '35 days' + interval '4 hours' and pk.next_delivery_ts - interval '35 days'  + interval '4 hours' or
                    to_timestamp(l.time_updated) between pk.route_date_time - interval '42 days' + interval '4 hours' and pk.next_delivery_ts - interval '42 days'  + interval '4 hours' or
                    to_timestamp(l.time_updated) between pk.route_date_time - interval '49 days' + interval '4 hours' and pk.next_delivery_ts - interval '49 days'  + interval '4 hours' or
                    to_timestamp(l.time_updated) between pk.route_date_time - interval '56 days' + interval '4 hours' and pk.next_delivery_ts - interval '56 days'  + interval '4 hours' or

                    to_timestamp(l.time_updated) between pk.route_date_time - interval '63 days' + interval '4 hours' and pk.next_delivery_ts - interval '63 days'  + interval '4 hours' or
                    to_timestamp(l.time_updated) between pk.route_date_time - interval '70 days' + interval '4 hours' and pk.next_delivery_ts - interval '70 days'  + interval '4 hours' or
                    to_timestamp(l.time_updated) between pk.route_date_time - interval '77 days' + interval '4 hours' and pk.next_delivery_ts - interval '77 days'  + interval '4 hours' or
                    to_timestamp(l.time_updated) between pk.route_date_time - interval '84 days' + interval '4 hours' and pk.next_delivery_ts - interval '84 days'  + interval '4 hours'
                  )
              group by 1, 2
            ) period_12_weeks

          on whole_12_weeks.kiosk_id = period_12_weeks.kiosk_id
      ) existing_kiosk_with_sales_ratio

                     on scheduled_kiosks.kiosk_id = existing_kiosk_with_sales_ratio.kiosk_id and scheduled_kiosks.route_date_time = existing_kiosk_with_sales_ratio.route_date_time;

end;

$$;


ALTER FUNCTION inm_test.sales_ratio_debug(start_ts timestamp with time zone, end_ts timestamp with time zone) OWNER TO erpuser;

--
-- Name: test_get_product_record(integer); Type: FUNCTION; Schema: migration; Owner: erpuser
--

CREATE FUNCTION migration.test_get_product_record(pid integer) RETURNS SETOF record
    LANGUAGE plpgsql
    AS $$
declare
  result record;
begin

      select * from migration.product where id=pid;

end;

$$;


ALTER FUNCTION migration.test_get_product_record(pid integer) OWNER TO erpuser;

--
-- Name: get_label_order_epc(); Type: FUNCTION; Schema: pantry; Owner: erpuser
--

CREATE FUNCTION pantry.get_label_order_epc() RETURNS TABLE(id bigint, title character varying, epc text)
    LANGUAGE plpgsql
    AS $$

declare
PREFIX text := '0000';
LOCATIONS text := '01';

begin
  /*
    Returns tag order data used for printing:
    - sku
    - product name
    - epc
  */
  return query
  select
    p.id,
    p.title,
    PREFIX || l.product_id || LOCATIONS || l.time_order || to_char(generator.id, 'fm0000') as epc
  from pantry.product as p, pantry.label_order as l, generate_series(1, l.amount) as generator(id)
where p.id = l.product_id and l.status = 'Scheduled' and p.archived = 0;
end;
$$;


ALTER FUNCTION pantry.get_label_order_epc() OWNER TO erpuser;

--
-- Name: FUNCTION get_label_order_epc(); Type: COMMENT; Schema: pantry; Owner: erpuser
--

COMMENT ON FUNCTION pantry.get_label_order_epc() IS 'retrieves tag data and generates epc for scheduled label orders';


--
-- Name: sync_campus(); Type: FUNCTION; Schema: pantry; Owner: erpuser
--

CREATE FUNCTION pantry.sync_campus() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
declare
  _target_record record;
  _insync BOOLEAN;

  -- Define same table two-way sync trigger function. To prevent circular sync,
  -- compare incoming record with existing record and cancel the trigger if
  -- the two are exactly the same.
begin
  -- calculate sync status of the triggered record
  if tg_op in ('INSERT', 'UPDATE')
    then
      select * from pantry.campus where id = new.id into _target_record;
      -- is the new version of record the same as the current record
      _insync = (_target_record = new);
    else
      _insync = false;
  end if;

  if _insync
    -- don't process the current trigger because the record is already in sync
    then
      return null;
    -- record is not in sync, so process the current trigger
    else
      -- return appropriate value for insert/update/delete to be performed by the system trigger handler
      if tg_op in ('INSERT', 'UPDATE')
        then
          return new;
        else
          return old;
      end if;
  end if;
end;
$$;


ALTER FUNCTION pantry.sync_campus() OWNER TO erpuser;

--
-- Name: sync_label_order(); Type: FUNCTION; Schema: pantry; Owner: erpuser
--

CREATE FUNCTION pantry.sync_label_order() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
declare
  _target_record record;
  _insync BOOLEAN;

  /*
  Insert/update/delete pantry.label_order according to tg_op value.

  This code works in conjunction with pantry.sync_label_order_reverse. Together they use transaction scope
  SKIP_SYNC_PARAM_NAME param to signal if the sync or reverse sync should be skipped to prevent unnecessary sync and
  more importantly infinite sync cycles.
  */

begin
  -- calculate sync status of the triggered record
  if tg_op in ('INSERT', 'UPDATE')
  then
    select * from pantry.label_order where id = new.id into _target_record;
    -- is the new version of record the same as the current record
    _insync = (_target_record = new);
  else
    _insync = false;
  end if;

  if _insync
    -- don't process the current trigger because either _skip_trigger is set, or the record is already in sync
  then
    return null;
    -- record is not in sync, so process the current trigger
  else
    -- return appropriate value for insert/update/delete to be performed by the system trigger handler
    if tg_op in ('INSERT', 'UPDATE')
    then
      return new;
    else
      return old;
    end if;
  end if;
end;
$$;


ALTER FUNCTION pantry.sync_label_order() OWNER TO erpuser;

--
-- Name: awsdms_intercept_ddl(); Type: FUNCTION; Schema: public; Owner: erpuser
--

CREATE FUNCTION public.awsdms_intercept_ddl() RETURNS event_trigger
    LANGUAGE plpgsql
    AS $$
  declare _qry text;
BEGIN
  if (tg_tag='CREATE TABLE' or tg_tag='ALTER TABLE' or tg_tag='DROP TABLE') then
	    SELECT current_query() into _qry;
	    insert into public.awsdms_ddl_audit
	    values
	    (
	    default,current_timestamp,current_user,cast(TXID_CURRENT()as varchar(16)),tg_tag,0,'',current_schema,_qry
	    );
	    delete from public.awsdms_ddl_audit;
 end if;
END;
$$;


ALTER FUNCTION public.awsdms_intercept_ddl() OWNER TO erpuser;

--
-- Name: dowhour(timestamp with time zone); Type: FUNCTION; Schema: public; Owner: erpuser
--

CREATE FUNCTION public.dowhour(timestamp with time zone) RETURNS integer
    LANGUAGE sql IMMUTABLE
    AS $_$
SELECT ((1+extract(DOW FROM $1))*100 + extract(hour from $1))::int
$_$;


ALTER FUNCTION public.dowhour(timestamp with time zone) OWNER TO erpuser;

--
-- Name: if(boolean, anyelement, anyelement); Type: FUNCTION; Schema: public; Owner: erpuser
--

CREATE FUNCTION public.if(boolean, anyelement, anyelement) RETURNS anyelement
    LANGUAGE sql IMMUTABLE
    AS $_$
SELECT CASE WHEN ($1) THEN ($2) ELSE ($3) END
$_$;


ALTER FUNCTION public.if(boolean, anyelement, anyelement) OWNER TO erpuser;

--
-- Name: make_odd_or_even_sequence(text, text, text); Type: FUNCTION; Schema: public; Owner: erpuser
--

CREATE FUNCTION public.make_odd_or_even_sequence(table_name text, sequence_field_name text, odd_or_even text) RETURNS text
    LANGUAGE plpgsql
    AS $$
declare
  sequence_name text;
  max_id integer;

  -- Modify table sequence to generate only odd or even id
begin
  if odd_or_even not in ('odd', 'even')
  then return 'error: last param has to be either `odd` or `even`';
  end if;

  execute concat('select max(', sequence_field_name, ') from ', table_name) into max_id;
  select pg_get_serial_sequence(table_name, sequence_field_name) into sequence_name;

  execute 'alter sequence ' || sequence_name || ' increment by 2';

  case odd_or_even
    when 'odd' then
      return setval(sequence_name, max_id + mod(max_id + 1, 2));
    when 'even' then
      return setval(sequence_name, max_id + mod(max_id, 2));
    end case;
end;

$$;


ALTER FUNCTION public.make_odd_or_even_sequence(table_name text, sequence_field_name text, odd_or_even text) OWNER TO erpuser;

--
-- Name: export_consolidated_remittance(date); Type: FUNCTION; Schema: test; Owner: erpuser
--

CREATE FUNCTION test.export_consolidated_remittance(month_date date) RETURNS TABLE(campus_title character varying, campus_id bigint, name character varying, email character varying, number_of_kiosks bigint, client_type text, sales_list_price numeric, sales_after_discount numeric, complimentary numeric, freedom_pay numeric, credit_card numeric, monthly_lease numeric, connectivity_fee numeric, payment_processing_fee numeric, tag_fee numeric, tags_got integer, tag_price numeric, net_remittance numeric, net_total numeric, manual_adjustment numeric, fees_before_tags numeric, details text)
    LANGUAGE plpgsql
    AS $$
    BEGIN
        RETURN QUERY
        SELECT campus_remittance.campus_title,
            campus_remittance.campus_id,
            campus_remittance.name,
            campus_remittance.email,
            campus_remittance.number_of_kiosks,
            campus_remittance.client_type,
            COALESCE(campus_remittance.sales_list_price, 0) as sales_list_price,
            COALESCE(campus_remittance.sales_after_discount, 0) as sales_after_discount,
            COALESCE(campus_remittance.complimentary, 0) as complimentary,
            COALESCE(campus_remittance.freedom_pay, 0) as freedom_pay,
            COALESCE(campus_remittance.credit_card, 0) as credit_card,
            COALESCE(campus_remittance.monthly_lease, 0) as monthly_lease,
            COALESCE(campus_remittance.connectivity_fee, 0) as connectivity_fee,
            COALESCE(campus_remittance.payment_processing_fee, 0) as payment_processing_fee,
            COALESCE(campus_remittance.tag_fee, 0) as tag_fee,
            COALESCE(campus_remittance.tags_got, 0) as tags_got,
            COALESCE(campus_remittance.tag_price, 0) as tag_price,
            COALESCE(campus_remittance.net_remittance, 0) as net_remittance,
            COALESCE(campus_remittance.net_total, 0) as net_total,
            COALESCE(campus_remittance.manual_adjustment, 0) as manual_adjustment,
            COALESCE(campus_remittance.connectivity_fee, 0)
                + COALESCE(campus_remittance.payment_processing_fee, 0)
                + COALESCE(campus_remittance.monthly_lease, 0) as fees_before_tags,
            campus_remittance.details
            FROM (SELECT c.campus_title,
                c.campus_id,
                r.name,
                r.email,
                r.number_of_kiosks,
                r.client_type,
                r.sales_after_discount,
                r.sales_list_price,
                r.complimentary,
                r.freedom_pay,
                r.credit_card,
                r.monthly_lease,
                r.connectivity_fee,
                r.payment_processing_fee,
                --- Calculate old tag fees + new tag fees
                (COALESCE(tags_obtained.tags_got, 0) * COALESCE(r.tag_price, 0) +
                 COALESCE(new_tags_obtained.total_price, 0)) as tag_fee,
                ---Combine old tag amount with new tag amount
                (COALESCE(new_tags_obtained.amount_total, 0) + tags_obtained.tags_got) as tags_got,
                r.tag_price,
                r.credit_card
                    - r.monthly_lease
                    - r.connectivity_fee
                    - r.payment_processing_fee
                    - (COALESCE(tags_obtained.tags_got, 0) * COALESCE(r.tag_price, 0))
                    - (COALESCE(new_tags_obtained.total_price, 0))
                    + r.manual_adjustment  as net_remittance,
                r.credit_card
                    - r.monthly_lease
                    - r.connectivity_fee
                    - r.payment_processing_fee
                    - (COALESCE(tags_obtained.tags_got, 0) * COALESCE(r.tag_price, 0))
                    - (COALESCE(new_tags_obtained.total_price, 0))
                    + r.manual_adjustment
                    + r.complimentary
                    + r.freedom_pay as net_total,
                r.manual_adjustment,
                r.details
                FROM (SELECT id as campus_id,
                    title as campus_title
                    FROM pantry.campus
                ) c
                LEFT JOIN (SELECT er.campus_title,
                    er.campus_id,
                    er.name,
                    er.email,
                    count(er.kiosk_id) as number_of_kiosks,
                    STRING_AGG(er.kiosk_id::text, ', ') as kiosk_id,
                    STRING_AGG(distinct(er.client_type), ', ') as client_type,
                    sum(er.credit_card) as credit_card,
                    sum(er.sales_after_discount) as sales_after_discount,
                    sum(er.sales_list_price) as sales_list_price,
                    sum(er.complimentary) as complimentary,
                    sum(er.freedom_pay) as freedom_pay,
                    sum(er.monthly_lease) as monthly_lease,
                    sum(er.connectivity_fee) as connectivity_fee,
                    sum(er.payment_processing_fee) as payment_processing_fee,
                    --- Per our meeting from https://bytetechnology.atlassian.net/browse/ENG-2291,
                    --- we decided to take the max tag_price for each campus.
                    --- All kiosks are supposed to have the same tag_price within
                    --- a campus, but that's not the case due to data entry errors.
                    max(er.tag_price) as tag_price,
                    sum(er.manual_adjustment) as manual_adjustment,
                    STRING_AGG(er.details, ' | ') as details
                    FROM dw.export_remittance(month_date) er
                    GROUP BY er.name, er.campus_id, er.campus_title, er.email
                ) r
                ON r.campus_id = c.campus_id
                LEFT JOIN
                --- Get the number of tags obtained for each campus
                (SELECT p.campus_id,
                    sum(lo.amount)::int tags_got
                    FROM pantry.label_order lo
                    JOIN pantry.product p
                    ON lo.product_id = p.id
                    WHERE lo.status = 'Fulfilled'
                    --- From the first second of the month
                    AND lo.time_delivery >= extract('EPOCH'
                        FROM ( date_trunc('month', month_date)))::BIGINT
                    --- To the last second of the month
                    AND lo.time_delivery <= extract('EPOCH'
                        FROM (date_trunc('month', month_date + INTERVAL '1 month')))::BIGINT - 1
                    GROUP BY p.campus_id
                ) as tags_obtained
                ON tags_obtained.campus_id = c.campus_id
                LEFT JOIN
                --- Get the tag pricing / number of tags obtained
                --- for each campus using new Tags UI
                (WITH consolidated_tag_price AS
                (SELECT implicit_price.campus_id, implicit_price.tag_type,
                    COALESCE(explicit_price.price, implicit_price.price) price
                    FROM (SELECT c.id campus_id, tag_type, tp.price
                    FROM pantry.campus c, erp.tag_price tp
                    WHERE tp.campus_id = 0) implicit_price
                LEFT JOIN
                (SELECT c.id campus_id, tp.tag_type, tp.price
                   FROM pantry.campus c
                   JOIN erp.tag_price tp ON tp.campus_id = c.id) explicit_price
                   ON explicit_price.campus_id = implicit_price.campus_id
                   AND explicit_price.tag_type = implicit_price.tag_type)
                SELECT SUM(tag_order.amount)::int AS amount_total,
                   p.campus_id,
                   SUM(tag_order.amount * tp.price) AS total_price
                   FROM erp.tag_order
                   LEFT JOIN erp.tag_type tt ON tt.id = tag_order.tag_type_id
                   JOIN pantry.product p ON tag_order.product_id = p.id
                   JOIN pantry.campus c ON p.campus_id = c.id
                   JOIN consolidated_tag_price tp ON tt.type = tp.tag_type
                   AND tp.campus_id = p.campus_id
                WHERE status = 'fulfilled'
                AND process_ts >=  date_trunc('month', month_date::date)
                AND process_ts <  date_trunc('month', month_date::date + INTERVAL '1 month')
                GROUP BY p.campus_id
                ) AS new_tags_obtained
                ON new_tags_obtained.campus_id = c.campus_id
            ) as campus_remittance
            WHERE campus_remittance.sales_after_discount > 0 OR
            campus_remittance.complimentary > 0 OR
            campus_remittance.freedom_pay > 0 OR
            campus_remittance.credit_card > 0 OR
            campus_remittance.monthly_lease > 0 OR
            campus_remittance.connectivity_fee > 0 OR
            campus_remittance.payment_processing_fee > 0 OR
            campus_remittance.tag_fee > 0 OR
            campus_remittance.tags_got > 0 OR
            campus_remittance.tag_price > 0 OR
            campus_remittance.net_remittance > 0 OR
            campus_remittance.net_total > 0 OR
            campus_remittance.manual_adjustment > 0 OR
            campus_remittance.number_of_kiosks > 0
            ORDER BY campus_remittance.campus_id;
    END;
$$;


ALTER FUNCTION test.export_consolidated_remittance(month_date date) OWNER TO erpuser;

--
-- Name: export_transaction(timestamp without time zone, timestamp without time zone, character varying); Type: FUNCTION; Schema: test; Owner: erpuser
--

CREATE FUNCTION test.export_transaction(beginning_date timestamp without time zone, ending_date timestamp without time zone, time_zone character varying) RETURNS TABLE(order_id character varying, date_time timestamp with time zone, state character varying, campus_title character varying, campus_id bigint, client_name character varying, kiosk_title character varying, kiosk_id bigint, uid bigint, email character varying, customer_first_name character varying, customer_last_name character varying, vendor character varying, product_tile character varying, sku bigint, menu_category character varying, product_group character varying, qty bigint, total_list_price numeric, price_after_discounts numeric, total_price_after_discounts numeric, total_coupon_value numeric, total_cost numeric, margin numeric, credit_card text, credit_card_number text, approval_code character varying, geo character varying, coupon_code character varying, coupon_campaign character varying)
    LANGUAGE plpgsql
    AS $_$
BEGIN
  RETURN QUERY
    --- This query returns a list of transactions for the selected date range
    SELECT o.order_id,
           to_timestamp(o.created) as date_time,
           o.state,
           c.title as campus_title,
           k.campus_id,
           k.client_name as client_name,
           k.title as kiosk_title,
           o.kiosk_id,
           ca.id as uid,
           o.email,
           o.first_name as customer_first_name,
           o.last_name as customer_last_name,
           p.vendor,
           p.title as product_tile,
           l.product_id as sku,
           p.consumer_category as menu_category,
           p.fc_title as product_group,
           count(l.epc) as qty,
           sum(COALESCE(ph.price, p.price,0)) as total_list_price,
           --- Price after discount = l.price - discounts
           --- Set price to zero if it is negative.
           GREATEST(COALESCE((l.price),0) - COALESCE((CASE WHEN real_discount != 0 AND real_discount
             IS NOT NULL THEN real_discount ELSE  flat_discount END), 0), 0) as
             price_after_discounts,
           --- Total price after discount. For example, if more than 1 of the item was purchased
           --- Set total to zero if it is negative.
           GREATEST(COALESCE(sum(l.price),0) - COALESCE(sum(CASE WHEN real_discount != 0 AND real_discount
             IS NOT NULL THEN real_discount ELSE  flat_discount END), 0), 0) as
             total_after_discounts,
           --- Total $ coupon value
           COALESCE(sum(CASE WHEN real_discount != 0 AND real_discount
             IS NOT NULL THEN real_discount ELSE  flat_discount END), 0) as total_coupon_value,
           (l.cost * count(l.epc)) as total_cost,
           sum(COALESCE(ph.price, p.price,0)) - (l.cost * count(l.epc)) as margin,
           CASE WHEN payment_system = 'IPCommerce' OR payment_system =  'Express'
                  THEN 'Y' ELSE 'N' END as credit_card,
           RIGHT(ca.number, 4) as credit_card_number,
           o.approval_code as approval_code,
           k.geo,
           o.coupon as coupon_code,
           co.campaign as coupon_campaign
    FROM pantry.order o
           LEFT JOIN pantry.label l ON l.order_id = o.order_id
           LEFT JOIN pantry.kiosk k ON k.id = o.kiosk_id
           LEFT JOIN pantry.campus c ON c.id = k.campus_id
           LEFT JOIN pantry.card ca ON ca.hash = o.card_hash
           LEFT JOIN pantry.product p ON p.id = l.product_id
           LEFT JOIN pantry.coupon co ON co.id = o.coupon_id
           LEFT JOIN pantry.product_history ph ON ph.product_id = p.id
      AND o.created >= ph.start_time AND (ph.end_time IS NULL OR o.created < ph.end_time)
    WHERE to_timestamp(o.created) AT TIME ZONE time_zone >= beginning_date
      AND to_timestamp(o.created) AT TIME ZONE time_zone <= ending_date
    GROUP BY o.order_id, to_timestamp(o.created), o.state, k.campus_id, c.title, k.title, o.kiosk_id,
             ca.id, o.email, o.first_name, o.last_name, p.vendor, p.title, l.product_id, p.consumer_category,
             p.fc_title, p.price, l.cost, o.approval_code, k.geo, co.campaign, o.coupon, l.price, co.real_discount,
             co.flat_discount, k.client_name;
END;
$_$;


ALTER FUNCTION test.export_transaction(beginning_date timestamp without time zone, ending_date timestamp without time zone, time_zone character varying) OWNER TO erpuser;

--
-- Name: insert_in_monthly_kiosk_summary(date); Type: FUNCTION; Schema: test; Owner: erpuser
--

CREATE FUNCTION test.insert_in_monthly_kiosk_summary(month_date date) RETURNS void
    LANGUAGE plpgsql
    AS $_$
BEGIN
  INSERT INTO test.fact_monthly_kiosk_summary(
    campus_id,
    kiosk_id,
    date_id,
    fee_plan_name,
    prepaid_number_of_months,
    prepaid_until,
    licensing_subscription_fee,
    tag_price,
    payment_processing_rate,
    sales_list_price,
    sales_after_discount,
    food_cost,
    credit_card ,
    freedom_pay,
    complimentary,
    monthly_lease,
    payment_processing_fee,
    connectivity_fee,
    manual_adjustment,
    details
  )
    (SELECT monthly_report.campus_id,
            monthly_report.kiosk_id,
            monthly_report.date_id,
            monthly_report.fee_plan_name,
            monthly_report.prepaid_number_of_months,
            monthly_report.prepaid_until,
            monthly_report.licensing_subscription_fee,
            monthly_report.tag_price,
            monthly_report.payment_processing_rate,
            monthly_report.sales_list_price,
            monthly_report.sales_after_discount,
            monthly_report.food_cost,
            monthly_report.credit_card ,
            monthly_report.freedom_pay,
            monthly_report.complimentary,
            monthly_report.monthly_lease,
            monthly_report.payment_processing_fee,
            monthly_report.connectivity_fee,
            monthly_report.manual_adjustment,
            monthly_report.details
     FROM (SELECT
             kiosks.campus_id,
             kiosks.kiosk_id,
             TO_CHAR(date_trunc('month', month_date::date)::date, 'YYYYMMDD')::int AS date_id,
             fee_plan_name,
             prepaid_number_of_months,
             prepaid_until,
             licensing_subscription_fee,
             tag_price,
             payment_processing_rate,
             COALESCE(amount_list_price, 0) as sales_list_price,
             COALESCE(sales_after_discount, 0) as sales_after_discount,
             COALESCE(food_cost, 0) as food_cost,
             COALESCE(ip_commerce, 0) as credit_card ,
             COALESCE(freedom_pay, 0) as freedom_pay,
             COALESCE(complimentary, 0) as complimentary,
             COALESCE(monthly_lease, 0) as monthly_lease,
             COALESCE(ROUND((ip_commerce * fee_ipc)::numeric, 2), 0) as payment_processing_fee,
             COALESCE(connectivity, 0) as connectivity_fee,
             COALESCE(manual_adjustment, 0) as manual_adjustment,
             details
             --- Get all kiosks
           FROM (SELECT id as kiosk_id,
                        campus_id
                 FROM pantry.kiosk
                ) as kiosks
                  --- The following query is used to get sales totals from the daily fact table at
                  --- a kiosk level
                  LEFT JOIN (SELECT campus_id,
                                    kiosk_id,
                                    SUM(sales_amt) as amount_list_price,
                                    SUM(cost_amt) as food_cost,
                                    SUM(ip_commerce) as ip_commerce,
                                    SUM(freedom_pay)  as freedom_pay,
                                    SUM(complimentary) as complimentary,
                                    SUM(sales_after_discount) as sales_after_discount
                             FROM dw.fact_daily_kiosk_sku_summary daily
                                    JOIN dw.dim_date as dd
                                         ON dd.date_id = daily.date_id
                             WHERE as_date >= date_trunc('month', month_date::date)::date
                               AND as_date <= (date_trunc('month', month_date::date) + interval '1 month'
                               -  interval '1 day' )::date
                             GROUP BY kiosk_id, campus_id
           ) as amount_list_price
                            ON kiosks.kiosk_id = amount_list_price.kiosk_id
             --- The following subquery is used to get manual adjustments at a kiosk level
                  LEFT JOIN (SELECT kiosk_id,
                                    campus_id,
                                    sum(sum) as manual_adjustment,
                                    --- A list of all manual adjustments along with the reasons and kiosk
                                    STRING_AGG( CASE WHEN sum IS NOT NULL
                                                       THEN CONCAT(
                                        --- Add a $ in front of the sum. If it's a negative number, add the
                                        --- sign after the "-"
                                        CASE WHEN SIGN(SUM) = 1
                                               THEN CONCAT('$', SUM)
                                             WHEN SIGN(SUM) = -1
                                               THEN CONCAT('-$', -SUM)
                                          END,
                                        ' ',
                                        reason,
                                        ' (for kiosk "', k.title, '")') END
                                      , ' | ' ) as details
                             FROM pantry.manual_adjustment ma
                                    JOIN pantry.kiosk k
                                         ON ma.kiosk_id = k.id
                                  --- date in pantry.manual_adjustment is not an actual date. It’s a period
                                  --- accounting numbers were calculated for with format: "YYYY-MM-H".
                                  --- H can be either "1" for the first half of month and "2" for the entire month
                             WHERE date = TO_CHAR(date_trunc('month', month_date::date) + interval '1' day,
                                                  'YYYY-MM-fmDD')
                               AND ma.archived = 0
                             GROUP BY campus_id, kiosk_id
           ) as manual_adjust
                            ON manual_adjust.kiosk_id = kiosks.kiosk_id
             --- The following subquery is used to get the monthly_lease and connectivity
             --- at a kiosk level for all kiosks that were deployed before or at
             --- the remittance month.
                  LEFT JOIN (SELECT deployed_kiosks.kiosk_id,
                                    deployed_kiosks.campus_id,
                                    COALESCE(monthly_lease, 0) as monthly_lease,
                                    COALESCE(connectivity, 0) as connectivity
                                    --- ALl kiosks deployed at or before the remittance month
                             FROM (SELECT id as kiosk_id,
                                          campus_id
                                   FROM pantry.kiosk
                                   WHERE to_timestamp(deployment_time)::date <=
                                           --- the last day of the given month
                                         (date_trunc('month', month_date) + interval '1 month'
                                           - interval '1 day')::date
                                  ) as deployed_kiosks
                                    LEFT JOIN (SELECT kiosk_id,
                                                      campus_id,
                                                      monthly_lease,
                                                      connectivity
                                               FROM (SELECT a.campus_id,
                                                            kiosk_id,
                                                            --- If prepaid = 0, get the monthly_lease. Prepaid represents the amount
                                                            --- of months  already paid for at the time. If prepaid is greater than
                                                            --- 1, then the client pays $0 for the given month. The monthly_lease
                                                            --- obtained from dw.calculate_prorated_fee returns fee_lease if the
                                                            --- deployment_time != the current month, otherwise, it calculates
                                                            --- and returns the prorated fee based on deployment_time.
                                                            (SELECT prorated_fee FROM dw.calculate_prorated_fee(fee_lease,
                                                                                                                month_date, to_timestamp(k.deployment_time)::date))
                                                              as monthly_lease,
                                                            --- If the deployment date was this month, prorate the connectivity fee,
                                                            --- if not, give the normal fee
                                                            (SELECT prorated_fee FROM dw.calculate_prorated_fee(fee_connectivity,
                                                                                                                month_date, to_timestamp(k.deployment_time)::date))
                                                              as connectivity
                                                     FROM pantry.accounting a
                                                            JOIN pantry.fee_rates r
                                                                 ON a.current_fee = r.id
                                                                   AND a.prepaid = 0
                                                            JOIN pantry.kiosk k
                                                                 ON k.id = a.kiosk_id
                                                     WHERE a.date = TO_CHAR(date_trunc('month', month_date::date) +
                                                                            interval '1' day, 'YYYY-MM-fmDD')
                                                    ) as fee_lease
                             ) as all_lease
                                              ON all_lease.kiosk_id = deployed_kiosks.kiosk_id
           ) as lease
                            ON lease.kiosk_id = kiosks.kiosk_id
             --- The following subquery is used to get other kiosk related fees and info
                  LEFT JOIN (SELECT kiosk_id,
                                    a.campus_id,
                                    r.name as fee_plan_name,
                                    a.prepaid as prepaid_number_of_months,
                                    --- licensing_subscription_fee is the set regular licensing fee for each kiosk.
                                    --- This is different from monthly_lease which is the re-calculated licensing
                                    --- fee for a given month. This means that the monhtly_lease
                                    --- can be different for any two given months while the
                                    --- licensing_subscription_fee is set.
                                    fee_lease as licensing_subscription_fee,
                                    r.fee_tags as tag_price,
                                    CONCAT(ROUND(fee_ipc * 100, 2), '%') as payment_processing_rate,
                                    --- prepaid_until = month_date + the number of months left
                                    --- a.prepaid represents the number of months paid in advance, including the
                                    --- current month.
                                    CASE WHEN a.prepaid = 0
                                           THEN '_'
                                         ELSE TO_CHAR((month_date + (a.prepaid - 1 || ' MONTH')::INTERVAL),
                                                      'MM/DD/YYYY')
                                      END as prepaid_until,
                                    fee_ipc
                             FROM pantry.accounting a
                                    JOIN pantry.fee_rates r
                                         ON a.current_fee = r.id
                                    LEFT JOIN pantry.kiosk k
                                              ON a.kiosk_id = k.id
                                  --- date in pantry.accounting is not an actual date. It’s a period accounting
                                  --- numbers  were calculated for with format: "YYYY-MM-H".
                                  --- H can be either "1" for the first half of month and "2" for the entire month
                             WHERE a.date = TO_CHAR(date_trunc('month', month_date::date)
                                                      + interval '1' day, 'YYYY-MM-fmDD')
                             GROUP BY a.campus_id, kiosk_id, r.name, a.prepaid, a.prepaid_day, fee_lease,
                                      r.fee_tags, fee_ipc,
                                      to_timestamp(k.deployment_time)::date
           ) as charge
                            ON kiosks.kiosk_id = charge.kiosk_id
          ) as monthly_report
     WHERE licensing_subscription_fee > 0 OR
         tag_price > 0 OR
         sales_list_price > 0 OR
         sales_after_discount > 0 OR
         food_cost > 0 OR
         credit_card > 0 OR
         freedom_pay > 0 OR
         complimentary > 0 OR
         monthly_lease > 0 OR
         payment_processing_fee > 0 OR
         connectivity_fee > 0 OR
         manual_adjustment > 0
    )
  ON CONFLICT (campus_id, kiosk_id, date_id) DO UPDATE
    SET (sales_list_price,
         sales_after_discount,
         food_cost,
         credit_card ,
         freedom_pay,
         complimentary,
         monthly_lease,
         payment_processing_fee,
         connectivity_fee,
         manual_adjustment,
         fee_plan_name,
         prepaid_number_of_months,
         prepaid_until,
         licensing_subscription_fee,
         tag_price,
         payment_processing_rate,
         details
          ) = (excluded.sales_list_price,
               excluded.sales_after_discount,
               excluded.food_cost,
               excluded.credit_card ,
               excluded.freedom_pay,
               excluded.complimentary,
               excluded.monthly_lease,
               excluded.payment_processing_fee,
               excluded.connectivity_fee,
               excluded.manual_adjustment,
               excluded.fee_plan_name,
               excluded.prepaid_number_of_months,
               excluded.prepaid_until,
               excluded.licensing_subscription_fee,
               excluded.tag_price,
               excluded.payment_processing_rate,
               excluded.details);
END;
$_$;


ALTER FUNCTION test.insert_in_monthly_kiosk_summary(month_date date) OWNER TO erpuser;

--
-- Name: FUNCTION insert_in_monthly_kiosk_summary(month_date date); Type: COMMENT; Schema: test; Owner: erpuser
--

COMMENT ON FUNCTION test.insert_in_monthly_kiosk_summary(month_date date) IS 'inserts key metrics in dw.fact_monthly_kiosk_summary';


--
-- Name: insert_sales_after_discount_in_daily_kiosk_sku_summary(date, date); Type: FUNCTION; Schema: test; Owner: erpuser
--

CREATE FUNCTION test.insert_sales_after_discount_in_daily_kiosk_sku_summary(beginning_date date, ending_date date) RETURNS void
    LANGUAGE plpgsql
    AS $_$
BEGIN
  INSERT INTO test.fact_daily_kiosk_sku_summary(
    campus_id,
    kiosk_id,
    product_id,
    date_id,
    ip_commerce,
    freedom_pay,
    card_smith,
    complimentary,
    sales_after_discount
  )
    (SELECT campus_id,
            kiosk_id,
            product_id,
            date_id,
            sum(ipcommerce) as ipcommerce,
            sum(freedomPay) as freedomPay,
            sum(CardSmith) as cardSmith,
            sum(Complimentary) as complimentary,
            sum(sales_after_discount) as sales_after_discount
     FROM (SELECT  kiosk_campus_id as campus_id,
                   kiosk_id,
                   product_id,
                   date_id,
                   CASE WHEN payment_system = 'IPCommerce' OR payment_system =  'Express'
                          THEN sum(price) END as ipcommerce,
                   CASE WHEN payment_system = 'FreedomPay'
                          THEN sum(price) END as freedomPay,
                   CASE WHEN payment_system = 'CardSmith'
                          THEN sum(price) END as cardSmith,
                   CASE WHEN payment_system = 'Complimentary' OR payment_system = 'Nursing'
                          THEN sum(price) END as complimentary,
                   CASE WHEN payment_system = 'Complimentary'
                     OR payment_system =  'Express'
                     OR payment_system = 'FreedomPay'
                     OR payment_system = 'CardSmith'
                     OR payment_system = 'Nursing'
                          THEN sum(price) END as sales_after_discount
                   --- The following subquery is used to get the total amount of $ customers paid. Unlike
                   --- sales_amount_list_price, which is the price tag on an item, this query factors in all discounts
                   --- and coupons applied to a sale. The price on the label table already includes all
                   --- coupons. Discounts need to be subtracted from the total label.price.
                   --- In addition, this query only filters for order states
                   --- ('Placed', 'Processed' ,'Refunded' ) and label status 'sold' OR order state 'PriceFinalized'
                   --- and payment_system  'Complimentary'. The reason is because
                   --- those are the only orders that generated a payment. Amount_list_price on the other
                   --- hand, includes other states regardless of if we received a payment or not.
                   --- Also see ENG-1922 and
                   --- https://docs.google.com/presentation/d/1A9xYMop8u1NR6O5DmcYK8asauV9R-0eiXNiyKpUb6dQ/edit#slide=id.p
           FROM (SELECT (TO_CHAR(date_, 'YYYYMMDD'))::int AS date_id,
                        kiosk_id,
                        product_id,
                        kiosk_campus_id,
                        payment_system,

                        CASE WHEN
                          -- is price positive?
                          COALESCE(sum(price),0) - COALESCE(sum(CASE WHEN real_discount != 0 AND real_discount
                            IS NOT NULL THEN real_discount ELSE  flat_discount END), 0) >= 0
                            -- then use it
                            THEN
                              COALESCE(sum(price),0) - COALESCE(sum(CASE WHEN real_discount != 0 AND real_discount
                                IS NOT NULL THEN real_discount ELSE  flat_discount END), 0)
                            -- else use zero
                            ELSE
                              0
                          END AS price

                 FROM (SELECT payment_system,
                              to_timestamp(created)::date as date_,
                              COALESCE(l.cost) as cost,
                              COALESCE(l.price) as price,
                              l.kiosk_id,
                              l.product_id,
                              k.campus_id as kiosk_campus_id,
                              k.enable_reporting,
                              co.real_discount,
                              co.flat_discount
                       FROM pantry.label l
                              JOIN pantry.kiosk k
                                   ON k.id = l.kiosk_id
                              JOIN pantry.product p
                                   ON p.id = l.product_id
                              JOIN pantry.order o
                                   ON o.order_id = l.order_id
                              LEFT JOIN pantry.coupon co
                                        ON co.id = o.coupon_id
                            --- Between the first second of the month and the last second of the month
                       WHERE created BETWEEN extract('EPOCH' FROM (beginning_date::date))::BIGINT
                         AND extract('EPOCH' FROM (ending_date::date + interval '1 day'))::BIGINT - 1
                         AND o.state in ('Processed', 'Refunded')
                         AND l.status = 'sold'
                      )  as amount_paid_without_discount
                 GROUP BY payment_system, kiosk_id, product_id, kiosk_campus_id, date_id
                ) as amount_paid_with_discounts
           GROUP BY kiosk_campus_id, kiosk_id, product_id, date_id, payment_system
          ) as sum_amount_paid
     GROUP BY campus_id, kiosk_id, product_id, date_id
    )
  ON CONFLICT (campus_id, product_id, kiosk_id, date_id) DO UPDATE
    SET (ip_commerce,
         freedom_pay,
         card_smith,
         complimentary,
         sales_after_discount
          ) = (
               excluded.ip_commerce,
               excluded.freedom_pay,
               excluded.card_smith,
               excluded.complimentary,
               excluded.sales_after_discount);
END;
$_$;


ALTER FUNCTION test.insert_sales_after_discount_in_daily_kiosk_sku_summary(beginning_date date, ending_date date) OWNER TO erpuser;

--
-- Name: spoils(date, date); Type: FUNCTION; Schema: test; Owner: erpuser
--

CREATE FUNCTION test.spoils(beginning_date date, ending_date date) RETURNS TABLE(epc_ character varying, order_id_ character varying, kiosk_id_ bigint, product_id_ bigint, time_updated_ timestamp with time zone, cost_ numeric, price_ numeric, kiosk_campus_id_ bigint, product_campus_id_ bigint, enable_reporting_ bigint)
    LANGUAGE plpgsql
    AS $$
BEGIN
  RETURN QUERY
    /*
    For a given time window W1 (e.g. from beginning_date through ending_date) and an extended time
    window W2, with W1 being a subset of W2 (e.g. W1 +1 and -1 month from beginning_date through
    ending_date)

    Spoil: count of unique epc’s which have at least one spoil label record within W1 and have no
    sale record within W2.

    A spoil label record has an order id which starts with RE and has an out or lost LABEL STATUS.
    For a spoil label record to be within time window W1, the order creation time needs to be within W1.

    * ENG-834: Art's logic, the origin for this function
    * ENG-1922: Add label state lost; Restrict order state from the sales subquery
    */

    SELECT epc as epc_,
           order_id as order_id_,
           kiosk_id as kiosk_id_,
           product_id as product_id_,
           time_updated as time_updated_,
           cost as cost_,
           price as pice_,
           kiosk_campus_id as kiosk_campus_id_,
           product_campus_id as product_campus_id_,
           enable_reporting as enable_reporting_
    FROM (SELECT unique_epcs.epc as epc,
                 order_id,
                 kiosk_id,
                 product_id,
                 to_timestamp(all_epc_data. time_updated) as time_updated,
                 cost,
                 price,
                 kiosk_campus_id,
                 product_campus_id,
                 enable_reporting
                 --- There are duplicated EPCs. This subquery selects the most recent distinct spoiled EPC
          FROM(SELECT epc,
                      max(created) as time_updated
               FROM pantry.label l
                      JOIN pantry.kiosk k
                           ON k.id = l.kiosk_id
                      JOIN pantry.product p
                           ON p.id = l.product_id
                      JOIN pantry.order o
                           ON o.order_id = l.order_id
               WHERE to_timestamp(created)::date >= beginning_date
                 AND to_timestamp(created)::date <= ending_date
                 AND l.status in ('out', 'lost')
                 AND l.order_id LIKE 'RE%'
               GROUP BY epc
              ) as unique_epcs
                /*
                This subquery is used to get the order_id, time the order was created, price and cost
                values for the distinct EPCs we selected in the subquery above.
                */
                LEFT JOIN (SELECT epc,
                                  l.product_id,
                                  l.order_id,
                                  o.created as time_updated,
                                  --- Get the cost from label, if NULL, get cost from product_history, if NULL get cost
                                  --- from product, if NULL get 0. label has the most accurate cost info for
                                  --- the specific epc, then product_history, then product.
                                  COALESCE(l.cost, ph.cost, p.cost,0) as cost,
                                  --- Get the price from product_history, if NULL, get price from label, if NULL get price
                                  --- from product, if NULL get 0. product_history has the most accurate price info for
                                  --- that time, then label, then product.
                                  COALESCE(ph.price, l.price, p.price,0) as price,
                                  l.kiosk_id,
                                  k.campus_id as kiosk_campus_id,
                                  p.campus_id as product_campus_id,
                                  k.enable_reporting
                           FROM pantry.label l
                                  JOIN pantry.kiosk k
                                       ON k.id = l.kiosk_id
                                  JOIN pantry.product p
                                       ON p.id = l.product_id
                                  JOIN pantry.order o
                                       ON o.order_id = l.order_id
                                  LEFT JOIN pantry.product_history ph ON ph.product_id = p.id
                             AND o.created >= ph.start_time AND (ph.end_time IS NULL OR o.created <
                                                                                        ph.end_time)
                           WHERE to_timestamp(created)::date >= beginning_date
                             AND to_timestamp(created)::date <= ending_date
                             AND l.status in ('out', 'lost')
                             AND l.order_id LIKE 'RE%'
          ) as all_epc_data
                          ON unique_epcs.epc = all_epc_data.epc
                            AND unique_epcs. time_updated = all_epc_data. time_updated
         ) as spoiled_data
      /*
      This subquery is used to eliminate any EPCs that were sold in W2
      (View first comment above to get details on W2)
      */
    WHERE epc NOT IN (SELECT epc
                      FROM pantry.label l
                             JOIN pantry.kiosk k
                                  ON k.id = l.kiosk_id
                             JOIN pantry.product p
                                  ON p.id = l.product_id
                             JOIN pantry.order o
                                  ON o.order_id = l.order_id
                      WHERE to_timestamp(created)::date >= (SELECT beginning_date::date - INTERVAL '1 month')
                        AND to_timestamp(created)::date <= (SELECT ending_date::date + INTERVAL '1 month')
                        AND o.state in ('Placed', 'Processed', 'Refunded', 'Adjusted', 'Declined', 'Error')
                        AND l.status = 'sold'
                        AND l.order_id NOT LIKE 'RE%'
                        AND l.order_id IS NOT NULL);
END;
$$;


ALTER FUNCTION test.spoils(beginning_date date, ending_date date) OWNER TO erpuser;

--
-- Name: uptime_percentage(date, date); Type: FUNCTION; Schema: test; Owner: erpuser
--

CREATE FUNCTION test.uptime_percentage(start_date date, end_date date) RETURNS TABLE(uptime_percent numeric)
    LANGUAGE plpgsql
    AS $$
declare
  total_active_kiosks integer;
  measured_heartbeats integer;
  expected_heartbeats integer;
begin
  /*
  Return uptime percentage: 100 * measured_heartbeats/expected_heartbeats.
  Heart beats are reported every 10 minutes.
  Caveat: kiosks that enter/exit service during the reporting period.
   */

  select count(*), sum(heart_beats)
  from
    (select
       kiosk_id, count(*) heart_beats
     FROM kiosk_status
            JOIN pantry.kiosk ON kiosk.id = kiosk_status.kiosk_id
     WHERE to_timestamp(time) >= start_date
       AND to_timestamp(time)  < end_date
       AND kiosk.archived = 0
       AND to_timestamp(deployment_time) < start_date
     group by 1) per_kiosk_heartbeats

    -- where heart_beats > 700
    into total_active_kiosks, measured_heartbeats;

  select 144 * total_active_kiosks *  (end_date - start_date) into expected_heartbeats;

  return query
    select (100 * measured_heartbeats::decimal/expected_heartbeats)::decimal(4,2);

end

$$;


ALTER FUNCTION test.uptime_percentage(start_date date, end_date date) OWNER TO erpuser;

--
-- Name: uptime_ratio(date, date); Type: FUNCTION; Schema: test; Owner: erpuser
--

CREATE FUNCTION test.uptime_ratio(start_date date, end_date date) RETURNS TABLE(uptime_percent numeric)
    LANGUAGE plpgsql
    AS $$
declare
  total_active_kiosks integer;
  measured_heartbeats integer;
  expected_heartbeats integer;
begin
  /*
  Return uptime ratio: measured_heartbeats/expected_heartbeats.
  Heart beats are reported every 10 minutes.
  Caveat: kiosks that enter/exit service during the reporting period.
   */

  select count(*), sum(heart_beats)
  from
    (select
       kiosk_id, count(*) heart_beats
     FROM kiosk_status
            JOIN pantry.kiosk ON kiosk.id = kiosk_status.kiosk_id
     WHERE to_timestamp(time) >= start_date
       AND to_timestamp(time)  < end_date
       AND kiosk.archived = 0
       AND to_timestamp(deployment_time) < start_date
     group by 1) per_kiosk_heartbeats

    -- where heart_beats > 700
    into total_active_kiosks, measured_heartbeats;

  select 144 * total_active_kiosks *  (end_date - start_date) into expected_heartbeats;

  return query
    select (measured_heartbeats::decimal/expected_heartbeats)::decimal(6,4);

end

$$;


ALTER FUNCTION test.uptime_ratio(start_date date, end_date date) OWNER TO erpuser;

--
-- Name: deps_restore_dependencies(character varying, character varying); Type: FUNCTION; Schema: util; Owner: erpuser
--

CREATE FUNCTION util.deps_restore_dependencies(p_view_schema character varying, p_view_name character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
declare
  v_curr record;
begin
  for v_curr in
    (
      select deps_ddl_to_run
      from util.deps_saved_ddl
      where deps_view_schema = p_view_schema and deps_view_name = p_view_name
      order by deps_id desc
    ) loop
    execute v_curr.deps_ddl_to_run;
  end loop;
  delete from util.deps_saved_ddl
  where deps_view_schema = p_view_schema and deps_view_name = p_view_name;
end;
$$;


ALTER FUNCTION util.deps_restore_dependencies(p_view_schema character varying, p_view_name character varying) OWNER TO erpuser;

--
-- Name: FUNCTION deps_restore_dependencies(p_view_schema character varying, p_view_name character varying); Type: COMMENT; Schema: util; Owner: erpuser
--

COMMENT ON FUNCTION util.deps_restore_dependencies(p_view_schema character varying, p_view_name character varying) IS 'part of save/drop/restore dependent views suite: restore previously saved dependent views';


--
-- Name: deps_save_and_drop_dependencies(character varying, character varying); Type: FUNCTION; Schema: util; Owner: erpuser
--

CREATE FUNCTION util.deps_save_and_drop_dependencies(p_view_schema character varying, p_view_name character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
declare
  v_curr record;
begin
  for v_curr in
    -- return a set of records of schema name, view name, view type (normal or materialized view)
    (
      select obj_schema, obj_name, obj_type from
        (
          with recursive recursive_deps(obj_schema, obj_name, obj_type, depth) as
            (
              select p_view_schema, p_view_name, null::varchar, 0
              union
              select dep_schema::varchar, dep_name::varchar, dep_type::varchar,
                     recursive_deps.depth + 1 from
                (
                  select ref_nsp.nspname ref_schema, ref_cl.relname ref_name,
                    rwr_cl.relkind dep_type,
                    rwr_nsp.nspname dep_schema,
                    rwr_cl.relname dep_name
                  from pg_depend dep
                         join pg_class ref_cl on dep.refobjid = ref_cl.oid
                         join pg_namespace ref_nsp on ref_cl.relnamespace = ref_nsp.oid
                         join pg_rewrite rwr on dep.objid = rwr.oid
                         join pg_class rwr_cl on rwr.ev_class = rwr_cl.oid
                         join pg_namespace rwr_nsp on rwr_cl.relnamespace = rwr_nsp.oid
                  where dep.deptype = 'n'
                  and dep.classid = 'pg_rewrite'::regclass
                ) deps
                  join recursive_deps on deps.ref_schema = recursive_deps.obj_schema
                                           and deps.ref_name = recursive_deps.obj_name
              where (deps.ref_schema != deps.dep_schema or deps.ref_name != deps.dep_name)
            )
          select obj_schema, obj_name, obj_type, depth
          from recursive_deps
          where depth > 0
        ) t
      group by obj_schema, obj_name, obj_type
      order by max(depth) desc
    ) loop

    insert into util.deps_saved_ddl(deps_view_schema, deps_view_name, deps_ddl_to_run)
      select p_view_schema, p_view_name, 'COMMENT ON '
        ||  case
             when c.relkind = 'v' then 'VIEW'
             when c.relkind = 'm' then 'MATERIALIZED VIEW'
             else ''
             end
        || ' ' || n.nspname || '.' || c.relname || ' IS '''
        || replace(d.description, '''', '''''') || ''';'
      from pg_class c
             join pg_namespace n on n.oid = c.relnamespace
             join pg_description d on d.objoid = c.oid and d.objsubid = 0
      where n.nspname = v_curr.obj_schema
        and c.relname = v_curr.obj_name and d.description is not null;

    insert into util.deps_saved_ddl(deps_view_schema, deps_view_name, deps_ddl_to_run)
      select p_view_schema, p_view_name, 'COMMENT ON COLUMN ' || n.nspname || '.' || c.relname
         || '.' || a.attname || ' IS ''' || replace(d.description, '''', '''''') || ''';'
      from pg_class c
             join pg_attribute a on c.oid = a.attrelid
             join pg_namespace n on n.oid = c.relnamespace
             join pg_description d on d.objoid = c.oid and d.objsubid = a.attnum
      where n.nspname = v_curr.obj_schema
        and c.relname = v_curr.obj_name and d.description is not null;

    insert into util.deps_saved_ddl(deps_view_schema, deps_view_name, deps_ddl_to_run)
      select p_view_schema, p_view_name, 'GRANT ' || privilege_type || ' ON ' || table_schema || '.'
         || table_name || ' TO ' || grantee
      from information_schema.role_table_grants
      where table_schema = v_curr.obj_schema and table_name = v_curr.obj_name;

    -- generate statement to create normal view
    if v_curr.obj_type = 'v' then
      insert into util.deps_saved_ddl(deps_view_schema, deps_view_name, deps_ddl_to_run)
        select p_view_schema, p_view_name, 'CREATE VIEW ' || v_curr.obj_schema || '.'
           || v_curr.obj_name || ' AS ' || view_definition
        from information_schema.views
        where table_schema = v_curr.obj_schema and table_name = v_curr.obj_name;

    -- generate statement to create materialized view
    elsif v_curr.obj_type = 'm' then
      insert into util.deps_saved_ddl(deps_view_schema, deps_view_name, deps_ddl_to_run)
        select p_view_schema, p_view_name, 'CREATE MATERIALIZED VIEW ' || v_curr.obj_schema
           || '.' || v_curr.obj_name || ' AS ' || definition
        from pg_matviews
        where schemaname = v_curr.obj_schema and matviewname = v_curr.obj_name;
    end if;

    execute 'DROP ' ||
            case
              when v_curr.obj_type = 'v' then 'VIEW'
              when v_curr.obj_type = 'm' then 'MATERIALIZED VIEW'
              end
      || ' ' || v_curr.obj_schema || '.' || v_curr.obj_name;

  end loop;
end;
$$;


ALTER FUNCTION util.deps_save_and_drop_dependencies(p_view_schema character varying, p_view_name character varying) OWNER TO erpuser;

--
-- Name: FUNCTION deps_save_and_drop_dependencies(p_view_schema character varying, p_view_name character varying); Type: COMMENT; Schema: util; Owner: erpuser
--

COMMENT ON FUNCTION util.deps_save_and_drop_dependencies(p_view_schema character varying, p_view_name character varying) IS 'part of save/drop/restore dependent views suite: store DDL of dependent views then drop the views';


SET default_tablespace = '';

--
-- Name: awsdms_apply_exceptions; Type: TABLE; Schema: aws_dms; Owner: erpuser
--

CREATE TABLE aws_dms.awsdms_apply_exceptions (
    "TASK_NAME" character varying(128) NOT NULL,
    "TABLE_OWNER" character varying(128) NOT NULL,
    "TABLE_NAME" character varying(128) NOT NULL,
    "ERROR_TIME" timestamp without time zone NOT NULL,
    "STATEMENT" text NOT NULL,
    "ERROR" text NOT NULL
);


ALTER TABLE aws_dms.awsdms_apply_exceptions OWNER TO erpuser;

--
-- Name: feedback; Type: TABLE; Schema: pantry; Owner: erpuser
--

CREATE TABLE pantry.feedback (
    id bigint NOT NULL,
    rate bigint NOT NULL,
    order_id character varying(45) NOT NULL,
    message character varying(512),
    taste bigint,
    freshness bigint,
    variety bigint,
    value bigint,
    ticket_created bigint
);


ALTER TABLE pantry.feedback OWNER TO erpuser;

--
-- Name: kiosk; Type: TABLE; Schema: pantry; Owner: erpuser
--

CREATE TABLE pantry.kiosk (
    id bigint NOT NULL,
    campus_id bigint NOT NULL,
    serial character varying(45) NOT NULL,
    title character varying(46),
    address character varying(127),
    location_x numeric(9,6) NOT NULL,
    location_y numeric(9,6) NOT NULL,
    gcm_id character varying(255),
    app_vname character varying(63),
    app_vcode integer,
    archived bigint,
    creation_time bigint,
    deployment_time bigint,
    last_update bigint,
    client_name character varying(255),
    last_status bigint,
    last_inventory bigint NOT NULL,
    kiosk_name character varying(255) NOT NULL,
    payment_start bigint,
    payment_stop bigint,
    features character varying(255) NOT NULL,
    sales_tax smallint NOT NULL,
    default_fee_plan bigint NOT NULL,
    timezone character varying(50),
    estd_num_users bigint,
    tags character varying(255),
    publicly_accessible bigint,
    cardkey_required bigint,
    delivery_insns character varying(65535),
    fridge_loc_info character varying(65535),
    contact_first_name character varying(65535),
    contact_last_name character varying(65535),
    contact_email character varying(65535),
    contact_phone character varying(65535),
    accounting_email character varying(65535),
    byte_discount character varying(255),
    subsidy_info character varying(50),
    subsidy_notes character varying(65535),
    max_subscription character varying(50),
    delivery_window_mon character varying(50),
    delivery_window_tue character varying(50),
    delivery_window_wed character varying(50),
    delivery_window_thu character varying(50),
    delivery_window_fri character varying(50),
    delivery_window_sat character varying(50),
    delivery_window_sun character varying(50),
    notes character varying(2000),
    components text,
    email_receipt_subject character varying(255),
    ops_team_notes character varying(65535),
    geo character varying(3),
    server_url character varying(127),
    subscription_amount numeric(8,2) NOT NULL,
    enable_reporting bigint,
    enable_monitoring bigint,
    employees_num bigint,
    kiosk_restrictions character varying(2000)
);


ALTER TABLE pantry.kiosk OWNER TO erpuser;

--
-- Name: order; Type: TABLE; Schema: pantry; Owner: erpuser
--

CREATE TABLE pantry."order" (
    order_id character varying(45) NOT NULL,
    first_name character varying(45),
    last_name character varying(45),
    kiosk_id bigint NOT NULL,
    kiosk_title character varying(46),
    email character varying(127) NOT NULL,
    amount_paid numeric(6,2),
    payment_system character varying(45) NOT NULL,
    transaction_id character varying(45) NOT NULL,
    approval_code character varying(45) NOT NULL,
    status_code character varying(45),
    status_message character varying(45),
    status character varying(45),
    batch_id character varying(15),
    created bigint,
    auth_amount character varying(7),
    data_token character varying(2047),
    time_opened bigint,
    time_closed bigint,
    card_hash character varying(88) NOT NULL,
    state character varying(15) NOT NULL,
    archived bigint,
    stamp bigint NOT NULL,
    last_update bigint,
    balance numeric(7,2),
    delta character varying(4),
    coupon_id bigint,
    coupon character varying(45),
    refund numeric(6,2) NOT NULL,
    receipt bigint NOT NULL,
    campus_id bigint NOT NULL,
    amount_list_price numeric(6,2),
    notes text,
    time_door_opened bigint,
    time_door_closed bigint
);


ALTER TABLE pantry."order" OWNER TO erpuser;

--
-- Name: all_raw_orders; Type: VIEW; Schema: public; Owner: erpuser
--

CREATE VIEW public.all_raw_orders AS
 SELECT o.order_id,
    o.first_name,
    o.last_name,
    o.kiosk_id,
    o.kiosk_title,
    o.email,
    o.amount_paid,
    o.payment_system,
    o.transaction_id,
    o.approval_code,
    o.status_code,
    o.status_message,
    o.status,
    o.batch_id,
    o.created,
    o.auth_amount,
    o.data_token,
    o.time_opened,
    o.time_closed,
    o.card_hash,
    o.state,
    o.archived,
    o.stamp,
    o.last_update,
    o.balance,
    o.delta,
    o.coupon_id,
    o.coupon,
    o.refund,
    o.receipt,
    o.campus_id,
    o.amount_list_price,
    o.notes,
    o.time_door_opened,
    o.time_door_closed,
    k.client_name,
    k.estd_num_users,
    to_timestamp((o.created)::double precision) AS ts,
    concat(btrim((o.first_name)::text), ' ', btrim((o.last_name)::text)) AS full_name,
    (o.time_closed - o.time_opened) AS door_opened_secs
   FROM (pantry."order" o
     JOIN pantry.kiosk k ON ((o.kiosk_id = k.id)));


ALTER TABLE public.all_raw_orders OWNER TO erpuser;

--
-- Name: _all_orders; Type: VIEW; Schema: public; Owner: erpuser
--

CREATE VIEW public._all_orders AS
 SELECT all_raw_orders.order_id,
    all_raw_orders.first_name,
    all_raw_orders.last_name,
    all_raw_orders.kiosk_id,
    all_raw_orders.kiosk_title,
    all_raw_orders.email,
    all_raw_orders.amount_paid,
    all_raw_orders.payment_system,
    all_raw_orders.transaction_id,
    all_raw_orders.approval_code,
    all_raw_orders.status_code,
    all_raw_orders.status_message,
    all_raw_orders.status,
    all_raw_orders.batch_id,
    all_raw_orders.created,
    all_raw_orders.auth_amount,
    all_raw_orders.data_token,
    all_raw_orders.time_opened,
    all_raw_orders.time_closed,
    all_raw_orders.card_hash,
    all_raw_orders.state,
    all_raw_orders.archived,
    all_raw_orders.stamp,
    all_raw_orders.last_update,
    all_raw_orders.balance,
    all_raw_orders.delta,
    all_raw_orders.coupon_id,
    all_raw_orders.coupon,
    all_raw_orders.refund,
    all_raw_orders.receipt,
    all_raw_orders.campus_id,
    all_raw_orders.amount_list_price,
    all_raw_orders.notes,
    all_raw_orders.time_door_opened,
    all_raw_orders.time_door_closed,
    all_raw_orders.client_name,
    all_raw_orders.estd_num_users,
    all_raw_orders.ts,
    all_raw_orders.full_name,
    all_raw_orders.door_opened_secs,
    date_trunc('month'::text, all_raw_orders.ts) AS month,
    date_trunc('week'::text, all_raw_orders.ts) AS week,
    date_trunc('day'::text, all_raw_orders.ts) AS date,
    date_part('dow'::text, all_raw_orders.ts) AS dayofweek,
    date_trunc('hour'::text, all_raw_orders.ts) AS hour
   FROM public.all_raw_orders;


ALTER TABLE public._all_orders OWNER TO erpuser;

--
-- Name: all_orders; Type: VIEW; Schema: public; Owner: erpuser
--

CREATE VIEW public.all_orders AS
 SELECT _all_orders.order_id,
    _all_orders.first_name,
    _all_orders.last_name,
    _all_orders.kiosk_id,
    _all_orders.kiosk_title,
    _all_orders.email,
    _all_orders.amount_paid,
    _all_orders.payment_system,
    _all_orders.transaction_id,
    _all_orders.approval_code,
    _all_orders.status_code,
    _all_orders.status_message,
    _all_orders.status,
    _all_orders.batch_id,
    _all_orders.created,
    _all_orders.auth_amount,
    _all_orders.data_token,
    _all_orders.time_opened,
    _all_orders.time_closed,
    _all_orders.card_hash,
    _all_orders.state,
    _all_orders.archived,
    _all_orders.stamp,
    _all_orders.last_update,
    _all_orders.balance,
    _all_orders.delta,
    _all_orders.coupon_id,
    _all_orders.coupon,
    _all_orders.refund,
    _all_orders.receipt,
    _all_orders.campus_id,
    _all_orders.amount_list_price,
    _all_orders.notes,
    _all_orders.time_door_opened,
    _all_orders.time_door_closed,
    _all_orders.client_name,
    _all_orders.estd_num_users,
    _all_orders.ts,
    _all_orders.full_name,
    _all_orders.door_opened_secs,
    _all_orders.month,
    _all_orders.week,
    _all_orders.date,
    _all_orders.dayofweek,
    _all_orders.hour,
    public.dowhour(_all_orders.hour) AS dowhour
   FROM public._all_orders;


ALTER TABLE public.all_orders OWNER TO erpuser;

--
-- Name: byte_orders; Type: VIEW; Schema: public; Owner: erpuser
--

CREATE VIEW public.byte_orders AS
 SELECT all_orders.order_id,
    all_orders.first_name,
    all_orders.last_name,
    all_orders.kiosk_id,
    all_orders.kiosk_title,
    all_orders.email,
    all_orders.amount_paid,
    all_orders.payment_system,
    all_orders.transaction_id,
    all_orders.approval_code,
    all_orders.status_code,
    all_orders.status_message,
    all_orders.status,
    all_orders.batch_id,
    all_orders.created,
    all_orders.auth_amount,
    all_orders.data_token,
    all_orders.time_opened,
    all_orders.time_closed,
    all_orders.card_hash,
    all_orders.state,
    all_orders.archived,
    all_orders.stamp,
    all_orders.last_update,
    all_orders.balance,
    all_orders.delta,
    all_orders.coupon_id,
    all_orders.coupon,
    all_orders.refund,
    all_orders.receipt,
    all_orders.campus_id,
    all_orders.amount_list_price,
    all_orders.notes,
    all_orders.time_door_opened,
    all_orders.time_door_closed,
    all_orders.client_name,
    all_orders.estd_num_users,
    all_orders.ts,
    all_orders.full_name,
    all_orders.door_opened_secs,
    all_orders.month,
    all_orders.week,
    all_orders.date,
    all_orders.dayofweek,
    all_orders.hour,
    all_orders.dowhour
   FROM (public.all_orders all_orders
     JOIN pantry.kiosk kiosk ON ((all_orders.kiosk_id = kiosk.id)))
  WHERE ((all_orders.campus_id = 87) AND (kiosk.enable_reporting = 1));


ALTER TABLE public.byte_orders OWNER TO erpuser;

--
-- Name: byte_tickets; Type: VIEW; Schema: public; Owner: erpuser
--

CREATE VIEW public.byte_tickets AS
 SELECT byte_orders.order_id,
    byte_orders.first_name,
    byte_orders.last_name,
    byte_orders.kiosk_id,
    byte_orders.kiosk_title,
    byte_orders.email,
    byte_orders.amount_paid,
    byte_orders.payment_system,
    byte_orders.transaction_id,
    byte_orders.approval_code,
    byte_orders.status_code,
    byte_orders.status_message,
    byte_orders.status,
    byte_orders.batch_id,
    byte_orders.created,
    byte_orders.auth_amount,
    byte_orders.data_token,
    byte_orders.time_opened,
    byte_orders.time_closed,
    byte_orders.card_hash,
    byte_orders.state,
    byte_orders.archived,
    byte_orders.stamp,
    byte_orders.last_update,
    byte_orders.balance,
    byte_orders.delta,
    byte_orders.coupon_id,
    byte_orders.coupon,
    byte_orders.refund,
    byte_orders.receipt,
    byte_orders.campus_id,
    byte_orders.amount_list_price,
    byte_orders.notes,
    byte_orders.time_door_opened,
    byte_orders.time_door_closed,
    byte_orders.client_name,
    byte_orders.estd_num_users,
    byte_orders.ts,
    byte_orders.full_name,
    byte_orders.door_opened_secs,
    byte_orders.month,
    byte_orders.week,
    byte_orders.date,
    byte_orders.dayofweek,
    byte_orders.hour,
    byte_orders.dowhour,
    btrim(concat("left"(btrim((byte_orders.first_name)::text), 1), '.', btrim((byte_orders.last_name)::text))) AS uniq_user
   FROM public.byte_orders
  WHERE ((byte_orders.state)::text <> 'NonTrans'::text);


ALTER TABLE public.byte_tickets OWNER TO erpuser;

--
-- Name: byte_feedback; Type: VIEW; Schema: public; Owner: erpuser
--

CREATE VIEW public.byte_feedback AS
 SELECT f.id,
    f.rate,
    f.order_id,
    f.message,
    f.taste,
    f.freshness,
    f.variety,
    f.value,
    f.ticket_created,
    date_trunc('month'::text, t.ts) AS month,
    date_trunc('week'::text, t.ts) AS week,
    date_trunc('day'::text, t.ts) AS date,
    date_trunc('hour'::text, t.ts) AS hour
   FROM (pantry.feedback f
     JOIN public.byte_tickets t ON (((f.order_id)::text = (t.order_id)::text)));


ALTER TABLE public.byte_feedback OWNER TO erpuser;

--
-- Name: byte_feedback_monthly; Type: VIEW; Schema: public; Owner: erpuser
--

CREATE VIEW public.byte_feedback_monthly AS
 SELECT t1.month,
    t1.avg_rating,
    t1.avg_value,
    t1.avg_taste,
    t1.avg_freshness,
    t1.avg_variety,
    ((1.0 * (t1.feedbacks)::numeric) / (t2.tix)::numeric) AS frac_feedbacks
   FROM (( SELECT byte_feedback.month,
            avg((1.0 * (byte_feedback.rate)::numeric)) AS avg_rating,
            avg(public.if((byte_feedback.value > 0), (1.0 * (byte_feedback.value)::numeric), NULL::numeric)) AS avg_value,
            avg(public.if((byte_feedback.taste > 0), (1.0 * (byte_feedback.taste)::numeric), NULL::numeric)) AS avg_taste,
            avg(public.if((byte_feedback.freshness > 0), (1.0 * (byte_feedback.freshness)::numeric), NULL::numeric)) AS avg_freshness,
            avg(public.if((byte_feedback.variety > 0), (1.0 * (byte_feedback.variety)::numeric), NULL::numeric)) AS avg_variety,
            count(*) AS feedbacks
           FROM public.byte_feedback
          WHERE (byte_feedback.month >= '2016-01-01 08:00:00+00'::timestamp with time zone)
          GROUP BY byte_feedback.month
          ORDER BY byte_feedback.month) t1
     JOIN ( SELECT byte_tickets.month,
            count(*) AS tix
           FROM public.byte_tickets
          GROUP BY byte_tickets.month) t2 ON ((t1.month = t2.month)));


ALTER TABLE public.byte_feedback_monthly OWNER TO erpuser;

--
-- Name: byte_feedback_monthly; Type: VIEW; Schema: campus_87; Owner: erpuser
--

CREATE VIEW campus_87.byte_feedback_monthly AS
 SELECT byte_feedback_monthly.month,
    byte_feedback_monthly.avg_rating,
    byte_feedback_monthly.avg_value,
    byte_feedback_monthly.avg_taste,
    byte_feedback_monthly.avg_freshness,
    byte_feedback_monthly.avg_variety,
    byte_feedback_monthly.frac_feedbacks
   FROM public.byte_feedback_monthly;


ALTER TABLE campus_87.byte_feedback_monthly OWNER TO erpuser;

--
-- Name: campus; Type: TABLE; Schema: pantry; Owner: erpuser
--

CREATE TABLE pantry.campus (
    id bigint NOT NULL,
    title character varying(45) NOT NULL,
    timezone character varying(50),
    archived integer
);


ALTER TABLE pantry.campus OWNER TO erpuser;

--
-- Name: campus; Type: VIEW; Schema: campus_87; Owner: erpuser
--

CREATE VIEW campus_87.campus AS
 SELECT campus.id,
    campus.title,
    campus.timezone,
    campus.archived
   FROM pantry.campus
  WHERE (campus.id = 87);


ALTER TABLE campus_87.campus OWNER TO erpuser;

--
-- Name: dim_date; Type: TABLE; Schema: dw; Owner: muriel
--

CREATE TABLE dw.dim_date (
    date_id integer NOT NULL,
    as_date date,
    year_month integer,
    month_num integer,
    month_name text,
    month_short_name text,
    week_num integer,
    day_of_year integer,
    day_of_month integer,
    day_of_week integer,
    day_name text,
    day_short_name text,
    quarter integer,
    year_quarter integer,
    day_of_quarter integer,
    year integer,
    year_week integer
);


ALTER TABLE dw.dim_date OWNER TO muriel;

--
-- Name: TABLE dim_date; Type: COMMENT; Schema: dw; Owner: muriel
--

COMMENT ON TABLE dw.dim_date IS 'date values from 2012 through 2039';


--
-- Name: dim_date; Type: VIEW; Schema: campus_87; Owner: erpuser
--

CREATE VIEW campus_87.dim_date AS
 SELECT dim_date.date_id,
    dim_date.as_date,
    dim_date.year_month,
    dim_date.month_num,
    dim_date.month_name,
    dim_date.month_short_name,
    dim_date.week_num,
    dim_date.day_of_year,
    dim_date.day_of_month,
    dim_date.day_of_week,
    dim_date.day_name,
    dim_date.day_short_name,
    dim_date.quarter,
    dim_date.year_quarter,
    dim_date.day_of_quarter,
    dim_date.year,
    dim_date.year_week
   FROM dw.dim_date;


ALTER TABLE campus_87.dim_date OWNER TO erpuser;

--
-- Name: fact_daily_kiosk_sku_summary; Type: TABLE; Schema: dw; Owner: muriel
--

CREATE TABLE dw.fact_daily_kiosk_sku_summary (
    campus_id integer NOT NULL,
    product_id bigint NOT NULL,
    kiosk_id bigint NOT NULL,
    date_id integer NOT NULL,
    sales_qty integer,
    sales_amt numeric(12,2),
    cost_amt numeric(12,2),
    gross_margin_amt numeric(12,2),
    spoils_qty integer,
    spoils_amt numeric(12,2),
    losses_qty integer,
    losses_amt numeric(12,2),
    stocked_percent numeric(3,2),
    ip_commerce numeric(12,2),
    freedom_pay numeric(12,2),
    card_smith numeric(12,2),
    complimentary numeric(12,2),
    sales_after_discount numeric(12,2)
);


ALTER TABLE dw.fact_daily_kiosk_sku_summary OWNER TO muriel;

--
-- Name: TABLE fact_daily_kiosk_sku_summary; Type: COMMENT; Schema: dw; Owner: muriel
--

COMMENT ON TABLE dw.fact_daily_kiosk_sku_summary IS 'key metrics per kiosk, SKU and day';


--
-- Name: fact_daily_kiosk_sku_summary; Type: VIEW; Schema: campus_87; Owner: erpuser
--

CREATE VIEW campus_87.fact_daily_kiosk_sku_summary AS
 SELECT fact_daily_kiosk_sku_summary.campus_id,
    fact_daily_kiosk_sku_summary.product_id,
    fact_daily_kiosk_sku_summary.kiosk_id,
    fact_daily_kiosk_sku_summary.date_id,
    fact_daily_kiosk_sku_summary.sales_qty,
    fact_daily_kiosk_sku_summary.sales_amt,
    fact_daily_kiosk_sku_summary.cost_amt,
    fact_daily_kiosk_sku_summary.gross_margin_amt,
    fact_daily_kiosk_sku_summary.spoils_qty,
    fact_daily_kiosk_sku_summary.spoils_amt,
    fact_daily_kiosk_sku_summary.losses_qty,
    fact_daily_kiosk_sku_summary.losses_amt,
    fact_daily_kiosk_sku_summary.stocked_percent,
    fact_daily_kiosk_sku_summary.ip_commerce,
    fact_daily_kiosk_sku_summary.freedom_pay,
    fact_daily_kiosk_sku_summary.card_smith,
    fact_daily_kiosk_sku_summary.complimentary,
    fact_daily_kiosk_sku_summary.sales_after_discount
   FROM dw.fact_daily_kiosk_sku_summary
  WHERE (fact_daily_kiosk_sku_summary.campus_id = 87);


ALTER TABLE campus_87.fact_daily_kiosk_sku_summary OWNER TO erpuser;

--
-- Name: kiosk; Type: VIEW; Schema: campus_87; Owner: erpuser
--

CREATE VIEW campus_87.kiosk AS
 SELECT kiosk.id,
    kiosk.campus_id,
    kiosk.serial,
    kiosk.title,
    kiosk.address,
    kiosk.location_x,
    kiosk.location_y,
    kiosk.gcm_id,
    kiosk.app_vname,
    kiosk.app_vcode,
    kiosk.archived,
    kiosk.creation_time,
    kiosk.deployment_time,
    kiosk.last_update,
    kiosk.client_name,
    kiosk.last_status,
    kiosk.last_inventory,
    kiosk.kiosk_name,
    kiosk.payment_start,
    kiosk.payment_stop,
    kiosk.features,
    kiosk.sales_tax,
    kiosk.default_fee_plan,
    kiosk.timezone,
    kiosk.estd_num_users,
    kiosk.tags,
    kiosk.publicly_accessible,
    kiosk.cardkey_required,
    kiosk.delivery_insns,
    kiosk.fridge_loc_info,
    kiosk.contact_first_name,
    kiosk.contact_last_name,
    kiosk.contact_email,
    kiosk.contact_phone,
    kiosk.accounting_email,
    kiosk.byte_discount,
    kiosk.subsidy_info,
    kiosk.subsidy_notes,
    kiosk.max_subscription,
    kiosk.delivery_window_mon,
    kiosk.delivery_window_tue,
    kiosk.delivery_window_wed,
    kiosk.delivery_window_thu,
    kiosk.delivery_window_fri,
    kiosk.delivery_window_sat,
    kiosk.delivery_window_sun,
    kiosk.notes,
    kiosk.components,
    kiosk.email_receipt_subject,
    kiosk.ops_team_notes,
    kiosk.geo,
    kiosk.server_url,
    kiosk.subscription_amount,
    kiosk.enable_reporting,
    kiosk.enable_monitoring,
    kiosk.employees_num,
    kiosk.kiosk_restrictions
   FROM pantry.kiosk
  WHERE (kiosk.campus_id = 87);


ALTER TABLE campus_87.kiosk OWNER TO erpuser;

--
-- Name: kiosk_control; Type: TABLE; Schema: inm; Owner: erpuser
--

CREATE TABLE inm.kiosk_control (
    kiosk_id integer NOT NULL,
    start_level numeric(4,2) DEFAULT 1.5 NOT NULL,
    min_level numeric(4,2) DEFAULT 0.5 NOT NULL,
    scale numeric(4,2) DEFAULT 1.0 NOT NULL,
    manual_multiplier numeric(4,2) DEFAULT 1.0 NOT NULL
);


ALTER TABLE inm.kiosk_control OWNER TO erpuser;

--
-- Name: TABLE kiosk_control; Type: COMMENT; Schema: inm; Owner: erpuser
--

COMMENT ON TABLE inm.kiosk_control IS 'kiosk settings';


--
-- Name: kiosk_control; Type: VIEW; Schema: campus_87; Owner: erpuser
--

CREATE VIEW campus_87.kiosk_control AS
 SELECT kiosk_control.kiosk_id,
    kiosk_control.start_level,
    kiosk_control.min_level,
    kiosk_control.scale,
    kiosk_control.manual_multiplier
   FROM inm.kiosk_control;


ALTER TABLE campus_87.kiosk_control OWNER TO erpuser;

--
-- Name: kiosk_restriction_by_product; Type: TABLE; Schema: inm; Owner: erpuser
--

CREATE TABLE inm.kiosk_restriction_by_product (
    kiosk_id bigint NOT NULL,
    product_id integer NOT NULL,
    end_date date DEFAULT '2050-01-01'::date,
    comment type.text400,
    record_ts timestamp with time zone DEFAULT CURRENT_TIMESTAMP
);


ALTER TABLE inm.kiosk_restriction_by_product OWNER TO erpuser;

--
-- Name: TABLE kiosk_restriction_by_product; Type: COMMENT; Schema: inm; Owner: erpuser
--

COMMENT ON TABLE inm.kiosk_restriction_by_product IS 'one kiosk, many restricted products';


--
-- Name: kiosk_restriction_by_product; Type: VIEW; Schema: campus_87; Owner: erpuser
--

CREATE VIEW campus_87.kiosk_restriction_by_product AS
 SELECT kiosk_restriction_by_product.kiosk_id,
    kiosk_restriction_by_product.product_id,
    kiosk_restriction_by_product.end_date,
    kiosk_restriction_by_product.comment,
    kiosk_restriction_by_product.record_ts
   FROM inm.kiosk_restriction_by_product;


ALTER TABLE campus_87.kiosk_restriction_by_product OWNER TO erpuser;

--
-- Name: kiosk_restriction_by_product_ed; Type: TABLE; Schema: inm; Owner: erpuser
--

CREATE TABLE inm.kiosk_restriction_by_product_ed (
    kiosk_id bigint NOT NULL,
    product_id integer NOT NULL,
    end_date date,
    comment type.text400,
    record_ts timestamp with time zone
);


ALTER TABLE inm.kiosk_restriction_by_product_ed OWNER TO erpuser;

--
-- Name: kiosk_restriction_by_product_ed; Type: VIEW; Schema: campus_87; Owner: erpuser
--

CREATE VIEW campus_87.kiosk_restriction_by_product_ed AS
 SELECT kiosk_restriction_by_product_ed.kiosk_id,
    kiosk_restriction_by_product_ed.product_id,
    kiosk_restriction_by_product_ed.end_date,
    kiosk_restriction_by_product_ed.comment,
    kiosk_restriction_by_product_ed.record_ts
   FROM inm.kiosk_restriction_by_product_ed;


ALTER TABLE campus_87.kiosk_restriction_by_product_ed OWNER TO erpuser;

--
-- Name: kiosk_restriction_by_property; Type: TABLE; Schema: inm; Owner: erpuser
--

CREATE TABLE inm.kiosk_restriction_by_property (
    kiosk_id integer NOT NULL,
    property_id integer NOT NULL
);


ALTER TABLE inm.kiosk_restriction_by_property OWNER TO erpuser;

--
-- Name: TABLE kiosk_restriction_by_property; Type: COMMENT; Schema: inm; Owner: erpuser
--

COMMENT ON TABLE inm.kiosk_restriction_by_property IS 'one kiosk, many restricted properties';


--
-- Name: kiosk_restriction_by_property; Type: VIEW; Schema: campus_87; Owner: erpuser
--

CREATE VIEW campus_87.kiosk_restriction_by_property AS
 SELECT kiosk_restriction_by_property.kiosk_id,
    kiosk_restriction_by_property.property_id
   FROM inm.kiosk_restriction_by_property;


ALTER TABLE campus_87.kiosk_restriction_by_property OWNER TO erpuser;

--
-- Name: kiosk_sku_group_manual_scale; Type: TABLE; Schema: inm; Owner: erpuser
--

CREATE TABLE inm.kiosk_sku_group_manual_scale (
    kiosk_id integer NOT NULL,
    sku_group_id integer NOT NULL,
    scale numeric(4,2) NOT NULL
);


ALTER TABLE inm.kiosk_sku_group_manual_scale OWNER TO erpuser;

--
-- Name: TABLE kiosk_sku_group_manual_scale; Type: COMMENT; Schema: inm; Owner: erpuser
--

COMMENT ON TABLE inm.kiosk_sku_group_manual_scale IS 'control sku_group scale per kiosk';


--
-- Name: kiosk_sku_group_manual_scale; Type: VIEW; Schema: campus_87; Owner: erpuser
--

CREATE VIEW campus_87.kiosk_sku_group_manual_scale AS
 SELECT kiosk_sku_group_manual_scale.kiosk_id,
    kiosk_sku_group_manual_scale.sku_group_id,
    kiosk_sku_group_manual_scale.scale
   FROM inm.kiosk_sku_group_manual_scale;


ALTER TABLE campus_87.kiosk_sku_group_manual_scale OWNER TO erpuser;

--
-- Name: label; Type: TABLE; Schema: pantry; Owner: erpuser
--

CREATE TABLE pantry.label (
    id bigint NOT NULL,
    product_id bigint NOT NULL,
    epc character varying(24) NOT NULL,
    is_generic_sku smallint,
    kiosk_id bigint,
    order_id character varying(45),
    status character varying(4),
    price numeric(6,2),
    cost numeric(6,2),
    time_created bigint,
    time_added bigint,
    time_updated bigint
);


ALTER TABLE pantry.label OWNER TO erpuser;

--
-- Name: label; Type: VIEW; Schema: campus_87; Owner: erpuser
--

CREATE VIEW campus_87.label AS
 SELECT l.id,
    l.product_id,
    l.epc,
    l.is_generic_sku,
    l.kiosk_id,
    l.order_id,
    l.status,
    l.price,
    l.cost,
    l.time_created,
    l.time_added,
    l.time_updated
   FROM (pantry.label l
     JOIN pantry.kiosk k ON ((l.kiosk_id = k.id)))
  WHERE (k.campus_id = 87);


ALTER TABLE campus_87.label OWNER TO erpuser;

--
-- Name: order; Type: VIEW; Schema: campus_87; Owner: erpuser
--

CREATE VIEW campus_87."order" AS
 SELECT "order".order_id,
    "order".first_name,
    "order".last_name,
    "order".kiosk_id,
    "order".kiosk_title,
    "order".email,
    "order".amount_paid,
    "order".payment_system,
    "order".transaction_id,
    "order".approval_code,
    "order".status_code,
    "order".status_message,
    "order".status,
    "order".batch_id,
    "order".created,
    "order".auth_amount,
    "order".data_token,
    "order".time_opened,
    "order".time_closed,
    "order".card_hash,
    "order".state,
    "order".archived,
    "order".stamp,
    "order".last_update,
    "order".balance,
    "order".delta,
    "order".coupon_id,
    "order".coupon,
    "order".refund,
    "order".receipt,
    "order".campus_id,
    "order".amount_list_price,
    "order".notes,
    "order".time_door_opened,
    "order".time_door_closed
   FROM pantry."order"
  WHERE ("order".campus_id = 87);


ALTER TABLE campus_87."order" OWNER TO erpuser;

--
-- Name: pick_allocation; Type: TABLE; Schema: inm; Owner: erpuser
--

CREATE TABLE inm.pick_allocation (
    pick_date date NOT NULL,
    route_date date NOT NULL,
    kiosk_id integer NOT NULL,
    sku_id integer NOT NULL,
    qty integer NOT NULL
);


ALTER TABLE inm.pick_allocation OWNER TO erpuser;

--
-- Name: TABLE pick_allocation; Type: COMMENT; Schema: inm; Owner: erpuser
--

COMMENT ON TABLE inm.pick_allocation IS 'items allocated per kiosk';


--
-- Name: pick_allocation; Type: VIEW; Schema: campus_87; Owner: erpuser
--

CREATE VIEW campus_87.pick_allocation AS
 SELECT pick_allocation.pick_date,
    pick_allocation.route_date,
    pick_allocation.kiosk_id,
    pick_allocation.sku_id,
    pick_allocation.qty
   FROM inm.pick_allocation;


ALTER TABLE campus_87.pick_allocation OWNER TO erpuser;

--
-- Name: pick_demand; Type: TABLE; Schema: inm; Owner: erpuser
--

CREATE TABLE inm.pick_demand (
    pick_date date NOT NULL,
    route_date date NOT NULL,
    kiosk_id integer NOT NULL,
    sku_group_id integer NOT NULL,
    qty integer NOT NULL
);


ALTER TABLE inm.pick_demand OWNER TO erpuser;

--
-- Name: TABLE pick_demand; Type: COMMENT; Schema: inm; Owner: erpuser
--

COMMENT ON TABLE inm.pick_demand IS 'sku_groups requested per kiosk';


--
-- Name: pick_demand; Type: VIEW; Schema: campus_87; Owner: erpuser
--

CREATE VIEW campus_87.pick_demand AS
 SELECT pick_demand.pick_date,
    pick_demand.route_date,
    pick_demand.kiosk_id,
    pick_demand.sku_group_id,
    pick_demand.qty
   FROM inm.pick_demand;


ALTER TABLE campus_87.pick_demand OWNER TO erpuser;

--
-- Name: pick_inventory; Type: TABLE; Schema: inm; Owner: erpuser
--

CREATE TABLE inm.pick_inventory (
    pick_date date NOT NULL,
    route_date date NOT NULL,
    kiosk_id integer NOT NULL,
    sku_group_id integer NOT NULL,
    qty integer NOT NULL
);


ALTER TABLE inm.pick_inventory OWNER TO erpuser;

--
-- Name: TABLE pick_inventory; Type: COMMENT; Schema: inm; Owner: erpuser
--

COMMENT ON TABLE inm.pick_inventory IS 'projected kiosk inventory at pick time';


--
-- Name: pick_inventory; Type: VIEW; Schema: campus_87; Owner: erpuser
--

CREATE VIEW campus_87.pick_inventory AS
 SELECT pick_inventory.pick_date,
    pick_inventory.route_date,
    pick_inventory.kiosk_id,
    pick_inventory.sku_group_id,
    pick_inventory.qty
   FROM inm.pick_inventory;


ALTER TABLE campus_87.pick_inventory OWNER TO erpuser;

--
-- Name: pick_list; Type: TABLE; Schema: inm; Owner: erpuser
--

CREATE TABLE inm.pick_list (
    pick_date date NOT NULL,
    create_ts timestamp with time zone DEFAULT CURRENT_TIMESTAMP NOT NULL,
    timeout_seconds smallint DEFAULT 360,
    finish_ts timestamp with time zone,
    status text DEFAULT 'started'::text,
    log text,
    url text,
    CONSTRAINT pick_list_status_check CHECK ((status = ANY (ARRAY['started'::text, 'ready'::text, 'failed'::text])))
);


ALTER TABLE inm.pick_list OWNER TO erpuser;

--
-- Name: TABLE pick_list; Type: COMMENT; Schema: inm; Owner: erpuser
--

COMMENT ON TABLE inm.pick_list IS 'completed picks';


--
-- Name: pick_list; Type: VIEW; Schema: campus_87; Owner: erpuser
--

CREATE VIEW campus_87.pick_list AS
 SELECT pick_list.pick_date,
    pick_list.create_ts,
    pick_list.timeout_seconds,
    pick_list.finish_ts,
    pick_list.status,
    pick_list.log,
    pick_list.url
   FROM inm.pick_list;


ALTER TABLE campus_87.pick_list OWNER TO erpuser;

--
-- Name: pick_preference_kiosk_sku; Type: TABLE; Schema: inm; Owner: erpuser
--

CREATE TABLE inm.pick_preference_kiosk_sku (
    kiosk_id integer NOT NULL,
    sku_id integer NOT NULL,
    preference smallint NOT NULL
);


ALTER TABLE inm.pick_preference_kiosk_sku OWNER TO erpuser;

--
-- Name: TABLE pick_preference_kiosk_sku; Type: COMMENT; Schema: inm; Owner: erpuser
--

COMMENT ON TABLE inm.pick_preference_kiosk_sku IS 'kiosk preference factor of skus';


--
-- Name: pick_preference_kiosk_sku; Type: VIEW; Schema: campus_87; Owner: erpuser
--

CREATE VIEW campus_87.pick_preference_kiosk_sku AS
 SELECT pick_preference_kiosk_sku.kiosk_id,
    pick_preference_kiosk_sku.sku_id,
    pick_preference_kiosk_sku.preference
   FROM inm.pick_preference_kiosk_sku;


ALTER TABLE campus_87.pick_preference_kiosk_sku OWNER TO erpuser;

--
-- Name: pick_priority_kiosk; Type: TABLE; Schema: inm; Owner: erpuser
--

CREATE TABLE inm.pick_priority_kiosk (
    kiosk_id integer NOT NULL,
    priority integer,
    start_date date,
    end_date date,
    comment text
);


ALTER TABLE inm.pick_priority_kiosk OWNER TO erpuser;

--
-- Name: TABLE pick_priority_kiosk; Type: COMMENT; Schema: inm; Owner: erpuser
--

COMMENT ON TABLE inm.pick_priority_kiosk IS 'higher priority get first pick';


--
-- Name: pick_priority_kiosk; Type: VIEW; Schema: campus_87; Owner: erpuser
--

CREATE VIEW campus_87.pick_priority_kiosk AS
 SELECT pick_priority_kiosk.kiosk_id,
    pick_priority_kiosk.priority,
    pick_priority_kiosk.start_date,
    pick_priority_kiosk.end_date,
    pick_priority_kiosk.comment
   FROM inm.pick_priority_kiosk;


ALTER TABLE campus_87.pick_priority_kiosk OWNER TO erpuser;

--
-- Name: pick_priority_sku; Type: TABLE; Schema: inm; Owner: erpuser
--

CREATE TABLE inm.pick_priority_sku (
    sku_id integer NOT NULL,
    priority integer,
    start_date date,
    end_date date,
    comment text
);


ALTER TABLE inm.pick_priority_sku OWNER TO erpuser;

--
-- Name: TABLE pick_priority_sku; Type: COMMENT; Schema: inm; Owner: erpuser
--

COMMENT ON TABLE inm.pick_priority_sku IS 'lower priority get distributed first';


--
-- Name: pick_priority_sku; Type: VIEW; Schema: campus_87; Owner: erpuser
--

CREATE VIEW campus_87.pick_priority_sku AS
 SELECT pick_priority_sku.sku_id,
    pick_priority_sku.priority,
    pick_priority_sku.start_date,
    pick_priority_sku.end_date,
    pick_priority_sku.comment
   FROM inm.pick_priority_sku;


ALTER TABLE campus_87.pick_priority_sku OWNER TO erpuser;

--
-- Name: pick_rejection; Type: TABLE; Schema: inm; Owner: erpuser
--

CREATE TABLE inm.pick_rejection (
    pick_date date NOT NULL,
    route_date date NOT NULL,
    kiosk_id integer NOT NULL,
    item_id integer NOT NULL,
    item_type character varying(32) NOT NULL,
    reason character varying(64) NOT NULL
);


ALTER TABLE inm.pick_rejection OWNER TO erpuser;

--
-- Name: TABLE pick_rejection; Type: COMMENT; Schema: inm; Owner: erpuser
--

COMMENT ON TABLE inm.pick_rejection IS 'items rejects by kiosk';


--
-- Name: pick_rejection; Type: VIEW; Schema: campus_87; Owner: erpuser
--

CREATE VIEW campus_87.pick_rejection AS
 SELECT pick_rejection.pick_date,
    pick_rejection.route_date,
    pick_rejection.kiosk_id,
    pick_rejection.item_id,
    pick_rejection.item_type,
    pick_rejection.reason
   FROM inm.pick_rejection;


ALTER TABLE campus_87.pick_rejection OWNER TO erpuser;

--
-- Name: pick_route; Type: TABLE; Schema: inm; Owner: erpuser
--

CREATE TABLE inm.pick_route (
    pick_date date NOT NULL,
    kiosk_id integer NOT NULL,
    route_number character varying(256),
    driver_name character varying(64) NOT NULL,
    route_time time(6) without time zone NOT NULL,
    route_date date NOT NULL,
    delivery_order smallint NOT NULL
);


ALTER TABLE inm.pick_route OWNER TO erpuser;

--
-- Name: TABLE pick_route; Type: COMMENT; Schema: inm; Owner: erpuser
--

COMMENT ON TABLE inm.pick_route IS 'route details including driver name';


--
-- Name: pick_route; Type: VIEW; Schema: campus_87; Owner: erpuser
--

CREATE VIEW campus_87.pick_route AS
 SELECT pick_route.pick_date,
    pick_route.kiosk_id,
    pick_route.route_number,
    pick_route.driver_name,
    pick_route.route_time,
    pick_route.route_date,
    pick_route.delivery_order
   FROM inm.pick_route;


ALTER TABLE campus_87.pick_route OWNER TO erpuser;

--
-- Name: product; Type: TABLE; Schema: pantry; Owner: erpuser
--

CREATE TABLE pantry.product (
    id bigint NOT NULL,
    title character varying(127) NOT NULL,
    description character varying(4095),
    tiny_description character varying(40),
    short_description character varying(100),
    medium_description character varying(400),
    long_description character varying(1200),
    price numeric(5,2) NOT NULL,
    cost numeric(5,2) NOT NULL,
    shelf_time integer NOT NULL,
    campus_id bigint NOT NULL,
    image smallint NOT NULL,
    image_time bigint,
    last_update bigint NOT NULL,
    archived bigint,
    taxable smallint,
    allergens character varying(255),
    attribute_names character varying(511),
    categories character varying(255),
    category_names character varying(511),
    vendor character varying(135),
    source character varying(135),
    notes character varying(2000),
    total_cal bigint,
    num_servings real,
    ingredients character varying(2000),
    calories real,
    proteins real,
    sugar real,
    carbohydrates real,
    fat real,
    consumer_category character varying(2000),
    ws_case_size bigint,
    kiosk_ship_qty bigint,
    ws_case_cost numeric(5,2),
    pick_station bigint,
    fc_title character varying(255),
    pricing_tier character varying(255),
    width_space real,
    height_space real,
    depth_space real,
    slotted_width real,
    tag_volume bigint,
    delivery_option character varying(255),
    tag_applied_by character varying(255),
    internal_id text
);


ALTER TABLE pantry.product OWNER TO erpuser;

--
-- Name: product; Type: VIEW; Schema: campus_87; Owner: erpuser
--

CREATE VIEW campus_87.product AS
 SELECT product.id,
    product.title,
    product.description,
    product.tiny_description,
    product.short_description,
    product.medium_description,
    product.long_description,
    product.price,
    product.cost,
    product.shelf_time,
    product.campus_id,
    product.image,
    product.image_time,
    product.last_update,
    product.archived,
    product.taxable,
    product.allergens,
    product.attribute_names,
    product.categories,
    product.category_names,
    product.vendor,
    product.source,
    product.notes,
    product.total_cal,
    product.num_servings,
    product.ingredients,
    product.calories,
    product.proteins,
    product.sugar,
    product.carbohydrates,
    product.fat,
    product.consumer_category,
    product.ws_case_size,
    product.kiosk_ship_qty,
    product.ws_case_cost,
    product.pick_station,
    product.fc_title,
    product.pricing_tier,
    product.width_space,
    product.height_space,
    product.depth_space,
    product.slotted_width,
    product.tag_volume,
    product.delivery_option,
    product.tag_applied_by
   FROM pantry.product
  WHERE (product.campus_id = 87);


ALTER TABLE campus_87.product OWNER TO erpuser;

--
-- Name: product_property; Type: TABLE; Schema: inm; Owner: erpuser
--

CREATE TABLE inm.product_property (
    product_id bigint NOT NULL,
    property_id integer NOT NULL
);


ALTER TABLE inm.product_property OWNER TO erpuser;

--
-- Name: TABLE product_property; Type: COMMENT; Schema: inm; Owner: erpuser
--

COMMENT ON TABLE inm.product_property IS 'one product - many properties';


--
-- Name: product_property; Type: VIEW; Schema: campus_87; Owner: erpuser
--

CREATE VIEW campus_87.product_property AS
 SELECT product_property.product_id,
    product_property.property_id
   FROM inm.product_property;


ALTER TABLE campus_87.product_property OWNER TO erpuser;

--
-- Name: product_property_def; Type: TABLE; Schema: inm; Owner: erpuser
--

CREATE TABLE inm.product_property_def (
    id integer NOT NULL,
    name text NOT NULL,
    value text
);


ALTER TABLE inm.product_property_def OWNER TO erpuser;

--
-- Name: TABLE product_property_def; Type: COMMENT; Schema: inm; Owner: erpuser
--

COMMENT ON TABLE inm.product_property_def IS 'Defines properties identified by id. `name` = property type, `value` = display text';


--
-- Name: product_property_def; Type: VIEW; Schema: campus_87; Owner: erpuser
--

CREATE VIEW campus_87.product_property_def AS
 SELECT product_property_def.id,
    product_property_def.name,
    product_property_def.value
   FROM inm.product_property_def;


ALTER TABLE campus_87.product_property_def OWNER TO erpuser;

--
-- Name: route_stop; Type: TABLE; Schema: inm; Owner: erpuser
--

CREATE TABLE inm.route_stop (
    route_date_time timestamp(6) with time zone NOT NULL,
    driver_name character varying(200) NOT NULL,
    location_name character varying(200) NOT NULL,
    schedule_at timestamp(6) with time zone NOT NULL,
    longitude numeric(28,6),
    address character varying(200),
    latitude numeric(28,6),
    stop_number integer,
    order_number character varying(200),
    location_number integer
);


ALTER TABLE inm.route_stop OWNER TO erpuser;

--
-- Name: TABLE route_stop; Type: COMMENT; Schema: inm; Owner: erpuser
--

COMMENT ON TABLE inm.route_stop IS 'delivery schedule for kiosks';


--
-- Name: route_stop; Type: VIEW; Schema: campus_87; Owner: erpuser
--

CREATE VIEW campus_87.route_stop AS
 SELECT route_stop.route_date_time,
    route_stop.driver_name,
    route_stop.location_name,
    route_stop.schedule_at,
    route_stop.longitude,
    route_stop.address,
    route_stop.latitude,
    route_stop.stop_number,
    route_stop.order_number,
    route_stop.location_number
   FROM inm.route_stop;


ALTER TABLE campus_87.route_stop OWNER TO erpuser;

--
-- Name: sku_group_attribute; Type: TABLE; Schema: inm; Owner: erpuser
--

CREATE TABLE inm.sku_group_attribute (
    id integer NOT NULL,
    title character varying(512) NOT NULL,
    relative_size numeric(4,2) NOT NULL,
    minimum_kiosk_qty smallint NOT NULL,
    maximum_kiosk_qty smallint
);


ALTER TABLE inm.sku_group_attribute OWNER TO erpuser;

--
-- Name: TABLE sku_group_attribute; Type: COMMENT; Schema: inm; Owner: erpuser
--

COMMENT ON TABLE inm.sku_group_attribute IS 'Defines sku_groups';


--
-- Name: sku_group_attribute; Type: VIEW; Schema: campus_87; Owner: erpuser
--

CREATE VIEW campus_87.sku_group_attribute AS
 SELECT sku_group_attribute.id,
    sku_group_attribute.title,
    sku_group_attribute.relative_size,
    sku_group_attribute.minimum_kiosk_qty,
    sku_group_attribute.maximum_kiosk_qty
   FROM inm.sku_group_attribute;


ALTER TABLE campus_87.sku_group_attribute OWNER TO erpuser;

--
-- Name: sku_group_control; Type: TABLE; Schema: inm; Owner: erpuser
--

CREATE TABLE inm.sku_group_control (
    sku_group_id integer NOT NULL,
    default_level numeric(4,2) DEFAULT '-1'::integer NOT NULL,
    scale numeric(4,2) DEFAULT 1.0 NOT NULL,
    min_qty smallint,
    max_qty smallint
);


ALTER TABLE inm.sku_group_control OWNER TO erpuser;

--
-- Name: TABLE sku_group_control; Type: COMMENT; Schema: inm; Owner: erpuser
--

COMMENT ON TABLE inm.sku_group_control IS 'allocation control for sku_groups';


--
-- Name: sku_group_control; Type: VIEW; Schema: campus_87; Owner: erpuser
--

CREATE VIEW campus_87.sku_group_control AS
 SELECT sku_group_control.sku_group_id,
    sku_group_control.default_level,
    sku_group_control.scale,
    sku_group_control.min_qty,
    sku_group_control.max_qty
   FROM inm.sku_group_control;


ALTER TABLE campus_87.sku_group_control OWNER TO erpuser;

--
-- Name: warehouse_inventory; Type: TABLE; Schema: inm; Owner: erpuser
--

CREATE TABLE inm.warehouse_inventory (
    inventory_date date NOT NULL,
    product_id integer NOT NULL,
    stickered_units integer DEFAULT 0 NOT NULL,
    unstickered_units integer DEFAULT 0 NOT NULL,
    stickered_cases integer DEFAULT 0 NOT NULL,
    unstickered_cases integer DEFAULT 0 NOT NULL,
    spoiled_units integer DEFAULT 0 NOT NULL,
    units_per_case integer NOT NULL,
    sort_order smallint NOT NULL
);


ALTER TABLE inm.warehouse_inventory OWNER TO erpuser;

--
-- Name: TABLE warehouse_inventory; Type: COMMENT; Schema: inm; Owner: erpuser
--

COMMENT ON TABLE inm.warehouse_inventory IS 'daily warehouse inventory';


--
-- Name: warehouse_inventory; Type: VIEW; Schema: campus_87; Owner: erpuser
--

CREATE VIEW campus_87.warehouse_inventory AS
 SELECT warehouse_inventory.inventory_date,
    warehouse_inventory.product_id,
    warehouse_inventory.stickered_units,
    warehouse_inventory.unstickered_units,
    warehouse_inventory.stickered_cases,
    warehouse_inventory.unstickered_cases,
    warehouse_inventory.spoiled_units,
    warehouse_inventory.units_per_case,
    warehouse_inventory.sort_order
   FROM inm.warehouse_inventory;


ALTER TABLE campus_87.warehouse_inventory OWNER TO erpuser;

--
-- Name: warehouse_order_history; Type: TABLE; Schema: inm; Owner: erpuser
--

CREATE TABLE inm.warehouse_order_history (
    time_added timestamp(6) with time zone NOT NULL,
    sku integer NOT NULL,
    qty integer NOT NULL,
    order_date date NOT NULL,
    delivery_date date NOT NULL,
    amount_arrived integer,
    status character varying(200),
    warehouse_comment text,
    ordering_comment text,
    action character varying(200),
    purchase_order character varying(200),
    best_by_date character varying(200)
);


ALTER TABLE inm.warehouse_order_history OWNER TO erpuser;

--
-- Name: TABLE warehouse_order_history; Type: COMMENT; Schema: inm; Owner: erpuser
--

COMMENT ON TABLE inm.warehouse_order_history IS 'product orders for the warehouse';


--
-- Name: warehouse_order_history; Type: VIEW; Schema: campus_87; Owner: erpuser
--

CREATE VIEW campus_87.warehouse_order_history AS
 SELECT warehouse_order_history.time_added,
    warehouse_order_history.sku,
    warehouse_order_history.qty,
    warehouse_order_history.order_date,
    warehouse_order_history.delivery_date,
    warehouse_order_history.amount_arrived,
    warehouse_order_history.status,
    warehouse_order_history.warehouse_comment,
    warehouse_order_history.ordering_comment,
    warehouse_order_history.action,
    warehouse_order_history.purchase_order,
    warehouse_order_history.best_by_date
   FROM inm.warehouse_order_history;


ALTER TABLE campus_87.warehouse_order_history OWNER TO erpuser;

--
-- Name: current_inventory; Type: VIEW; Schema: dw; Owner: erpuser
--

CREATE VIEW dw.current_inventory AS
 SELECT current_inventory.epc,
    current_inventory.kiosk_id,
    current_inventory.product_id,
    current_inventory.time_added,
    current_inventory.cost,
    current_inventory.price,
    current_inventory.kiosk_campus_id,
    current_inventory.product_campus_id,
    current_inventory.enable_reporting
   FROM ( SELECT unique_epcs.epc,
            all_epc_data.kiosk_id,
            all_epc_data.product_id,
            to_timestamp((all_epc_data.time_added)::double precision) AS time_added,
            all_epc_data.cost,
            all_epc_data.price,
            all_epc_data.kiosk_campus_id,
            all_epc_data.product_campus_id,
            all_epc_data.enable_reporting
           FROM (( SELECT l.epc,
                    max(l.time_added) AS time_added
                   FROM ((pantry.label l
                     JOIN pantry.kiosk k ON ((k.id = l.kiosk_id)))
                     JOIN pantry.product p ON ((p.id = l.product_id)))
                  WHERE (((l.status)::text = 'ok'::text) AND (l.order_id IS NULL))
                  GROUP BY l.epc) unique_epcs
             LEFT JOIN ( SELECT l.epc,
                    l.product_id,
                    l.time_added,
                    p.cost,
                    p.price,
                    l.kiosk_id,
                    k.campus_id AS kiosk_campus_id,
                    p.campus_id AS product_campus_id,
                    k.enable_reporting
                   FROM ((pantry.label l
                     JOIN pantry.kiosk k ON ((k.id = l.kiosk_id)))
                     JOIN pantry.product p ON ((p.id = l.product_id)))
                  WHERE (((l.status)::text = 'ok'::text) AND (l.order_id IS NULL))) all_epc_data ON ((((unique_epcs.epc)::text = (all_epc_data.epc)::text) AND (unique_epcs.time_added = all_epc_data.time_added))))) current_inventory
  WHERE ((NOT ((current_inventory.epc)::text IN ( SELECT l.epc
           FROM (((pantry.label l
             JOIN pantry.kiosk k ON ((k.id = l.kiosk_id)))
             JOIN pantry.product p ON ((p.id = l.product_id)))
             JOIN pantry."order" o ON (((o.order_id)::text = (l.order_id)::text)))
          WHERE ((o.created >= (date_part('EPOCH'::text, ((now())::date - '1 mon'::interval)))::bigint) AND (o.created <= ((date_part('EPOCH'::text, ((now())::date + '1 mon'::interval)))::bigint - 1)) AND ((o.state)::text = ANY ((ARRAY['Placed'::character varying, 'Processed'::character varying, 'Refunded'::character varying, 'Adjusted'::character varying, 'Declined'::character varying, 'Error'::character varying])::text[])) AND ((l.status)::text = 'sold'::text) AND ((l.order_id)::text !~~ 'RE%'::text) AND (l.order_id IS NOT NULL))))) AND (NOT ((current_inventory.epc)::text IN ( SELECT l.epc
           FROM (((pantry.label l
             JOIN pantry.kiosk k ON ((k.id = l.kiosk_id)))
             JOIN pantry.product p ON ((p.id = l.product_id)))
             JOIN pantry."order" o ON (((o.order_id)::text = (l.order_id)::text)))
          WHERE ((o.created >= (date_part('EPOCH'::text, ((now())::date - '1 mon'::interval)))::bigint) AND (o.created <= (date_part('EPOCH'::text, ((now())::date + '1 mon'::interval)))::bigint) AND ((l.status)::text = ANY ((ARRAY['out'::character varying, 'lost'::character varying])::text[])) AND ((l.order_id)::text ~~ 'RE%'::text))))));


ALTER TABLE dw.current_inventory OWNER TO erpuser;

--
-- Name: VIEW current_inventory; Type: COMMENT; Schema: dw; Owner: erpuser
--

COMMENT ON VIEW dw.current_inventory IS 'returns current inventory';


--
-- Name: byte_current_inventory; Type: VIEW; Schema: dw; Owner: erpuser
--

CREATE VIEW dw.byte_current_inventory AS
 WITH campus AS (
         SELECT 87 AS byte_campus
        )
 SELECT current_inventory.epc,
    current_inventory.kiosk_id,
    current_inventory.product_id,
    current_inventory.time_added,
    current_inventory.cost,
    current_inventory.price
   FROM dw.current_inventory
  WHERE ((current_inventory.kiosk_campus_id = ( SELECT campus.byte_campus
           FROM campus)) AND (current_inventory.enable_reporting = 1));


ALTER TABLE dw.byte_current_inventory OWNER TO erpuser;

--
-- Name: VIEW byte_current_inventory; Type: COMMENT; Schema: dw; Owner: erpuser
--

COMMENT ON VIEW dw.byte_current_inventory IS 'returns campus 87 current inventory';


--
-- Name: dim_campus; Type: TABLE; Schema: dw; Owner: muriel
--

CREATE TABLE dw.dim_campus (
    id bigint NOT NULL,
    title character varying(135) NOT NULL,
    timezone character varying(150),
    archived integer
);


ALTER TABLE dw.dim_campus OWNER TO muriel;

--
-- Name: TABLE dim_campus; Type: COMMENT; Schema: dw; Owner: muriel
--

COMMENT ON TABLE dw.dim_campus IS 'campus info';


--
-- Name: dim_kiosk; Type: TABLE; Schema: dw; Owner: muriel
--

CREATE TABLE dw.dim_kiosk (
    id bigint NOT NULL,
    campus_id integer NOT NULL,
    client_name character varying(765),
    title text,
    geo text,
    location_type integer,
    enable_reporting smallint,
    archived smallint
);


ALTER TABLE dw.dim_kiosk OWNER TO muriel;

--
-- Name: TABLE dim_kiosk; Type: COMMENT; Schema: dw; Owner: muriel
--

COMMENT ON TABLE dw.dim_kiosk IS 'kiosk info';


--
-- Name: dim_product; Type: TABLE; Schema: dw; Owner: muriel
--

CREATE TABLE dw.dim_product (
    id bigint NOT NULL,
    title text,
    campus_id integer NOT NULL,
    fc_title text,
    archived smallint NOT NULL,
    consumer_category text
);


ALTER TABLE dw.dim_product OWNER TO muriel;

--
-- Name: TABLE dim_product; Type: COMMENT; Schema: dw; Owner: muriel
--

COMMENT ON TABLE dw.dim_product IS 'product info';


--
-- Name: tag; Type: TABLE; Schema: pantry; Owner: erpuser
--

CREATE TABLE pantry.tag (
    id bigint NOT NULL,
    tag character varying(100)
);


ALTER TABLE pantry.tag OWNER TO erpuser;

--
-- Name: export_inventory_lots; Type: VIEW; Schema: dw; Owner: erpuser
--

CREATE VIEW dw.export_inventory_lots AS
 SELECT k.campus_id,
    ci.kiosk_id,
    k.title,
    k.geo,
    p.id AS product_id,
    p.title AS product_title,
    ( SELECT string_agg((t.tag)::text, ','::text) AS string_agg
           FROM pantry.tag t
          WHERE ((t.id)::text = ANY (string_to_array((p.categories)::text, ','::text)))) AS categories,
    ci.time_added,
    ((now())::date - (ci.time_added)::date) AS days_in_kiosk,
    p.shelf_time,
    count(*) AS count_,
    p.price,
    p.cost,
    p.source AS source_,
    p.consumer_category,
    date_trunc('second'::text, now()) AS now_
   FROM ((dw.current_inventory ci
     JOIN pantry.product p ON ((p.id = ci.product_id)))
     JOIN pantry.kiosk k ON (((k.id = ci.kiosk_id) AND (k.archived = 0) AND (p.price > 0.01))))
  GROUP BY k.campus_id, ci.kiosk_id, k.title, k.geo, p.id, p.title, p.categories, ci.time_added, p.shelf_time, p.price, p.cost, p.source, p.consumer_category;


ALTER TABLE dw.export_inventory_lots OWNER TO erpuser;

--
-- Name: VIEW export_inventory_lots; Type: COMMENT; Schema: dw; Owner: erpuser
--

COMMENT ON VIEW dw.export_inventory_lots IS 'returns detailed current inventory';


--
-- Name: fact_daily_byte_foods_summary; Type: TABLE; Schema: dw; Owner: erpuser
--

CREATE TABLE dw.fact_daily_byte_foods_summary (
    date_id integer NOT NULL,
    active_byte_customers integer,
    active_skus integer,
    active_brands integer,
    active_cards integer,
    active_usernames integer,
    active_emails integer,
    orders integer,
    orders_w_email integer,
    inventory_units integer,
    inventory_amt_list numeric(12,2),
    inventory_kiosks integer,
    avg_inventory_dollar numeric(12,2),
    avg_inventory_units integer,
    fridge_uptime numeric(3,2),
    major_fridge_outages integer
);


ALTER TABLE dw.fact_daily_byte_foods_summary OWNER TO erpuser;

--
-- Name: TABLE fact_daily_byte_foods_summary; Type: COMMENT; Schema: dw; Owner: erpuser
--

COMMENT ON TABLE dw.fact_daily_byte_foods_summary IS 'campus 87 key metrics per day';


--
-- Name: fact_monthly_byte_foods_summary; Type: TABLE; Schema: dw; Owner: erpuser
--

CREATE TABLE dw.fact_monthly_byte_foods_summary (
    year_month integer NOT NULL,
    active_byte_customers integer,
    active_skus integer,
    active_brands integer,
    active_cards integer,
    active_usernames integer,
    active_emails integer,
    orders integer,
    orders_w_email integer
);


ALTER TABLE dw.fact_monthly_byte_foods_summary OWNER TO erpuser;

--
-- Name: fact_monthly_kiosk_summary; Type: TABLE; Schema: dw; Owner: erpuser
--

CREATE TABLE dw.fact_monthly_kiosk_summary (
    campus_id integer NOT NULL,
    kiosk_id bigint NOT NULL,
    date_id integer NOT NULL,
    sales_list_price numeric(12,2),
    sales_after_discount numeric(12,2),
    food_cost numeric(12,2),
    credit_card numeric(12,2),
    freedom_pay numeric(12,2),
    complimentary numeric(12,2),
    monthly_lease numeric(12,2),
    payment_processing_fee numeric(12,2),
    connectivity_fee numeric(12,2),
    sales_tax numeric(12,2),
    tag_fee numeric(12,2),
    losses_amt numeric(12,2),
    manual_adjustment numeric(12,2),
    fee_plan_name text,
    prepaid_number_of_months bigint,
    prepaid_until character varying(20),
    licensing_subscription_fee numeric(12,2),
    tag_price numeric(12,2),
    payment_processing_rate character varying(20),
    details text
);


ALTER TABLE dw.fact_monthly_kiosk_summary OWNER TO erpuser;

--
-- Name: TABLE fact_monthly_kiosk_summary; Type: COMMENT; Schema: dw; Owner: erpuser
--

COMMENT ON TABLE dw.fact_monthly_kiosk_summary IS 'key metrics per kiosk and month';


--
-- Name: last_15_months; Type: VIEW; Schema: dw; Owner: muriel
--

CREATE VIEW dw.last_15_months AS
 SELECT DISTINCT dim_date.year_month
   FROM dw.dim_date
  WHERE (dim_date.as_date < CURRENT_DATE)
  ORDER BY dim_date.year_month DESC
 LIMIT 15;


ALTER TABLE dw.last_15_months OWNER TO muriel;

--
-- Name: VIEW last_15_months; Type: COMMENT; Schema: dw; Owner: muriel
--

COMMENT ON VIEW dw.last_15_months IS 'returns the last 15 months';


--
-- Name: last_15_weeks; Type: VIEW; Schema: dw; Owner: muriel
--

CREATE VIEW dw.last_15_weeks AS
 SELECT DISTINCT dim_date.year_week
   FROM dw.dim_date
  WHERE (dim_date.as_date < CURRENT_DATE)
  ORDER BY dim_date.year_week DESC
 LIMIT 15;


ALTER TABLE dw.last_15_weeks OWNER TO muriel;

--
-- Name: VIEW last_15_weeks; Type: COMMENT; Schema: dw; Owner: muriel
--

COMMENT ON VIEW dw.last_15_weeks IS 'returns the last 15 weeks';


--
-- Name: last_30_days; Type: VIEW; Schema: dw; Owner: muriel
--

CREATE VIEW dw.last_30_days AS
 SELECT dim_date.date_id
   FROM dw.dim_date
  WHERE (dim_date.as_date < CURRENT_DATE)
  ORDER BY dim_date.date_id DESC
 LIMIT 30;


ALTER TABLE dw.last_30_days OWNER TO muriel;

--
-- Name: VIEW last_30_days; Type: COMMENT; Schema: dw; Owner: muriel
--

COMMENT ON VIEW dw.last_30_days IS 'returns the last 30 days';


--
-- Name: last_30_days_kpis; Type: VIEW; Schema: dw; Owner: muriel
--

CREATE VIEW dw.last_30_days_kpis AS
 SELECT f.kiosk_id,
    f.product_id,
    sum(f.sales_amt) AS sales,
    sum(f.gross_margin_amt) AS gross_margin,
    sum(f.spoils_amt) AS spoils,
    sum(f.losses_amt) AS losses,
    ((COALESCE(sum(f.gross_margin_amt), (0)::numeric) - COALESCE(sum(f.spoils_amt), (0)::numeric)) - COALESCE(sum(f.losses_amt), (0)::numeric)) AS net_margin,
    sum(f.cost_amt) AS cost
   FROM ((dw.fact_daily_kiosk_sku_summary f
     JOIN dw.dim_date dd ON ((f.date_id = dd.date_id)))
     JOIN dw.last_30_days ltd ON ((dd.date_id = ltd.date_id)))
  WHERE (f.campus_id = 87)
  GROUP BY f.kiosk_id, f.product_id;


ALTER TABLE dw.last_30_days_kpis OWNER TO muriel;

--
-- Name: monthly_kpis; Type: VIEW; Schema: dw; Owner: muriel
--

CREATE VIEW dw.monthly_kpis AS
 SELECT dd.year_month,
    f.kiosk_id,
    f.product_id,
    sum(f.sales_amt) AS sales,
    sum(f.gross_margin_amt) AS gross_margin,
    sum(f.spoils_amt) AS spoils,
    sum(f.losses_amt) AS losses,
    ((COALESCE(sum(f.gross_margin_amt), (0)::numeric) - COALESCE(sum(f.spoils_amt), (0)::numeric)) - COALESCE(sum(f.losses_amt), (0)::numeric)) AS net_margin
   FROM ((dw.fact_daily_kiosk_sku_summary f
     JOIN dw.dim_date dd ON ((f.date_id = dd.date_id)))
     JOIN dw.last_15_months lfm ON ((dd.year_month = lfm.year_month)))
  WHERE (f.campus_id = 87)
  GROUP BY dd.year_month, f.kiosk_id, f.product_id;


ALTER TABLE dw.monthly_kpis OWNER TO muriel;

--
-- Name: non_byte_current_inventory; Type: VIEW; Schema: dw; Owner: erpuser
--

CREATE VIEW dw.non_byte_current_inventory AS
 WITH campus AS (
         SELECT 87 AS byte_campus
        )
 SELECT current_inventory.epc,
    current_inventory.kiosk_id,
    current_inventory.product_id,
    current_inventory.time_added,
    current_inventory.cost,
    current_inventory.price
   FROM dw.current_inventory
  WHERE (current_inventory.kiosk_campus_id <> ( SELECT campus.byte_campus
           FROM campus));


ALTER TABLE dw.non_byte_current_inventory OWNER TO erpuser;

--
-- Name: address; Type: TABLE; Schema: erp; Owner: erpuser
--

CREATE TABLE erp.address (
    id integer NOT NULL,
    client_id integer,
    address1 type.text200,
    address2 type.text200,
    city type.text40,
    state type.text40,
    zip type.text40,
    location_x numeric(9,6) NOT NULL,
    location_y numeric(9,6) NOT NULL,
    timezone type.text40
);


ALTER TABLE erp.address OWNER TO erpuser;

--
-- Name: TABLE address; Type: COMMENT; Schema: erp; Owner: erpuser
--

COMMENT ON TABLE erp.address IS 'addresses and geographical information including latitude and longitude';


--
-- Name: address_id_seq; Type: SEQUENCE; Schema: erp; Owner: erpuser
--

ALTER TABLE erp.address ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME erp.address_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: awsdms_apply_exceptions; Type: TABLE; Schema: erp; Owner: erpuser
--

CREATE TABLE erp.awsdms_apply_exceptions (
    "TASK_NAME" character varying(128) NOT NULL,
    "TABLE_OWNER" character varying(128) NOT NULL,
    "TABLE_NAME" character varying(128) NOT NULL,
    "ERROR_TIME" timestamp without time zone NOT NULL,
    "STATEMENT" text NOT NULL,
    "ERROR" text NOT NULL
);


ALTER TABLE erp.awsdms_apply_exceptions OWNER TO erpuser;

--
-- Name: classic_product_allergen_tag; Type: TABLE; Schema: erp; Owner: erpuser
--

CREATE TABLE erp.classic_product_allergen_tag (
    product_id integer NOT NULL,
    tag_id integer NOT NULL
);


ALTER TABLE erp.classic_product_allergen_tag OWNER TO erpuser;

--
-- Name: classic_product_category_tag; Type: TABLE; Schema: erp; Owner: erpuser
--

CREATE TABLE erp.classic_product_category_tag (
    product_id integer NOT NULL,
    tag_id integer NOT NULL
);


ALTER TABLE erp.classic_product_category_tag OWNER TO erpuser;

--
-- Name: TABLE classic_product_category_tag; Type: COMMENT; Schema: erp; Owner: erpuser
--

COMMENT ON TABLE erp.classic_product_category_tag IS 'product tag compatible with pantry.kiosk';


--
-- Name: client; Type: TABLE; Schema: erp; Owner: erpuser
--

CREATE TABLE erp.client (
    id integer NOT NULL,
    name type.text_name,
    address_id integer,
    employees_num integer,
    industry integer
);


ALTER TABLE erp.client OWNER TO erpuser;

--
-- Name: TABLE client; Type: COMMENT; Schema: erp; Owner: erpuser
--

COMMENT ON TABLE erp.client IS 'client data';


--
-- Name: client_campus; Type: TABLE; Schema: erp; Owner: erpuser
--

CREATE TABLE erp.client_campus (
    client_id integer NOT NULL,
    campus_id integer NOT NULL
);


ALTER TABLE erp.client_campus OWNER TO erpuser;

--
-- Name: TABLE client_campus; Type: COMMENT; Schema: erp; Owner: erpuser
--

COMMENT ON TABLE erp.client_campus IS 'one client, many campuses';


--
-- Name: client_contact; Type: TABLE; Schema: erp; Owner: erpuser
--

CREATE TABLE erp.client_contact (
    contact_id integer NOT NULL,
    client_id integer NOT NULL
);


ALTER TABLE erp.client_contact OWNER TO erpuser;

--
-- Name: TABLE client_contact; Type: COMMENT; Schema: erp; Owner: erpuser
--

COMMENT ON TABLE erp.client_contact IS 'one client, many contacts';


--
-- Name: client_id_seq; Type: SEQUENCE; Schema: erp; Owner: erpuser
--

ALTER TABLE erp.client ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME erp.client_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: client_industry; Type: TABLE; Schema: erp; Owner: erpuser
--

CREATE TABLE erp.client_industry (
    client_name type.text400 NOT NULL,
    industry type.text40 NOT NULL
);


ALTER TABLE erp.client_industry OWNER TO erpuser;

--
-- Name: TABLE client_industry; Type: COMMENT; Schema: erp; Owner: erpuser
--

COMMENT ON TABLE erp.client_industry IS 'one client, one industry';


--
-- Name: contact; Type: TABLE; Schema: erp; Owner: erpuser
--

CREATE TABLE erp.contact (
    id integer NOT NULL,
    client_id integer NOT NULL,
    title type.text_name,
    first_name type.text_name,
    last_name type.text_name,
    email type.email,
    phone type.phone,
    contact_type integer NOT NULL
);


ALTER TABLE erp.contact OWNER TO erpuser;

--
-- Name: TABLE contact; Type: COMMENT; Schema: erp; Owner: erpuser
--

COMMENT ON TABLE erp.contact IS 'contacts catalog';


--
-- Name: contact_id_seq; Type: SEQUENCE; Schema: erp; Owner: erpuser
--

ALTER TABLE erp.contact ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME erp.contact_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: fcm_repeater; Type: TABLE; Schema: erp; Owner: erpuser
--

CREATE TABLE erp.fcm_repeater (
    id integer NOT NULL,
    kiosk_id bigint NOT NULL,
    email character varying(127),
    fcm_command character varying(100) NOT NULL,
    req_time bigint NOT NULL,
    resolution_time bigint,
    process smallint DEFAULT 0,
    resolution smallint DEFAULT 0
);


ALTER TABLE erp.fcm_repeater OWNER TO erpuser;

--
-- Name: fcm_repeater_id_seq; Type: SEQUENCE; Schema: erp; Owner: erpuser
--

CREATE SEQUENCE erp.fcm_repeater_id_seq
CREATE SEQUENCE erp.fcm_repeater_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE erp.fcm_repeater_id_seq OWNER TO erpuser;

--
-- Name: fcm_repeater_id_seq; Type: SEQUENCE OWNED BY; Schema: erp; Owner: erpuser
--

ALTER SEQUENCE erp.fcm_repeater_id_seq OWNED BY erp.fcm_repeater.id;


--
-- Name: global_attribute_def; Type: TABLE; Schema: erp; Owner: erpuser
--

CREATE TABLE erp.global_attribute_def (
    id integer NOT NULL,
    name type.text_name NOT NULL,
    value type.text200 NOT NULL,
    note type.text200
);


ALTER TABLE erp.global_attribute_def OWNER TO erpuser;

--
-- Name: TABLE global_attribute_def; Type: COMMENT; Schema: erp; Owner: erpuser
--

COMMENT ON TABLE erp.global_attribute_def IS 'Defines attributes identified by id. `name` = attribute type, `value` = display text';


--
-- Name: global_attribute_def_id_seq; Type: SEQUENCE; Schema: erp; Owner: erpuser
--

ALTER TABLE erp.global_attribute_def ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME erp.global_attribute_def_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: hardware_software; Type: TABLE; Schema: erp; Owner: erpuser
--

CREATE TABLE erp.hardware_software (
    kiosk_id bigint NOT NULL,
    gcm_id type.text400,
    app_vname type.text40,
    app_vcode integer,
    features type.text400 NOT NULL,
    components type.text2k,
    server_url type.text400,
    peekaboo_url type.text400,
    email_receipt_subject type.text200
);


ALTER TABLE erp.hardware_software OWNER TO erpuser;

--
-- Name: TABLE hardware_software; Type: COMMENT; Schema: erp; Owner: erpuser
--

COMMENT ON TABLE erp.hardware_software IS 'kiosk hardware and software versions';


--
-- Name: kiosk; Type: TABLE; Schema: erp; Owner: erpuser
--

CREATE TABLE erp.kiosk (
    id bigint NOT NULL,
    campus_id integer NOT NULL,
    serial type.text100 NOT NULL,
    client_id integer NOT NULL,
    title type.text_name,
    name type.text_name NOT NULL,
    geo type.text_name,
    address_id integer,
    publicly_accessible type.zero_or_one,
    location_type integer,
    estd_num_users integer,
    enable_reporting smallint,
    creation_time bigint,
    deployment_time bigint,
    deployment_status_id integer,
    bank type.zero_or_one,
    archived type.zero_or_one
);


ALTER TABLE erp.kiosk OWNER TO erpuser;

--
-- Name: TABLE kiosk; Type: COMMENT; Schema: erp; Owner: erpuser
--

COMMENT ON TABLE erp.kiosk IS 'main table for kiosk data';


--
-- Name: kiosk_access_card; Type: TABLE; Schema: erp; Owner: erpuser
--

CREATE TABLE erp.kiosk_access_card (
    id integer NOT NULL,
    card_id type.text400 NOT NULL,
    client_id integer NOT NULL,
    expiration_date date
);


ALTER TABLE erp.kiosk_access_card OWNER TO erpuser;

--
-- Name: TABLE kiosk_access_card; Type: COMMENT; Schema: erp; Owner: erpuser
--

COMMENT ON TABLE erp.kiosk_access_card IS 'kiosk physical location access card';


--
-- Name: kiosk_access_card_id_seq; Type: SEQUENCE; Schema: erp; Owner: erpuser
--

ALTER TABLE erp.kiosk_access_card ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME erp.kiosk_access_card_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: kiosk_accounting; Type: TABLE; Schema: erp; Owner: erpuser
--

CREATE TABLE erp.kiosk_accounting (
    kiosk_id bigint NOT NULL,
    start_date date,
    payment_start date,
    payment_stop date,
    sales_tax type.zero_or_one NOT NULL,
    default_fee_plan integer NOT NULL,
    byte_discount type.text40,
    subsidy_info type.text40,
    max_subscription type.text40,
    subscription_amount type.money_max_1m NOT NULL,
    setup_fee type.money_max_1m,
    subsidy_notes type.text400
);


ALTER TABLE erp.kiosk_accounting OWNER TO erpuser;

--
-- Name: TABLE kiosk_accounting; Type: COMMENT; Schema: erp; Owner: erpuser
--

COMMENT ON TABLE erp.kiosk_accounting IS 'one kiosk_accounting, one kiosk';


--
-- Name: kiosk_attribute; Type: TABLE; Schema: erp; Owner: erpuser
--

CREATE TABLE erp.kiosk_attribute (
    kiosk_id bigint NOT NULL,
    attribute_id integer NOT NULL
);


ALTER TABLE erp.kiosk_attribute OWNER TO erpuser;

--
-- Name: TABLE kiosk_attribute; Type: COMMENT; Schema: erp; Owner: erpuser
--

COMMENT ON TABLE erp.kiosk_attribute IS 'one kiosk, many attributes';


--
-- Name: kiosk_contact; Type: TABLE; Schema: erp; Owner: erpuser
--

CREATE TABLE erp.kiosk_contact (
    contact_id integer NOT NULL,
    kiosk_id integer NOT NULL
);


ALTER TABLE erp.kiosk_contact OWNER TO erpuser;

--
-- Name: TABLE kiosk_contact; Type: COMMENT; Schema: erp; Owner: erpuser
--

COMMENT ON TABLE erp.kiosk_contact IS 'one kiosk, many contacts';


--
-- Name: kiosk_delivery_window; Type: TABLE; Schema: erp; Owner: erpuser
--

CREATE TABLE erp.kiosk_delivery_window (
    kiosk_id bigint NOT NULL,
    dow type.dow NOT NULL,
    start_time time with time zone NOT NULL,
    end_time time with time zone NOT NULL,
    access_card_required type.zero_or_one
);


ALTER TABLE erp.kiosk_delivery_window OWNER TO erpuser;

--
-- Name: TABLE kiosk_delivery_window; Type: COMMENT; Schema: erp; Owner: erpuser
--

COMMENT ON TABLE erp.kiosk_delivery_window IS 'one kiosk, many delivery time blocks';


--
-- Name: kiosk_note; Type: TABLE; Schema: erp; Owner: erpuser
--

CREATE TABLE erp.kiosk_note (
    id integer NOT NULL,
    kiosk_id bigint NOT NULL,
    note_type integer NOT NULL,
    content type.text10k NOT NULL,
    start_ts timestamp with time zone,
    end_ts timestamp with time zone
);


ALTER TABLE erp.kiosk_note OWNER TO erpuser;

--
-- Name: TABLE kiosk_note; Type: COMMENT; Schema: erp; Owner: erpuser
--

COMMENT ON TABLE erp.kiosk_note IS 'one kiosk, many notes, with possible start/end time';


--
-- Name: kiosk_status; Type: TABLE; Schema: erp; Owner: erpuser
--

CREATE TABLE erp.kiosk_status (
    kiosk_id integer NOT NULL,
    last_update bigint,
    last_status bigint,
    last_inventory bigint NOT NULL
);


ALTER TABLE erp.kiosk_status OWNER TO erpuser;

--
-- Name: TABLE kiosk_status; Type: COMMENT; Schema: erp; Owner: erpuser
--

COMMENT ON TABLE erp.kiosk_status IS 'last update timestamps';


--
-- Name: kiosk_classic_view; Type: VIEW; Schema: erp; Owner: erpuser
--

CREATE VIEW erp.kiosk_classic_view AS
 SELECT k.id,
    k.campus_id,
    k.serial,
    k.title,
    concat_ws(', '::text, addr.address1, addr.address2, addr.city, concat_ws(' '::text, addr.state, addr.zip)) AS address,
    addr.location_x,
    addr.location_y,
    hs.gcm_id,
    hs.app_vname,
    hs.app_vcode,
    k.archived,
    k.creation_time,
    k.deployment_time,
    ks.last_update,
    client.name AS client_name,
    ks.last_status,
    ks.last_inventory,
    k.name AS kiosk_name,
    COALESCE(date_part('epoch'::text, ka.payment_start), (0)::double precision) AS payment_start,
    COALESCE(date_part('epoch'::text, ka.payment_stop), (0)::double precision) AS payment_stop,
    hs.features,
    ka.sales_tax,
    ka.default_fee_plan,
    addr.timezone,
    k.estd_num_users,
    NULL::text AS tags,
    k.publicly_accessible,
    card_key.cardkey_required,
    delivery_note.content AS delivery_insns,
    location_note.content AS fridge_loc_info,
    kiosk_contact.first_name AS contact_first_name,
    kiosk_contact.last_name AS contact_last_name,
    kiosk_contact.email AS contact_email,
    kiosk_contact.phone AS contact_phone,
    accounting_contact.email AS accounting_email,
    ka.byte_discount,
    ka.subsidy_info,
    ka.subsidy_notes,
    ka.max_subscription,
    NULL::text AS delivery_window_mon,
    NULL::text AS delivery_window_tue,
    NULL::text AS delivery_window_wed,
    NULL::text AS delivery_window_thu,
    NULL::text AS delivery_window_fri,
    NULL::text AS delivery_window_sat,
    NULL::text AS delivery_window_sun,
    ''::text AS notes,
    hs.components,
    hs.email_receipt_subject,
    ops_note.content AS ops_team_notes,
    k.geo,
    hs.server_url,
    ka.subscription_amount,
    k.enable_reporting,
    k.enable_reporting AS enable_monitoring,
    client.employees_num,
    kr.restrictions AS kiosk_restrictions
   FROM ((((((((((((erp.kiosk k
     LEFT JOIN erp.address addr ON ((k.address_id = addr.id)))
     LEFT JOIN erp.hardware_software hs ON ((k.id = hs.kiosk_id)))
     LEFT JOIN erp.kiosk_status ks ON ((k.id = ks.kiosk_id)))
     LEFT JOIN erp.client client ON ((k.client_id = client.id)))
     LEFT JOIN erp.kiosk_accounting ka ON ((k.id = ka.kiosk_id)))
     LEFT JOIN ( SELECT k_1.id AS kiosk_id,
            c.id,
            c.client_id,
            c.title,
            c.first_name,
            c.last_name,
            c.email,
            c.phone,
            c.contact_type
           FROM (((erp.kiosk k_1
             LEFT JOIN erp.kiosk_contact kc ON ((kc.kiosk_id = k_1.id)))
             JOIN erp.contact c ON ((c.id = kc.contact_id)))
             JOIN erp.global_attribute_def ga ON (((c.contact_type = ga.id) AND ((ga.value)::text = 'general'::text))))) kiosk_contact ON ((kiosk_contact.kiosk_id = k.id)))
     LEFT JOIN ( SELECT k_1.id AS kiosk_id,
            c.id,
            c.client_id,
            c.title,
            c.first_name,
            c.last_name,
            c.email,
            c.phone,
            c.contact_type
           FROM ((erp.kiosk k_1
             JOIN erp.contact c ON ((c.client_id = k_1.client_id)))
             JOIN erp.global_attribute_def ga ON (((c.contact_type = ga.id) AND ((ga.value)::text = 'accounting'::text))))) accounting_contact ON ((accounting_contact.kiosk_id = k.id)))
     LEFT JOIN ( SELECT kiosk_delivery_window.kiosk_id,
                CASE
                    WHEN (sum((kiosk_delivery_window.access_card_required)::smallint) > 0) THEN 1
                    ELSE 0
                END AS cardkey_required
           FROM erp.kiosk_delivery_window
          GROUP BY kiosk_delivery_window.kiosk_id
          ORDER BY kiosk_delivery_window.kiosk_id) card_key ON ((card_key.kiosk_id = k.id)))
     LEFT JOIN ( SELECT kn.id,
            kn.kiosk_id,
            kn.note_type,
            kn.content,
            kn.start_ts,
            kn.end_ts,
            ga.id,
            ga.name,
            ga.value,
            ga.note
           FROM (erp.kiosk_note kn
             JOIN erp.global_attribute_def ga ON (((kn.note_type = ga.id) AND ((ga.value)::text = 'Delivery Instruction'::text))))) delivery_note(id, kiosk_id, note_type, content, start_ts, end_ts, id_1, name, value, note) ON ((k.id = delivery_note.kiosk_id)))
     LEFT JOIN ( SELECT kn.id,
            kn.kiosk_id,
            kn.note_type,
            kn.content,
            kn.start_ts,
            kn.end_ts,
            ga.id,
            ga.name,
            ga.value,
            ga.note
           FROM (erp.kiosk_note kn
             JOIN erp.global_attribute_def ga ON (((kn.note_type = ga.id) AND ((ga.value)::text = 'Location'::text))))) location_note(id, kiosk_id, note_type, content, start_ts, end_ts, id_1, name, value, note) ON ((k.id = location_note.kiosk_id)))
     LEFT JOIN ( SELECT kn.id,
            kn.kiosk_id,
            kn.note_type,
            kn.content,
            kn.start_ts,
            kn.end_ts,
            ga.id,
            ga.name,
            ga.value,
            ga.note
           FROM (erp.kiosk_note kn
             JOIN erp.global_attribute_def ga ON (((kn.note_type = ga.id) AND ((ga.value)::text = 'OPS'::text))))) ops_note(id, kiosk_id, note_type, content, start_ts, end_ts, id_1, name, value, note) ON ((k.id = ops_note.kiosk_id)))
     LEFT JOIN ( SELECT pp.kiosk_id,
            string_agg(pd.value, ','::text) AS restrictions
           FROM (inm.kiosk_restriction_by_property pp
             JOIN inm.product_property_def pd ON ((pp.property_id = pd.id)))
          GROUP BY pp.kiosk_id) kr ON ((k.id = kr.kiosk_id)));


ALTER TABLE erp.kiosk_classic_view OWNER TO erpuser;

--
-- Name: kiosk_note_id_seq; Type: SEQUENCE; Schema: erp; Owner: erpuser
--

ALTER TABLE erp.kiosk_note ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME erp.kiosk_note_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: kiosk_restriction_by_product; Type: TABLE; Schema: erp; Owner: erpuser
--

CREATE TABLE erp.kiosk_restriction_by_product (
    kiosk_id bigint NOT NULL,
    product_id integer NOT NULL
);


ALTER TABLE erp.kiosk_restriction_by_product OWNER TO erpuser;

--
-- Name: TABLE kiosk_restriction_by_product; Type: COMMENT; Schema: erp; Owner: erpuser
--

COMMENT ON TABLE erp.kiosk_restriction_by_product IS 'one kiosk, many restricted products';


--
-- Name: kiosk_restriction_by_property; Type: TABLE; Schema: erp; Owner: erpuser
--

CREATE TABLE erp.kiosk_restriction_by_property (
    kiosk_id bigint NOT NULL,
    property_id integer NOT NULL
);


ALTER TABLE erp.kiosk_restriction_by_property OWNER TO erpuser;

--
-- Name: TABLE kiosk_restriction_by_property; Type: COMMENT; Schema: erp; Owner: erpuser
--

COMMENT ON TABLE erp.kiosk_restriction_by_property IS 'one kiosk, many restricted properties';


--
-- Name: product; Type: TABLE; Schema: erp; Owner: erpuser
--

CREATE TABLE erp.product (
    id bigint NOT NULL,
    brand type.text400,
    campus_id integer NOT NULL,
    sku_group_id integer,
    fc_title type.text_name,
    archived type.zero_or_one NOT NULL,
    last_update bigint NOT NULL
);


ALTER TABLE erp.product OWNER TO erpuser;

--
-- Name: TABLE product; Type: COMMENT; Schema: erp; Owner: erpuser
--

COMMENT ON TABLE erp.product IS 'main table for product data';


--
-- Name: product_asset; Type: TABLE; Schema: erp; Owner: erpuser
--

CREATE TABLE erp.product_asset (
    product_id bigint NOT NULL,
    title type.text400 NOT NULL,
    description type.text4k,
    tiny_description type.text100,
    short_description type.text200,
    medium_description type.text400,
    long_description type.text1k,
    image type.zero_or_one,
    image_url type.text400,
    image_time bigint
);


ALTER TABLE erp.product_asset OWNER TO erpuser;

--
-- Name: TABLE product_asset; Type: COMMENT; Schema: erp; Owner: erpuser
--

COMMENT ON TABLE erp.product_asset IS 'product display values';


--
-- Name: product_category; Type: TABLE; Schema: erp; Owner: erpuser
--

CREATE TABLE erp.product_category (
    product_id bigint NOT NULL,
    category_id integer NOT NULL
);


ALTER TABLE erp.product_category OWNER TO erpuser;

--
-- Name: TABLE product_category; Type: COMMENT; Schema: erp; Owner: erpuser
--

COMMENT ON TABLE erp.product_category IS 'one product, many categories';


--
-- Name: product_category_def; Type: TABLE; Schema: erp; Owner: erpuser
--

CREATE TABLE erp.product_category_def (
    id integer NOT NULL,
    name type.text_name NOT NULL,
    value type.text100 NOT NULL
);


ALTER TABLE erp.product_category_def OWNER TO erpuser;

--
-- Name: TABLE product_category_def; Type: COMMENT; Schema: erp; Owner: erpuser
--

COMMENT ON TABLE erp.product_category_def IS 'Defines categories identified by id. `name` = category type, `value` = display text';


--
-- Name: product_category_def_id_seq; Type: SEQUENCE; Schema: erp; Owner: erpuser
--

ALTER TABLE erp.product_category_def ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME erp.product_category_def_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: product_categories; Type: TABLE; Schema: pantry; Owner: erpuser
--

CREATE TABLE pantry.product_categories (
    id bigint NOT NULL,
    cat_name character varying(150) NOT NULL,
    cat_name_tiny character varying(150),
    subcat_name character varying(150) NOT NULL,
    subcat_name_tiny character varying(150),
    tags character varying(765) NOT NULL,
    no_image_placeholder character varying(765),
    icon character varying(765)
);


ALTER TABLE pantry.product_categories OWNER TO erpuser;

--
-- Name: product_category_tag; Type: VIEW; Schema: erp; Owner: erpuser
--

CREATE VIEW erp.product_category_tag AS
 SELECT (unnest(string_to_array((product_categories.tags)::text, ','::text)))::integer AS tag_id,
    product_categories.cat_name,
    product_categories.subcat_name
   FROM pantry.product_categories;


ALTER TABLE erp.product_category_tag OWNER TO erpuser;

--
-- Name: product_handling; Type: TABLE; Schema: erp; Owner: erpuser
--

CREATE TABLE erp.product_handling (
    product_id bigint NOT NULL,
    width_space real,
    height_space real,
    depth_space real,
    slotted_width real,
    kiosk_ship_qty smallint,
    ws_case_size smallint,
    preparation_instruction type.text4k,
    include_microwave_warning type.zero_or_one DEFAULT 0,
    rfid_tag_type integer,
    tag_volume integer,
    tag_delivery_option type.tag_delivery_option,
    tag_applied_by type.tag_applied_by,
    pick_station smallint
);


ALTER TABLE erp.product_handling OWNER TO erpuser;

--
-- Name: TABLE product_handling; Type: COMMENT; Schema: erp; Owner: erpuser
--

COMMENT ON TABLE erp.product_handling IS 'Product physical characteristics. Product rfid tags order handling options';


--
-- Name: product_nutrition; Type: TABLE; Schema: erp; Owner: erpuser
--

CREATE TABLE erp.product_nutrition (
    product_id bigint NOT NULL,
    total_cal smallint,
    num_servings real,
    calories real,
    proteins real,
    sugar real,
    carbohydrates real,
    fat real,
    sodium real,
    ingredients type.text4k,
    shelf_time smallint NOT NULL
);


ALTER TABLE erp.product_nutrition OWNER TO erpuser;

--
-- Name: TABLE product_nutrition; Type: COMMENT; Schema: erp; Owner: erpuser
--

COMMENT ON TABLE erp.product_nutrition IS 'one product, one product_nutrition record';


--
-- Name: product_pricing; Type: TABLE; Schema: erp; Owner: erpuser
--

CREATE TABLE erp.product_pricing (
    product_id bigint NOT NULL,
    price type.money_max_1k NOT NULL,
    cost type.money_max_10k NOT NULL,
    ws_case_cost type.money_max_10k,
    pricing_tier type.text40,
    taxable type.zero_or_one
);


ALTER TABLE erp.product_pricing OWNER TO erpuser;

--
-- Name: TABLE product_pricing; Type: COMMENT; Schema: erp; Owner: erpuser
--

COMMENT ON TABLE erp.product_pricing IS 'unit and case price, cost, tax info';


--
-- Name: product_property; Type: TABLE; Schema: erp; Owner: erpuser
--

CREATE TABLE erp.product_property (
    product_id bigint NOT NULL,
    property_id integer NOT NULL
);


ALTER TABLE erp.product_property OWNER TO erpuser;

--
-- Name: TABLE product_property; Type: COMMENT; Schema: erp; Owner: erpuser
--

COMMENT ON TABLE erp.product_property IS 'one product, many properties';


--
-- Name: product_property_tag; Type: TABLE; Schema: erp; Owner: erpuser
--

CREATE TABLE erp.product_property_tag (
    property_id integer NOT NULL,
    tag_id integer NOT NULL,
    tag type.text_name NOT NULL
);


ALTER TABLE erp.product_property_tag OWNER TO erpuser;

--
-- Name: TABLE product_property_tag; Type: COMMENT; Schema: erp; Owner: erpuser
--

COMMENT ON TABLE erp.product_property_tag IS 'translates between product property and pantry.tag';


--
-- Name: product_sourcing; Type: TABLE; Schema: erp; Owner: erpuser
--

CREATE TABLE erp.product_sourcing (
    product_id bigint NOT NULL,
    vendor type.text400,
    source type.text400
);


ALTER TABLE erp.product_sourcing OWNER TO erpuser;

--
-- Name: TABLE product_sourcing; Type: COMMENT; Schema: erp; Owner: erpuser
--

COMMENT ON TABLE erp.product_sourcing IS 'product vendor and source';


--
-- Name: product_classic_view; Type: VIEW; Schema: erp; Owner: erpuser
--

CREATE VIEW erp.product_classic_view AS
 SELECT p.id,
    pa.title,
    pa.description,
    pa.tiny_description,
    pa.short_description,
    pa.medium_description,
    pa.long_description,
    pp.price,
    pp.cost,
    pn.shelf_time,
    p.campus_id,
    COALESCE((pa.image)::integer, 0) AS image,
    pa.image_time,
    p.last_update,
    p.archived,
    pp.taxable,
    property_tag.allergens,
    property_tag.attribute_names,
    cat.categories,
    cat.category_names,
    ps.vendor,
    ps.source,
    'fixme'::text AS notes,
    pn.total_cal,
    pn.num_servings,
    pn.ingredients,
    pn.calories,
    pn.proteins,
    pn.sugar,
    pn.carbohydrates,
    pn.fat,
    category_tag.consumer_category,
    ph.ws_case_size,
    ph.kiosk_ship_qty,
    pp.ws_case_cost,
    ph.pick_station,
    p.fc_title,
    pp.pricing_tier,
    ph.width_space,
    ph.height_space,
    ph.depth_space,
    ph.slotted_width,
    ph.tag_volume,
    ph.tag_delivery_option AS delivery_option,
    ph.tag_applied_by
   FROM ((((((((erp.product p
     JOIN erp.product_asset pa ON ((p.id = pa.product_id)))
     JOIN erp.product_pricing pp ON ((p.id = pp.product_id)))
     JOIN erp.product_nutrition pn ON ((p.id = pn.product_id)))
     JOIN erp.product_sourcing ps ON ((p.id = ps.product_id)))
     JOIN erp.product_handling ph ON ((p.id = ph.product_id)))
     LEFT JOIN ( SELECT p_1.id AS product_id,
            string_agg((pt.tag_id)::text, ','::text) AS allergens,
            string_agg((pt.tag)::text, ','::text) AS attribute_names
           FROM ((erp.product p_1
             JOIN erp.product_property pp_1 ON ((p_1.id = pp_1.product_id)))
             JOIN erp.product_property_tag pt ON ((pt.property_id = pp_1.property_id)))
          GROUP BY p_1.id) property_tag ON ((p.id = property_tag.product_id)))
     LEFT JOIN ( SELECT pc.product_id,
            pcd.value AS consumer_category
           FROM (erp.product_category pc
             JOIN erp.product_category_def pcd ON (((pc.category_id = pcd.id) AND ((pcd.name)::text = 'consumer'::text))))) category_tag ON ((p.id = category_tag.product_id)))
     LEFT JOIN ( SELECT cpct.product_id,
            string_agg((cpct.tag_id)::text, ','::text) AS categories,
            string_agg((t.tag)::text, ';'::text) AS category_names
           FROM (erp.classic_product_category_tag cpct
             JOIN pantry.tag t ON ((cpct.tag_id = t.id)))
          GROUP BY cpct.product_id) cat ON ((p.id = cat.product_id)));


ALTER TABLE erp.product_classic_view OWNER TO erpuser;

--
-- Name: product_property_def; Type: TABLE; Schema: erp; Owner: erpuser
--

CREATE TABLE erp.product_property_def (
    id integer NOT NULL,
    name type.text_name NOT NULL,
    value type.text100
);


ALTER TABLE erp.product_property_def OWNER TO erpuser;

--
-- Name: TABLE product_property_def; Type: COMMENT; Schema: erp; Owner: erpuser
--

COMMENT ON TABLE erp.product_property_def IS 'Defines properties identified by id. `name` = property type, `value` = display text';


--
-- Name: product_property_def_id_seq; Type: SEQUENCE; Schema: erp; Owner: erpuser
--

ALTER TABLE erp.product_property_def ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME erp.product_property_def_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: sku_group; Type: TABLE; Schema: erp; Owner: erpuser
--

CREATE TABLE erp.sku_group (
    id integer NOT NULL,
    fc_title type.text_name NOT NULL,
    unit_size numeric(4,2) NOT NULL
);


ALTER TABLE erp.sku_group OWNER TO erpuser;

--
-- Name: TABLE sku_group; Type: COMMENT; Schema: erp; Owner: erpuser
--

COMMENT ON TABLE erp.sku_group IS 'Defines facing categories title and physical size';


--
-- Name: tag_order; Type: TABLE; Schema: erp; Owner: erpuser
--

CREATE TABLE erp.tag_order (
    id integer NOT NULL,
    tag_type_id integer NOT NULL,
    product_id integer NOT NULL,
    amount integer NOT NULL,
    custom_product_name type.text1k,
    microwave_warning boolean,
    status type.text200 NOT NULL,
    delivery_option type.text200 NOT NULL,
    tracking type.text200,
    order_ts timestamp with time zone NOT NULL,
    process_ts timestamp with time zone,
    ship_ts timestamp with time zone
);


ALTER TABLE erp.tag_order OWNER TO erpuser;

--
-- Name: TABLE tag_order; Type: COMMENT; Schema: erp; Owner: erpuser
--

COMMENT ON TABLE erp.tag_order IS 'order data for tags';


--
-- Name: tag_order_id_seq; Type: SEQUENCE; Schema: erp; Owner: erpuser
--

ALTER TABLE erp.tag_order ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME erp.tag_order_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: tag_order_stats; Type: TABLE; Schema: erp; Owner: erpuser
--

CREATE TABLE erp.tag_order_stats (
    product_id bigint NOT NULL,
    used_since_last_delivery bigint,
    used_total bigint,
    last_delivery_date timestamp with time zone,
    last_delivery bigint,
    delivered_total bigint
);


ALTER TABLE erp.tag_order_stats OWNER TO erpuser;

--
-- Name: TABLE tag_order_stats; Type: COMMENT; Schema: erp; Owner: erpuser
--

COMMENT ON TABLE erp.tag_order_stats IS 'stats for fulfilled tag orders';


--
-- Name: tag_price; Type: TABLE; Schema: erp; Owner: erpuser
--

CREATE TABLE erp.tag_price (
    campus_id integer NOT NULL,
    tag_type type.text100 NOT NULL,
    price numeric(6,2)
);


ALTER TABLE erp.tag_price OWNER TO erpuser;

--
-- Name: TABLE tag_price; Type: COMMENT; Schema: erp; Owner: erpuser
--

COMMENT ON TABLE erp.tag_price IS 'tag price per campus';


--
-- Name: tag_type; Type: TABLE; Schema: erp; Owner: erpuser
--

CREATE TABLE erp.tag_type (
    id integer NOT NULL,
    type type.text100 NOT NULL,
    description type.text400,
    char_limit smallint NOT NULL,
    dimensions box NOT NULL,
    active boolean DEFAULT true NOT NULL,
    show_micro_warning boolean DEFAULT true NOT NULL,
    print_template type.text400
);


ALTER TABLE erp.tag_type OWNER TO erpuser;

--
-- Name: TABLE tag_type; Type: COMMENT; Schema: erp; Owner: erpuser
--

COMMENT ON TABLE erp.tag_type IS 'types for tags a.k.a. labels';


--
-- Name: tag_type_id_seq; Type: SEQUENCE; Schema: erp; Owner: erpuser
--

ALTER TABLE erp.tag_type ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME erp.tag_type_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: v_campus_list; Type: VIEW; Schema: erp; Owner: lambdazen
--

CREATE VIEW erp.v_campus_list AS
 SELECT campus.id,
    campus.title,
    campus.timezone,
    campus.archived,
    campus.id AS campusid
   FROM pantry.campus;


ALTER TABLE erp.v_campus_list OWNER TO lambdazen;

--
-- Name: v_client; Type: VIEW; Schema: erp; Owner: lambdazen
--

CREATE VIEW erp.v_client AS
 SELECT c.id AS cid,
    c.name,
    c.employees_num AS numemployees,
    c.industry,
    a.address1,
    a.address2,
    a.city,
    a.state,
    a.zip,
    ( SELECT count(*) AS count
           FROM erp.kiosk k
          WHERE (k.client_id = c.id)) AS numkiosks,
    ( SELECT min(ca.id) AS min
           FROM (erp.kiosk k
             JOIN pantry.campus ca ON ((k.campus_id = ca.id)))
          WHERE (k.client_id = c.id)) AS campusid
   FROM (erp.client c
     LEFT JOIN erp.address a ON ((c.address_id = a.id)));


ALTER TABLE erp.v_client OWNER TO lambdazen;

--
-- Name: v_client_list; Type: VIEW; Schema: erp; Owner: lambdazen
--

CREATE VIEW erp.v_client_list AS
 SELECT c.id AS cid,
    c.name,
    concat_ws(', '::text, a.address1, (a.city)::text, concat_ws(' '::text, a.state, (a.zip)::text)) AS address,
    ( SELECT count(*) AS count
           FROM erp.kiosk k
          WHERE (k.client_id = c.id)) AS numkiosks,
    ( SELECT min(ca.id) AS min
           FROM (erp.kiosk k
             JOIN pantry.campus ca ON ((k.campus_id = ca.id)))
          WHERE (k.client_id = c.id)) AS campusid
   FROM (erp.client c
     LEFT JOIN erp.address a ON ((c.address_id = a.id)));


ALTER TABLE erp.v_client_list OWNER TO lambdazen;

--
-- Name: last_kiosk_status; Type: TABLE; Schema: pantry; Owner: erpuser
--

CREATE TABLE pantry.last_kiosk_status (
    id bigint NOT NULL,
    kiosk_id bigint NOT NULL,
    kiosk_temperature numeric(6,3),
    kiosk_temperature_count smallint,
    kit_temperature numeric(6,3),
    temperature_tags character varying(6141),
    kiosk_temperature_source character varying(93),
    power integer,
    battery_level smallint,
    rfid_0 integer,
    rfid_1 integer,
    rfid_2 integer,
    rfid_3 integer,
    rfid_4 integer,
    rfid_5 integer,
    rfid_6 integer,
    rfid_7 integer,
    "time" bigint,
    modem_signal_percentage smallint,
    modem_signal_type character varying(81),
    ip character varying(135),
    app_uptime bigint,
    system_uptime bigint,
    is_locked smallint,
    num_payment_messages_pending_sync integer
);


ALTER TABLE pantry.last_kiosk_status OWNER TO erpuser;

--
-- Name: v_kiosk; Type: VIEW; Schema: erp; Owner: lambdazen
--

CREATE VIEW erp.v_kiosk AS
 SELECT k.id AS kid,
    k.campus_id AS campusid,
    k.serial,
    k.client_id AS clientid,
    k.title,
    k.name,
    k.geo,
    k.address_id AS addressid,
    a.address1,
    a.address2,
    a.city,
    a.state,
    a.zip,
    a.location_x AS locationx,
    a.location_y AS locationy,
    a.timezone,
    k.publicly_accessible AS publiclyaccessible,
    k.location_type AS locationtype,
    k.estd_num_users AS estdnumusers,
    k.enable_reporting AS enablereporting,
    k.creation_time AS creationtime,
    k.deployment_time AS deploymenttime,
    k.deployment_status_id AS status,
    k.bank,
    k.archived,
    hs.server_url AS serverurl,
    hs.peekaboo_url AS peekaboourl,
    hs.app_vname AS appname,
    hs.app_vcode AS appvcode,
    hs.email_receipt_subject AS emailreceiptsubject,
    hs.features,
    ka.start_date AS accstartdate,
    ka.setup_fee AS setupfee,
    ka.byte_discount AS bytediscount,
    ka.subscription_amount AS subscriptionamt,
    ka.subsidy_info AS subsidyinfo,
    ka.subsidy_notes AS subsidyhoursnotes,
    ( SELECT kn1.content
           FROM erp.kiosk_note kn1
          WHERE ((kn1.note_type = 12) AND (kn1.kiosk_id = k.id))) AS deliveryinstructions,
    ( SELECT kn2.content
           FROM erp.kiosk_note kn2
          WHERE ((kn2.note_type = 13) AND (kn2.kiosk_id = k.id))) AS locationdetails,
    ( SELECT kn3.content
           FROM erp.kiosk_note kn3
          WHERE ((kn3.note_type = 93) AND (kn3.kiosk_id = k.id))) AS accessdetails,
    kc.start_level AS inmstartlevel,
    kc.min_level AS inmminlevel,
    kc.scale AS inmmanuallevelmultipler,
    ( SELECT string_agg(aggattr.value, '| '::text) AS string_agg
           FROM ( SELECT (((('{"name" : "'::text || ppd.name) || '", "value" : "'::text) || ppd.value) || '" }'::text) AS value
                   FROM (inm.product_property_def ppd
                     JOIN inm.kiosk_restriction_by_property krbp ON (((ppd.id = krbp.property_id) AND (krbp.kiosk_id = k.id))))) aggattr) AS restrictionsbyproperty,
    ( SELECT string_agg(aggattr.value, '| '::text) AS string_agg
           FROM ( SELECT (((('{"name" : "'::text || (gad.name)::text) || '", "value" : "'::text) || (gad.value)::text) || '" }'::text) AS value
                   FROM (erp.global_attribute_def gad
                     JOIN erp.kiosk_attribute ka_1 ON (((gad.id = ka_1.attribute_id) AND (ka_1.kiosk_id = k.id))))) aggattr) AS attributes,
    ( SELECT string_agg(aggattr.value, '| '::text) AS string_agg
           FROM ( SELECT (((((((('{"dow" : '::text || (kdw.dow)::smallint) || ', "begin" : "'::text) || to_char(((kdw.start_time)::time without time zone)::interval, 'HH24:MI'::text)) || '", "end" : "'::text) || to_char(((kdw.end_time)::time without time zone)::interval, 'HH24:MI'::text)) || '", "access" : '::text) || (kdw.access_card_required)::smallint) || ' }'::text) AS value
                   FROM erp.kiosk_delivery_window kdw
                  WHERE (kdw.kiosk_id = k.id)) aggattr) AS deliverywindow,
    ( SELECT string_agg(aggattr.value, '| '::text) AS string_agg
           FROM ( SELECT (krbp.product_id)::text AS value
                   FROM inm.kiosk_restriction_by_product krbp
                  WHERE (krbp.kiosk_id = k.id)
                  ORDER BY krbp.product_id) aggattr) AS restrictionsbysku,
    ( SELECT string_agg(aggattr.value, '| '::text) AS string_agg
           FROM ( SELECT (((('{"sgid" : '::text || (ksgms.sku_group_id)::smallint) || ', "scale" : '::text) || (ksgms.scale)::real) || ' }'::text) AS value
                   FROM inm.kiosk_sku_group_manual_scale ksgms
                  WHERE (ksgms.kiosk_id = k.id)
                  ORDER BY ksgms.sku_group_id) aggattr) AS manualscale,
    ppk.priority AS inmallocpriority,
    lks."time" AS lasthbts,
    lks.is_locked AS locked,
    lks.kiosk_temperature AS temperature,
    (((((((
        CASE
            WHEN (lks.rfid_0 < 100) THEN 1
            ELSE 0
        END +
        CASE
            WHEN (lks.rfid_1 < 100) THEN 1
            ELSE 0
        END) +
        CASE
            WHEN (lks.rfid_2 < 100) THEN 1
            ELSE 0
        END) +
        CASE
            WHEN (lks.rfid_3 < 100) THEN 1
            ELSE 0
        END) +
        CASE
            WHEN (lks.rfid_4 < 100) THEN 1
            ELSE 0
        END) +
        CASE
            WHEN (lks.rfid_5 < 100) THEN 1
            ELSE 0
        END) +
        CASE
            WHEN (lks.rfid_6 < 100) THEN 1
            ELSE 0
        END) +
        CASE
            WHEN (lks.rfid_7 < 100) THEN 1
            ELSE 0
        END) AS downants,
    (((((((
        CASE
            WHEN (lks.rfid_0 IS NULL) THEN 0
            ELSE 1
        END +
        CASE
            WHEN (lks.rfid_1 IS NULL) THEN 0
            ELSE 1
        END) +
        CASE
            WHEN (lks.rfid_2 IS NULL) THEN 0
            ELSE 1
        END) +
        CASE
            WHEN (lks.rfid_3 IS NULL) THEN 0
            ELSE 1
        END) +
        CASE
            WHEN (lks.rfid_4 IS NULL) THEN 0
            ELSE 1
        END) +
        CASE
            WHEN (lks.rfid_5 IS NULL) THEN 0
            ELSE 1
        END) +
        CASE
            WHEN (lks.rfid_6 IS NULL) THEN 0
            ELSE 1
        END) +
        CASE
            WHEN (lks.rfid_7 IS NULL) THEN 0
            ELSE 1
        END) AS totants,
    lks.battery_level AS battery,
    lks.power,
    lks.ip AS ipaddress,
    lks.kiosk_temperature_source AS tempsource
   FROM ((((((erp.kiosk k
     LEFT JOIN erp.address a ON ((k.address_id = a.id)))
     LEFT JOIN erp.hardware_software hs ON ((k.id = hs.kiosk_id)))
     LEFT JOIN erp.kiosk_accounting ka ON ((k.id = ka.kiosk_id)))
     LEFT JOIN inm.kiosk_control kc ON ((k.id = kc.kiosk_id)))
     LEFT JOIN inm.pick_priority_kiosk ppk ON ((k.id = ppk.kiosk_id)))
     LEFT JOIN pantry.last_kiosk_status lks ON ((lks.kiosk_id = k.id)));


ALTER TABLE erp.v_kiosk OWNER TO lambdazen;

--
-- Name: kiosk_status; Type: TABLE; Schema: pantry; Owner: erpuser
--

CREATE TABLE pantry.kiosk_status (
    id bigint NOT NULL,
    kiosk_id bigint NOT NULL,
    kiosk_temperature numeric(6,3),
    kiosk_temperature_count smallint,
    kit_temperature numeric(6,3),
    temperature_tags character varying(2047),
    kiosk_temperature_source character varying(31),
    power integer,
    battery_level smallint,
    rfid_0 integer,
    rfid_1 integer,
    rfid_2 integer,
    rfid_3 integer,
    rfid_4 integer,
    rfid_5 integer,
    rfid_6 integer,
    rfid_7 integer,
    "time" bigint,
    modem_signal_percentage smallint,
    modem_signal_type character varying(27),
    ip character varying(45),
    app_uptime bigint,
    system_uptime bigint,
    is_locked smallint,
    num_payment_messages_pending_sync integer,
    offline smallint
);


ALTER TABLE pantry.kiosk_status OWNER TO erpuser;

--
-- Name: v_kiosk_heartbeat; Type: VIEW; Schema: erp; Owner: lambdazen
--

CREATE VIEW erp.v_kiosk_heartbeat AS
 SELECT ks.kiosk_id AS kid,
    ks."time" AS ts,
    ks.is_locked AS locked,
    round(ks.kiosk_temperature, 1) AS temperature,
    ks.kiosk_temperature_source AS tempsource,
    ks.rfid_0 AS rfid0,
    ks.rfid_1 AS rfid1,
    ks.rfid_2 AS rfid2,
    ks.rfid_3 AS rfid3,
    ks.rfid_4 AS rfid4,
    ks.rfid_5 AS rfid5,
    ks.rfid_6 AS rfid6,
    ks.rfid_7 AS rfid7,
    ks.battery_level AS battery,
        CASE
            WHEN (ks.power = 0) THEN 'ON'::text
            ELSE 'OFF'::text
        END AS power,
    ks.ip AS ipaddress,
    k.campus_id AS campusid
   FROM (pantry.kiosk_status ks
     JOIN pantry.kiosk k ON ((ks.kiosk_id = k.id)))
  ORDER BY ks."time" DESC;


ALTER TABLE erp.v_kiosk_heartbeat OWNER TO lambdazen;

--
-- Name: v_kiosk_inventory; Type: VIEW; Schema: erp; Owner: lambdazen
--

CREATE VIEW erp.v_kiosk_inventory AS
 SELECT k.campus_id AS campusid,
    l.kiosk_id AS kid,
    k.title AS kname,
    l.product_id AS sku,
    p.title AS pname,
    p.price,
    count(*) FILTER (WHERE ((l.status)::text = 'ok'::text)) AS inventory,
    count(*) FILTER (WHERE ((l.status)::text <> 'ok'::text)) AS sold
   FROM ((pantry.label l
     JOIN pantry.product p ON ((l.product_id = p.id)))
     JOIN pantry.kiosk k ON ((l.kiosk_id = k.id)))
  WHERE (((l.status)::text = 'ok'::text) OR (((l.time_updated)::double precision > (date_part('epoch'::text, now()) - (2592000)::double precision)) AND ((l.status)::text = ANY ((ARRAY['out'::character varying, 'sold'::character varying])::text[])) AND (l.order_id IS NOT NULL) AND ((l.order_id)::text !~~ 'RE%'::text)))
  GROUP BY k.campus_id, l.kiosk_id, k.title, l.product_id, p.title, p.price;


ALTER TABLE erp.v_kiosk_inventory OWNER TO lambdazen;

--
-- Name: v_kiosk_list; Type: VIEW; Schema: erp; Owner: lambdazen
--

CREATE VIEW erp.v_kiosk_list AS
 SELECT k.id AS kid,
    k.title AS name,
        CASE
            WHEN ((k.archived)::smallint = 0) THEN 'Live'::text
            ELSE 'Archived'::text
        END AS status,
    concat_ws(', '::text, a.address1, (a.city)::text, concat_ws(' '::text, a.state, (a.zip)::text)) AS address,
    c.name AS clientname,
    k.campus_id AS campusid,
    round((date_part('epoch'::text, now()) - (COALESCE(lks."time", (0)::bigint))::double precision)) AS lasthb,
    lks.is_locked AS locked,
    lks.kiosk_temperature AS temperature,
    COALESCE(( SELECT 1
           FROM pantry.label l
          WHERE (((l.status)::text = 'ok'::text) AND (l.kiosk_id = k.id))
         LIMIT 1), 0) AS inventory,
    COALESCE(( SELECT 1
           FROM pantry."order" o
          WHERE (((o.state)::text = 'NonTrans'::text) AND (o.kiosk_id = k.id) AND ((o.created)::double precision > (date_part('epoch'::text, now()) - (1296000)::double precision)))
         LIMIT 1), 0) AS restocked,
    (((((((
        CASE
            WHEN (lks.rfid_0 < 100) THEN 1
            ELSE 0
        END +
        CASE
            WHEN (lks.rfid_1 < 100) THEN 1
            ELSE 0
        END) +
        CASE
            WHEN (lks.rfid_2 < 100) THEN 1
            ELSE 0
        END) +
        CASE
            WHEN (lks.rfid_3 < 100) THEN 1
            ELSE 0
        END) +
        CASE
            WHEN (lks.rfid_4 < 100) THEN 1
            ELSE 0
        END) +
        CASE
            WHEN (lks.rfid_5 < 100) THEN 1
            ELSE 0
        END) +
        CASE
            WHEN (lks.rfid_6 < 100) THEN 1
            ELSE 0
        END) +
        CASE
            WHEN (lks.rfid_7 < 100) THEN 1
            ELSE 0
        END) AS downants,
    (((((((
        CASE
            WHEN (lks.rfid_0 IS NULL) THEN 0
            ELSE 1
        END +
        CASE
            WHEN (lks.rfid_1 IS NULL) THEN 0
            ELSE 1
        END) +
        CASE
            WHEN (lks.rfid_2 IS NULL) THEN 0
            ELSE 1
        END) +
        CASE
            WHEN (lks.rfid_3 IS NULL) THEN 0
            ELSE 1
        END) +
        CASE
            WHEN (lks.rfid_4 IS NULL) THEN 0
            ELSE 1
        END) +
        CASE
            WHEN (lks.rfid_5 IS NULL) THEN 0
            ELSE 1
        END) +
        CASE
            WHEN (lks.rfid_6 IS NULL) THEN 0
            ELSE 1
        END) +
        CASE
            WHEN (lks.rfid_7 IS NULL) THEN 0
            ELSE 1
        END) AS totants,
    lks.kiosk_temperature_source AS tempsource,
    k.archived
   FROM (((erp.kiosk k
     LEFT JOIN erp.address a ON ((k.address_id = a.id)))
     LEFT JOIN erp.client c ON ((k.client_id = c.id)))
     LEFT JOIN pantry.last_kiosk_status lks ON ((lks.kiosk_id = k.id)));


ALTER TABLE erp.v_kiosk_list OWNER TO lambdazen;

--
-- Name: v_kiosk_options; Type: VIEW; Schema: erp; Owner: lambdazen
--

CREATE VIEW erp.v_kiosk_options AS
 SELECT gad.id,
    gad.name,
    gad.value,
    ''::text AS optionalvalue
   FROM erp.global_attribute_def gad
UNION
 SELECT ppd.id,
    'all_prod_prop_def'::text AS name,
    ppd.name AS value,
    ppd.value AS optionalvalue
   FROM inm.product_property_def ppd;


ALTER TABLE erp.v_kiosk_options OWNER TO lambdazen;

--
-- Name: v_product; Type: VIEW; Schema: erp; Owner: lambdazen
--

CREATE VIEW erp.v_product AS
 SELECT p.id AS sku,
    pa.title AS name,
    pa.tiny_description AS tinydesc,
    pa.short_description AS shortdesc,
    pa.medium_description AS mediumdesc,
    pa.long_description AS longdesc,
    pa.image_url AS imageurl,
    pc.category_id AS consumercategory,
    ps.source,
    p.archived,
        CASE
            WHEN ((p.archived)::smallint = 0) THEN 'Live'::text
            ELSE 'Archived'::text
        END AS status,
    pn.num_servings AS numservings,
    pn.calories,
    pn.proteins,
    pn.sugar,
    pn.carbohydrates,
    pn.fat,
    pn.ingredients,
    pn.shelf_time AS shelflife,
    pn.sodium,
    ph.kiosk_ship_qty AS kioskshipqty,
    ph.width_space AS widthspace,
    ph.depth_space AS depthspace,
    ph.height_space AS heightspace,
    ph.pick_station AS pickstation,
    ph.ws_case_size AS wscasesize,
    ph.tag_volume AS tagvolume,
    ph.tag_applied_by AS tagappliedby,
    ph.tag_delivery_option AS deliveryoption,
    ph.preparation_instruction AS preparation,
    ph.rfid_tag_type AS labeltype,
    ph.include_microwave_warning AS microwavewarning,
    pp.ws_case_cost AS wscasecost,
    pp.price,
    ( SELECT string_agg(aggattr.value, '| '::text) AS string_agg
           FROM ( SELECT (((('{"name" : "'::text || ppd.name) || '", "value" : "'::text) || ppd.value) || '" }'::text) AS value
                   FROM (inm.product_property_def ppd
                     JOIN inm.product_property ppro ON (((ppd.id = ppro.property_id) AND (ppro.product_id = p.id))))) aggattr) AS attributes,
    p.brand,
    pa.description,
    p.sku_group_id AS skugroupid,
    pps.priority AS inmallocpriority,
    p.campus_id AS campusid
   FROM (((((((erp.product p
     LEFT JOIN erp.product_asset pa ON ((pa.product_id = p.id)))
     LEFT JOIN erp.product_category pc ON ((pc.product_id = p.id)))
     LEFT JOIN erp.product_sourcing ps ON ((ps.product_id = p.id)))
     LEFT JOIN erp.product_nutrition pn ON ((pn.product_id = p.id)))
     LEFT JOIN erp.product_handling ph ON ((ph.product_id = p.id)))
     LEFT JOIN erp.product_pricing pp ON ((pp.product_id = p.id)))
     LEFT JOIN inm.pick_priority_sku pps ON ((pps.sku_id = p.id)));


ALTER TABLE erp.v_product OWNER TO lambdazen;

--
-- Name: v_product_list; Type: VIEW; Schema: erp; Owner: lambdazen
--

CREATE VIEW erp.v_product_list AS
 SELECT p.id AS sku,
    pa.title,
    ( SELECT pcd.value
           FROM erp.product_category_def pcd
          WHERE (pcd.id = pc.category_id)) AS category,
    ps.source,
        CASE
            WHEN ((p.archived)::smallint = 0) THEN 'Live'::text
            ELSE 'Archived'::text
        END AS status,
    p.brand,
    ph.pick_station AS pickstation,
    ph.ws_case_size AS wscasesize,
    p.campus_id AS campusid,
    sg.fc_title AS skugroup,
    p.archived
   FROM (((((erp.product p
     LEFT JOIN erp.product_asset pa ON ((pa.product_id = p.id)))
     LEFT JOIN erp.product_category pc ON ((pc.product_id = p.id)))
     LEFT JOIN erp.product_sourcing ps ON ((ps.product_id = p.id)))
     LEFT JOIN erp.product_handling ph ON ((ph.product_id = p.id)))
     LEFT JOIN erp.sku_group sg ON ((p.sku_group_id = sg.id)))
  ORDER BY p.id;


ALTER TABLE erp.v_product_list OWNER TO lambdazen;

--
-- Name: v_product_options; Type: VIEW; Schema: erp; Owner: lambdazen
--

CREATE VIEW erp.v_product_options AS
 SELECT pcd.id,
    pcd.name,
    pcd.value,
    ''::text AS optionalvalue
   FROM erp.product_category_def pcd
UNION
 SELECT ppd.id,
    'all_prod_prop_def'::text AS name,
    ppd.name AS value,
    ppd.value AS optionalvalue
   FROM inm.product_property_def ppd
UNION
 SELECT gad.id,
    gad.name,
    gad.value,
    ''::text AS optionalvalue
   FROM erp.global_attribute_def gad;


ALTER TABLE erp.v_product_options OWNER TO lambdazen;

--
-- Name: sku_group; Type: VIEW; Schema: inm; Owner: erpuser
--

CREATE VIEW inm.sku_group AS
 SELECT sku_group.id,
    sku_group.fc_title,
    sku_group.unit_size
   FROM erp.sku_group;


ALTER TABLE inm.sku_group OWNER TO erpuser;

--
-- Name: v_sku_group_list; Type: VIEW; Schema: erp; Owner: lambdazen
--

CREATE VIEW erp.v_sku_group_list AS
 SELECT sg.id,
    sg.fc_title AS name,
    sg.unit_size AS unitsize,
    sgc.default_level AS defaultlevel,
    sgc.scale,
    sgc.min_qty AS minqty,
    sgc.max_qty AS maxqty
   FROM (inm.sku_group sg
     LEFT JOIN inm.sku_group_control sgc ON ((sg.id = sgc.sku_group_id)));


ALTER TABLE erp.v_sku_group_list OWNER TO lambdazen;

--
-- Name: label_order; Type: TABLE; Schema: pantry; Owner: erpuser
--

CREATE TABLE pantry.label_order (
    id bigint NOT NULL,
    product_id bigint,
    group_id bigint,
    box_id character varying(16),
    amount bigint NOT NULL,
    time_order bigint NOT NULL,
    time_encoded bigint,
    time_delivery bigint,
    time_updated bigint,
    status character varying(15),
    delivery_option character varying(255),
    priority character varying(255)
);


ALTER TABLE pantry.label_order OWNER TO erpuser;

--
-- Name: v_tag_order_list; Type: VIEW; Schema: erp; Owner: lambdazen
--

CREATE VIEW erp.v_tag_order_list AS
 SELECT lo.time_order AS ts,
    lo.id,
    lo.priority,
    p.id AS sku,
    p.title AS pname,
    lo.amount,
    lo.delivery_option AS delivery,
    p.campus_id AS campusid,
        CASE
            WHEN ((p.archived IS NOT NULL) AND (p.archived = 0)) THEN lo.status
            ELSE 'Cancelled'::character varying
        END AS status,
        CASE
            WHEN ((lo.priority)::text = 'high'::text) THEN 2
            ELSE
            CASE
                WHEN ((lo.priority)::text = 'medium'::text) THEN 1
                ELSE 0
            END
        END AS prioritynum
   FROM (pantry.label_order lo
     LEFT JOIN pantry.product p ON ((lo.product_id = p.id)));


ALTER TABLE erp.v_tag_order_list OWNER TO lambdazen;

--
-- Name: coupon; Type: TABLE; Schema: pantry; Owner: erpuser
--

CREATE TABLE pantry.coupon (
    id bigint NOT NULL,
    code character varying(45) NOT NULL,
    flat_discount numeric(5,2) NOT NULL,
    real_discount numeric(5,2) NOT NULL,
    used bigint NOT NULL,
    kiosk_list character varying(255),
    campaign character varying(255),
    created_by character varying(255)
);


ALTER TABLE pantry.coupon OWNER TO erpuser;

--
-- Name: discount_applied; Type: TABLE; Schema: pantry; Owner: erpuser
--

CREATE TABLE pantry.discount_applied (
    id integer NOT NULL,
    order_id character varying(135),
    sequence integer,
    epc character varying(135),
    product_id integer,
    discount character varying(65535),
    price_before numeric(6,2),
    price_after numeric(6,2),
    sponsor character varying(135),
    ts integer,
    notes text
);


ALTER TABLE pantry.discount_applied OWNER TO erpuser;

--
-- Name: v_transaction_detail; Type: VIEW; Schema: erp; Owner: lambdazen
--

CREATE VIEW erp.v_transaction_detail AS
 SELECT o.order_id AS id,
    o.campus_id AS campusid,
        CASE
            WHEN ("left"((o.order_id)::text, 2) = 'RE'::text) THEN 'Restock'::text
            ELSE 'Sale'::text
        END AS type,
    o.kiosk_id AS kid,
    o.kiosk_title AS kname,
    o.email,
    concat_ws(' '::text, btrim((o.first_name)::text), btrim((o.last_name)::text)) AS name,
    ( SELECT sum(label.price) AS sum
           FROM pantry.label
          WHERE (((label.order_id)::text = (o.order_id)::text) AND ((label.status)::text = ANY (ARRAY[('sold'::character varying)::text, ('out'::character varying)::text])))) AS total,
    ( SELECT string_agg(aggattr.value, '| '::text) AS string_agg
           FROM ( SELECT (((((('{"item" : "'::text || (p.title)::text) || '", "price" : '::text) || (l.price)::real) || ', "qty" : '::text) || (count(*))::smallint) || '}'::text) AS value
                   FROM (pantry.label l
                     JOIN pantry.product p ON ((l.product_id = p.id)))
                  WHERE (((l.order_id)::text = (o.order_id)::text) AND ((l.status)::text = ANY (ARRAY[('sold'::character varying)::text, ('out'::character varying)::text])))
                  GROUP BY p.title, l.price) aggattr) AS items,
    o.amount_paid AS amount,
    concat_ws('/'::text, o.state, o.status) AS status,
    o.created AS ts,
    f.rate AS feedback,
    f.message AS feedbackmsg,
    c.code AS couponcode,
    c.flat_discount AS couponamt,
    o.receipt,
    COALESCE(( SELECT (sum(da.price_before) - sum(da.price_after))
           FROM pantry.discount_applied da
          WHERE ((da.order_id)::text = (o.order_id)::text)), (0)::numeric) AS discountamt,
        CASE
            WHEN ((COALESCE(k.features, ''::character varying))::text ~~ '%no_vending%'::text) THEN 'N'::text
            ELSE 'Y'::text
        END AS paid,
    COALESCE(o.payment_system, 'N/A'::character varying) AS paymentsystem
   FROM (((pantry."order" o
     LEFT JOIN pantry.feedback f ON (((o.order_id)::text = (f.order_id)::text)))
     LEFT JOIN pantry.coupon c ON (((c.code)::text = (o.coupon)::text)))
     LEFT JOIN pantry.kiosk k ON ((o.kiosk_id = k.id)));


ALTER TABLE erp.v_transaction_detail OWNER TO lambdazen;

--
-- Name: v_transaction_list; Type: VIEW; Schema: erp; Owner: lambdazen
--

CREATE VIEW erp.v_transaction_list AS
 SELECT o.order_id AS id,
    o.campus_id AS campusid,
        CASE
            WHEN ("left"((o.order_id)::text, 2) = 'RE'::text) THEN 'Restock'::text
            ELSE 'Sale'::text
        END AS type,
    o.kiosk_id AS kid,
    o.kiosk_title AS kname,
    o.email,
    concat_ws(' '::text, btrim((o.first_name)::text), btrim((o.last_name)::text)) AS name,
    ( SELECT sum(label.price) AS sum
           FROM pantry.label
          WHERE (((label.order_id)::text = (o.order_id)::text) AND ((label.status)::text = ANY (ARRAY[('sold'::character varying)::text, ('out'::character varying)::text])))) AS total,
    o.amount_paid AS amount,
    concat_ws('/'::text, o.state, o.status) AS status,
    o.created AS ts,
    f.rate AS feedback,
    f.message AS feedbackmsg,
    o.receipt,
        CASE
            WHEN ((COALESCE(k.features, ''::character varying))::text ~~ '%no_vending%'::text) THEN 'N'::text
            ELSE 'Y'::text
        END AS paid
   FROM ((pantry."order" o
     LEFT JOIN pantry.feedback f ON (((o.order_id)::text = (f.order_id)::text)))
     LEFT JOIN pantry.kiosk k ON ((o.kiosk_id = k.id)));


ALTER TABLE erp.v_transaction_list OWNER TO lambdazen;

--
-- Name: v_warehouse_inventory; Type: VIEW; Schema: erp; Owner: lambdazen
--

CREATE VIEW erp.v_warehouse_inventory AS
 SELECT wh.inventory_date AS invdate,
    wh.product_id AS sku,
    COALESCE((pa.title)::text, 'N/A'::text) AS name,
    wh.stickered_units AS stickeredunits,
    wh.stickered_cases AS stickeredcases,
    wh.unstickered_cases AS unstickeredcases,
    wh.spoiled_units AS spoiledunits,
    wh.units_per_case AS wscasesize
   FROM (inm.warehouse_inventory wh
     LEFT JOIN erp.product_asset pa ON ((wh.product_id = pa.product_id)))
  WHERE (((wh.stickered_units + wh.unstickered_cases) + wh.stickered_cases) > 0);


ALTER TABLE erp.v_warehouse_inventory OWNER TO lambdazen;

--
-- Name: v_warehouse_inventory_entry; Type: VIEW; Schema: erp; Owner: lambdazen
--

CREATE VIEW erp.v_warehouse_inventory_entry AS
 SELECT p.id AS sku,
    pa.title AS name,
    ph.pick_station AS pickstation,
    ph.ws_case_size AS wscasesize
   FROM ((erp.product p
     JOIN erp.product_asset pa ON ((p.id = pa.product_id)))
     LEFT JOIN erp.product_handling ph ON ((p.id = ph.product_id)))
  WHERE ((p.campus_id = 87) AND ((p.archived)::smallint = 0))
  ORDER BY ph.pick_station, ( SELECT w.sort_order
           FROM inm.warehouse_inventory w
          WHERE ((p.id = w.product_id) AND (w.inventory_date = ( SELECT max(w2.inventory_date) AS max
                   FROM inm.warehouse_inventory w2
                  WHERE (p.id = w2.product_id)))));


ALTER TABLE erp.v_warehouse_inventory_entry OWNER TO lambdazen;

--
-- Name: address; Type: TABLE; Schema: erp_backup; Owner: erpuser
--

CREATE TABLE erp_backup.address (
    id integer NOT NULL,
    client_id integer,
    address1 type.text200,
    address2 type.text200,
    city type.text40,
    state type.text40,
    zip type.text40,
    location_x numeric(9,6) NOT NULL,
    location_y numeric(9,6) NOT NULL,
    timezone type.text40
);


ALTER TABLE erp_backup.address OWNER TO erpuser;

--
-- Name: address_id_seq; Type: SEQUENCE; Schema: erp_backup; Owner: erpuser
--

ALTER TABLE erp_backup.address ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME erp_backup.address_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1
);


--
-- Name: client; Type: TABLE; Schema: erp_backup; Owner: erpuser
--

CREATE TABLE erp_backup.client (
    id integer NOT NULL,
    name type.text_name,
    address_id integer,
    employees_num integer,
    industry integer
);


ALTER TABLE erp_backup.client OWNER TO erpuser;

--
-- Name: client_id_seq; Type: SEQUENCE; Schema: erp_backup; Owner: erpuser
--

ALTER TABLE erp_backup.client ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME erp_backup.client_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1
);


--
-- Name: contact; Type: TABLE; Schema: erp_backup; Owner: erpuser
--

CREATE TABLE erp_backup.contact (
    id integer NOT NULL,
    client_id integer NOT NULL,
    title type.text_name,
    first_name type.text_name,
    last_name type.text_name,
    email type.email,
    phone type.phone,
    contact_type integer NOT NULL
);


ALTER TABLE erp_backup.contact OWNER TO erpuser;

--
-- Name: contact_id_seq; Type: SEQUENCE; Schema: erp_backup; Owner: erpuser
--

ALTER TABLE erp_backup.contact ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME erp_backup.contact_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1
);


--
-- Name: hardware_software; Type: TABLE; Schema: erp_backup; Owner: erpuser
--

CREATE TABLE erp_backup.hardware_software (
    kiosk_id bigint NOT NULL,
    gcm_id type.text400,
    app_vname type.text40,
    app_vcode integer,
    features type.text400 NOT NULL,
    components type.text2k,
    server_url type.text400,
    peekaboo_url type.text400,
    email_receipt_subject type.text200
);


ALTER TABLE erp_backup.hardware_software OWNER TO erpuser;

--
-- Name: kiosk; Type: TABLE; Schema: erp_backup; Owner: erpuser
--

CREATE TABLE erp_backup.kiosk (
    id bigint NOT NULL,
    campus_id integer NOT NULL,
    serial type.text100 NOT NULL,
    client_id integer NOT NULL,
    title type.text_name,
    name type.text_name NOT NULL,
    geo type.text_name,
    address_id integer,
    publicly_accessible type.zero_or_one,
    location_type integer,
    estd_num_users integer,
    enable_reporting smallint,
    creation_time bigint,
    deployment_time bigint,
    deployment_status_id integer,
    bank type.zero_or_one,
    archived type.zero_or_one
);


ALTER TABLE erp_backup.kiosk OWNER TO erpuser;

--
-- Name: kiosk_accounting; Type: TABLE; Schema: erp_backup; Owner: erpuser
--

CREATE TABLE erp_backup.kiosk_accounting (
    kiosk_id bigint NOT NULL,
    start_date date,
    payment_start date,
    payment_stop date,
    sales_tax type.zero_or_one NOT NULL,
    default_fee_plan integer NOT NULL,
    byte_discount type.text40,
    subsidy_info type.text40,
    max_subscription type.text40,
    subscription_amount type.money_max_1m NOT NULL,
    setup_fee type.money_max_1m,
    subsidy_notes type.text400
);


ALTER TABLE erp_backup.kiosk_accounting OWNER TO erpuser;

--
-- Name: kiosk_note; Type: TABLE; Schema: erp_backup; Owner: erpuser
--

CREATE TABLE erp_backup.kiosk_note (
    id integer NOT NULL,
    kiosk_id bigint NOT NULL,
    note_type integer NOT NULL,
    content type.text10k NOT NULL,
    start_ts timestamp with time zone,
    end_ts timestamp with time zone
);


ALTER TABLE erp_backup.kiosk_note OWNER TO erpuser;

--
-- Name: kiosk_note_id_seq; Type: SEQUENCE; Schema: erp_backup; Owner: erpuser
--

ALTER TABLE erp_backup.kiosk_note ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME erp_backup.kiosk_note_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1
);


--
-- Name: product_classic_view; Type: VIEW; Schema: erp_backup; Owner: erpuser
--

CREATE VIEW erp_backup.product_classic_view AS
 SELECT p.id,
    pa.title,
    pa.description,
    pa.tiny_description,
    pa.short_description,
    pa.medium_description,
    pa.long_description,
    pp.price,
    pp.cost,
    pn.shelf_time,
    p.campus_id,
    COALESCE((pa.image)::integer, 0) AS image,
    pa.image_time,
    p.last_update,
    p.archived,
    pp.taxable,
    'fixme'::text AS allergens,
    'fixme'::text AS attribute_names,
    'fixme'::text AS categories,
    'fixme'::text AS category_names,
    ps.vendor,
    ps.source,
    'fixme'::text AS notes,
    pn.total_cal,
    pn.num_servings,
    pn.ingredients,
    pn.calories,
    pn.proteins,
    pn.sugar,
    pn.carbohydrates,
    pn.fat,
    'fixme'::text AS consumer_category,
    ph.ws_case_size,
    ph.kiosk_ship_qty,
    pp.ws_case_cost,
    ph.pick_station,
    p.fc_title,
    pp.pricing_tier,
    ph.width_space,
    ph.height_space,
    ph.depth_space,
    ph.slotted_width,
    ph.tag_volume,
    ph.tag_delivery_option AS delivery_option,
    ph.tag_applied_by
   FROM (((((erp.product p
     JOIN erp.product_asset pa ON ((p.id = pa.product_id)))
     JOIN erp.product_pricing pp ON ((p.id = pp.product_id)))
     JOIN erp.product_nutrition pn ON ((p.id = pn.product_id)))
     JOIN erp.product_sourcing ps ON ((p.id = ps.product_id)))
     JOIN erp.product_handling ph ON ((p.id = ph.product_id)));


ALTER TABLE erp_backup.product_classic_view OWNER TO erpuser;

--
-- Name: product_property; Type: TABLE; Schema: erp_backup; Owner: erpuser
--

CREATE TABLE erp_backup.product_property (
    product_id bigint NOT NULL,
    property_id integer NOT NULL
);


ALTER TABLE erp_backup.product_property OWNER TO erpuser;

--
-- Name: product_property_def; Type: TABLE; Schema: erp_backup; Owner: erpuser
--

CREATE TABLE erp_backup.product_property_def (
    id integer NOT NULL,
    name type.text_name NOT NULL,
    value type.text100
);


ALTER TABLE erp_backup.product_property_def OWNER TO erpuser;

--
-- Name: product_property_def_id_seq; Type: SEQUENCE; Schema: erp_backup; Owner: erpuser
--

ALTER TABLE erp_backup.product_property_def ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME erp_backup.product_property_def_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1
);


--
-- Name: address; Type: TABLE; Schema: erp_test; Owner: erpuser
--

CREATE TABLE erp_test.address (
    id integer NOT NULL,
    client_id integer,
    address1 type.text200,
    address2 type.text200,
    city type.text40,
    state type.text40,
    zip type.text40,
    location_x numeric(9,6) NOT NULL,
    location_y numeric(9,6) NOT NULL,
    timezone type.text40
);


ALTER TABLE erp_test.address OWNER TO erpuser;

--
-- Name: address_id_seq; Type: SEQUENCE; Schema: erp_test; Owner: erpuser
--

ALTER TABLE erp_test.address ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME erp_test.address_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: client; Type: TABLE; Schema: erp_test; Owner: erpuser
--

CREATE TABLE erp_test.client (
    id integer NOT NULL,
    name type.text_name,
    address_id integer,
    employees_num integer,
    industry integer
);


ALTER TABLE erp_test.client OWNER TO erpuser;

--
-- Name: client_campus; Type: TABLE; Schema: erp_test; Owner: erpuser
--

CREATE TABLE erp_test.client_campus (
    client_id integer NOT NULL,
    campus_id integer NOT NULL
);


ALTER TABLE erp_test.client_campus OWNER TO erpuser;

--
-- Name: client_contact; Type: TABLE; Schema: erp_test; Owner: erpuser
--

CREATE TABLE erp_test.client_contact (
    contact_id integer NOT NULL,
    client_id integer NOT NULL
);


ALTER TABLE erp_test.client_contact OWNER TO erpuser;

--
-- Name: client_id_seq; Type: SEQUENCE; Schema: erp_test; Owner: erpuser
--

ALTER TABLE erp_test.client ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME erp_test.client_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: client_industry; Type: TABLE; Schema: erp_test; Owner: erpuser
--

CREATE TABLE erp_test.client_industry (
    client_name type.text400,
    industry type.text40
);


ALTER TABLE erp_test.client_industry OWNER TO erpuser;

--
-- Name: contact; Type: TABLE; Schema: erp_test; Owner: erpuser
--

CREATE TABLE erp_test.contact (
    id integer NOT NULL,
    client_id integer NOT NULL,
    title type.text_name,
    first_name type.text_name,
    last_name type.text_name,
    email type.email,
    phone type.phone,
    contact_type integer NOT NULL
);


ALTER TABLE erp_test.contact OWNER TO erpuser;

--
-- Name: contact_id_seq; Type: SEQUENCE; Schema: erp_test; Owner: erpuser
--

ALTER TABLE erp_test.contact ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME erp_test.contact_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: global_attribute_def; Type: TABLE; Schema: erp_test; Owner: erpuser
--

CREATE TABLE erp_test.global_attribute_def (
    id integer NOT NULL,
    name type.text_name NOT NULL,
    value type.text200 NOT NULL,
    note type.text200
);


ALTER TABLE erp_test.global_attribute_def OWNER TO erpuser;

--
-- Name: global_attribute_def_id_seq; Type: SEQUENCE; Schema: erp_test; Owner: erpuser
--

ALTER TABLE erp_test.global_attribute_def ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME erp_test.global_attribute_def_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1
);


--
-- Name: hardware_software; Type: TABLE; Schema: erp_test; Owner: erpuser
--

CREATE TABLE erp_test.hardware_software (
    kiosk_id bigint NOT NULL,
    gcm_id type.text400,
    app_vname type.text40,
    app_vcode integer,
    features type.text400 NOT NULL,
    components type.text2k,
    server_url type.text400,
    peekaboo_url type.text400,
    email_receipt_subject type.text200
);


ALTER TABLE erp_test.hardware_software OWNER TO erpuser;

--
-- Name: kiosk; Type: TABLE; Schema: erp_test; Owner: erpuser
--

CREATE TABLE erp_test.kiosk (
    id bigint NOT NULL,
    campus_id integer NOT NULL,
    serial type.text100 NOT NULL,
    client_id integer NOT NULL,
    title type.text_name,
    name type.text_name NOT NULL,
    geo type.text_name,
    address_id integer,
    publicly_accessible type.zero_or_one,
    location_type integer,
    estd_num_users integer,
    enable_reporting smallint,
    creation_time bigint,
    deployment_time bigint,
    deployment_status_id integer,
    bank type.zero_or_one,
    archived type.zero_or_one
);


ALTER TABLE erp_test.kiosk OWNER TO erpuser;

--
-- Name: kiosk_accounting; Type: TABLE; Schema: erp_test; Owner: erpuser
--

CREATE TABLE erp_test.kiosk_accounting (
    kiosk_id bigint NOT NULL,
    start_date date,
    payment_start date,
    payment_stop date,
    sales_tax type.zero_or_one NOT NULL,
    default_fee_plan integer NOT NULL,
    byte_discount type.text40,
    subsidy_info type.text40,
    max_subscription type.text40,
    subscription_amount type.money_max_1m NOT NULL,
    setup_fee type.money_max_1m,
    subsidy_notes type.text400
);


ALTER TABLE erp_test.kiosk_accounting OWNER TO erpuser;

--
-- Name: kiosk_audit; Type: TABLE; Schema: erp_test; Owner: erpuser
--

CREATE TABLE erp_test.kiosk_audit (
    a text,
    b text,
    kid integer NOT NULL,
    status text,
    e text,
    enable_reporting character(1),
    enable_monitoring character(1)
);


ALTER TABLE erp_test.kiosk_audit OWNER TO erpuser;

--
-- Name: kiosk_classic_view; Type: VIEW; Schema: erp_test; Owner: erpuser
--

CREATE VIEW erp_test.kiosk_classic_view AS
 SELECT k.id,
    k.campus_id,
    k.serial,
    k.title,
    'fixme'::text AS address,
    addr.location_x,
    addr.location_y,
    hs.gcm_id,
    hs.app_vname,
    hs.app_vcode,
    k.archived,
    k.creation_time,
    k.deployment_time,
    ks.last_update,
    client.name AS client_name,
    ks.last_status,
    ks.last_inventory,
    k.name,
    ka.payment_start,
    ka.payment_stop,
    hs.features,
    ka.sales_tax,
    ka.default_fee_plan,
    addr.timezone,
    k.estd_num_users,
    NULL::text AS tags,
    k.publicly_accessible,
    '-1'::integer AS card_key_required,
    delivery_note.content AS delivery_insns,
    location_note.content AS fridge_loc_info,
    ka.byte_discount,
    ka.subsidy_info,
    ka.subsidy_notes,
    ka.max_subscription,
    hs.components,
    hs.email_receipt_subject,
    ops_note.content AS opt_team_notes,
    k.geo,
    'fixme'::text AS server_url,
    ka.subscription_amount,
    k.enable_reporting,
    k.enable_reporting AS enable_mornitoring,
    client.employees_num,
    kr.restrictions AS kiosk_restrictions
   FROM (((((((((erp.kiosk k
     JOIN erp.address addr ON ((k.id = addr.id)))
     JOIN erp.hardware_software hs ON ((k.id = hs.kiosk_id)))
     LEFT JOIN erp.kiosk_status ks ON ((k.id = ks.kiosk_id)))
     JOIN erp.client client ON ((k.client_id = client.id)))
     JOIN erp.kiosk_accounting ka ON ((k.id = ka.kiosk_id)))
     LEFT JOIN ( SELECT kn.id,
            kn.kiosk_id,
            kn.note_type,
            kn.content,
            kn.start_ts,
            kn.end_ts,
            ga.id,
            ga.name,
            ga.value,
            ga.note
           FROM (erp.kiosk_note kn
             JOIN erp.global_attribute_def ga ON (((kn.note_type = ga.id) AND ((ga.value)::text = 'Delivery Instruction'::text))))) delivery_note(id, kiosk_id, note_type, content, start_ts, end_ts, id_1, name, value, note) ON ((k.id = delivery_note.kiosk_id)))
     LEFT JOIN ( SELECT kn.id,
            kn.kiosk_id,
            kn.note_type,
            kn.content,
            kn.start_ts,
            kn.end_ts,
            ga.id,
            ga.name,
            ga.value,
            ga.note
           FROM (erp.kiosk_note kn
             JOIN erp.global_attribute_def ga ON (((kn.note_type = ga.id) AND ((ga.value)::text = 'Location'::text))))) location_note(id, kiosk_id, note_type, content, start_ts, end_ts, id_1, name, value, note) ON ((k.id = location_note.kiosk_id)))
     LEFT JOIN ( SELECT kn.id,
            kn.kiosk_id,
            kn.note_type,
            kn.content,
            kn.start_ts,
            kn.end_ts,
            ga.id,
            ga.name,
            ga.value,
            ga.note
           FROM (erp.kiosk_note kn
             JOIN erp.global_attribute_def ga ON (((kn.note_type = ga.id) AND ((ga.value)::text = 'OPS'::text))))) ops_note(id, kiosk_id, note_type, content, start_ts, end_ts, id_1, name, value, note) ON ((k.id = ops_note.kiosk_id)))
     LEFT JOIN ( SELECT pp.kiosk_id,
            string_agg(pd.value, ','::text) AS restrictions
           FROM (inm.kiosk_restriction_by_property pp
             JOIN inm.product_property_def pd ON ((pp.property_id = pd.id)))
          GROUP BY pp.kiosk_id) kr ON ((k.id = kr.kiosk_id)));


ALTER TABLE erp_test.kiosk_classic_view OWNER TO erpuser;

--
-- Name: kiosk_contact; Type: TABLE; Schema: erp_test; Owner: erpuser
--

CREATE TABLE erp_test.kiosk_contact (
    contact_id integer NOT NULL,
    kiosk_id integer NOT NULL
);


ALTER TABLE erp_test.kiosk_contact OWNER TO erpuser;

--
-- Name: kiosk_note; Type: TABLE; Schema: erp_test; Owner: erpuser
--

CREATE TABLE erp_test.kiosk_note (
    id integer NOT NULL,
    kiosk_id bigint NOT NULL,
    note_type integer NOT NULL,
    content type.text10k NOT NULL,
    start_ts timestamp with time zone,
    end_ts timestamp with time zone
);


ALTER TABLE erp_test.kiosk_note OWNER TO erpuser;

--
-- Name: kiosk_note_id_seq; Type: SEQUENCE; Schema: erp_test; Owner: erpuser
--

ALTER TABLE erp_test.kiosk_note ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME erp_test.kiosk_note_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1
);


--
-- Name: kiosk_status; Type: TABLE; Schema: erp_test; Owner: erpuser
--

CREATE TABLE erp_test.kiosk_status (
    kiosk_id integer NOT NULL,
    last_update bigint,
    last_status bigint,
    last_inventory bigint NOT NULL
);


ALTER TABLE erp_test.kiosk_status OWNER TO erpuser;

--
-- Name: product; Type: TABLE; Schema: erp_test; Owner: erpuser
--

CREATE TABLE erp_test.product (
    id bigint NOT NULL,
    brand type.text400,
    campus_id integer NOT NULL,
    sku_group_id integer,
    fc_title type.text_name,
    archived type.zero_or_one NOT NULL,
    last_update bigint NOT NULL
);


ALTER TABLE erp_test.product OWNER TO erpuser;

--
-- Name: product_asset; Type: TABLE; Schema: erp_test; Owner: erpuser
--

CREATE TABLE erp_test.product_asset (
    product_id bigint NOT NULL,
    title type.text400 NOT NULL,
    description type.text4k,
    tiny_description type.text100,
    short_description type.text200,
    medium_description type.text400,
    long_description type.text1k,
    image type.zero_or_one,
    image_url type.text400,
    image_time bigint
);


ALTER TABLE erp_test.product_asset OWNER TO erpuser;

--
-- Name: product_handling; Type: TABLE; Schema: erp_test; Owner: erpuser
--

CREATE TABLE erp_test.product_handling (
    product_id bigint NOT NULL,
    width_space real,
    height_space real,
    depth_space real,
    slotted_width real,
    kiosk_ship_qty smallint,
    ws_case_size smallint,
    preparation_instruction type.text4k,
    include_microwave_warning type.zero_or_one DEFAULT 0,
    rfid_tag_type integer,
    tag_volume integer,
    tag_delivery_option type.tag_delivery_option,
    tag_applied_by type.tag_applied_by,
    pick_station smallint
);


ALTER TABLE erp_test.product_handling OWNER TO erpuser;

--
-- Name: product_nutrition; Type: TABLE; Schema: erp_test; Owner: erpuser
--

CREATE TABLE erp_test.product_nutrition (
    product_id bigint NOT NULL,
    total_cal smallint,
    num_servings real,
    calories real,
    proteins real,
    sugar real,
    carbohydrates real,
    fat real,
    sodium real,
    ingredients type.text4k,
    shelf_time smallint NOT NULL
);


ALTER TABLE erp_test.product_nutrition OWNER TO erpuser;

--
-- Name: product_pricing; Type: TABLE; Schema: erp_test; Owner: erpuser
--

CREATE TABLE erp_test.product_pricing (
    product_id bigint NOT NULL,
    price type.money_max_1k NOT NULL,
    cost type.money_max_10k NOT NULL,
    ws_case_cost type.money_max_10k,
    pricing_tier type.text40,
    taxable type.zero_or_one
);


ALTER TABLE erp_test.product_pricing OWNER TO erpuser;

--
-- Name: product_property; Type: TABLE; Schema: erp_test; Owner: erpuser
--

CREATE TABLE erp_test.product_property (
    product_id bigint NOT NULL,
    property_id integer NOT NULL
);


ALTER TABLE erp_test.product_property OWNER TO erpuser;

--
-- Name: product_sourcing; Type: TABLE; Schema: erp_test; Owner: erpuser
--

CREATE TABLE erp_test.product_sourcing (
    product_id bigint NOT NULL,
    vendor type.text400,
    source type.text400
);


ALTER TABLE erp_test.product_sourcing OWNER TO erpuser;

--
-- Name: sku_group; Type: TABLE; Schema: erp_test; Owner: erpuser
--

CREATE TABLE erp_test.sku_group (
    id integer,
    fc_title type.text_name,
    unit_size numeric(4,2)
);


ALTER TABLE erp_test.sku_group OWNER TO erpuser;

--
-- Name: awsdms_apply_exceptions; Type: TABLE; Schema: fnrenames; Owner: erpuser
--

CREATE TABLE fnrenames.awsdms_apply_exceptions (
    "TASK_NAME" character varying(128) NOT NULL,
    "TABLE_OWNER" character varying(128) NOT NULL,
    "TABLE_NAME" character varying(128) NOT NULL,
    "ERROR_TIME" timestamp without time zone NOT NULL,
    "STATEMENT" text NOT NULL,
    "ERROR" text NOT NULL
);


ALTER TABLE fnrenames.awsdms_apply_exceptions OWNER TO erpuser;

--
-- Name: awsdms_validation_failures_v1; Type: TABLE; Schema: fnrenames; Owner: erpuser
--

CREATE TABLE fnrenames.awsdms_validation_failures_v1 (
    "TASK_NAME" character varying(128) NOT NULL,
    "TABLE_OWNER" character varying(128) NOT NULL,
    "TABLE_NAME" character varying(128) NOT NULL,
    "FAILURE_TIME" timestamp without time zone NOT NULL,
    "KEY_TYPE" character varying(128) NOT NULL,
    "KEY" character varying(8000) NOT NULL,
    "FAILURE_TYPE" character varying(128) NOT NULL,
    "DETAILS" character varying(8000) NOT NULL
);


ALTER TABLE fnrenames.awsdms_validation_failures_v1 OWNER TO erpuser;

--
-- Name: kiosk_product_disabled; Type: VIEW; Schema: inm; Owner: erpuser
--

CREATE VIEW inm.kiosk_product_disabled AS
 SELECT rp.kiosk_id,
    pp.product_id
   FROM (inm.product_property pp
     JOIN inm.kiosk_restriction_by_property rp ON ((pp.property_id = rp.property_id)))
UNION
 SELECT kiosk_restriction_by_product.kiosk_id,
    kiosk_restriction_by_product.product_id
   FROM inm.kiosk_restriction_by_product
UNION
 SELECT kiosk_restriction_by_product_ed.kiosk_id,
    kiosk_restriction_by_product_ed.product_id
   FROM inm.kiosk_restriction_by_product_ed;


ALTER TABLE inm.kiosk_product_disabled OWNER TO erpuser;

--
-- Name: byte_products_fast; Type: VIEW; Schema: public; Owner: erpuser
--

CREATE VIEW public.byte_products_fast AS
 SELECT product.id,
    product.title,
    product.description,
    product.tiny_description,
    product.short_description,
    product.medium_description,
    product.long_description,
    product.price,
    product.cost,
    product.shelf_time,
    product.campus_id,
    product.image,
    product.image_time,
    product.last_update,
    product.archived,
    product.taxable,
    product.allergens,
    product.attribute_names,
    product.categories,
    product.category_names,
    product.vendor,
    product.source,
    product.notes,
    product.total_cal,
    product.num_servings,
    product.ingredients,
    product.calories,
    product.proteins,
    product.sugar,
    product.carbohydrates,
    product.fat,
    product.consumer_category,
    product.ws_case_size,
    product.kiosk_ship_qty,
    product.ws_case_cost,
    product.pick_station,
    product.fc_title,
    product.pricing_tier,
    product.width_space,
    product.height_space,
    product.depth_space,
    product.slotted_width,
    product.tag_volume,
    product.delivery_option,
    product.shelf_time AS shelf_life_days
   FROM pantry.product
  WHERE (product.campus_id = 87);


ALTER TABLE public.byte_products_fast OWNER TO erpuser;

--
-- Name: byte_products; Type: VIEW; Schema: public; Owner: erpuser
--

CREATE VIEW public.byte_products AS
 SELECT byte_products_fast.id,
    byte_products_fast.title,
    byte_products_fast.vendor,
    byte_products_fast.price,
    byte_products_fast.cost,
    byte_products_fast.shelf_time AS shelf_life_days,
    byte_products_fast.archived,
    byte_products_fast.attribute_names AS attributes,
    byte_products_fast.category_names AS categories,
    byte_products_fast.consumer_category,
    byte_products_fast.source,
    byte_products_fast.ws_case_size,
    byte_products_fast.kiosk_ship_qty,
    byte_products_fast.ws_case_cost,
    byte_products_fast.pick_station,
    byte_products_fast.allergens AS pantry_allergens,
    byte_products_fast.categories AS pantry_categories,
    byte_products_fast.fc_title
   FROM public.byte_products_fast;


ALTER TABLE public.byte_products OWNER TO erpuser;

--
-- Name: byte_label_product; Type: VIEW; Schema: public; Owner: erpuser
--

CREATE VIEW public.byte_label_product AS
 SELECT l.epc,
    l.order_id AS label_order_id,
    l.status AS label_status,
    l.price AS label_price,
    l.time_created,
    l.time_added,
    l.time_updated,
    to_timestamp((l.time_created)::double precision) AS ts_created,
    to_timestamp((l.time_added)::double precision) AS ts_added,
    to_timestamp((l.time_updated)::double precision) AS ts_updated,
    l.kiosk_id AS label_kiosk_id,
    p.id AS product_id,
    p.title AS product_title,
    p.archived AS product_archived,
    p.vendor AS product_vendor,
    p.price AS product_price,
    p.cost AS product_cost,
    p.shelf_life_days AS product_shelf_life_days,
    p.attributes AS product_attributes,
    p.categories AS product_categories,
    p.consumer_category,
    p.source AS product_source,
    p.fc_title
   FROM (pantry.label l
     JOIN public.byte_products p ON ((l.product_id = p.id)));


ALTER TABLE public.byte_label_product OWNER TO erpuser;

--
-- Name: byte_tickets_12weeks; Type: VIEW; Schema: public; Owner: erpuser
--

CREATE VIEW public.byte_tickets_12weeks AS
 SELECT byte_tickets.order_id,
    byte_tickets.first_name,
    byte_tickets.last_name,
    byte_tickets.kiosk_id,
    byte_tickets.kiosk_title,
    byte_tickets.email,
    byte_tickets.amount_paid,
    byte_tickets.payment_system,
    byte_tickets.transaction_id,
    byte_tickets.approval_code,
    byte_tickets.status_code,
    byte_tickets.status_message,
    byte_tickets.status,
    byte_tickets.batch_id,
    byte_tickets.created,
    byte_tickets.auth_amount,
    byte_tickets.data_token,
    byte_tickets.time_opened,
    byte_tickets.time_closed,
    byte_tickets.card_hash,
    byte_tickets.state,
    byte_tickets.archived,
    byte_tickets.stamp,
    byte_tickets.last_update,
    byte_tickets.balance,
    byte_tickets.delta,
    byte_tickets.coupon_id,
    byte_tickets.coupon,
    byte_tickets.refund,
    byte_tickets.receipt,
    byte_tickets.campus_id,
    byte_tickets.amount_list_price,
    byte_tickets.notes,
    byte_tickets.time_door_opened,
    byte_tickets.time_door_closed,
    byte_tickets.client_name,
    byte_tickets.estd_num_users,
    byte_tickets.ts,
    byte_tickets.full_name,
    byte_tickets.door_opened_secs,
    byte_tickets.month,
    byte_tickets.week,
    byte_tickets.date,
    byte_tickets.dayofweek,
    byte_tickets.hour,
    byte_tickets.dowhour,
    byte_tickets.uniq_user
   FROM public.byte_tickets
  WHERE (byte_tickets.ts > (now() - '84 days'::interval day));


ALTER TABLE public.byte_tickets_12weeks OWNER TO erpuser;

--
-- Name: byte_epcssold_12weeks; Type: VIEW; Schema: public; Owner: erpuser
--

CREATE VIEW public.byte_epcssold_12weeks AS
 SELECT o.order_id,
    o.first_name,
    o.last_name,
    o.kiosk_id,
    o.kiosk_title,
    o.email,
    o.amount_paid,
    o.payment_system,
    o.transaction_id,
    o.approval_code,
    o.status_code,
    o.status_message,
    o.status,
    o.batch_id,
    o.created,
    o.auth_amount,
    o.data_token,
    o.time_opened,
    o.time_closed,
    o.card_hash,
    o.state,
    o.archived,
    o.stamp,
    o.last_update,
    o.balance,
    o.delta,
    o.coupon_id,
    o.coupon,
    o.refund,
    o.receipt,
    o.campus_id,
    o.amount_list_price,
    o.notes,
    o.time_door_opened,
    o.time_door_closed,
    o.client_name,
    o.estd_num_users,
    o.ts,
    o.full_name,
    o.door_opened_secs,
    o.month,
    o.week,
    o.date,
    o.dayofweek,
    o.hour,
    o.dowhour,
    o.uniq_user,
    lp.epc,
    lp.label_order_id,
    lp.label_status,
    lp.label_price,
    lp.time_created,
    lp.time_added,
    lp.time_updated,
    lp.ts_created,
    lp.ts_added,
    lp.ts_updated,
    lp.label_kiosk_id,
    lp.product_id,
    lp.product_title,
    lp.product_archived,
    lp.product_vendor,
    lp.product_price,
    lp.product_cost,
    lp.product_shelf_life_days,
    lp.product_attributes,
    lp.product_categories,
    lp.consumer_category,
    lp.product_source,
    lp.fc_title
   FROM (public.byte_tickets_12weeks o
     JOIN public.byte_label_product lp ON (((lp.label_order_id)::text = (o.order_id)::text)))
  WHERE ((lp.label_status)::text = 'sold'::text);


ALTER TABLE public.byte_epcssold_12weeks OWNER TO erpuser;

--
-- Name: v_kiosk_sale_hourly; Type: VIEW; Schema: inm; Owner: erpuser
--

CREATE VIEW inm.v_kiosk_sale_hourly AS
 SELECT units_sold.kiosk_id,
    units_sold.dow,
    units_sold.hod,
    units_sold.units_sold,
    round((units_sold.units_sold / GREATEST(1.00, sum(units_sold.units_sold) OVER (PARTITION BY units_sold.kiosk_id))), 4) AS units_sold_normalized
   FROM ( SELECT k.kiosk_id,
            dow.dow,
            hod.hod,
            round(COALESCE(((s.units_sold)::numeric / 12.0), 0.00), 2) AS units_sold
           FROM (((( SELECT k_1.id AS kiosk_id
                   FROM pantry.kiosk k_1
                  WHERE ((k_1.campus_id = 87) AND (k_1.archived = 0) AND (k_1.enable_reporting = 1))) k
             CROSS JOIN ( SELECT generate_series.generate_series AS dow
                   FROM generate_series(0, 6) generate_series(generate_series)) dow)
             CROSS JOIN ( SELECT generate_series.generate_series AS hod
                   FROM generate_series(0, 23) generate_series(generate_series)) hod)
             LEFT JOIN ( SELECT byte_epcssold_12weeks.kiosk_id,
                    date_part('dow'::text, timezone('US/Pacific'::text, byte_epcssold_12weeks.ts)) AS dow,
                    date_part('hour'::text, timezone('US/Pacific'::text, byte_epcssold_12weeks.ts)) AS hod,
                    count(*) AS units_sold
                   FROM public.byte_epcssold_12weeks
                  GROUP BY byte_epcssold_12weeks.kiosk_id, (date_part('dow'::text, timezone('US/Pacific'::text, byte_epcssold_12weeks.ts))), (date_part('hour'::text, timezone('US/Pacific'::text, byte_epcssold_12weeks.ts)))
                  ORDER BY byte_epcssold_12weeks.kiosk_id, (date_part('dow'::text, timezone('US/Pacific'::text, byte_epcssold_12weeks.ts))), (date_part('hour'::text, timezone('US/Pacific'::text, byte_epcssold_12weeks.ts)))) s ON (((k.kiosk_id = s.kiosk_id) AND ((dow.dow)::double precision = s.dow) AND ((hod.hod)::double precision = s.hod))))
          ORDER BY k.kiosk_id, dow.dow, hod.hod) units_sold;


ALTER TABLE inm.v_kiosk_sale_hourly OWNER TO erpuser;

--
-- Name: route_stop; Type: TABLE; Schema: mixalot; Owner: erpuser
--

CREATE TABLE mixalot.route_stop (
    route_date_time timestamp(6) with time zone NOT NULL,
    driver_name character varying(200) NOT NULL,
    location_name character varying(200) NOT NULL,
    schedule_at timestamp(6) with time zone NOT NULL,
    longitude numeric(28,6),
    address character varying(200),
    latitude numeric(28,6),
    stop_number integer,
    order_number character varying(200),
    location_number integer
);


ALTER TABLE mixalot.route_stop OWNER TO erpuser;

--
-- Name: v_kiosk_demand_plan_ratio; Type: VIEW; Schema: inm; Owner: erpuser
--

CREATE VIEW inm.v_kiosk_demand_plan_ratio AS
 SELECT ksh.kiosk_id,
        CASE
            WHEN (rdt.d0_delivery = 1) THEN (ksh.d0_demand +
            CASE
                WHEN (rdt.d1_delivery = 0) THEN (ksh.d1_demand +
                CASE
                    WHEN (rdt.d2_delivery = 0) THEN (ksh.d2_demand +
                    CASE
                        WHEN (rdt.d3_delivery = 0) THEN (ksh.d3_demand +
                        CASE
                            WHEN (rdt.d4_delivery = 0) THEN ksh.d4_demand
                            ELSE (0)::numeric
                        END)
                        ELSE (0)::numeric
                    END)
                    ELSE (0)::numeric
                END)
                ELSE (0)::numeric
            END)
            ELSE (0)::numeric
        END AS d0_plan_demand_ratio,
        CASE
            WHEN (rdt.d1_delivery = 1) THEN (ksh.d1_demand +
            CASE
                WHEN (rdt.d2_delivery = 0) THEN (ksh.d2_demand +
                CASE
                    WHEN (rdt.d3_delivery = 0) THEN (ksh.d3_demand +
                    CASE
                        WHEN (rdt.d4_delivery = 0) THEN (ksh.d4_demand +
                        CASE
                            WHEN (rdt.d0_delivery = 0) THEN ksh.d0_demand
                            ELSE (0)::numeric
                        END)
                        ELSE (0)::numeric
                    END)
                    ELSE (0)::numeric
                END)
                ELSE (0)::numeric
            END)
            ELSE (0)::numeric
        END AS d1_plan_demand_ratio,
        CASE
            WHEN (rdt.d2_delivery = 1) THEN (ksh.d2_demand +
            CASE
                WHEN (rdt.d3_delivery = 0) THEN (ksh.d3_demand +
                CASE
                    WHEN (rdt.d4_delivery = 0) THEN (ksh.d4_demand +
                    CASE
                        WHEN (rdt.d1_delivery = 0) THEN (ksh.d1_demand +
                        CASE
                            WHEN (rdt.d2_delivery = 0) THEN ksh.d2_demand
                            ELSE (0)::numeric
                        END)
                        ELSE (0)::numeric
                    END)
                    ELSE (0)::numeric
                END)
                ELSE (0)::numeric
            END)
            ELSE (0)::numeric
        END AS d2_plan_demand_ratio,
        CASE
            WHEN (rdt.d3_delivery = 1) THEN (ksh.d3_demand +
            CASE
                WHEN (rdt.d4_delivery = 0) THEN (ksh.d4_demand +
                CASE
                    WHEN (rdt.d0_delivery = 0) THEN (ksh.d0_demand +
                    CASE
                        WHEN (rdt.d1_delivery = 0) THEN (ksh.d1_demand +
                        CASE
                            WHEN (rdt.d2_delivery = 0) THEN ksh.d2_demand
                            ELSE (0)::numeric
                        END)
                        ELSE (0)::numeric
                    END)
                    ELSE (0)::numeric
                END)
                ELSE (0)::numeric
            END)
            ELSE (0)::numeric
        END AS d3_plan_demand_ratio,
        CASE
            WHEN (rdt.d4_delivery = 1) THEN (ksh.d4_demand +
            CASE
                WHEN (rdt.d0_delivery = 0) THEN (ksh.d0_demand +
                CASE
                    WHEN (rdt.d1_delivery = 0) THEN (ksh.d1_demand +
                    CASE
                        WHEN (rdt.d2_delivery = 0) THEN (ksh.d2_demand +
                        CASE
                            WHEN (rdt.d3_delivery = 0) THEN ksh.d3_demand
                            ELSE (0)::numeric
                        END)
                        ELSE (0)::numeric
                    END)
                    ELSE (0)::numeric
                END)
                ELSE (0)::numeric
            END)
            ELSE (0)::numeric
        END AS d4_plan_demand_ratio
   FROM (( SELECT ksh_1.kiosk_id,
            sum(ksh_1.units_sold_normalized) FILTER (WHERE ((ksh_1.how >= 34) AND (ksh_1.how < 58))) AS d0_demand,
            sum(ksh_1.units_sold_normalized) FILTER (WHERE ((ksh_1.how >= 58) AND (ksh_1.how < 82))) AS d1_demand,
            sum(ksh_1.units_sold_normalized) FILTER (WHERE ((ksh_1.how >= 82) AND (ksh_1.how < 106))) AS d2_demand,
            sum(ksh_1.units_sold_normalized) FILTER (WHERE ((ksh_1.how >= 106) AND (ksh_1.how < 130))) AS d3_demand,
            sum(ksh_1.units_sold_normalized) FILTER (WHERE ((ksh_1.how >= 130) OR (ksh_1.how < 34))) AS d4_demand
           FROM ( SELECT ksh_2.kiosk_id,
                    ksh_2.dow,
                    ksh_2.hod,
                    ksh_2.units_sold,
                    ksh_2.units_sold_normalized,
                    ((24 * ksh_2.dow) + ksh_2.hod) AS how
                   FROM inm.v_kiosk_sale_hourly ksh_2) ksh_1
          GROUP BY ksh_1.kiosk_id) ksh
     LEFT JOIN ( SELECT rdt_1.kiosk_id,
            count(rdt_1.d) FILTER (WHERE (rdt_1.d = (0)::double precision)) AS d0_delivery,
            count(rdt_1.d) FILTER (WHERE (rdt_1.d = (1)::double precision)) AS d1_delivery,
            count(rdt_1.d) FILTER (WHERE (rdt_1.d = (2)::double precision)) AS d2_delivery,
            count(rdt_1.d) FILTER (WHERE (rdt_1.d = (3)::double precision)) AS d3_delivery,
            count(rdt_1.d) FILTER (WHERE (rdt_1.d = (4)::double precision)) AS d4_delivery
           FROM ( SELECT route_stop.location_number AS kiosk_id,
                    date_part('dow'::text, (timezone('US/Pacific'::text, route_stop.route_date_time) - ('11:00:00'::time without time zone)::interval)) AS d
                   FROM mixalot.route_stop
                  WHERE (date_trunc('week'::text, route_stop.route_date_time) = date_trunc('week'::text, now()))
                  ORDER BY route_stop.route_date_time, route_stop.schedule_at) rdt_1
          GROUP BY rdt_1.kiosk_id) rdt ON ((ksh.kiosk_id = rdt.kiosk_id)))
  ORDER BY ksh.kiosk_id;


ALTER TABLE inm.v_kiosk_demand_plan_ratio OWNER TO erpuser;

--
-- Name: v_kiosk_sku_enabled; Type: VIEW; Schema: inm; Owner: dbservice
--

CREATE VIEW inm.v_kiosk_sku_enabled AS
 SELECT k.kiosk_id,
    p.sku_group,
    p.sku,
    public.if((kpd.product_id IS NOT NULL), 0, 1) AS enabled
   FROM ((( SELECT k_1.id AS kiosk_id
           FROM pantry.kiosk k_1
          WHERE ((k_1.campus_id = 87) AND (k_1.archived = 0) AND (k_1.enable_reporting = 1))) k
     CROSS JOIN ( SELECT p_1.id AS sku,
            p_1.fc_title AS sku_group
           FROM pantry.product p_1
          WHERE ((p_1.campus_id = 87) AND (p_1.archived = 0) AND (p_1.fc_title IS NOT NULL) AND ((p_1.fc_title)::text <> 'N/A'::text))
          ORDER BY p_1.fc_title) p)
     LEFT JOIN inm.kiosk_product_disabled kpd ON (((k.kiosk_id = kpd.kiosk_id) AND (p.sku = kpd.product_id))))
  ORDER BY k.kiosk_id, p.sku_group, p.sku;


ALTER TABLE inm.v_kiosk_sku_enabled OWNER TO dbservice;

--
-- Name: v_kiosk_sku_group_stock_sale_spoil_history; Type: VIEW; Schema: inm; Owner: dbservice
--

CREATE VIEW inm.v_kiosk_sku_group_stock_sale_spoil_history AS
 SELECT t3.kiosk_id,
    t3.sku_group,
    round(avg(t3.stock_count), 2) AS stock_avg,
    round(stddev(t3.stock_count), 2) AS stock_std,
    round(avg(t3.sale_count), 2) AS sale_avg,
    round(stddev(t3.sale_count), 2) AS sale_std,
    round(avg(t3.spoil_count), 2) AS spoil_avg,
    round(stddev(t3.spoil_count), 2) AS spoil_std,
    round(avg(t3.week_stock), 2) AS week_stock_avg,
    round(stddev(t3.week_stock), 2) AS week_stock_std,
    round(avg(t3.week_sale), 2) AS week_sale_avg,
    round(stddev(t3.week_sale), 2) AS week_sale_std,
    round(avg(t3.week_spoil), 2) AS week_spoil_avg,
    round(stddev(t3.week_spoil), 2) AS week_spoil_std
   FROM ( SELECT t2.kiosk_id,
            t2.week,
            t2.sku_group,
            t2.stock_count,
            t2.sale_count,
            t2.spoil_count,
            sum(t2.stock_count) OVER (PARTITION BY t2.kiosk_id, t2.week) AS week_stock,
            sum(t2.sale_count) OVER (PARTITION BY t2.kiosk_id, t2.week) AS week_sale,
            sum(t2.spoil_count) OVER (PARTITION BY t2.kiosk_id, t2.week) AS week_spoil
           FROM ( SELECT t1.kiosk_id,
                    t1.week,
                    t1.sku_group,
                    sum(t1.stock_count) AS stock_count,
                    sum(t1.sale_count) AS sale_count,
                    sum(t1.spoil_count) AS spoil_count
                   FROM ( SELECT kk.kiosk_id,
                            kk.week,
                            pp.sku_group,
                            sss.product_id,
                            COALESCE(sss.stock_count, (0)::bigint) AS stock_count,
                            COALESCE(sss.sale_count, (0)::bigint) AS sale_count,
                            COALESCE(sss.spoil_count, (0)::bigint) AS spoil_count
                           FROM ((( SELECT k.id AS kiosk_id,
                                    (date_trunc('week'::text, generate_series((now() - '3 mons'::interval month), now(), '7 days'::interval)))::date AS week
                                   FROM pantry.kiosk k
                                  WHERE ((k.campus_id = 87) AND (k.archived = 0) AND (k.enable_reporting = 1) AND (k.enable_monitoring = 1))) kk
                             CROSS JOIN ( SELECT DISTINCT p.fc_title AS sku_group
                                   FROM pantry.product p
                                  WHERE ((p.campus_id = 87) AND (p.archived = 0) AND (p.fc_title IS NOT NULL) AND ((p.fc_title)::text <> 'N/A'::text))) pp)
                             LEFT JOIN ( SELECT COALESCE(stock.kiosk_id, sale.kiosk_id, spoil.kiosk_id) AS kiosk_id,
                                    COALESCE(stock.week, sale.week, spoil.week) AS week,
                                    COALESCE(stock.sku_group, sale.sku_group, spoil.sku_group) AS sku_group,
                                    COALESCE(stock.product_id, sale.product_id, spoil.product_id) AS product_id,
                                    COALESCE(stock.stock_count, (0)::bigint) AS stock_count,
                                    COALESCE(sale.sale_count, (0)::bigint) AS sale_count,
                                    COALESCE(spoil.spoil_count, (0)::bigint) AS spoil_count
                                   FROM ((( SELECT l.kiosk_id,
    p.fc_title AS sku_group,
    l.product_id,
    (date_trunc('week'::text, to_timestamp((l.time_updated)::double precision)))::date AS week,
    count(*) AS stock_count
   FROM (pantry.label l
     LEFT JOIN pantry.product p ON ((l.product_id = p.id)))
  WHERE ((to_timestamp((l.time_added)::double precision) > (now() - '3 mons'::interval month)) AND (p.campus_id = 87) AND (p.archived = 0) AND (p.fc_title IS NOT NULL) AND ((p.fc_title)::text <> 'N/A'::text))
  GROUP BY l.kiosk_id, p.fc_title, l.product_id, ((date_trunc('week'::text, to_timestamp((l.time_updated)::double precision)))::date)) stock
                                     FULL JOIN ( SELECT l.kiosk_id,
    p.fc_title AS sku_group,
    l.product_id,
    (date_trunc('week'::text, to_timestamp((l.time_updated)::double precision)))::date AS week,
    count(*) AS sale_count
   FROM (pantry.label l
     LEFT JOIN pantry.product p ON ((l.product_id = p.id)))
  WHERE ((to_timestamp((l.time_updated)::double precision) > (now() - '3 mons'::interval month)) AND ((l.status)::text = 'sold'::text) AND (l.order_id IS NOT NULL) AND (p.campus_id = 87) AND (p.archived = 0) AND (p.fc_title IS NOT NULL) AND ((p.fc_title)::text <> 'N/A'::text))
  GROUP BY l.kiosk_id, p.fc_title, l.product_id, ((date_trunc('week'::text, to_timestamp((l.time_updated)::double precision)))::date)) sale ON (((stock.kiosk_id = sale.kiosk_id) AND (stock.week = sale.week) AND ((stock.sku_group)::text = (sale.sku_group)::text) AND (stock.product_id = sale.product_id))))
                                     FULL JOIN ( SELECT l.kiosk_id,
    p.fc_title AS sku_group,
    l.product_id,
    (date_trunc('week'::text, to_timestamp((l.time_updated)::double precision)))::date AS week,
    count(*) AS spoil_count
   FROM (pantry.label l
     LEFT JOIN pantry.product p ON ((l.product_id = p.id)))
  WHERE ((to_timestamp((l.time_updated)::double precision) > (now() - '3 mons'::interval month)) AND ((l.status)::text = 'out'::text) AND ((l.order_id)::text ~~ 'RE%'::text) AND (p.campus_id = 87) AND (p.archived = 0) AND (p.fc_title IS NOT NULL) AND ((p.fc_title)::text <> 'N/A'::text))
  GROUP BY l.kiosk_id, p.fc_title, l.product_id, ((date_trunc('week'::text, to_timestamp((l.time_updated)::double precision)))::date)) spoil ON (((stock.kiosk_id = spoil.kiosk_id) AND (stock.week = spoil.week) AND ((stock.sku_group)::text = (spoil.sku_group)::text) AND (stock.product_id = spoil.product_id))))) sss ON (((kk.kiosk_id = sss.kiosk_id) AND (kk.week = sss.week) AND ((pp.sku_group)::text = (sss.sku_group)::text))))
                          ORDER BY kk.kiosk_id, kk.week, pp.sku_group) t1
                  GROUP BY t1.kiosk_id, t1.week, t1.sku_group) t2) t3
  GROUP BY t3.kiosk_id, t3.sku_group
  ORDER BY t3.kiosk_id, t3.sku_group;


ALTER TABLE inm.v_kiosk_sku_group_stock_sale_spoil_history OWNER TO dbservice;

--
-- Name: byte_tickets_3months; Type: VIEW; Schema: public; Owner: erpuser
--

CREATE VIEW public.byte_tickets_3months AS
 SELECT byte_tickets.order_id,
    byte_tickets.first_name,
    byte_tickets.last_name,
    byte_tickets.kiosk_id,
    byte_tickets.kiosk_title,
    byte_tickets.email,
    byte_tickets.amount_paid,
    byte_tickets.payment_system,
    byte_tickets.transaction_id,
    byte_tickets.approval_code,
    byte_tickets.status_code,
    byte_tickets.status_message,
    byte_tickets.status,
    byte_tickets.batch_id,
    byte_tickets.created,
    byte_tickets.auth_amount,
    byte_tickets.data_token,
    byte_tickets.time_opened,
    byte_tickets.time_closed,
    byte_tickets.card_hash,
    byte_tickets.state,
    byte_tickets.archived,
    byte_tickets.stamp,
    byte_tickets.last_update,
    byte_tickets.balance,
    byte_tickets.delta,
    byte_tickets.coupon_id,
    byte_tickets.coupon,
    byte_tickets.refund,
    byte_tickets.receipt,
    byte_tickets.campus_id,
    byte_tickets.amount_list_price,
    byte_tickets.notes,
    byte_tickets.time_door_opened,
    byte_tickets.time_door_closed,
    byte_tickets.client_name,
    byte_tickets.estd_num_users,
    byte_tickets.ts,
    byte_tickets.full_name,
    byte_tickets.door_opened_secs,
    byte_tickets.month,
    byte_tickets.week,
    byte_tickets.date,
    byte_tickets.dayofweek,
    byte_tickets.hour,
    byte_tickets.dowhour,
    byte_tickets.uniq_user
   FROM public.byte_tickets
  WHERE (byte_tickets.ts > (now() - '3 mons'::interval month));


ALTER TABLE public.byte_tickets_3months OWNER TO erpuser;

--
-- Name: byte_epcssold_3months; Type: VIEW; Schema: public; Owner: erpuser
--

CREATE VIEW public.byte_epcssold_3months AS
 SELECT o.order_id,
    o.first_name,
    o.last_name,
    o.kiosk_id,
    o.kiosk_title,
    o.email,
    o.amount_paid,
    o.payment_system,
    o.transaction_id,
    o.approval_code,
    o.status_code,
    o.status_message,
    o.status,
    o.batch_id,
    o.created,
    o.auth_amount,
    o.data_token,
    o.time_opened,
    o.time_closed,
    o.card_hash,
    o.state,
    o.archived,
    o.stamp,
    o.last_update,
    o.balance,
    o.delta,
    o.coupon_id,
    o.coupon,
    o.refund,
    o.receipt,
    o.campus_id,
    o.amount_list_price,
    o.notes,
    o.time_door_opened,
    o.time_door_closed,
    o.client_name,
    o.estd_num_users,
    o.ts,
    o.full_name,
    o.door_opened_secs,
    o.month,
    o.week,
    o.date,
    o.dayofweek,
    o.hour,
    o.dowhour,
    o.uniq_user,
    lp.epc,
    lp.label_order_id,
    lp.label_status,
    lp.label_price,
    lp.time_created,
    lp.time_added,
    lp.time_updated,
    lp.ts_created,
    lp.ts_added,
    lp.ts_updated,
    lp.label_kiosk_id,
    lp.product_id,
    lp.product_title,
    lp.product_archived,
    lp.product_vendor,
    lp.product_price,
    lp.product_cost,
    lp.product_shelf_life_days,
    lp.product_attributes,
    lp.product_categories,
    lp.consumer_category,
    lp.product_source
   FROM (public.byte_tickets_3months o
     JOIN public.byte_label_product lp ON (((lp.label_order_id)::text = (o.order_id)::text)))
  WHERE ((lp.label_status)::text = 'sold'::text);


ALTER TABLE public.byte_epcssold_3months OWNER TO erpuser;

--
-- Name: v_kiosk_sku_group_velocity_demand_week; Type: VIEW; Schema: inm; Owner: erpuser
--

CREATE VIEW inm.v_kiosk_sku_group_velocity_demand_week AS
 SELECT kc.kiosk_id,
    sg.id AS sku_group_id,
    (sg.fc_title)::text AS sku_group,
    COALESCE(dwwom.sample_size, (0)::bigint) AS sample_size,
    COALESCE(dwwom.preference, 0.00) AS preference,
    max(COALESCE(dwwom.ws_avg, 0.00)) OVER (PARTITION BY kc.kiosk_id) AS ws_avg,
    max(COALESCE(dwwom.ws_std, 0.00)) OVER (PARTITION BY kc.kiosk_id) AS ws_std,
    max(COALESCE(dwwom.ws_max, 0.00)) OVER (PARTITION BY kc.kiosk_id) AS ws_max,
    max(COALESCE(dwwom.ws_live, (0)::bigint)) OVER (PARTITION BY kc.kiosk_id) AS ws_live,
    kc.start_level AS kc_start_level,
    kc.min_level AS kc_min_level,
    kc.manual_multiplier AS kc_manual_multiplier,
    sgc.default_level AS sgc_default_level,
    sgc.scale AS sgc_scale,
    COALESCE(ksms.scale, 1.00) AS ksms_scale,
    round(((((kc.start_level * kc.manual_multiplier) * sgc.scale) * COALESCE(ksms.scale, 1.00)) * sgc.default_level), 2) AS start_count,
    round(((((kc.min_level * kc.manual_multiplier) * sgc.scale) * COALESCE(ksms.scale, 1.00)) * sgc.default_level), 2) AS min_count,
    round((((COALESCE(dwwom.preference, 0.00) * kc.manual_multiplier) * sgc.scale) * COALESCE(ksms.scale, 1.00)), 2) AS scaled_preference,
    round(sum((((COALESCE(dwwom.preference, 0.00) * kc.manual_multiplier) * sgc.scale) * COALESCE(ksms.scale, 1.00))) OVER (PARTITION BY kc.kiosk_id), 2) AS scaled_preference_total,
    round((COALESCE(dwwom.ws_max, 0.00) * ((((COALESCE(dwwom.preference, 0.00) * kc.manual_multiplier) * sgc.scale) * COALESCE(ksms.scale, 1.00)) / GREATEST(0.01, sum((((COALESCE(dwwom.preference, 0.00) * kc.manual_multiplier) * sgc.scale) * COALESCE(ksms.scale, 1.00))) OVER (PARTITION BY kc.kiosk_id)))), 2) AS preference_count
   FROM ((((inm.sku_group sg
     CROSS JOIN inm.kiosk_control kc)
     LEFT JOIN inm.kiosk_sku_group_manual_scale ksms ON (((ksms.kiosk_id = kc.kiosk_id) AND (ksms.sku_group_id = sg.id))))
     LEFT JOIN inm.sku_group_control sgc ON ((sgc.sku_group_id = sg.id)))
     LEFT JOIN ( SELECT t4.kiosk_id,
            t4.sku_group,
            t4.sample_size,
            t4.dt_avg,
            t4.dt_std,
            t4.w_departure_time,
            t4.preference,
            t6.ws_avg,
            t6.ws_std,
            t6.ws_max,
            t6.ws_live
           FROM (( SELECT t3.kiosk_id,
                    t3.sku_group,
                    count(t3.purchase_index) AS sample_size,
                    round(avg(t3.departure_time), 2) AS dt_avg,
                    COALESCE(round(stddev(t3.departure_time), 2), (0)::numeric) AS dt_std,
                    round((sum((t3.departure_time * (t3.w)::numeric)) / (sum(t3.w))::numeric), 2) AS w_departure_time,
                    LEAST(round((1.00 / (sum((t3.departure_time * (t3.w)::numeric)) / (sum(t3.w))::numeric)), 2), 0.20) AS preference
                   FROM ( SELECT t2.kiosk_id,
                            t2.sku_group,
                            t2.time_stocked,
                            t2.time_sold,
                            t2.purchase_index,
                            t2.last_sale,
                            t2.last_purchase_index,
                            GREATEST(COALESCE(round((((t2.time_sold - GREATEST(t2.last_sale, t2.time_stocked)))::numeric / (3600)::numeric), 2), 50.00), 1.00) AS departure_time,
                            0 AS qty_sold,
                            1 AS w
                           FROM ( SELECT t1.kiosk_id,
                                    t1.sku_group,
                                    t1.time_stocked,
                                    t1.time_sold,
                                    t1.purchase_index,
                                    lag(t1.time_sold, 1) OVER (PARTITION BY t1.kiosk_id, t1.sku_group ORDER BY t1.time_sold) AS last_sale,
                                    lag(t1.purchase_index, 1) OVER (PARTITION BY t1.kiosk_id, t1.sku_group ORDER BY t1.time_sold) AS last_purchase_index
                                   FROM ( SELECT k.kiosk_id,
    p.sku_group,
    l.time_stocked,
    l.time_sold,
    l.purchase_index
   FROM ((( SELECT k_1.id AS kiosk_id
     FROM pantry.kiosk k_1
    WHERE ((k_1.campus_id = 87) AND (k_1.archived = 0) AND (k_1.enable_reporting = 1))) k
     CROSS JOIN ( SELECT DISTINCT p_1.fc_title AS sku_group
     FROM pantry.product p_1
    WHERE ((p_1.campus_id = 87) AND (p_1.archived = 0) AND (p_1.fc_title IS NOT NULL) AND ((p_1.fc_title)::text <> 'N/A'::text))
    ORDER BY p_1.fc_title) p)
     LEFT JOIN ( SELECT l_1.kiosk_id,
      p_1.fc_title AS sku_group,
      l_1.time_created AS time_stocked,
      l_1.time_updated AS time_sold,
      row_number() OVER (PARTITION BY l_1.kiosk_id ORDER BY l_1.time_updated) AS purchase_index
     FROM (pantry.label l_1
       JOIN pantry.product p_1 ON ((l_1.product_id = p_1.id)))
    WHERE ((l_1.kiosk_id IS NOT NULL) AND ((l_1.status)::text = 'sold'::text) AND (timezone('US/Pacific'::text, to_timestamp((l_1.time_updated)::double precision)) > (date_trunc('week'::text, CURRENT_TIMESTAMP) - '168 days'::interval)) AND (p_1.campus_id = 87) AND (p_1.archived = 0) AND (p_1.fc_title IS NOT NULL))) l ON (((k.kiosk_id = l.kiosk_id) AND ((p.sku_group)::text = (l.sku_group)::text))))
  ORDER BY k.kiosk_id, p.sku_group, l.purchase_index) t1) t2) t3
                  GROUP BY t3.kiosk_id, t3.sku_group) t4
             JOIN ( SELECT t5.kiosk_id,
                    round(avg(t5.units_sold), 2) AS ws_avg,
                    round(stddev(t5.units_sold), 2) AS ws_std,
                    round((max(t5.units_sold))::numeric, 2) AS ws_max,
                    count(t5.units_sold) AS ws_live
                   FROM ( SELECT concat((kk.kiosk_id)::character varying(4), ' ', kk.woy) AS key,
                            kk.kiosk_id,
                            kk.woy,
                            ss.units_sold
                           FROM (( SELECT k.id AS kiosk_id,
                                    generate_series(1, 52) AS woy
                                   FROM pantry.kiosk k
                                  WHERE ((k.campus_id = 87) AND (k.archived = 0) AND (k.enable_reporting = 1) AND (k.enable_monitoring = 1))) kk
                             LEFT JOIN ( SELECT s.kiosk_id,
                                    date_part('week'::text, s.ts) AS woy,
                                    count(*) AS units_sold
                                   FROM public.byte_epcssold_3months s
                                  GROUP BY s.kiosk_id, (date_part('week'::text, s.ts))) ss ON (((kk.kiosk_id = ss.kiosk_id) AND ((kk.woy)::double precision = ss.woy))))
                          ORDER BY ss.kiosk_id, ss.woy) t5
                  GROUP BY t5.kiosk_id
                  ORDER BY t5.kiosk_id) t6 ON ((t4.kiosk_id = t6.kiosk_id)))) dwwom ON (((dwwom.kiosk_id = kc.kiosk_id) AND ((dwwom.sku_group)::text = (sg.fc_title)::text))));


ALTER TABLE inm.v_kiosk_sku_group_velocity_demand_week OWNER TO erpuser;

--
-- Name: v_kiosk_sku_velocity; Type: VIEW; Schema: inm; Owner: erpuser
--

CREATE VIEW inm.v_kiosk_sku_velocity AS
 SELECT t3.kiosk_id,
    t3.sku_group,
    t3.sku,
    t3.name,
    count(t3.purchase_index) AS sample_size,
    round(avg(t3.departure_time), 2) AS dt_avg,
    COALESCE(round(stddev(t3.departure_time), 2), (0)::numeric) AS dt_std,
    round((sum((t3.departure_time * (t3.w)::numeric)) / (sum(t3.w))::numeric), 2) AS w_departure_time,
    LEAST(round((1.00 / (sum((t3.departure_time * (t3.w)::numeric)) / (sum(t3.w))::numeric)), 2), 0.20) AS preference
   FROM ( SELECT t2.kiosk_id,
            t2.sku_group,
            t2.sku,
            t2.name,
            t2.time_stocked,
            t2.time_sold,
            t2.purchase_index,
            t2.last_sale,
            t2.last_purchase_index,
            GREATEST(COALESCE(round((((t2.time_sold - GREATEST(t2.last_sale, t2.time_stocked)))::numeric / (3600)::numeric), 2), 50.00), 1.00) AS departure_time,
            0 AS qty_sold,
            1 AS w
           FROM ( SELECT t1.kiosk_id,
                    t1.sku_group,
                    t1.sku,
                    t1.name,
                    t1.time_stocked,
                    t1.time_sold,
                    t1.purchase_index,
                    lag(t1.time_sold, 1) OVER (PARTITION BY t1.kiosk_id, t1.sku ORDER BY t1.time_sold) AS last_sale,
                    lag(t1.purchase_index, 1) OVER (PARTITION BY t1.kiosk_id, t1.sku ORDER BY t1.time_sold) AS last_purchase_index
                   FROM ( SELECT k.kiosk_id,
                            p.sku_group,
                            p.sku,
                            p.name,
                            l.time_stocked,
                            l.time_sold,
                            l.purchase_index
                           FROM ((( SELECT k_1.id AS kiosk_id
                                   FROM pantry.kiosk k_1
                                  WHERE ((k_1.campus_id = 87) AND (k_1.archived = 0) AND (k_1.enable_reporting = 1))) k
                             CROSS JOIN ( SELECT p_1.fc_title AS sku_group,
                                    p_1.id AS sku,
                                    p_1.title AS name
                                   FROM pantry.product p_1
                                  WHERE ((p_1.campus_id = 87) AND (p_1.archived = 0) AND ((p_1.fc_title)::text <> 'N/A'::text) AND (p_1.fc_title IS NOT NULL))
                                  ORDER BY p_1.fc_title, p_1.id) p)
                             LEFT JOIN ( SELECT l_1.kiosk_id,
                                    p_1.fc_title AS sku_group,
                                    p_1.id AS sku,
                                    l_1.time_created AS time_stocked,
                                    l_1.time_updated AS time_sold,
                                    row_number() OVER (PARTITION BY l_1.kiosk_id ORDER BY l_1.time_updated) AS purchase_index
                                   FROM (pantry.label l_1
                                     JOIN pantry.product p_1 ON ((l_1.product_id = p_1.id)))
                                  WHERE ((l_1.kiosk_id IS NOT NULL) AND ((l_1.status)::text = 'sold'::text) AND (timezone('US/Pacific'::text, to_timestamp((l_1.time_updated)::double precision)) > (date_trunc('week'::text, CURRENT_TIMESTAMP) - '168 days'::interval)) AND (p_1.campus_id = 87) AND (p_1.archived = 0) AND ((p_1.fc_title)::text <> 'N/A'::text) AND (p_1.fc_title IS NOT NULL))) l ON (((k.kiosk_id = l.kiosk_id) AND (p.sku = l.sku))))
                          ORDER BY k.kiosk_id, p.sku_group, p.sku, l.purchase_index) t1) t2) t3
  GROUP BY t3.kiosk_id, t3.sku_group, t3.sku, t3.name
  ORDER BY t3.kiosk_id, t3.sku_group, t3.sku;


ALTER TABLE inm.v_kiosk_sku_velocity OWNER TO erpuser;

--
-- Name: v_kiosk_sku_group_sku_stats; Type: VIEW; Schema: inm; Owner: erpuser
--

CREATE VIEW inm.v_kiosk_sku_group_sku_stats AS
 SELECT enabled.kiosk_id,
    enabled.sku_group,
    demand.sku_group_id,
    enabled.sku,
    velocity.name,
    enabled.enabled,
    velocity.sample_size AS sku_sample_size,
    velocity.w_departure_time AS sku_departure_time,
    velocity.preference AS sku_preference,
    demand.sample_size AS sku_group_sample_size,
    demand.preference AS sku_group_preference,
    demand.kc_start_level AS kiosk_start_level,
    demand.kc_min_level AS kiosk_min_level,
    demand.kc_manual_multiplier AS kiosk_manual_multiplier,
    demand.sgc_default_level AS sku_group_default_level,
    demand.sgc_scale AS sku_group_scale,
    demand.ksms_scale AS kiosk_sku_group_scale,
    demand.start_count AS sku_group_start_count,
    demand.min_count AS sku_group_min_count,
    demand.preference_count AS sku_group_preference_count,
    history.stock_avg AS sku_group_stock_avg,
    history.stock_std AS sku_group_stock_std,
    history.sale_avg AS sku_group_sale_avg,
    history.sale_std AS sku_group_sale_std,
    history.spoil_avg AS sku_group_spoil_avg,
    history.spoil_std AS sku_group_spoil_std,
    demand.ws_live AS kiosk_weeks_live,
    demand.ws_max AS kiosk_sale_max,
    history.week_stock_avg AS kiosk_stock_avg,
    history.week_stock_std AS kiosk_stock_std,
    history.week_sale_avg AS kiosk_sale_avg,
    history.week_sale_std AS kiosk_sale_std,
    history.week_spoil_avg AS kiosk_spoil_avg,
    history.week_spoil_std AS kiosk_spoil_std,
    plan.d0_plan_demand_ratio,
    plan.d1_plan_demand_ratio,
    plan.d2_plan_demand_ratio,
    plan.d3_plan_demand_ratio,
    plan.d4_plan_demand_ratio
   FROM ((((inm.v_kiosk_sku_enabled enabled
     LEFT JOIN inm.v_kiosk_sku_velocity velocity ON (((enabled.kiosk_id = velocity.kiosk_id) AND (enabled.sku = velocity.sku))))
     LEFT JOIN inm.v_kiosk_sku_group_velocity_demand_week demand ON (((enabled.kiosk_id = demand.kiosk_id) AND ((enabled.sku_group)::text = demand.sku_group))))
     LEFT JOIN inm.v_kiosk_sku_group_stock_sale_spoil_history history ON (((enabled.kiosk_id = history.kiosk_id) AND ((enabled.sku_group)::text = (history.sku_group)::text))))
     LEFT JOIN inm.v_kiosk_demand_plan_ratio plan ON ((enabled.kiosk_id = plan.kiosk_id)))
  ORDER BY enabled.kiosk_id, enabled.sku_group, enabled.sku;


ALTER TABLE inm.v_kiosk_sku_group_sku_stats OWNER TO erpuser;

--
-- Name: v_warehouse_ordering_rec; Type: VIEW; Schema: fnrenames; Owner: erpuser
--

CREATE VIEW fnrenames.v_warehouse_ordering_rec AS
 SELECT stats.sku_group,
    stats.sku,
    stats.name,
    stats.vendor,
    ceiling(sum((stats.d0_plan_demand_ratio * (stats.sku_demand + stats.sku_overstock)))) AS su,
    ceiling(sum((stats.d1_plan_demand_ratio * (stats.sku_demand + stats.sku_overstock)))) AS mo,
    ceiling(sum((stats.d2_plan_demand_ratio * (stats.sku_demand + stats.sku_overstock)))) AS tu,
    ceiling(sum((stats.d3_plan_demand_ratio * (stats.sku_demand + stats.sku_overstock)))) AS we,
    ceiling(sum((stats.d4_plan_demand_ratio * (stats.sku_demand + stats.sku_overstock)))) AS th,
    ceiling(sum(stats.sku_demand)) AS demand_week,
    ceiling(sum(stats.sku_overstock)) AS overstock_week,
    max(stats.sku_shelf_time) AS shelf_time
   FROM ( SELECT stats_1.kiosk_id,
            stats_1.sku_group,
            stats_1.sku_group_id,
            stats_1.sku,
            stats_1.name,
            stats_1.enabled,
            stats_1.sku_sample_size,
            stats_1.sku_departure_time,
            stats_1.sku_preference,
            stats_1.sku_group_sample_size,
            stats_1.sku_group_preference,
            stats_1.kiosk_start_level,
            stats_1.kiosk_min_level,
            stats_1.kiosk_manual_multiplier,
            stats_1.sku_group_default_level,
            stats_1.sku_group_scale,
            stats_1.kiosk_sku_group_scale,
            stats_1.sku_group_start_count,
            stats_1.sku_group_min_count,
            stats_1.sku_group_preference_count,
            stats_1.sku_group_stock_avg,
            stats_1.sku_group_stock_std,
            stats_1.sku_group_sale_avg,
            stats_1.sku_group_sale_std,
            stats_1.sku_group_spoil_avg,
            stats_1.sku_group_spoil_std,
            stats_1.kiosk_weeks_live,
            stats_1.kiosk_sale_max,
            stats_1.kiosk_stock_avg,
            stats_1.kiosk_stock_std,
            stats_1.kiosk_sale_avg,
            stats_1.kiosk_sale_std,
            stats_1.kiosk_spoil_avg,
            stats_1.kiosk_spoil_std,
            stats_1.d0_plan_demand_ratio,
            stats_1.d1_plan_demand_ratio,
            stats_1.d2_plan_demand_ratio,
            stats_1.d3_plan_demand_ratio,
            stats_1.d4_plan_demand_ratio,
            stats_1.vendor,
            stats_1.sku_shelf_time,
            stats_1.sku_pref_total_kiosk_sku_group,
            stats_1.sku_group_demand,
            stats_1.sku_group_overstock,
            round(public.if((stats_1.sku_pref_total_kiosk_sku_group <> (0)::numeric), (((stats_1.sku_group_demand * (stats_1.enabled)::numeric) * stats_1.sku_preference) / stats_1.sku_pref_total_kiosk_sku_group), 0.00), 2) AS sku_demand,
            round(public.if((stats_1.sku_pref_total_kiosk_sku_group <> (0)::numeric), ((((LEAST(1.00, (7.00 / (stats_1.sku_shelf_time)::numeric)) * stats_1.sku_group_overstock) * (stats_1.enabled)::numeric) * stats_1.sku_preference) / stats_1.sku_pref_total_kiosk_sku_group), 0.00), 2) AS sku_overstock
           FROM ( SELECT stats_2.kiosk_id,
                    stats_2.sku_group,
                    stats_2.sku_group_id,
                    stats_2.sku,
                    stats_2.name,
                    stats_2.enabled,
                    stats_2.sku_sample_size,
                    stats_2.sku_departure_time,
                    stats_2.sku_preference,
                    stats_2.sku_group_sample_size,
                    stats_2.sku_group_preference,
                    stats_2.kiosk_start_level,
                    stats_2.kiosk_min_level,
                    stats_2.kiosk_manual_multiplier,
                    stats_2.sku_group_default_level,
                    stats_2.sku_group_scale,
                    stats_2.kiosk_sku_group_scale,
                    stats_2.sku_group_start_count,
                    stats_2.sku_group_min_count,
                    stats_2.sku_group_preference_count,
                    stats_2.sku_group_stock_avg,
                    stats_2.sku_group_stock_std,
                    stats_2.sku_group_sale_avg,
                    stats_2.sku_group_sale_std,
                    stats_2.sku_group_spoil_avg,
                    stats_2.sku_group_spoil_std,
                    stats_2.kiosk_weeks_live,
                    stats_2.kiosk_sale_max,
                    stats_2.kiosk_stock_avg,
                    stats_2.kiosk_stock_std,
                    stats_2.kiosk_sale_avg,
                    stats_2.kiosk_sale_std,
                    stats_2.kiosk_spoil_avg,
                    stats_2.kiosk_spoil_std,
                    stats_2.d0_plan_demand_ratio,
                    stats_2.d1_plan_demand_ratio,
                    stats_2.d2_plan_demand_ratio,
                    stats_2.d3_plan_demand_ratio,
                    stats_2.d4_plan_demand_ratio,
                    product.vendor,
                    product.shelf_time AS sku_shelf_time,
                    sum(((stats_2.enabled)::numeric * stats_2.sku_preference)) OVER (PARTITION BY stats_2.kiosk_id, stats_2.sku_group) AS sku_pref_total_kiosk_sku_group,
                    stats_2.sku_group_preference_count AS sku_group_demand,
                    GREATEST((public.if((stats_2.kiosk_weeks_live <= 4), GREATEST(stats_2.sku_group_start_count, stats_2.sku_group_preference_count), GREATEST(stats_2.sku_group_min_count, stats_2.sku_group_preference_count)) - stats_2.sku_group_preference_count), 0.00) AS sku_group_overstock
                   FROM (inm.v_kiosk_sku_group_sku_stats stats_2
                     LEFT JOIN pantry.product product ON ((stats_2.sku = product.id)))) stats_1) stats
  GROUP BY stats.sku_group, stats.sku, stats.name, stats.vendor
  ORDER BY stats.sku_group, stats.vendor;


ALTER TABLE fnrenames.v_warehouse_ordering_rec OWNER TO erpuser;

--
-- Name: product_picking_order; Type: VIEW; Schema: inm; Owner: erpuser
--

CREATE VIEW inm.product_picking_order AS
 SELECT po.id AS product_id,
    (po.pick_order)::smallint AS pick_order
   FROM ( SELECT product.id,
            product.vendor,
            product.title,
            row_number() OVER (ORDER BY product.pick_station, product.vendor, product.title) AS pick_order
           FROM pantry.product
          WHERE ((product.campus_id = 87) AND (product.archived = 0))) po;


ALTER TABLE inm.product_picking_order OWNER TO erpuser;

--
-- Name: allocable_inventory; Type: VIEW; Schema: inm; Owner: erpuser
--

CREATE VIEW inm.allocable_inventory AS
 SELECT i.inventory_date,
    i.product_id,
    ((i.stickered_units + (i.stickered_cases * i.units_per_case)) - i.spoiled_units) AS qty,
    p.pick_station,
    p.title,
    p.fc_title,
    p.vendor,
    COALESCE(po.pick_order, (0)::smallint) AS pick_order
   FROM ((inm.warehouse_inventory i
     JOIN pantry.product p ON ((i.product_id = p.id)))
     LEFT JOIN inm.product_picking_order po ON ((i.product_id = po.product_id)))
  WHERE (((i.stickered_units + (i.stickered_cases * i.units_per_case)) - i.spoiled_units) > 0);


ALTER TABLE inm.allocable_inventory OWNER TO erpuser;

--
-- Name: configuration; Type: TABLE; Schema: inm; Owner: erpuser
--

CREATE TABLE inm.configuration (
    setting character varying(100) NOT NULL,
    value numeric NOT NULL
);


ALTER TABLE inm.configuration OWNER TO erpuser;

--
-- Name: TABLE configuration; Type: COMMENT; Schema: inm; Owner: erpuser
--

COMMENT ON TABLE inm.configuration IS 'inm configuration values';


--
-- Name: kiosk_projected_stock; Type: VIEW; Schema: inm; Owner: erpuser
--

CREATE VIEW inm.kiosk_projected_stock AS
 SELECT combined_stock.kiosk_id,
    combined_stock.kiosk_title,
    combined_stock.fc_title,
    sum(combined_stock.qty) AS count
   FROM ( SELECT l.kiosk_id,
            k.title AS kiosk_title,
            p.fc_title,
            count(l.epc) AS qty
           FROM ((pantry.label l
             JOIN pantry.product p ON ((l.product_id = p.id)))
             JOIN pantry.kiosk k ON ((l.kiosk_id = k.id)))
          WHERE (((l.status)::text ~~ 'ok'::text) AND (k.campus_id = 87) AND (k.archived <> 1))
          GROUP BY l.kiosk_id, k.title, p.fc_title
        UNION ALL
         SELECT a.kiosk_id,
            k.title AS kiosk_title,
            p.fc_title,
            a.qty
           FROM (((inm.pick_allocation a
             LEFT JOIN pantry."order" o ON (((a.route_date = (to_timestamp((o.created)::double precision))::date) AND (a.kiosk_id = o.kiosk_id) AND ((o.payment_system)::text = 'Restocking'::text))))
             JOIN pantry.product p ON ((a.sku_id = p.id)))
             JOIN pantry.kiosk k ON ((a.kiosk_id = k.id)))
          WHERE ((a.route_date >= ('now'::text)::date) AND (a.pick_date = (('now'::text)::date - 1)) AND (o.kiosk_id IS NULL))
        UNION ALL
         SELECT pl.kiosk_id,
            pl.kiosk_title,
            p.fc_title,
            count(*) AS qty
           FROM (inm.get_spoilage_pull_list() pl(category, kiosk_id, kiosk_title, product_id, product_tile, epc)
             JOIN pantry.product p ON ((pl.product_id = p.id)))
          GROUP BY pl.kiosk_id, pl.kiosk_title, p.fc_title) combined_stock
  WHERE (combined_stock.fc_title IS NOT NULL)
  GROUP BY combined_stock.kiosk_id, combined_stock.kiosk_title, combined_stock.fc_title;


ALTER TABLE inm.kiosk_projected_stock OWNER TO erpuser;

--
-- Name: VIEW kiosk_projected_stock; Type: COMMENT; Schema: inm; Owner: erpuser
--

COMMENT ON VIEW inm.kiosk_projected_stock IS 'kiosk current stock plus items on route';


--
-- Name: kiosk_restriction_list; Type: VIEW; Schema: inm; Owner: erpuser
--

CREATE VIEW inm.kiosk_restriction_list AS
 SELECT kr.kiosk_id,
    string_agg(pp.value, ','::text) AS restrictions
   FROM (inm.kiosk_restriction_by_property kr
     JOIN inm.product_property_def pp ON ((pp.id = kr.property_id)))
  GROUP BY kr.kiosk_id;


ALTER TABLE inm.kiosk_restriction_list OWNER TO erpuser;

--
-- Name: pick_substitution; Type: TABLE; Schema: inm; Owner: erpuser
--

CREATE TABLE inm.pick_substitution (
    substituting_sku_group_id integer NOT NULL,
    substituted_sku_group_id integer NOT NULL,
    qty integer NOT NULL,
    pick_date date NOT NULL
);


ALTER TABLE inm.pick_substitution OWNER TO erpuser;

--
-- Name: TABLE pick_substitution; Type: COMMENT; Schema: inm; Owner: erpuser
--

COMMENT ON TABLE inm.pick_substitution IS 'items substituted';


--
-- Name: product_pick_order; Type: TABLE; Schema: inm; Owner: erpuser
--

CREATE TABLE inm.product_pick_order (
    product_id integer NOT NULL,
    pick_order smallint DEFAULT 0 NOT NULL
);


ALTER TABLE inm.product_pick_order OWNER TO erpuser;

--
-- Name: product_pick_order_temp; Type: TABLE; Schema: inm; Owner: erpuser
--

CREATE TABLE inm.product_pick_order_temp (
    product_id integer NOT NULL,
    qty integer,
    sku_group text,
    pick_order smallint DEFAULT 0 NOT NULL
);


ALTER TABLE inm.product_pick_order_temp OWNER TO erpuser;

--
-- Name: product_property_def_id_seq; Type: SEQUENCE; Schema: inm; Owner: erpuser
--

CREATE SEQUENCE inm.product_property_def_id_seq
CREATE SEQUENCE inm.product_property_def_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE inm.product_property_def_id_seq OWNER TO erpuser;

--
-- Name: product_property_def_id_seq; Type: SEQUENCE OWNED BY; Schema: inm; Owner: erpuser
--

ALTER SEQUENCE inm.product_property_def_id_seq OWNED BY inm.product_property_def.id;


--
-- Name: v_warehouse_order_delivered_totals; Type: VIEW; Schema: inm; Owner: erpuser
--

CREATE VIEW inm.v_warehouse_order_delivered_totals AS
 SELECT warehouse_order_history.sku,
    sum(warehouse_order_history.amount_arrived) AS received_prod,
    warehouse_order_history.delivery_date
   FROM inm.warehouse_order_history
  GROUP BY warehouse_order_history.sku, warehouse_order_history.delivery_date;


ALTER TABLE inm.v_warehouse_order_delivered_totals OWNER TO erpuser;

--
-- Name: v_warehouse_ordering_rec; Type: VIEW; Schema: inm; Owner: erpuser
--

CREATE VIEW inm.v_warehouse_ordering_rec AS
 SELECT stats.sku_group,
    stats.sku,
    stats.name,
    stats.vendor,
    ceiling(sum((stats.d0_plan_demand_ratio * (stats.sku_demand + stats.sku_overstock)))) AS su,
    ceiling(sum((stats.d1_plan_demand_ratio * (stats.sku_demand + stats.sku_overstock)))) AS mo,
    ceiling(sum((stats.d2_plan_demand_ratio * (stats.sku_demand + stats.sku_overstock)))) AS tu,
    ceiling(sum((stats.d3_plan_demand_ratio * (stats.sku_demand + stats.sku_overstock)))) AS we,
    ceiling(sum((stats.d4_plan_demand_ratio * (stats.sku_demand + stats.sku_overstock)))) AS th,
    ceiling(sum(stats.sku_demand)) AS demand_week,
    ceiling(sum(stats.sku_overstock)) AS overstock_week,
    max(stats.sku_shelf_time) AS shelf_time
   FROM ( SELECT stats_1.kiosk_id,
            stats_1.sku_group,
            stats_1.sku_group_id,
            stats_1.sku,
            stats_1.name,
            stats_1.enabled,
            stats_1.sku_sample_size,
            stats_1.sku_departure_time,
            stats_1.sku_preference,
            stats_1.sku_group_sample_size,
            stats_1.sku_group_preference,
            stats_1.kiosk_start_level,
            stats_1.kiosk_min_level,
            stats_1.kiosk_manual_multiplier,
            stats_1.sku_group_default_level,
            stats_1.sku_group_scale,
            stats_1.kiosk_sku_group_scale,
            stats_1.sku_group_start_count,
            stats_1.sku_group_min_count,
            stats_1.sku_group_preference_count,
            stats_1.sku_group_stock_avg,
            stats_1.sku_group_stock_std,
            stats_1.sku_group_sale_avg,
            stats_1.sku_group_sale_std,
            stats_1.sku_group_spoil_avg,
            stats_1.sku_group_spoil_std,
            stats_1.kiosk_weeks_live,
            stats_1.kiosk_sale_max,
            stats_1.kiosk_stock_avg,
            stats_1.kiosk_stock_std,
            stats_1.kiosk_sale_avg,
            stats_1.kiosk_sale_std,
            stats_1.kiosk_spoil_avg,
            stats_1.kiosk_spoil_std,
            stats_1.d0_plan_demand_ratio,
            stats_1.d1_plan_demand_ratio,
            stats_1.d2_plan_demand_ratio,
            stats_1.d3_plan_demand_ratio,
            stats_1.d4_plan_demand_ratio,
            stats_1.vendor,
            stats_1.sku_shelf_time,
            stats_1.sku_pref_total_kiosk_sku_group,
            stats_1.sku_group_demand,
            stats_1.sku_group_overstock,
            round(public.if((stats_1.sku_pref_total_kiosk_sku_group <> (0)::numeric), (((stats_1.sku_group_demand * (stats_1.enabled)::numeric) * stats_1.sku_preference) / stats_1.sku_pref_total_kiosk_sku_group), 0.00), 2) AS sku_demand,
            round(public.if((stats_1.sku_pref_total_kiosk_sku_group <> (0)::numeric), ((((LEAST(1.00, (7.00 / (stats_1.sku_shelf_time)::numeric)) * stats_1.sku_group_overstock) * (stats_1.enabled)::numeric) * stats_1.sku_preference) / stats_1.sku_pref_total_kiosk_sku_group), 0.00), 2) AS sku_overstock
           FROM ( SELECT stats_2.kiosk_id,
                    stats_2.sku_group,
                    stats_2.sku_group_id,
                    stats_2.sku,
                    stats_2.name,
                    stats_2.enabled,
                    stats_2.sku_sample_size,
                    stats_2.sku_departure_time,
                    stats_2.sku_preference,
                    stats_2.sku_group_sample_size,
                    stats_2.sku_group_preference,
                    stats_2.kiosk_start_level,
                    stats_2.kiosk_min_level,
                    stats_2.kiosk_manual_multiplier,
                    stats_2.sku_group_default_level,
                    stats_2.sku_group_scale,
                    stats_2.kiosk_sku_group_scale,
                    stats_2.sku_group_start_count,
                    stats_2.sku_group_min_count,
                    stats_2.sku_group_preference_count,
                    stats_2.sku_group_stock_avg,
                    stats_2.sku_group_stock_std,
                    stats_2.sku_group_sale_avg,
                    stats_2.sku_group_sale_std,
                    stats_2.sku_group_spoil_avg,
                    stats_2.sku_group_spoil_std,
                    stats_2.kiosk_weeks_live,
                    stats_2.kiosk_sale_max,
                    stats_2.kiosk_stock_avg,
                    stats_2.kiosk_stock_std,
                    stats_2.kiosk_sale_avg,
                    stats_2.kiosk_sale_std,
                    stats_2.kiosk_spoil_avg,
                    stats_2.kiosk_spoil_std,
                    stats_2.d0_plan_demand_ratio,
                    stats_2.d1_plan_demand_ratio,
                    stats_2.d2_plan_demand_ratio,
                    stats_2.d3_plan_demand_ratio,
                    stats_2.d4_plan_demand_ratio,
                    product.vendor,
                    product.shelf_time AS sku_shelf_time,
                    sum(((stats_2.enabled)::numeric * stats_2.sku_preference)) OVER (PARTITION BY stats_2.kiosk_id, stats_2.sku_group) AS sku_pref_total_kiosk_sku_group,
                    stats_2.sku_group_preference_count AS sku_group_demand,
                    GREATEST((public.if((stats_2.kiosk_weeks_live <= 4), GREATEST(stats_2.sku_group_start_count, stats_2.sku_group_preference_count), GREATEST(stats_2.sku_group_min_count, stats_2.sku_group_preference_count)) - stats_2.sku_group_preference_count), 0.00) AS sku_group_overstock
                   FROM (inm.v_kiosk_sku_group_sku_stats stats_2
                     LEFT JOIN pantry.product product ON ((stats_2.sku = product.id)))) stats_1) stats
  GROUP BY stats.sku_group, stats.sku, stats.name, stats.vendor
  ORDER BY stats.sku_group, stats.vendor;


ALTER TABLE inm.v_warehouse_ordering_rec OWNER TO erpuser;

--
-- Name: diff_kiosk_control; Type: TABLE; Schema: inm_restore_0625; Owner: erpuser
--

CREATE TABLE inm_restore_0625.diff_kiosk_control (
    kiosk_id integer,
    start_level numeric(4,2),
    min_level numeric(4,2),
    scale numeric(4,2),
    manual_multiplier numeric(4,2),
    count bigint
);


ALTER TABLE inm_restore_0625.diff_kiosk_control OWNER TO erpuser;

--
-- Name: diff_kiosk_restriction_by_property; Type: TABLE; Schema: inm_restore_0625; Owner: erpuser
--

CREATE TABLE inm_restore_0625.diff_kiosk_restriction_by_property (
    kiosk_id integer,
    property_id integer,
    count bigint
);


ALTER TABLE inm_restore_0625.diff_kiosk_restriction_by_property OWNER TO erpuser;

--
-- Name: diff_kiosk_sku_group_manual_scale; Type: TABLE; Schema: inm_restore_0625; Owner: erpuser
--

CREATE TABLE inm_restore_0625.diff_kiosk_sku_group_manual_scale (
    kiosk_id integer,
    sku_group_id integer,
    scale numeric(4,2),
    count bigint
);


ALTER TABLE inm_restore_0625.diff_kiosk_sku_group_manual_scale OWNER TO erpuser;

--
-- Name: kiosk_control; Type: TABLE; Schema: inm_restore_0625; Owner: erpuser
--

CREATE TABLE inm_restore_0625.kiosk_control (
    kiosk_id integer,
    start_level numeric(4,2),
    min_level numeric(4,2),
    scale numeric(4,2),
    manual_multiplier numeric(4,2)
);


ALTER TABLE inm_restore_0625.kiosk_control OWNER TO erpuser;

--
-- Name: kiosk_control_gs; Type: TABLE; Schema: inm_restore_0625; Owner: erpuser
--

CREATE TABLE inm_restore_0625.kiosk_control_gs (
    kiosk_id integer,
    start_level numeric(4,2),
    min_level numeric(4,2),
    scale numeric(4,2),
    manual_multiplier numeric(4,2)
);


ALTER TABLE inm_restore_0625.kiosk_control_gs OWNER TO erpuser;

--
-- Name: kiosk_restriction_by_property; Type: TABLE; Schema: inm_restore_0625; Owner: erpuser
--

CREATE TABLE inm_restore_0625.kiosk_restriction_by_property (
    kiosk_id integer,
    property_id integer
);


ALTER TABLE inm_restore_0625.kiosk_restriction_by_property OWNER TO erpuser;

--
-- Name: kiosk_restriction_by_property_gs; Type: TABLE; Schema: inm_restore_0625; Owner: erpuser
--

CREATE TABLE inm_restore_0625.kiosk_restriction_by_property_gs (
    kiosk_id integer,
    property_id integer
);


ALTER TABLE inm_restore_0625.kiosk_restriction_by_property_gs OWNER TO erpuser;

--
-- Name: kiosk_sku_group_manual_scale; Type: TABLE; Schema: inm_restore_0625; Owner: erpuser
--

CREATE TABLE inm_restore_0625.kiosk_sku_group_manual_scale (
    kiosk_id integer,
    sku_group_id integer,
    scale numeric(4,2)
);


ALTER TABLE inm_restore_0625.kiosk_sku_group_manual_scale OWNER TO erpuser;

--
-- Name: kiosk_sku_group_manual_scale_gs; Type: TABLE; Schema: inm_restore_0625; Owner: erpuser
--

CREATE TABLE inm_restore_0625.kiosk_sku_group_manual_scale_gs (
    kiosk_id integer,
    sku_group_id integer,
    scale numeric(4,2)
);


ALTER TABLE inm_restore_0625.kiosk_sku_group_manual_scale_gs OWNER TO erpuser;

--
-- Name: product_property; Type: TABLE; Schema: inm_restore_0625; Owner: erpuser
--

CREATE TABLE inm_restore_0625.product_property (
    product_id bigint,
    property_id integer
);


ALTER TABLE inm_restore_0625.product_property OWNER TO erpuser;

--
-- Name: product_property_gs; Type: TABLE; Schema: inm_restore_0625; Owner: erpuser
--

CREATE TABLE inm_restore_0625.product_property_gs (
    product_id bigint,
    property_id integer
);


ALTER TABLE inm_restore_0625.product_property_gs OWNER TO erpuser;

--
-- Name: sku_group_control; Type: TABLE; Schema: inm_restore_0625; Owner: erpuser
--

CREATE TABLE inm_restore_0625.sku_group_control (
    sku_group_id integer,
    default_level numeric(4,2),
    scale numeric(4,2),
    min_qty smallint,
    max_qty smallint
);


ALTER TABLE inm_restore_0625.sku_group_control OWNER TO erpuser;

--
-- Name: sku_group_control_gs; Type: TABLE; Schema: inm_restore_0625; Owner: erpuser
--

CREATE TABLE inm_restore_0625.sku_group_control_gs (
    sku_group_id integer,
    default_level numeric(4,2),
    scale numeric(4,2),
    min_qty smallint,
    max_qty smallint
);


ALTER TABLE inm_restore_0625.sku_group_control_gs OWNER TO erpuser;

--
-- Name: bkup_kiosk_product_disabled; Type: TABLE; Schema: inm_test; Owner: erpuser
--

CREATE TABLE inm_test.bkup_kiosk_product_disabled (
    kiosk_id bigint,
    product_id integer
);


ALTER TABLE inm_test.bkup_kiosk_product_disabled OWNER TO erpuser;

--
-- Name: bkup_kiosk_product_disabled_20190408; Type: TABLE; Schema: inm_test; Owner: erpuser
--

CREATE TABLE inm_test.bkup_kiosk_product_disabled_20190408 (
    kiosk_id bigint,
    product_id bigint
);


ALTER TABLE inm_test.bkup_kiosk_product_disabled_20190408 OWNER TO erpuser;

--
-- Name: bkup_kiosk_restriction_by_product; Type: TABLE; Schema: inm_test; Owner: erpuser
--

CREATE TABLE inm_test.bkup_kiosk_restriction_by_product (
    kiosk_id bigint,
    product_id integer,
    end_date date,
    comment type.text400,
    record_ts timestamp with time zone
);


ALTER TABLE inm_test.bkup_kiosk_restriction_by_product OWNER TO erpuser;

--
-- Name: even_id_id_seq; Type: SEQUENCE; Schema: inm_test; Owner: erpuser
--

CREATE SEQUENCE inm_test.even_id_id_seq
CREATE SEQUENCE inm_test.even_id_id_seq
    START WITH 1
    INCREMENT BY 2
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE inm_test.even_id_id_seq OWNER TO erpuser;

--
-- Name: even_id; Type: TABLE; Schema: inm_test; Owner: erpuser
--

CREATE TABLE inm_test.even_id (
    id integer DEFAULT nextval('inm_test.even_id_id_seq'::regclass) NOT NULL,
    ts timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    comment text
);


ALTER TABLE inm_test.even_id OWNER TO erpuser;

--
-- Name: even_id_seq; Type: SEQUENCE; Schema: inm_test; Owner: erpuser
--

CREATE SEQUENCE inm_test.even_id_seq
CREATE SEQUENCE inm_test.even_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE inm_test.even_id_seq OWNER TO erpuser;

--
-- Name: kiosk_classic_view; Type: VIEW; Schema: inm_test; Owner: erpuser
--

CREATE VIEW inm_test.kiosk_classic_view AS
 SELECT k.id,
    k.campus_id,
    k.serial,
    k.title,
    'fixme'::text AS address,
    addr.location_x,
    addr.location_y,
    hs.gcm_id,
    hs.app_vname,
    hs.app_vcode,
    k.archived,
    k.creation_time,
    k.deployment_time,
    ks.last_update,
    client.name AS client_name,
    ks.last_status,
    ks.last_inventory,
    k.name,
    ka.payment_start,
    ka.payment_stop,
    hs.features,
    ka.sales_tax,
    ka.default_fee_plan,
    addr.timezone,
    k.estd_num_users,
    NULL::text AS tags,
    k.publicly_accessible,
    '-1'::integer AS card_key_required,
    delivery_note.content AS delivery_insns,
    location_note.content AS fridge_loc_info,
    ka.byte_discount,
    ka.subsidy_info,
    ka.subsidy_notes,
    ka.max_subscription,
    hs.components,
    hs.email_receipt_subject,
    ops_note.content AS opt_team_notes,
    k.geo,
    'fixme'::text AS server_url,
    ka.subscription_amount,
    k.enable_reporting,
    k.enable_reporting AS enable_mornitoring,
    client.employees_num,
    kr.restrictions AS kiosk_restrictions
   FROM (((((((((erp.kiosk k
     JOIN erp.address addr ON ((k.id = addr.id)))
     JOIN erp.hardware_software hs ON ((k.id = hs.kiosk_id)))
     LEFT JOIN erp.kiosk_status ks ON ((k.id = ks.kiosk_id)))
     JOIN erp.client client ON ((k.client_id = client.id)))
     JOIN erp.kiosk_accounting ka ON ((k.id = ka.kiosk_id)))
     LEFT JOIN ( SELECT kn.id,
            kn.kiosk_id,
            kn.note_type,
            kn.content,
            kn.start_ts,
            kn.end_ts,
            ga.id,
            ga.name,
            ga.value,
            ga.note
           FROM (erp.kiosk_note kn
             JOIN erp.global_attribute_def ga ON (((kn.note_type = ga.id) AND ((ga.value)::text = 'Delivery Instruction'::text))))) delivery_note(id, kiosk_id, note_type, content, start_ts, end_ts, id_1, name, value, note) ON ((k.id = delivery_note.kiosk_id)))
     LEFT JOIN ( SELECT kn.id,
            kn.kiosk_id,
            kn.note_type,
            kn.content,
            kn.start_ts,
            kn.end_ts,
            ga.id,
            ga.name,
            ga.value,
            ga.note
           FROM (erp.kiosk_note kn
             JOIN erp.global_attribute_def ga ON (((kn.note_type = ga.id) AND ((ga.value)::text = 'Location'::text))))) location_note(id, kiosk_id, note_type, content, start_ts, end_ts, id_1, name, value, note) ON ((k.id = location_note.kiosk_id)))
     LEFT JOIN ( SELECT kn.id,
            kn.kiosk_id,
            kn.note_type,
            kn.content,
            kn.start_ts,
            kn.end_ts,
            ga.id,
            ga.name,
            ga.value,
            ga.note
           FROM (erp.kiosk_note kn
             JOIN erp.global_attribute_def ga ON (((kn.note_type = ga.id) AND ((ga.value)::text = 'OPS'::text))))) ops_note(id, kiosk_id, note_type, content, start_ts, end_ts, id_1, name, value, note) ON ((k.id = ops_note.kiosk_id)))
     LEFT JOIN ( SELECT pp.kiosk_id,
            string_agg(pd.value, ','::text) AS restrictions
           FROM (inm.kiosk_restriction_by_property pp
             JOIN inm.product_property_def pd ON ((pp.property_id = pd.id)))
          GROUP BY pp.kiosk_id) kr ON ((k.id = kr.kiosk_id)));


ALTER TABLE inm_test.kiosk_classic_view OWNER TO erpuser;

--
-- Name: kiosk_par_level; Type: TABLE; Schema: inm_test; Owner: erpuser
--

CREATE TABLE inm_test.kiosk_par_level (
    kiosk_id bigint NOT NULL,
    product_id bigint NOT NULL,
    amount bigint
);


ALTER TABLE inm_test.kiosk_par_level OWNER TO erpuser;

--
-- Name: kiosk_projected_stock; Type: TABLE; Schema: inm_test; Owner: erpuser
--

CREATE TABLE inm_test.kiosk_projected_stock (
    kiosk_id bigint,
    kiosk_title character varying,
    fc_title character varying(765),
    count numeric
);


ALTER TABLE inm_test.kiosk_projected_stock OWNER TO erpuser;

--
-- Name: kiosk_sku_group_manual_scale_20190624; Type: TABLE; Schema: inm_test; Owner: erpuser
--

CREATE TABLE inm_test.kiosk_sku_group_manual_scale_20190624 (
    kiosk_id integer,
    sku_group_id integer,
    scale numeric(4,2)
);


ALTER TABLE inm_test.kiosk_sku_group_manual_scale_20190624 OWNER TO erpuser;

--
-- Name: label; Type: TABLE; Schema: inm_test; Owner: erpuser
--

CREATE TABLE inm_test.label (
    id bigint NOT NULL,
    product_id bigint NOT NULL,
    epc character varying(24) NOT NULL,
    is_generic_sku smallint,
    kiosk_id bigint,
    order_id character varying(45),
    status character varying(4),
    price numeric(6,2),
    cost numeric(6,2),
    time_created bigint,
    time_added bigint,
    time_updated bigint,
    notes text
);


ALTER TABLE inm_test.label OWNER TO erpuser;

--
-- Name: odd_id; Type: TABLE; Schema: inm_test; Owner: erpuser
--

CREATE TABLE inm_test.odd_id (
    id integer NOT NULL,
    ts timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    comment text
);


ALTER TABLE inm_test.odd_id OWNER TO erpuser;

--
-- Name: odd_id_id_seq; Type: SEQUENCE; Schema: inm_test; Owner: erpuser
--

ALTER TABLE inm_test.odd_id ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME inm_test.odd_id_id_seq
    START WITH 1
    INCREMENT BY 2
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: order; Type: TABLE; Schema: inm_test; Owner: erpuser
--

CREATE TABLE inm_test."order" (
    order_id character varying(45) NOT NULL,
    first_name character varying(45),
    last_name character varying(45),
    kiosk_id bigint NOT NULL,
    kiosk_title character varying(46),
    email character varying(127) NOT NULL,
    amount_paid numeric(6,2),
    payment_system character varying(45) NOT NULL,
    transaction_id character varying(45) NOT NULL,
    approval_code character varying(45) NOT NULL,
    status_code character varying(45),
    status_message character varying(45),
    status character varying(45),
    batch_id character varying(15),
    created bigint,
    auth_amount character varying(7),
    data_token character varying(2047),
    time_opened bigint,
    time_closed bigint,
    card_hash character varying(88) NOT NULL,
    state character varying(15) NOT NULL,
    archived bigint,
    stamp bigint NOT NULL,
    last_update bigint,
    balance numeric(7,2),
    delta character varying(4),
    coupon_id bigint,
    coupon character varying(45),
    refund numeric(6,2) NOT NULL,
    receipt bigint NOT NULL,
    campus_id bigint NOT NULL,
    amount_list_price numeric(6,2),
    notes text,
    time_door_opened bigint,
    time_door_closed bigint
);


ALTER TABLE inm_test."order" OWNER TO erpuser;

--
-- Name: pick_allocation; Type: TABLE; Schema: inm_test; Owner: erpuser
--

CREATE TABLE inm_test.pick_allocation (
    pick_date date NOT NULL,
    route_date date NOT NULL,
    kiosk_id integer NOT NULL,
    sku_id integer NOT NULL,
    qty integer NOT NULL
);


ALTER TABLE inm_test.pick_allocation OWNER TO erpuser;

--
-- Name: pick_demand; Type: TABLE; Schema: inm_test; Owner: erpuser
--

CREATE TABLE inm_test.pick_demand (
    pick_date date NOT NULL,
    route_date date NOT NULL,
    kiosk_id integer NOT NULL,
    sku_group_id integer NOT NULL,
    qty integer NOT NULL
);


ALTER TABLE inm_test.pick_demand OWNER TO erpuser;

--
-- Name: pick_inventory; Type: TABLE; Schema: inm_test; Owner: erpuser
--

CREATE TABLE inm_test.pick_inventory (
    pick_date date NOT NULL,
    route_date date NOT NULL,
    kiosk_id integer NOT NULL,
    sku_group_id integer NOT NULL,
    qty integer NOT NULL
);


ALTER TABLE inm_test.pick_inventory OWNER TO erpuser;

--
-- Name: pick_rejection; Type: TABLE; Schema: inm_test; Owner: erpuser
--

CREATE TABLE inm_test.pick_rejection (
    pick_date date NOT NULL,
    route_date date NOT NULL,
    kiosk_id integer NOT NULL,
    item_id integer NOT NULL,
    item_type character varying(32) NOT NULL,
    reason character varying(64) NOT NULL
);


ALTER TABLE inm_test.pick_rejection OWNER TO erpuser;

--
-- Name: pick_route; Type: TABLE; Schema: inm_test; Owner: erpuser
--

CREATE TABLE inm_test.pick_route (
    pick_date date NOT NULL,
    kiosk_id integer NOT NULL,
    route_number character varying(256),
    driver_name character varying(64) NOT NULL,
    route_time time(6) without time zone NOT NULL,
    route_date date NOT NULL,
    delivery_order smallint NOT NULL
);


ALTER TABLE inm_test.pick_route OWNER TO erpuser;

--
-- Name: pick_substitution; Type: TABLE; Schema: inm_test; Owner: erpuser
--

CREATE TABLE inm_test.pick_substitution (
    substituting_sku_group_id integer NOT NULL,
    substituted_sku_group_id integer NOT NULL,
    qty integer NOT NULL,
    pick_date date NOT NULL
);


ALTER TABLE inm_test.pick_substitution OWNER TO erpuser;

--
-- Name: route_stop_20190616; Type: TABLE; Schema: inm_test; Owner: erpuser
--

CREATE TABLE inm_test.route_stop_20190616 (
    route_date_time timestamp(6) with time zone,
    driver_name character varying(200),
    location_name character varying(200),
    schedule_at timestamp(6) with time zone,
    longitude numeric(28,6),
    address character varying(200),
    latitude numeric(28,6),
    stop_number integer,
    order_number character varying(200),
    location_number integer
);


ALTER TABLE inm_test.route_stop_20190616 OWNER TO erpuser;

--
-- Name: temp_a; Type: TABLE; Schema: inm_test; Owner: erpuser
--

CREATE TABLE inm_test.temp_a (
    id integer NOT NULL,
    name text
);


ALTER TABLE inm_test.temp_a OWNER TO erpuser;

--
-- Name: temp_b; Type: TABLE; Schema: inm_test; Owner: erpuser
--

CREATE TABLE inm_test.temp_b (
    id integer NOT NULL,
    name text
);


ALTER TABLE inm_test.temp_b OWNER TO erpuser;

--
-- Name: temp_kiosk; Type: TABLE; Schema: inm_test; Owner: erpuser
--

CREATE TABLE inm_test.temp_kiosk (
    id bigint NOT NULL,
    campus_id bigint NOT NULL,
    serial character varying(45) NOT NULL,
    title character varying(46),
    address character varying(127),
    location_x numeric(9,6) NOT NULL,
    location_y numeric(9,6) NOT NULL,
    gcm_id character varying(255),
    app_vname character varying(63),
    app_vcode integer,
    archived bigint,
    creation_time bigint,
    deployment_time bigint,
    last_update bigint,
    client_name character varying(255),
    last_status bigint,
    last_inventory bigint NOT NULL,
    kiosk_name character varying(255) NOT NULL,
    payment_start bigint,
    payment_stop bigint,
    features character varying(255) NOT NULL,
    sales_tax smallint NOT NULL,
    default_fee_plan bigint NOT NULL,
    timezone character varying(50),
    estd_num_users bigint,
    tags character varying(255),
    publicly_accessible bigint,
    cardkey_required bigint,
    delivery_insns character varying(65535),
    fridge_loc_info character varying(65535),
    contact_first_name character varying(65535),
    contact_last_name character varying(65535),
    contact_email character varying(65535),
    contact_phone character varying(65535),
    accounting_email character varying(65535),
    byte_discount character varying(255),
    subsidy_info character varying(50),
    subsidy_notes character varying(65535),
    max_subscription character varying(50),
    delivery_window_mon character varying(50),
    delivery_window_tue character varying(50),
    delivery_window_wed character varying(50),
    delivery_window_thu character varying(50),
    delivery_window_fri character varying(50),
    delivery_window_sat character varying(50),
    delivery_window_sun character varying(50),
    notes character varying(2000),
    components text,
    email_receipt_subject character varying(255),
    ops_team_notes character varying(65535),
    geo character varying(3),
    server_url character varying(127),
    subscription_amount numeric(8,2) NOT NULL,
    enable_reporting bigint,
    enable_monitoring bigint,
    employees_num bigint,
    kiosk_restrictions character varying(2000)
);


ALTER TABLE inm_test.temp_kiosk OWNER TO erpuser;

--
-- Name: temp_test; Type: TABLE; Schema: inm_test; Owner: erpuser
--

CREATE TABLE inm_test.temp_test (
    id integer NOT NULL
);


ALTER TABLE inm_test.temp_test OWNER TO erpuser;

--
-- Name: test; Type: TABLE; Schema: inm_test; Owner: erpuser
--

CREATE TABLE inm_test.test (
    id integer NOT NULL
);


ALTER TABLE inm_test.test OWNER TO erpuser;

--
-- Name: test2; Type: TABLE; Schema: inm_test; Owner: erpuser
--

CREATE TABLE inm_test.test2 (
    id integer NOT NULL,
    intval integer,
    strval text
);


ALTER TABLE inm_test.test2 OWNER TO erpuser;

--
-- Name: test_sequence; Type: TABLE; Schema: inm_test; Owner: erpuser
--

CREATE TABLE inm_test.test_sequence (
    id integer NOT NULL,
    name text
);


ALTER TABLE inm_test.test_sequence OWNER TO erpuser;

--
-- Name: test_sequence_id_seq; Type: SEQUENCE; Schema: inm_test; Owner: erpuser
--

ALTER TABLE inm_test.test_sequence ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME inm_test.test_sequence_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: kiosk; Type: TABLE; Schema: migration; Owner: erpuser
--

CREATE TABLE migration.kiosk (
    id bigint NOT NULL,
    campus_id bigint NOT NULL,
    serial character varying(45) NOT NULL,
    title character varying(46),
    address character varying(127),
    location_x numeric(9,6) NOT NULL,
    location_y numeric(9,6) NOT NULL,
    gcm_id character varying(255),
    app_vname character varying(63),
    app_vcode integer,
    archived bigint,
    creation_time bigint,
    deployment_time bigint,
    last_update bigint,
    client_name character varying(255),
    last_status bigint,
    last_inventory bigint NOT NULL,
    kiosk_name character varying(255) NOT NULL,
    payment_start bigint,
    payment_stop bigint,
    features character varying(255) NOT NULL,
    sales_tax smallint NOT NULL,
    default_fee_plan bigint NOT NULL,
    timezone character varying(50),
    estd_num_users bigint,
    tags character varying(255),
    publicly_accessible bigint,
    cardkey_required bigint,
    delivery_insns character varying(65535),
    fridge_loc_info character varying(65535),
    contact_first_name character varying(65535),
    contact_last_name character varying(65535),
    contact_email character varying(65535),
    contact_phone character varying(65535),
    accounting_email character varying(65535),
    byte_discount character varying(255),
    subsidy_info character varying(50),
    subsidy_notes character varying(65535),
    max_subscription character varying(50),
    delivery_window_mon character varying(50),
    delivery_window_tue character varying(50),
    delivery_window_wed character varying(50),
    delivery_window_thu character varying(50),
    delivery_window_fri character varying(50),
    delivery_window_sat character varying(50),
    delivery_window_sun character varying(50),
    notes character varying(2000),
    components text,
    email_receipt_subject character varying(255),
    ops_team_notes character varying(65535),
    geo character varying(3),
    server_url character varying(127),
    subscription_amount numeric(8,2) NOT NULL,
    enable_reporting bigint,
    enable_monitoring bigint,
    employees_num bigint,
    kiosk_restrictions character varying(2000)
);


ALTER TABLE migration.kiosk OWNER TO erpuser;

--
-- Name: kiosk_dest_to_match; Type: VIEW; Schema: migration; Owner: erpuser
--

CREATE VIEW migration.kiosk_dest_to_match AS
 SELECT kiosk_classic_view.id,
    kiosk_classic_view.campus_id,
    kiosk_classic_view.serial,
    kiosk_classic_view.title,
    kiosk_classic_view.gcm_id,
    kiosk_classic_view.app_vname,
    kiosk_classic_view.app_vcode,
    kiosk_classic_view.archived,
    kiosk_classic_view.creation_time,
    kiosk_classic_view.deployment_time,
    kiosk_classic_view.last_update,
    kiosk_classic_view.last_status,
    kiosk_classic_view.last_inventory,
    kiosk_classic_view.kiosk_name,
    kiosk_classic_view.features,
    kiosk_classic_view.sales_tax,
    kiosk_classic_view.default_fee_plan,
    kiosk_classic_view.estd_num_users,
    kiosk_classic_view.publicly_accessible,
    kiosk_classic_view.delivery_insns,
    kiosk_classic_view.fridge_loc_info,
    kiosk_classic_view.byte_discount,
    kiosk_classic_view.subsidy_info,
    kiosk_classic_view.subsidy_notes,
    kiosk_classic_view.max_subscription,
    kiosk_classic_view.components,
    kiosk_classic_view.email_receipt_subject,
    kiosk_classic_view.ops_team_notes,
    kiosk_classic_view.geo,
    kiosk_classic_view.server_url,
    kiosk_classic_view.subscription_amount,
    kiosk_classic_view.enable_reporting
   FROM erp.kiosk_classic_view;


ALTER TABLE migration.kiosk_dest_to_match OWNER TO erpuser;

--
-- Name: kiosk_source_to_match; Type: VIEW; Schema: migration; Owner: erpuser
--

CREATE VIEW migration.kiosk_source_to_match AS
 SELECT kiosk.id,
    kiosk.campus_id,
    kiosk.serial,
    kiosk.title,
    kiosk.gcm_id,
    kiosk.app_vname,
    kiosk.app_vcode,
    kiosk.archived,
    kiosk.creation_time,
    kiosk.deployment_time,
    kiosk.last_update,
    kiosk.last_status,
    kiosk.last_inventory,
    kiosk.kiosk_name,
    kiosk.features,
    kiosk.sales_tax,
    kiosk.default_fee_plan,
    kiosk.estd_num_users,
    kiosk.publicly_accessible,
    kiosk.delivery_insns,
    kiosk.fridge_loc_info,
    kiosk.byte_discount,
    kiosk.subsidy_info,
    kiosk.subsidy_notes,
    kiosk.max_subscription,
    kiosk.components,
    kiosk.email_receipt_subject,
    kiosk.ops_team_notes,
    kiosk.geo,
    kiosk.server_url,
    kiosk.subscription_amount,
    kiosk.enable_reporting
   FROM pantry.kiosk;


ALTER TABLE migration.kiosk_source_to_match OWNER TO erpuser;

--
-- Name: product; Type: TABLE; Schema: migration; Owner: erpuser
--

CREATE TABLE migration.product (
    id bigint NOT NULL,
    title character varying(127) NOT NULL,
    description character varying(4095),
    tiny_description character varying(40),
    short_description character varying(100),
    medium_description character varying(400),
    long_description character varying(1200),
    price numeric(5,2) NOT NULL,
    cost numeric(5,2) NOT NULL,
    shelf_time integer NOT NULL,
    campus_id bigint NOT NULL,
    image smallint NOT NULL,
    image_time bigint,
    last_update bigint NOT NULL,
    archived bigint,
    taxable smallint,
    allergens character varying(255),
    attribute_names character varying(511),
    categories character varying(255),
    category_names character varying(511),
    vendor character varying(135),
    source character varying(135),
    notes character varying(2000),
    total_cal bigint,
    num_servings real,
    ingredients character varying(2000),
    calories real,
    proteins real,
    sugar real,
    carbohydrates real,
    fat real,
    consumer_category character varying(2000),
    ws_case_size bigint,
    kiosk_ship_qty bigint,
    ws_case_cost numeric(5,2),
    pick_station bigint,
    fc_title character varying(255),
    pricing_tier character varying(255),
    width_space real,
    height_space real,
    depth_space real,
    slotted_width real,
    tag_volume bigint,
    delivery_option character varying(255),
    tag_applied_by character varying(255)
);


ALTER TABLE migration.product OWNER TO erpuser;

--
-- Name: reverse_product; Type: TABLE; Schema: migration; Owner: erpuser
--

CREATE TABLE migration.reverse_product (
    id bigint NOT NULL,
    title character varying(127) NOT NULL,
    description character varying(4095),
    tiny_description character varying(40),
    short_description character varying(100),
    medium_description character varying(400),
    long_description character varying(1200),
    price numeric(5,2) NOT NULL,
    cost numeric(5,2) NOT NULL,
    shelf_time integer NOT NULL,
    campus_id bigint NOT NULL,
    image smallint NOT NULL,
    image_time bigint,
    last_update bigint NOT NULL,
    archived bigint,
    taxable smallint,
    allergens character varying(255),
    attribute_names character varying(511),
    categories character varying(255),
    category_names character varying(511),
    vendor character varying(135),
    source character varying(135),
    notes character varying(2000),
    total_cal bigint,
    num_servings real,
    ingredients character varying(2000),
    calories real,
    proteins real,
    sugar real,
    carbohydrates real,
    fat real,
    consumer_category character varying(2000),
    ws_case_size bigint,
    kiosk_ship_qty bigint,
    ws_case_cost numeric(5,2),
    pick_station bigint,
    fc_title character varying(255),
    pricing_tier character varying(255),
    width_space real,
    height_space real,
    depth_space real,
    slotted_width real,
    tag_volume bigint,
    delivery_option character varying(255),
    tag_applied_by character varying(255)
);


ALTER TABLE migration.reverse_product OWNER TO erpuser;

--
-- Name: sync_qa_product_dest; Type: VIEW; Schema: migration; Owner: erpuser
--

CREATE VIEW migration.sync_qa_product_dest AS
 SELECT product_classic_view.id,
    product_classic_view.title,
    product_classic_view.description,
    product_classic_view.tiny_description,
    product_classic_view.short_description,
    product_classic_view.medium_description,
    product_classic_view.long_description,
    product_classic_view.price,
    product_classic_view.cost,
    product_classic_view.shelf_time,
    product_classic_view.campus_id,
    product_classic_view.image_time,
    product_classic_view.last_update,
    product_classic_view.archived,
    product_classic_view.taxable,
    product_classic_view.vendor,
    product_classic_view.source,
    product_classic_view.total_cal,
    product_classic_view.num_servings,
    product_classic_view.ingredients,
    product_classic_view.calories,
    product_classic_view.proteins,
    product_classic_view.sugar,
    product_classic_view.carbohydrates,
    product_classic_view.fat,
    product_classic_view.consumer_category,
    product_classic_view.ws_case_size,
    product_classic_view.kiosk_ship_qty,
    product_classic_view.ws_case_cost,
    product_classic_view.pick_station,
    product_classic_view.fc_title,
    product_classic_view.pricing_tier,
    product_classic_view.width_space,
    product_classic_view.height_space,
    product_classic_view.depth_space,
    product_classic_view.slotted_width,
    product_classic_view.tag_volume,
    product_classic_view.delivery_option,
    product_classic_view.tag_applied_by
   FROM erp.product_classic_view;


ALTER TABLE migration.sync_qa_product_dest OWNER TO erpuser;

--
-- Name: sync_qa_product_source; Type: VIEW; Schema: migration; Owner: erpuser
--

CREATE VIEW migration.sync_qa_product_source AS
 SELECT product.id,
    product.title,
    product.description,
    product.tiny_description,
    product.short_description,
    product.medium_description,
    product.long_description,
    product.price,
    product.cost,
    product.shelf_time,
    product.campus_id,
    product.image_time,
    product.last_update,
    product.archived,
    product.taxable,
    product.vendor,
    product.source,
    product.total_cal,
    product.num_servings,
    product.ingredients,
    product.calories,
    product.proteins,
    product.sugar,
    product.carbohydrates,
    product.fat,
    product.consumer_category,
    product.ws_case_size,
    product.kiosk_ship_qty,
    product.ws_case_cost,
    product.pick_station,
    product.fc_title,
    product.pricing_tier,
    product.width_space,
    product.height_space,
    product.depth_space,
    product.slotted_width,
    product.tag_volume,
    product.delivery_option,
    product.tag_applied_by
   FROM pantry.product;


ALTER TABLE migration.sync_qa_product_source OWNER TO erpuser;

--
-- Name: temp_product; Type: TABLE; Schema: migration; Owner: erpuser
--

CREATE TABLE migration.temp_product (
    id bigint NOT NULL,
    title character varying(127) NOT NULL,
    description character varying(4095),
    tiny_description character varying(40),
    short_description character varying(100),
    medium_description character varying(400),
    long_description character varying(1200),
    price numeric(5,2) NOT NULL,
    cost numeric(5,2) NOT NULL,
    shelf_time integer NOT NULL,
    campus_id bigint NOT NULL,
    image smallint NOT NULL,
    image_time bigint,
    last_update bigint NOT NULL,
    archived bigint,
    taxable smallint,
    allergens character varying(255),
    attribute_names character varying(511),
    categories character varying(255),
    category_names character varying(511),
    vendor character varying(135),
    source character varying(135),
    notes character varying(2000),
    total_cal bigint,
    num_servings real,
    ingredients character varying(2000),
    calories real,
    proteins real,
    sugar real,
    carbohydrates real,
    fat real,
    consumer_category character varying(2000),
    ws_case_size bigint,
    kiosk_ship_qty bigint,
    ws_case_cost numeric(5,2),
    pick_station bigint,
    fc_title character varying(255),
    pricing_tier character varying(255),
    width_space real,
    height_space real,
    depth_space real,
    slotted_width real,
    tag_volume bigint,
    delivery_option character varying(255),
    tag_applied_by character varying(255)
);


ALTER TABLE migration.temp_product OWNER TO erpuser;

--
-- Name: v_product; Type: VIEW; Schema: migration; Owner: erpuser
--

CREATE VIEW migration.v_product AS
 SELECT p.id,
    pa.title,
    pa.description,
    pa.tiny_description,
    pa.short_description,
    pa.medium_description,
    pa.long_description,
    pp.price,
    pp.cost,
    pn.shelf_time,
    p.campus_id,
    COALESCE((pa.image)::integer, 0) AS "coalesce",
    pa.image_time,
    p.last_update,
    p.archived,
    pp.taxable,
    'fixme'::text AS allergens,
    'fixme'::text AS attribute_names,
    'fixme'::text AS categories,
    'fixme'::text AS category_names,
    ps.vendor,
    ps.source,
    'fixme'::text AS notes,
    pn.total_cal,
    pn.num_servings,
    pn.ingredients,
    pn.calories,
    pn.proteins,
    pn.sugar,
    pn.carbohydrates,
    pn.fat,
    'fixme'::text AS consumer_category,
    ph.ws_case_size,
    ph.kiosk_ship_qty,
    pp.ws_case_cost,
    ph.pick_station
   FROM (((((erp.product p
     JOIN erp.product_asset pa ON ((p.id = pa.product_id)))
     JOIN erp.product_pricing pp ON ((p.id = pp.product_id)))
     JOIN erp.product_nutrition pn ON ((p.id = pn.product_id)))
     JOIN erp.product_sourcing ps ON ((p.id = ps.product_id)))
     JOIN erp.product_handling ph ON ((p.id = ph.product_id)));


ALTER TABLE migration.v_product OWNER TO erpuser;

--
-- Name: card_product_fact; Type: TABLE; Schema: mixalot; Owner: erpuser
--

CREATE TABLE mixalot.card_product_fact (
    id integer NOT NULL,
    card_hash text,
    product_id integer,
    sku text,
    first_available_ts timestamp(6) with time zone,
    first_purchased_ts timestamp(6) with time zone,
    acc_sales_1w double precision,
    acc_sales_30d double precision,
    acc_sales_6m double precision,
    avg_item_price double precision,
    avg_item_discount double precision,
    cnt_purchases_lt integer,
    cnt_purchased_30d integer,
    cnt_purchased_6m integer,
    cnt_purchased_1y integer,
    prob_purch_first double precision,
    prob_purch_again double precision,
    number_not_purchased_before_1st integer,
    number_available_lt integer,
    number_not_purchased_lt integer,
    number_available_after_1st integer,
    number_not_purchased_after_1st integer,
    number_stockouts_after_1st integer
);


ALTER TABLE mixalot.card_product_fact OWNER TO erpuser;

--
-- Name: card_product_fact_id_seq; Type: SEQUENCE; Schema: mixalot; Owner: erpuser
--

CREATE SEQUENCE mixalot.card_product_fact_id_seq
CREATE SEQUENCE mixalot.card_product_fact_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE mixalot.card_product_fact_id_seq OWNER TO erpuser;

--
-- Name: card_product_fact_id_seq; Type: SEQUENCE OWNED BY; Schema: mixalot; Owner: erpuser
--

ALTER SEQUENCE mixalot.card_product_fact_id_seq OWNED BY mixalot.card_product_fact.id;


--
-- Name: gsheet_cache; Type: TABLE; Schema: mixalot; Owner: erpuser
--

CREATE TABLE mixalot.gsheet_cache (
    id character varying(50) NOT NULL,
    update_d timestamp(6) with time zone,
    email_count integer,
    email_json text,
    payload json
);


ALTER TABLE mixalot.gsheet_cache OWNER TO erpuser;

--
-- Name: history_order_pipeline; Type: TABLE; Schema: mixalot; Owner: erpuser
--

CREATE TABLE mixalot.history_order_pipeline (
    id integer NOT NULL,
    order_id character varying(45),
    action character varying(45),
    system character varying(45),
    "user" character varying(45),
    data text,
    ts timestamp(6) with time zone
);


ALTER TABLE mixalot.history_order_pipeline OWNER TO erpuser;

--
-- Name: history_order_pipeline_id_seq; Type: SEQUENCE; Schema: mixalot; Owner: erpuser
--

CREATE SEQUENCE mixalot.history_order_pipeline_id_seq
CREATE SEQUENCE mixalot.history_order_pipeline_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE mixalot.history_order_pipeline_id_seq OWNER TO erpuser;

--
-- Name: history_order_pipeline_id_seq; Type: SEQUENCE OWNED BY; Schema: mixalot; Owner: erpuser
--

ALTER SEQUENCE mixalot.history_order_pipeline_id_seq OWNED BY mixalot.history_order_pipeline.id;


--
-- Name: inm_data; Type: TABLE; Schema: mixalot; Owner: erpuser
--

CREATE TABLE mixalot.inm_data (
    id integer NOT NULL,
    import_ts timestamp(6) with time zone,
    kiosk_id integer,
    product_id integer,
    fc_title text,
    qty integer,
    data_type text,
    route_date timestamp(6) with time zone,
    route_name text,
    route_time text,
    driver_name text,
    refrigerated smallint,
    sort_order integer
);


ALTER TABLE mixalot.inm_data OWNER TO erpuser;

--
-- Name: inm_data_id_seq; Type: SEQUENCE; Schema: mixalot; Owner: erpuser
--

CREATE SEQUENCE mixalot.inm_data_id_seq
CREATE SEQUENCE mixalot.inm_data_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE mixalot.inm_data_id_seq OWNER TO erpuser;

--
-- Name: inm_data_id_seq; Type: SEQUENCE OWNED BY; Schema: mixalot; Owner: erpuser
--

ALTER SEQUENCE mixalot.inm_data_id_seq OWNED BY mixalot.inm_data.id;


--
-- Name: inm_kiosk_projected_stock; Type: VIEW; Schema: mixalot; Owner: erpuser
--

CREATE VIEW mixalot.inm_kiosk_projected_stock AS
 SELECT combined_stock.kiosk_id,
    combined_stock.kiosk_title,
    combined_stock.fc_title,
    sum(combined_stock.qty) AS count
   FROM ( SELECT l.kiosk_id,
            k.title AS kiosk_title,
            p.fc_title,
            count(l.epc) AS qty
           FROM ((pantry.label l
             JOIN pantry.product p ON ((l.product_id = p.id)))
             JOIN pantry.kiosk k ON ((l.kiosk_id = k.id)))
          WHERE (((l.status)::text ~~ 'ok'::text) AND (k.campus_id = 87) AND (k.enable_reporting = 1) AND (k.archived <> 1))
          GROUP BY l.kiosk_id, k.title, p.fc_title
        UNION ALL
         SELECT a.kiosk_id,
            k.title AS kiosk_title,
            p.fc_title,
            a.qty
           FROM (((inm.pick_allocation a
             LEFT JOIN pantry."order" o ON (((a.route_date = (to_timestamp((o.created)::double precision))::date) AND (a.kiosk_id = o.kiosk_id) AND ((o.payment_system)::text = 'Restocking'::text))))
             JOIN pantry.product p ON ((a.sku_id = p.id)))
             JOIN pantry.kiosk k ON ((a.kiosk_id = k.id)))
          WHERE ((a.route_date >= ('now'::text)::date) AND (a.pick_date = (('now'::text)::date - 1)) AND (o.kiosk_id IS NULL))
        UNION ALL
         SELECT pl.kiosk_id,
            pl.kiosk_title,
            p.fc_title,
            count(*) AS qty
           FROM (inm.get_spoilage_pull_list() pl(category, kiosk_id, kiosk_title, product_id, product_tile, epc)
             JOIN pantry.product p ON ((pl.product_id = p.id)))
          GROUP BY pl.kiosk_id, pl.kiosk_title, p.fc_title) combined_stock
  WHERE (combined_stock.fc_title IS NOT NULL)
  GROUP BY combined_stock.kiosk_id, combined_stock.kiosk_title, combined_stock.fc_title;


ALTER TABLE mixalot.inm_kiosk_projected_stock OWNER TO erpuser;

--
-- Name: merchandising_slot_sku_group; Type: TABLE; Schema: mixalot; Owner: erpuser
--

CREATE TABLE mixalot.merchandising_slot_sku_group (
    sku_group_id integer NOT NULL,
    merchandising_slot_id integer NOT NULL
);


ALTER TABLE mixalot.merchandising_slot_sku_group OWNER TO erpuser;

--
-- Name: sku_group_def; Type: TABLE; Schema: mixalot; Owner: erpuser
--

CREATE TABLE mixalot.sku_group_def (
    id integer NOT NULL,
    title character varying(512) NOT NULL,
    volume numeric(4,2)
);


ALTER TABLE mixalot.sku_group_def OWNER TO erpuser;

--
-- Name: inm_sku_group_title_to_merchandising_slot; Type: VIEW; Schema: mixalot; Owner: erpuser
--

CREATE VIEW mixalot.inm_sku_group_title_to_merchandising_slot AS
 SELECT sgd.title AS sku_group_title,
    mssg.merchandising_slot_id
   FROM (mixalot.merchandising_slot_sku_group mssg
     JOIN mixalot.sku_group_def sgd ON ((mssg.sku_group_id = sgd.id)))
  ORDER BY mssg.merchandising_slot_id;


ALTER TABLE mixalot.inm_sku_group_title_to_merchandising_slot OWNER TO erpuser;

--
-- Name: inm_sku_velocity; Type: VIEW; Schema: mixalot; Owner: erpuser
--

CREATE VIEW mixalot.inm_sku_velocity AS
 SELECT t3.kiosk_id,
    t3.sku_group,
    t3.sku,
    t3.name,
    count(t3.purchase_index) AS sample_size,
    round(avg(t3.departure_time), 2) AS dt_avg,
    COALESCE(round(stddev(t3.departure_time), 2), (0)::numeric) AS dt_std,
    round((sum((t3.departure_time * (t3.w)::numeric)) / (sum(t3.w))::numeric), 2) AS w_departure_time,
    LEAST(round((1.00 / (sum((t3.departure_time * (t3.w)::numeric)) / (sum(t3.w))::numeric)), 2), 0.20) AS preference
   FROM ( SELECT t2.kiosk_id,
            t2.sku_group,
            t2.sku,
            t2.name,
            t2.time_stocked,
            t2.time_sold,
            t2.purchase_index,
            t2.last_sale,
            t2.last_purchase_index,
            GREATEST(COALESCE(round((((t2.time_sold - GREATEST(t2.last_sale, t2.time_stocked)))::numeric / (3600)::numeric), 2), 50.00), 1.00) AS departure_time,
            0 AS qty_sold,
            1 AS w
           FROM ( SELECT t1.kiosk_id,
                    t1.sku_group,
                    t1.sku,
                    t1.name,
                    t1.time_stocked,
                    t1.time_sold,
                    t1.purchase_index,
                    lag(t1.time_sold, 1) OVER (PARTITION BY t1.kiosk_id, t1.sku ORDER BY t1.time_sold) AS last_sale,
                    lag(t1.purchase_index, 1) OVER (PARTITION BY t1.kiosk_id, t1.sku ORDER BY t1.time_sold) AS last_purchase_index
                   FROM ( SELECT k.kiosk_id,
                            p.sku_group,
                            p.sku,
                            p.name,
                            l.time_stocked,
                            l.time_sold,
                            l.purchase_index
                           FROM ((( SELECT k_1.id AS kiosk_id
                                   FROM pantry.kiosk k_1
                                  WHERE ((k_1.campus_id = 87) AND (k_1.archived = 0) AND (k_1.enable_reporting = 1))) k
                             CROSS JOIN ( SELECT p_1.fc_title AS sku_group,
                                    p_1.id AS sku,
                                    p_1.title AS name
                                   FROM pantry.product p_1
                                  WHERE ((p_1.campus_id = 87) AND (p_1.archived = 0) AND ((p_1.fc_title)::text <> 'N/A'::text) AND (p_1.fc_title IS NOT NULL))
                                  ORDER BY p_1.fc_title, p_1.id) p)
                             LEFT JOIN ( SELECT l_1.kiosk_id,
                                    p_1.fc_title AS sku_group,
                                    p_1.id AS sku,
                                    l_1.time_created AS time_stocked,
                                    l_1.time_updated AS time_sold,
                                    row_number() OVER (PARTITION BY l_1.kiosk_id ORDER BY l_1.time_updated) AS purchase_index
                                   FROM (pantry.label l_1
                                     JOIN pantry.product p_1 ON ((l_1.product_id = p_1.id)))
                                  WHERE ((l_1.kiosk_id IS NOT NULL) AND ((l_1.status)::text = 'sold'::text) AND (timezone('US/Pacific'::text, to_timestamp((l_1.time_updated)::double precision)) > (date_trunc('week'::text, CURRENT_TIMESTAMP) - '168 days'::interval)) AND (p_1.campus_id = 87) AND (p_1.archived = 0) AND ((p_1.fc_title)::text <> 'N/A'::text) AND (p_1.fc_title IS NOT NULL))) l ON (((k.kiosk_id = l.kiosk_id) AND (p.sku = l.sku))))
                          ORDER BY k.kiosk_id, p.sku_group, p.sku, l.purchase_index) t1) t2) t3
  GROUP BY t3.kiosk_id, t3.sku_group, t3.sku, t3.name
  ORDER BY t3.kiosk_id, t3.sku_group, t3.sku;


ALTER TABLE mixalot.inm_sku_velocity OWNER TO erpuser;

--
-- Name: kiosk_contents; Type: TABLE; Schema: mixalot; Owner: erpuser
--

CREATE TABLE mixalot.kiosk_contents (
    id integer NOT NULL,
    product_id integer,
    quantity integer,
    "time" bigint
);


ALTER TABLE mixalot.kiosk_contents OWNER TO erpuser;

--
-- Name: kiosk_contents_id_seq; Type: SEQUENCE; Schema: mixalot; Owner: erpuser
--

CREATE SEQUENCE mixalot.kiosk_contents_id_seq
CREATE SEQUENCE mixalot.kiosk_contents_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE mixalot.kiosk_contents_id_seq OWNER TO erpuser;

--
-- Name: kiosk_contents_id_seq; Type: SEQUENCE OWNED BY; Schema: mixalot; Owner: erpuser
--

ALTER SEQUENCE mixalot.kiosk_contents_id_seq OWNED BY mixalot.kiosk_contents.id;


--
-- Name: kiosk_fact; Type: TABLE; Schema: mixalot; Owner: erpuser
--

CREATE TABLE mixalot.kiosk_fact (
    id integer NOT NULL,
    kiosk_id integer,
    kiosk_title text,
    campus_id integer,
    serials text,
    current_serial text,
    archived integer,
    last_delivery_ts timestamp(6) with time zone,
    last_purchase_ts timestamp(6) with time zone,
    cnt_deliveries_1w double precision,
    cnt_deliveries_30d double precision,
    cnt_deliveries_6m double precision,
    acc_list_price_1w double precision,
    acc_list_price_30d double precision,
    acc_list_price_6m double precision,
    cnt_orders_1w double precision,
    cnt_orders_30d double precision,
    cnt_orders_6m double precision,
    cnt_unique_cards_1w double precision,
    cnt_unique_cards_30d double precision,
    cnt_unique_cards_6m double precision
);


ALTER TABLE mixalot.kiosk_fact OWNER TO erpuser;

--
-- Name: kiosk_fact_id_seq; Type: SEQUENCE; Schema: mixalot; Owner: erpuser
--

CREATE SEQUENCE mixalot.kiosk_fact_id_seq
CREATE SEQUENCE mixalot.kiosk_fact_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE mixalot.kiosk_fact_id_seq OWNER TO erpuser;

--
-- Name: kiosk_fact_id_seq; Type: SEQUENCE OWNED BY; Schema: mixalot; Owner: erpuser
--

ALTER SEQUENCE mixalot.kiosk_fact_id_seq OWNED BY mixalot.kiosk_fact.id;


--
-- Name: last_kiosk_status; Type: VIEW; Schema: mixalot; Owner: erpuser
--

CREATE VIEW mixalot.last_kiosk_status AS
 SELECT last_kiosk_status.id,
    last_kiosk_status.kiosk_id,
    last_kiosk_status.kiosk_temperature,
    last_kiosk_status.kiosk_temperature_count,
    last_kiosk_status.kit_temperature,
    last_kiosk_status.temperature_tags,
    last_kiosk_status.kiosk_temperature_source,
    last_kiosk_status.power,
    last_kiosk_status.battery_level,
    last_kiosk_status.rfid_0,
    last_kiosk_status.rfid_1,
    last_kiosk_status.rfid_2,
    last_kiosk_status.rfid_3,
    last_kiosk_status.rfid_4,
    last_kiosk_status.rfid_5,
    last_kiosk_status.rfid_6,
    last_kiosk_status.rfid_7,
    last_kiosk_status."time",
    last_kiosk_status.modem_signal_percentage,
    last_kiosk_status.modem_signal_type,
    last_kiosk_status.ip,
    last_kiosk_status.app_uptime,
    last_kiosk_status.system_uptime,
    last_kiosk_status.is_locked
   FROM pantry.last_kiosk_status;


ALTER TABLE mixalot.last_kiosk_status OWNER TO erpuser;

--
-- Name: log; Type: TABLE; Schema: mixalot; Owner: erpuser
--

CREATE TABLE mixalot.log (
    id integer NOT NULL,
    request_uuid uuid,
    endpoint text,
    version text,
    system text,
    subsystem text,
    ts timestamp(6) with time zone,
    message text,
    herenow text,
    traceback text,
    kiosk_id integer,
    order_id character varying(135),
    product_id integer,
    epc text,
    client_ip text,
    attributes json
);


ALTER TABLE mixalot.log OWNER TO erpuser;

--
-- Name: log_id_seq; Type: SEQUENCE; Schema: mixalot; Owner: erpuser
--

CREATE SEQUENCE mixalot.log_id_seq
CREATE SEQUENCE mixalot.log_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE mixalot.log_id_seq OWNER TO erpuser;

--
-- Name: log_id_seq; Type: SEQUENCE OWNED BY; Schema: mixalot; Owner: erpuser
--

ALTER SEQUENCE mixalot.log_id_seq OWNED BY mixalot.log.id;


--
-- Name: order_fact; Type: TABLE; Schema: mixalot; Owner: erpuser
--

CREATE TABLE mixalot.order_fact (
    id integer NOT NULL,
    order_id text,
    hash text,
    email text,
    first_name text,
    last_name text,
    kiosk_id integer,
    kiosk_title text,
    campus_id integer,
    sales_price double precision,
    list_price double precision,
    contents_id integer
);


ALTER TABLE mixalot.order_fact OWNER TO erpuser;

--
-- Name: order_fact_id_seq; Type: SEQUENCE; Schema: mixalot; Owner: erpuser
--

CREATE SEQUENCE mixalot.order_fact_id_seq
CREATE SEQUENCE mixalot.order_fact_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE mixalot.order_fact_id_seq OWNER TO erpuser;

--
-- Name: order_fact_id_seq; Type: SEQUENCE OWNED BY; Schema: mixalot; Owner: erpuser
--

ALTER SEQUENCE mixalot.order_fact_id_seq OWNED BY mixalot.order_fact.id;


--
-- Name: pgdu; Type: VIEW; Schema: mixalot; Owner: erpuser
--

CREATE VIEW mixalot.pgdu AS
 SELECT pretty_sizes.table_name,
    pg_size_pretty(pretty_sizes.table_size) AS table_size,
    pg_size_pretty(pretty_sizes.indexes_size) AS indexes_size,
    pg_size_pretty(pretty_sizes.total_size) AS total_size
   FROM ( SELECT all_tables.table_name,
            pg_table_size((all_tables.table_name)::regclass) AS table_size,
            pg_indexes_size((all_tables.table_name)::regclass) AS indexes_size,
            pg_total_relation_size((all_tables.table_name)::regclass) AS total_size
           FROM ( SELECT (((('"'::text || (tables.table_schema)::text) || '"."'::text) || (tables.table_name)::text) || '"'::text) AS table_name
                   FROM information_schema.tables) all_tables
          ORDER BY (pg_total_relation_size((all_tables.table_name)::regclass)) DESC) pretty_sizes
 LIMIT 10;


ALTER TABLE mixalot.pgdu OWNER TO erpuser;

--
-- Name: pick_preference_kiosk_sku; Type: TABLE; Schema: mixalot; Owner: erpuser
--

CREATE TABLE mixalot.pick_preference_kiosk_sku (
    kiosk_id integer NOT NULL,
    sku_id integer NOT NULL,
    preference smallint NOT NULL
);


ALTER TABLE mixalot.pick_preference_kiosk_sku OWNER TO erpuser;

--
-- Name: pick_priority_kiosk; Type: TABLE; Schema: mixalot; Owner: erpuser
--

CREATE TABLE mixalot.pick_priority_kiosk (
    kiosk_id integer NOT NULL,
    priority integer,
    comment text,
    end_date date
);


ALTER TABLE mixalot.pick_priority_kiosk OWNER TO erpuser;

--
-- Name: product_fact; Type: TABLE; Schema: mixalot; Owner: erpuser
--

CREATE TABLE mixalot.product_fact (
    id integer NOT NULL,
    product_id integer,
    sku text,
    first_available_ts timestamp(6) with time zone,
    first_purchased_ts timestamp(6) with time zone,
    kiosks text,
    cnt_sales_1w integer,
    cnt_sales_30d integer,
    cnt_sales_6m integer
);


ALTER TABLE mixalot.product_fact OWNER TO erpuser;

--
-- Name: product_fact_id_seq; Type: SEQUENCE; Schema: mixalot; Owner: erpuser
--

CREATE SEQUENCE mixalot.product_fact_id_seq
CREATE SEQUENCE mixalot.product_fact_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE mixalot.product_fact_id_seq OWNER TO erpuser;

--
-- Name: product_fact_id_seq; Type: SEQUENCE OWNED BY; Schema: mixalot; Owner: erpuser
--

ALTER SEQUENCE mixalot.product_fact_id_seq OWNED BY mixalot.product_fact.id;


--
-- Name: request_log; Type: TABLE; Schema: mixalot; Owner: erpuser
--

CREATE TABLE mixalot.request_log (
    request_uuid uuid NOT NULL,
    endpoint text,
    client_ip text,
    version text,
    cookie text,
    message text,
    request_body text,
    request_headers text,
    start_ts timestamp(6) with time zone,
    response_body text,
    response_headers text,
    status_code integer,
    end_ts timestamp(6) with time zone,
    traceback text,
    request_body_json text,
    request_headers_json text,
    response_headers_json text,
    kiosk_id character varying(50),
    source text,
    flushed timestamp(6) with time zone,
    order_id character varying(135),
    stamp bigint,
    "time" bigint,
    kid bigint,
    client_time timestamp(6) with time zone,
    rec_version integer,
    query_string text
);


ALTER TABLE mixalot.request_log OWNER TO erpuser;

--
-- Name: route; Type: TABLE; Schema: mixalot; Owner: erpuser
--

CREATE TABLE mixalot.route (
    route_date_time timestamp(6) with time zone NOT NULL,
    duration integer,
    vehicle_label character varying(200),
    vehicle_registration character varying(200),
    driver_serial character varying(200),
    distance numeric(28,6),
    driver_name character varying(200) NOT NULL
);


ALTER TABLE mixalot.route OWNER TO erpuser;

--
-- Name: sku_group; Type: TABLE; Schema: mixalot; Owner: erpuser
--

CREATE TABLE mixalot.sku_group (
    id integer NOT NULL,
    title character varying(50),
    group_type character varying(50),
    replacement_type character varying(50),
    created timestamp(6) with time zone,
    updated timestamp(6) with time zone
);


ALTER TABLE mixalot.sku_group OWNER TO erpuser;

--
-- Name: sku_group_def_id_seq; Type: SEQUENCE; Schema: mixalot; Owner: erpuser
--

CREATE SEQUENCE mixalot.sku_group_def_id_seq
CREATE SEQUENCE mixalot.sku_group_def_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE mixalot.sku_group_def_id_seq OWNER TO erpuser;

--
-- Name: sku_group_def_id_seq; Type: SEQUENCE OWNED BY; Schema: mixalot; Owner: erpuser
--

ALTER SEQUENCE mixalot.sku_group_def_id_seq OWNED BY mixalot.sku_group_def.id;


--
-- Name: sku_group_id_seq; Type: SEQUENCE; Schema: mixalot; Owner: erpuser
--

CREATE SEQUENCE mixalot.sku_group_id_seq
CREATE SEQUENCE mixalot.sku_group_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE mixalot.sku_group_id_seq OWNER TO erpuser;

--
-- Name: sku_group_id_seq; Type: SEQUENCE OWNED BY; Schema: mixalot; Owner: erpuser
--

ALTER SEQUENCE mixalot.sku_group_id_seq OWNED BY mixalot.sku_group.id;


--
-- Name: sku_group_member; Type: TABLE; Schema: mixalot; Owner: erpuser
--

CREATE TABLE mixalot.sku_group_member (
    id integer NOT NULL,
    sku_group_id integer,
    product_id integer,
    created timestamp(6) with time zone,
    updated timestamp(6) with time zone
);


ALTER TABLE mixalot.sku_group_member OWNER TO erpuser;

--
-- Name: sku_group_member_id_seq; Type: SEQUENCE; Schema: mixalot; Owner: erpuser
--

CREATE SEQUENCE mixalot.sku_group_member_id_seq
CREATE SEQUENCE mixalot.sku_group_member_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE mixalot.sku_group_member_id_seq OWNER TO erpuser;

--
-- Name: sku_group_member_id_seq; Type: SEQUENCE OWNED BY; Schema: mixalot; Owner: erpuser
--

ALTER SEQUENCE mixalot.sku_group_member_id_seq OWNED BY mixalot.sku_group_member.id;


--
-- Name: sku_property; Type: TABLE; Schema: mixalot; Owner: erpuser
--

CREATE TABLE mixalot.sku_property (
    sku_id integer NOT NULL,
    property_id integer NOT NULL
);


ALTER TABLE mixalot.sku_property OWNER TO erpuser;

--
-- Name: sku_property_def; Type: TABLE; Schema: mixalot; Owner: erpuser
--

CREATE TABLE mixalot.sku_property_def (
    id integer NOT NULL,
    attribute character varying(256),
    title character varying(512) NOT NULL
);


ALTER TABLE mixalot.sku_property_def OWNER TO erpuser;

--
-- Name: TABLE sku_property_def; Type: COMMENT; Schema: mixalot; Owner: erpuser
--

COMMENT ON TABLE mixalot.sku_property_def IS 'property_id, attribute, value.
Example:
1234 | container | glass
1235 | allergen | peanut
';


--
-- Name: sku_property_def_id_seq; Type: SEQUENCE; Schema: mixalot; Owner: erpuser
--

CREATE SEQUENCE mixalot.sku_property_def_id_seq
CREATE SEQUENCE mixalot.sku_property_def_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE mixalot.sku_property_def_id_seq OWNER TO erpuser;

--
-- Name: sku_property_def_id_seq; Type: SEQUENCE OWNED BY; Schema: mixalot; Owner: erpuser
--

ALTER SEQUENCE mixalot.sku_property_def_id_seq OWNED BY mixalot.sku_property_def.id;


--
-- Name: tmp_discount_applied; Type: TABLE; Schema: mixalot; Owner: erpuser
--

CREATE TABLE mixalot.tmp_discount_applied (
    id integer NOT NULL,
    order_id character varying(135),
    sequence integer,
    epc character varying(135),
    product_id integer,
    discount json,
    price_before numeric(28,6),
    price_after numeric(28,6),
    sponsor character varying(135),
    ts timestamp(6) with time zone
);


ALTER TABLE mixalot.tmp_discount_applied OWNER TO erpuser;

--
-- Name: tmp_discount_applied_id_seq; Type: SEQUENCE; Schema: mixalot; Owner: erpuser
--

CREATE SEQUENCE mixalot.tmp_discount_applied_id_seq
CREATE SEQUENCE mixalot.tmp_discount_applied_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE mixalot.tmp_discount_applied_id_seq OWNER TO erpuser;

--
-- Name: tmp_discount_applied_id_seq; Type: SEQUENCE OWNED BY; Schema: mixalot; Owner: erpuser
--

ALTER SEQUENCE mixalot.tmp_discount_applied_id_seq OWNED BY mixalot.tmp_discount_applied.id;


--
-- Name: tmp_kiosk_status; Type: TABLE; Schema: mixalot; Owner: erpuser
--

CREATE TABLE mixalot.tmp_kiosk_status (
    id integer NOT NULL,
    kiosk_id integer NOT NULL,
    kiosk_temperature numeric(6,3),
    kit_temperature numeric(6,3),
    power integer,
    battery_level smallint,
    rfid_0 integer,
    rfid_1 integer,
    rfid_2 integer,
    rfid_3 integer,
    rfid_4 integer,
    rfid_5 integer,
    rfid_6 integer,
    rfid_7 integer,
    "time" bigint,
    modem_signal_percentage smallint,
    modem_signal_type character varying(81),
    ip character varying(135),
    notes text
);


ALTER TABLE mixalot.tmp_kiosk_status OWNER TO erpuser;

--
-- Name: tmp_kiosk_status_id_seq; Type: SEQUENCE; Schema: mixalot; Owner: erpuser
--

CREATE SEQUENCE mixalot.tmp_kiosk_status_id_seq
CREATE SEQUENCE mixalot.tmp_kiosk_status_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE mixalot.tmp_kiosk_status_id_seq OWNER TO erpuser;

--
-- Name: tmp_kiosk_status_id_seq; Type: SEQUENCE OWNED BY; Schema: mixalot; Owner: erpuser
--

ALTER SEQUENCE mixalot.tmp_kiosk_status_id_seq OWNED BY mixalot.tmp_kiosk_status.id;


--
-- Name: tmp_transact; Type: TABLE; Schema: mixalot; Owner: erpuser
--

CREATE TABLE mixalot.tmp_transact (
    order_id character varying(135) NOT NULL,
    first_name text,
    last_name text,
    kiosk_id integer,
    kiosk_title text,
    email text,
    amount_paid numeric(28,6),
    payment_system text,
    transaction_id text,
    approval_code text,
    status_code text,
    status_message text,
    created timestamp(6) with time zone,
    time_opened timestamp(6) with time zone,
    time_closed timestamp(6) with time zone,
    card_hash text,
    card_number text,
    card_type text,
    state text,
    stamp integer,
    last_update timestamp(6) with time zone,
    balance numeric(28,6),
    coupon_id integer,
    coupon text,
    refund numeric(28,6),
    receipt integer,
    campus_id integer,
    amount_list_price numeric(28,6),
    flushed timestamp(6) with time zone,
    create_dt timestamp(6) with time zone,
    modify_dt timestamp(6) with time zone,
    finalized integer
);


ALTER TABLE mixalot.tmp_transact OWNER TO erpuser;

--
-- Name: accounting; Type: TABLE; Schema: pantry; Owner: erpuser
--

CREATE TABLE pantry.accounting (
    id bigint NOT NULL,
    date character varying(45) NOT NULL,
    kiosk_id bigint NOT NULL,
    campus_id bigint NOT NULL,
    sales_ipc numeric(6,2) NOT NULL,
    sales_fp numeric(6,2) NOT NULL,
    sales_cs numeric(6,2) NOT NULL,
    sales_cp numeric(6,2) NOT NULL,
    tags_got bigint NOT NULL,
    tags_spent bigint NOT NULL,
    timezone smallint NOT NULL,
    sales_tax numeric(4,2) NOT NULL,
    sales_tax_ipc numeric(6,2) NOT NULL,
    sales_tax_fp numeric(6,2) NOT NULL,
    sales_tax_cs numeric(6,2) NOT NULL,
    sales_tax_cp numeric(6,2) NOT NULL,
    prepaid bigint NOT NULL,
    current_fee bigint NOT NULL,
    next_fee bigint NOT NULL,
    recalculated_fee numeric(6,2),
    prepaid_day bigint NOT NULL,
    next_fee_from character varying(45),
    fee_connectivity numeric(5,2) NOT NULL
);


ALTER TABLE pantry.accounting OWNER TO erpuser;

--
-- Name: awsdms_apply_exceptions; Type: TABLE; Schema: pantry; Owner: erpuser
--

CREATE TABLE pantry.awsdms_apply_exceptions (
    "TASK_NAME" character varying(128) NOT NULL,
    "TABLE_OWNER" character varying(128) NOT NULL,
    "TABLE_NAME" character varying(128) NOT NULL,
    "ERROR_TIME" timestamp without time zone NOT NULL,
    "STATEMENT" text NOT NULL,
    "ERROR" text NOT NULL
);


ALTER TABLE pantry.awsdms_apply_exceptions OWNER TO erpuser;

--
-- Name: bad_timestamp; Type: TABLE; Schema: pantry; Owner: erpuser
--

CREATE TABLE pantry.bad_timestamp (
    id bigint NOT NULL,
    kiosk_id bigint,
    endpoint character varying(93),
    server_time bigint,
    data character varying(3069)
);


ALTER TABLE pantry.bad_timestamp OWNER TO erpuser;

--
-- Name: campus_assets; Type: TABLE; Schema: pantry; Owner: erpuser
--

CREATE TABLE pantry.campus_assets (
    campus_id bigint NOT NULL,
    logo character varying(255),
    background_image character varying(255),
    background_color character varying(50),
    receipt_header_text character varying(300),
    receipt_footer_text character varying(300)
);


ALTER TABLE pantry.campus_assets OWNER TO erpuser;

--
-- Name: card; Type: TABLE; Schema: pantry; Owner: erpuser
--

CREATE TABLE pantry.card (
    id bigint NOT NULL,
    hash character varying(88) NOT NULL,
    first_name character varying(45),
    last_name character varying(45),
    type character varying(15),
    number character varying(31),
    email character varying(127) NOT NULL,
    notes text,
    created bigint,
    last_update bigint
);


ALTER TABLE pantry.card OWNER TO erpuser;

--
-- Name: discount; Type: TABLE; Schema: pantry; Owner: erpuser
--

CREATE TABLE pantry.discount (
    id bigint NOT NULL,
    kiosk_id bigint,
    product_id bigint,
    value integer NOT NULL,
    type character varying(10),
    end_time integer,
    cron_task_id integer
);


ALTER TABLE pantry.discount OWNER TO erpuser;

--
-- Name: discount_history; Type: TABLE; Schema: pantry; Owner: erpuser
--

CREATE TABLE pantry.discount_history (
    id integer NOT NULL,
    kiosk_id integer,
    product_id integer,
    value integer,
    start_time integer,
    end_time integer,
    discount_id integer
);


ALTER TABLE pantry.discount_history OWNER TO erpuser;

--
-- Name: email; Type: TABLE; Schema: pantry; Owner: erpuser
--

CREATE TABLE pantry.email (
    id integer NOT NULL,
    hash character varying(100),
    "timestamp" integer NOT NULL,
    "from" character varying(200),
    "to" character varying(200),
    cc character varying(200),
    bcc character varying(200),
    subject character varying(200),
    body character varying(65535),
    order_id character varying(12),
    kiosk_id integer,
    type character varying(100) NOT NULL
);


ALTER TABLE pantry.email OWNER TO erpuser;

--
-- Name: email_id_seq; Type: SEQUENCE; Schema: pantry; Owner: erpuser
--

CREATE SEQUENCE pantry.email_id_seq
CREATE SEQUENCE pantry.email_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.email_id_seq OWNER TO erpuser;

--
-- Name: email_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: erpuser
--

ALTER SEQUENCE pantry.email_id_seq OWNED BY pantry.email.id;


--
-- Name: empty_transaction; Type: TABLE; Schema: pantry; Owner: erpuser
--

CREATE TABLE pantry.empty_transaction (
    id integer NOT NULL,
    order_id character varying(36),
    kiosk_name character varying(192),
    email character varying(384),
    created character varying(384),
    representative character varying(384),
    notes character varying(65535),
    fixed character varying(90),
    status character varying(150)
);


ALTER TABLE pantry.empty_transaction OWNER TO erpuser;

--
-- Name: empty_transaction_id_seq; Type: SEQUENCE; Schema: pantry; Owner: erpuser
--

CREATE SEQUENCE pantry.empty_transaction_id_seq
CREATE SEQUENCE pantry.empty_transaction_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.empty_transaction_id_seq OWNER TO erpuser;

--
-- Name: empty_transaction_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: erpuser
--

ALTER SEQUENCE pantry.empty_transaction_id_seq OWNED BY pantry.empty_transaction.id;


--
-- Name: fee_rates; Type: TABLE; Schema: pantry; Owner: erpuser
--

CREATE TABLE pantry.fee_rates (
    id bigint NOT NULL,
    fee_lease numeric(6,2) NOT NULL,
    fee_tags numeric(3,2) NOT NULL,
    fee_ipc numeric(5,4) NOT NULL,
    bi_monthly smallint NOT NULL,
    archived smallint NOT NULL,
    custom smallint NOT NULL,
    prepaid_amount bigint NOT NULL,
    name character varying(128) NOT NULL
);


ALTER TABLE pantry.fee_rates OWNER TO erpuser;

--
-- Name: group; Type: TABLE; Schema: pantry; Owner: erpuser
--

CREATE TABLE pantry."group" (
    id bigint NOT NULL,
    name character varying(45) NOT NULL,
    title character varying(45) NOT NULL,
    notes character varying(2000) NOT NULL,
    archived integer
);


ALTER TABLE pantry."group" OWNER TO erpuser;

--
-- Name: group_campus; Type: TABLE; Schema: pantry; Owner: erpuser
--

CREATE TABLE pantry.group_campus (
    group_id bigint NOT NULL,
    campus_id bigint NOT NULL,
    owner smallint NOT NULL,
    archived integer
);


ALTER TABLE pantry.group_campus OWNER TO erpuser;

--
-- Name: history; Type: TABLE; Schema: pantry; Owner: erpuser
--

CREATE TABLE pantry.history (
    id bigint NOT NULL,
    epc character varying(24) NOT NULL,
    kiosk_id bigint NOT NULL,
    user_id bigint,
    order_id character varying(45),
    direction character varying(3) NOT NULL,
    "time" bigint NOT NULL
);


ALTER TABLE pantry.history OWNER TO erpuser;

--
-- Name: history_epc_order; Type: TABLE; Schema: pantry; Owner: erpuser
--

CREATE TABLE pantry.history_epc_order (
    id bigint NOT NULL,
    epc character varying(72) NOT NULL,
    kiosk_id bigint NOT NULL,
    order_id character varying(135),
    "time" bigint NOT NULL,
    product_id integer,
    price numeric(5,2),
    action character varying(135),
    system character varying(135),
    "user" character varying(135)
);


ALTER TABLE pantry.history_epc_order OWNER TO erpuser;

--
-- Name: history_epc_order_id_seq; Type: SEQUENCE; Schema: pantry; Owner: erpuser
--

CREATE SEQUENCE pantry.history_epc_order_id_seq
CREATE SEQUENCE pantry.history_epc_order_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.history_epc_order_id_seq OWNER TO erpuser;

--
-- Name: history_epc_order_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: erpuser
--

ALTER SEQUENCE pantry.history_epc_order_id_seq OWNED BY pantry.history_epc_order.id;


--
-- Name: inventory_history; Type: TABLE; Schema: pantry; Owner: erpuser
--

CREATE TABLE pantry.inventory_history (
    id integer NOT NULL,
    "time" integer NOT NULL,
    kiosk_id integer NOT NULL,
    product_id integer NOT NULL,
    qty integer NOT NULL,
    campus_id integer NOT NULL,
    is_restored bigint NOT NULL
);


ALTER TABLE pantry.inventory_history OWNER TO erpuser;

--
-- Name: inventory_request; Type: TABLE; Schema: pantry; Owner: erpuser
--

CREATE TABLE pantry.inventory_request (
    id bigint NOT NULL,
    kiosk_id bigint,
    "time" bigint,
    epc character varying(72)
);


ALTER TABLE pantry.inventory_request OWNER TO erpuser;

--
-- Name: inventory_request_id_seq; Type: SEQUENCE; Schema: pantry; Owner: erpuser
--

CREATE SEQUENCE pantry.inventory_request_id_seq
CREATE SEQUENCE pantry.inventory_request_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.inventory_request_id_seq OWNER TO erpuser;

--
-- Name: inventory_request_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: erpuser
--

ALTER SEQUENCE pantry.inventory_request_id_seq OWNED BY pantry.inventory_request.id;


--
-- Name: kiosk_audit_log; Type: TABLE; Schema: pantry; Owner: erpuser
--

CREATE TABLE pantry.kiosk_audit_log (
    id bigint NOT NULL,
    kiosk_id integer NOT NULL,
    created_at timestamp(6) without time zone,
    archived smallint,
    enable_reporting smallint,
    enable_monitoring smallint
);


ALTER TABLE pantry.kiosk_audit_log OWNER TO erpuser;

--
-- Name: kiosk_catalog_downloads; Type: TABLE; Schema: pantry; Owner: erpuser
--

CREATE TABLE pantry.kiosk_catalog_downloads (
    id bigint NOT NULL,
    kiosk_id bigint NOT NULL,
    "timestamp" bigint NOT NULL,
    duration bigint NOT NULL,
    num_bytes bigint NOT NULL,
    num_products bigint NOT NULL,
    current_discounts character varying(765),
    recent_discount_history character varying(765)
);


ALTER TABLE pantry.kiosk_catalog_downloads OWNER TO erpuser;

--
-- Name: kiosk_catalog_downloads_id_seq; Type: SEQUENCE; Schema: pantry; Owner: erpuser
--

CREATE SEQUENCE pantry.kiosk_catalog_downloads_id_seq
CREATE SEQUENCE pantry.kiosk_catalog_downloads_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.kiosk_catalog_downloads_id_seq OWNER TO erpuser;

--
-- Name: kiosk_catalog_downloads_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: erpuser
--

ALTER SEQUENCE pantry.kiosk_catalog_downloads_id_seq OWNED BY pantry.kiosk_catalog_downloads.id;


--
-- Name: kiosk_components_history; Type: TABLE; Schema: pantry; Owner: erpuser
--

CREATE TABLE pantry.kiosk_components_history (
    id bigint NOT NULL,
    kiosk_id bigint NOT NULL,
    "time" bigint NOT NULL,
    type character varying(63),
    common_name character varying(63),
    version character varying(63),
    "full" character varying(255),
    notes text
);


ALTER TABLE pantry.kiosk_components_history OWNER TO erpuser;

--
-- Name: kiosk_components_history_id_seq; Type: SEQUENCE; Schema: pantry; Owner: erpuser
--

CREATE SEQUENCE pantry.kiosk_components_history_id_seq
CREATE SEQUENCE pantry.kiosk_components_history_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.kiosk_components_history_id_seq OWNER TO erpuser;

--
-- Name: kiosk_components_history_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: erpuser
--

ALTER SEQUENCE pantry.kiosk_components_history_id_seq OWNED BY pantry.kiosk_components_history.id;


--
-- Name: kiosk_par_level; Type: TABLE; Schema: pantry; Owner: erpuser
--

CREATE TABLE pantry.kiosk_par_level (
    kiosk_id bigint NOT NULL,
    product_id bigint NOT NULL,
    amount bigint
);


ALTER TABLE pantry.kiosk_par_level OWNER TO erpuser;

--
-- Name: kiosks_date_non_new; Type: TABLE; Schema: pantry; Owner: erpuser
--

CREATE TABLE pantry.kiosks_date_non_new (
    id integer NOT NULL,
    kiosk_id integer NOT NULL,
    new_ts integer NOT NULL
);


ALTER TABLE pantry.kiosks_date_non_new OWNER TO erpuser;

--
-- Name: label_order_id_seq; Type: SEQUENCE; Schema: pantry; Owner: erpuser
--

CREATE SEQUENCE pantry.label_order_id_seq
CREATE SEQUENCE pantry.label_order_id_seq
    START WITH 1
    INCREMENT BY 2
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.label_order_id_seq OWNER TO erpuser;

--
-- Name: label_order_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: erpuser
--

ALTER SEQUENCE pantry.label_order_id_seq OWNED BY pantry.label_order.id;


--
-- Name: label_stats; Type: TABLE; Schema: pantry; Owner: erpuser
--

CREATE TABLE pantry.label_stats (
    product_id bigint,
    used_since_last_delivery bigint,
    used_total bigint,
    last_delivery_date bigint,
    last_delivery bigint,
    delivered_total bigint
);


ALTER TABLE pantry.label_stats OWNER TO erpuser;

--
-- Name: manual_adjustment; Type: TABLE; Schema: pantry; Owner: erpuser
--

CREATE TABLE pantry.manual_adjustment (
    id bigint NOT NULL,
    kiosk_id bigint NOT NULL,
    date character varying(45) NOT NULL,
    sum numeric(6,2) NOT NULL,
    reason character varying(128) NOT NULL,
    auto_generated smallint NOT NULL,
    archived bigint NOT NULL
);


ALTER TABLE pantry.manual_adjustment OWNER TO erpuser;

--
-- Name: nutrition_filter; Type: TABLE; Schema: pantry; Owner: erpuser
--

CREATE TABLE pantry.nutrition_filter (
    id bigint NOT NULL,
    tag_id bigint,
    label character varying(150),
    icon character varying(381)
);


ALTER TABLE pantry.nutrition_filter OWNER TO erpuser;

--
-- Name: payment_order; Type: TABLE; Schema: pantry; Owner: erpuser
--

CREATE TABLE pantry.payment_order (
    order_id character varying(45) NOT NULL,
    payload jsonb,
    re_auth_attempts integer DEFAULT 0,
    id integer NOT NULL
);


ALTER TABLE pantry.payment_order OWNER TO erpuser;

--
-- Name: payment_order_nursing; Type: VIEW; Schema: pantry; Owner: erpuser
--

CREATE VIEW pantry.payment_order_nursing AS
 SELECT payment_order.order_id,
    (payment_order.payload ->> 'nurse_id'::text) AS nurse_id,
    (payment_order.payload ->> 'patient_id'::text) AS patient_id
   FROM pantry.payment_order
  WHERE (((payment_order.payload ->> 'nurse_id'::text) IS NOT NULL) AND ((payment_order.payload ->> 'patient_id'::text) IS NOT NULL));


ALTER TABLE pantry.payment_order_nursing OWNER TO erpuser;

--
-- Name: pick_list_row; Type: TABLE; Schema: pantry; Owner: erpuser
--

CREATE TABLE pantry.pick_list_row (
    id integer NOT NULL,
    "SiteCode" character varying(384),
    "SiteName" character varying(384),
    "PickStation" character varying(384),
    "Vendor" character varying(384),
    "ItemName" character varying(384),
    "ProposedSupply" integer,
    status character varying(150),
    "DriverName" character varying(384),
    "RouteTime" character varying(384),
    "RouteDate" character varying(384),
    "RouteNumber" character varying(384),
    route_time bigint,
    created bigint,
    "Refrigerated" character varying(65535),
    "TotalPickQty" character varying(65535),
    "TotalPickSKU" integer,
    "KioskInvQty" character varying(65535),
    "KioskSKUCnt" integer
);


ALTER TABLE pantry.pick_list_row OWNER TO erpuser;

--
-- Name: pick_list_row_id_seq; Type: SEQUENCE; Schema: pantry; Owner: erpuser
--

CREATE SEQUENCE pantry.pick_list_row_id_seq
CREATE SEQUENCE pantry.pick_list_row_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.pick_list_row_id_seq OWNER TO erpuser;

--
-- Name: pick_list_row_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: erpuser
--

ALTER SEQUENCE pantry.pick_list_row_id_seq OWNED BY pantry.pick_list_row.id;


--
-- Name: product_history; Type: TABLE; Schema: pantry; Owner: erpuser
--

CREATE TABLE pantry.product_history (
    id integer NOT NULL,
    price numeric(5,2),
    cost numeric(5,2),
    start_time integer,
    end_time integer,
    product_id integer,
    campus_id integer
);


ALTER TABLE pantry.product_history OWNER TO erpuser;

--
-- Name: recent_transactions; Type: TABLE; Schema: pantry; Owner: erpuser
--

CREATE TABLE pantry.recent_transactions (
    kiosk_id integer NOT NULL,
    current_less_recent integer,
    current_most_recent integer,
    less_recent integer,
    most_recent integer
);


ALTER TABLE pantry.recent_transactions OWNER TO erpuser;

--
-- Name: refunds; Type: TABLE; Schema: pantry; Owner: erpuser
--

CREATE TABLE pantry.refunds (
    order_id character varying(135) NOT NULL,
    product_id integer NOT NULL,
    price numeric(6,2) NOT NULL
);


ALTER TABLE pantry.refunds OWNER TO erpuser;

--
-- Name: ro_order; Type: TABLE; Schema: pantry; Owner: erpuser
--

CREATE TABLE pantry.ro_order (
    order_id character varying(135) NOT NULL,
    campus_id bigint NOT NULL,
    kiosk_id bigint NOT NULL,
    kiosk_title character varying(138),
    created bigint,
    state character varying(45) NOT NULL,
    customer_full_name character varying(300),
    full_price numeric(6,2),
    real_full_price numeric(6,2),
    archived bigint,
    time_updated bigint
);


ALTER TABLE pantry.ro_order OWNER TO erpuser;

--
-- Name: role; Type: TABLE; Schema: pantry; Owner: erpuser
--

CREATE TABLE pantry.role (
    id integer NOT NULL,
    role character varying(765)
);


ALTER TABLE pantry.role OWNER TO erpuser;

--
-- Name: temp_kiosk; Type: TABLE; Schema: pantry; Owner: erpuser
--

CREATE TABLE pantry.temp_kiosk (
    id bigint NOT NULL,
    campus_id bigint NOT NULL,
    serial character varying(45) NOT NULL,
    title character varying(46),
    address character varying(127),
    location_x numeric(9,6) NOT NULL,
    location_y numeric(9,6) NOT NULL,
    gcm_id character varying(255),
    app_vname character varying(63),
    app_vcode integer,
    archived bigint,
    creation_time bigint,
    deployment_time bigint,
    last_update bigint,
    client_name character varying(255),
    last_status bigint,
    last_inventory bigint NOT NULL,
    kiosk_name character varying(255) NOT NULL,
    payment_start bigint,
    payment_stop bigint,
    features character varying(255) NOT NULL,
    sales_tax smallint NOT NULL,
    default_fee_plan bigint NOT NULL,
    timezone character varying(50),
    estd_num_users bigint,
    tags character varying(255),
    publicly_accessible bigint,
    cardkey_required bigint,
    delivery_insns character varying(65535),
    fridge_loc_info character varying(65535),
    contact_first_name character varying(65535),
    contact_last_name character varying(65535),
    contact_email character varying(65535),
    contact_phone character varying(65535),
    accounting_email character varying(65535),
    byte_discount character varying(255),
    subsidy_info character varying(50),
    subsidy_notes character varying(65535),
    max_subscription character varying(50),
    delivery_window_mon character varying(50),
    delivery_window_tue character varying(50),
    delivery_window_wed character varying(50),
    delivery_window_thu character varying(50),
    delivery_window_fri character varying(50),
    delivery_window_sat character varying(50),
    delivery_window_sun character varying(50),
    notes character varying(2000),
    components text,
    email_receipt_subject character varying(255),
    ops_team_notes character varying(65535),
    geo character varying(3),
    server_url character varying(127),
    subscription_amount numeric(8,2) NOT NULL,
    enable_reporting bigint,
    enable_monitoring bigint,
    employees_num bigint,
    kiosk_restrictions character varying(2000)
);


ALTER TABLE pantry.temp_kiosk OWNER TO erpuser;

--
-- Name: temp_product; Type: TABLE; Schema: pantry; Owner: erpuser
--

CREATE TABLE pantry.temp_product (
    id bigint NOT NULL,
    title character varying(127) NOT NULL,
    description character varying(4095),
    tiny_description character varying(40),
    short_description character varying(100),
    medium_description character varying(400),
    long_description character varying(1200),
    price numeric(5,2) NOT NULL,
    cost numeric(5,2) NOT NULL,
    shelf_time integer NOT NULL,
    campus_id bigint NOT NULL,
    image smallint NOT NULL,
    image_time bigint,
    last_update bigint NOT NULL,
    archived bigint,
    taxable smallint,
    allergens character varying(255),
    attribute_names character varying(511),
    categories character varying(255),
    category_names character varying(511),
    vendor character varying(135),
    source character varying(135),
    notes character varying(2000),
    total_cal bigint,
    num_servings real,
    ingredients character varying(2000),
    calories real,
    proteins real,
    sugar real,
    carbohydrates real,
    fat real,
    consumer_category character varying(2000),
    ws_case_size bigint,
    kiosk_ship_qty bigint,
    ws_case_cost numeric(5,2),
    pick_station bigint,
    fc_title character varying(255),
    pricing_tier character varying(255),
    width_space real,
    height_space real,
    depth_space real,
    slotted_width real,
    tag_volume bigint,
    delivery_option character varying(255),
    tag_applied_by character varying(255)
);


ALTER TABLE pantry.temp_product OWNER TO erpuser;

--
-- Name: temperature_tag_history; Type: TABLE; Schema: pantry; Owner: erpuser
--

CREATE TABLE pantry.temperature_tag_history (
    id bigint NOT NULL,
    kiosk_id bigint,
    "time" bigint,
    epc character varying(72),
    current numeric(5,2),
    average numeric(5,2),
    "full" character varying(381),
    read_count smallint
);


ALTER TABLE pantry.temperature_tag_history OWNER TO erpuser;

--
-- Name: temperature_tag_history_id_seq; Type: SEQUENCE; Schema: pantry; Owner: erpuser
--

CREATE SEQUENCE pantry.temperature_tag_history_id_seq
CREATE SEQUENCE pantry.temperature_tag_history_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pantry.temperature_tag_history_id_seq OWNER TO erpuser;

--
-- Name: temperature_tag_history_id_seq; Type: SEQUENCE OWNED BY; Schema: pantry; Owner: erpuser
--

ALTER SEQUENCE pantry.temperature_tag_history_id_seq OWNED BY pantry.temperature_tag_history.id;


--
-- Name: user; Type: TABLE; Schema: pantry; Owner: erpuser
--

CREATE TABLE pantry."user" (
    id bigint NOT NULL,
    login character varying(45) NOT NULL,
    first_name character varying(127),
    last_name character varying(127),
    password character varying(88) NOT NULL,
    email character varying(127),
    role_id bigint NOT NULL,
    group_id bigint NOT NULL,
    archived bigint NOT NULL,
    date_registered bigint NOT NULL,
    timezone character varying(50),
    email_params character varying(65535),
    token character varying(40),
    notes character varying(2000)
);


ALTER TABLE pantry."user" OWNER TO erpuser;

--
-- Name: awsdms_ddl_audit; Type: TABLE; Schema: public; Owner: erpuser
--

CREATE TABLE public.awsdms_ddl_audit (
    c_key bigint NOT NULL,
    c_time timestamp without time zone,
    c_user character varying(64),
    c_txn character varying(16),
    c_tag character varying(24),
    c_oid integer,
    c_name character varying(64),
    c_schema character varying(64),
    c_ddlqry text
);


ALTER TABLE public.awsdms_ddl_audit OWNER TO erpuser;

--
-- Name: awsdms_ddl_audit_c_key_seq; Type: SEQUENCE; Schema: public; Owner: erpuser
--

CREATE SEQUENCE public.awsdms_ddl_audit_c_key_seq
CREATE SEQUENCE public.awsdms_ddl_audit_c_key_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.awsdms_ddl_audit_c_key_seq OWNER TO erpuser;

--
-- Name: awsdms_ddl_audit_c_key_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: erpuser
--

ALTER SEQUENCE public.awsdms_ddl_audit_c_key_seq OWNED BY public.awsdms_ddl_audit.c_key;


--
-- Name: bak_awsdms_apply_exceptions; Type: TABLE; Schema: public; Owner: erpuser
--

CREATE TABLE public.bak_awsdms_apply_exceptions (
    "TASK_NAME" character varying(128) NOT NULL,
    "TABLE_OWNER" character varying(128) NOT NULL,
    "TABLE_NAME" character varying(128) NOT NULL,
    "ERROR_TIME" timestamp without time zone NOT NULL,
    "STATEMENT" text NOT NULL,
    "ERROR" text NOT NULL
);


ALTER TABLE public.bak_awsdms_apply_exceptions OWNER TO erpuser;

--
-- Name: bak_awsdms_validation_failures_v1; Type: TABLE; Schema: public; Owner: erpuser
--

CREATE TABLE public.bak_awsdms_validation_failures_v1 (
    "TASK_NAME" character varying(128) NOT NULL,
    "TABLE_OWNER" character varying(128) NOT NULL,
    "TABLE_NAME" character varying(128) NOT NULL,
    "FAILURE_TIME" timestamp without time zone NOT NULL,
    "KEY_TYPE" character varying(128) NOT NULL,
    "KEY" character varying(8000) NOT NULL,
    "FAILURE_TYPE" character varying(128) NOT NULL,
    "DETAILS" character varying(8000) NOT NULL
);


ALTER TABLE public.bak_awsdms_validation_failures_v1 OWNER TO erpuser;

--
-- Name: byte_epcssold; Type: VIEW; Schema: public; Owner: erpuser
--

CREATE VIEW public.byte_epcssold AS
 SELECT o.order_id,
    o.first_name,
    o.last_name,
    o.kiosk_id,
    o.kiosk_title,
    o.email,
    o.amount_paid,
    o.payment_system,
    o.transaction_id,
    o.approval_code,
    o.status_code,
    o.status_message,
    o.status,
    o.batch_id,
    o.created,
    o.auth_amount,
    o.data_token,
    o.time_opened,
    o.time_closed,
    o.card_hash,
    o.state,
    o.archived,
    o.stamp,
    o.last_update,
    o.balance,
    o.delta,
    o.coupon_id,
    o.coupon,
    o.refund,
    o.receipt,
    o.campus_id,
    o.amount_list_price,
    o.notes,
    o.time_door_opened,
    o.time_door_closed,
    o.client_name,
    o.estd_num_users,
    o.ts,
    o.full_name,
    o.door_opened_secs,
    o.month,
    o.week,
    o.date,
    o.dayofweek,
    o.hour,
    o.dowhour,
    o.uniq_user,
    lp.epc,
    lp.label_order_id,
    lp.label_status,
    lp.label_price,
    lp.time_created,
    lp.time_added,
    lp.time_updated,
    lp.ts_created,
    lp.ts_added,
    lp.ts_updated,
    lp.label_kiosk_id,
    lp.product_id,
    lp.product_title,
    lp.product_archived,
    lp.product_vendor,
    lp.product_price,
    lp.product_cost,
    lp.product_shelf_life_days,
    lp.product_attributes,
    lp.product_categories,
    lp.consumer_category,
    lp.product_source
   FROM (public.byte_tickets o
     JOIN public.byte_label_product lp ON (((lp.label_order_id)::text = (o.order_id)::text)))
  WHERE ((lp.label_status)::text = 'sold'::text);


ALTER TABLE public.byte_epcssold OWNER TO erpuser;

--
-- Name: byte_feedback_weekly; Type: VIEW; Schema: public; Owner: erpuser
--

CREATE VIEW public.byte_feedback_weekly AS
 SELECT t1.week,
    t1.avg_rating,
    t1.avg_value,
    t1.avg_taste,
    t1.avg_freshness,
    t1.avg_variety,
    ((1.0 * (t1.feedbacks)::numeric) / (t2.tix)::numeric) AS frac_feedbacks
   FROM (( SELECT byte_feedback.week,
            avg((1.0 * (byte_feedback.rate)::numeric)) AS avg_rating,
            avg(public.if((byte_feedback.value > 0), (1.0 * (byte_feedback.value)::numeric), NULL::numeric)) AS avg_value,
            avg(public.if((byte_feedback.taste > 0), (1.0 * (byte_feedback.taste)::numeric), NULL::numeric)) AS avg_taste,
            avg(public.if((byte_feedback.freshness > 0), (1.0 * (byte_feedback.freshness)::numeric), NULL::numeric)) AS avg_freshness,
            avg(public.if((byte_feedback.variety > 0), (1.0 * (byte_feedback.variety)::numeric), NULL::numeric)) AS avg_variety,
            count(*) AS feedbacks
           FROM public.byte_feedback
          WHERE (byte_feedback.week >= '2016-01-01 08:00:00+00'::timestamp with time zone)
          GROUP BY byte_feedback.week
          ORDER BY byte_feedback.week) t1
     JOIN ( SELECT byte_tickets.week,
            count(*) AS tix
           FROM public.byte_tickets
          GROUP BY byte_tickets.week) t2 ON ((t1.week = t2.week)));


ALTER TABLE public.byte_feedback_weekly OWNER TO erpuser;

--
-- Name: byte_kiosks; Type: VIEW; Schema: public; Owner: erpuser
--

CREATE VIEW public.byte_kiosks AS
 SELECT kiosk.id,
    kiosk.campus_id,
    kiosk.serial,
    kiosk.title,
    kiosk.address,
    kiosk.location_x,
    kiosk.location_y,
    kiosk.gcm_id,
    kiosk.app_vname,
    kiosk.app_vcode,
    kiosk.archived,
    kiosk.creation_time,
    kiosk.deployment_time,
    kiosk.last_update,
    kiosk.client_name,
    kiosk.last_status,
    kiosk.last_inventory,
    kiosk.kiosk_name,
    kiosk.payment_start,
    kiosk.payment_stop,
    kiosk.features,
    kiosk.sales_tax,
    kiosk.default_fee_plan,
    kiosk.timezone,
    kiosk.estd_num_users,
    kiosk.tags,
    kiosk.publicly_accessible,
    kiosk.cardkey_required,
    kiosk.delivery_insns,
    kiosk.fridge_loc_info,
    kiosk.contact_first_name,
    kiosk.contact_last_name,
    kiosk.contact_email,
    kiosk.contact_phone,
    kiosk.accounting_email,
    kiosk.byte_discount,
    kiosk.subsidy_info,
    kiosk.subsidy_notes,
    kiosk.max_subscription,
    kiosk.delivery_window_mon,
    kiosk.delivery_window_tue,
    kiosk.delivery_window_wed,
    kiosk.delivery_window_thu,
    kiosk.delivery_window_fri,
    kiosk.delivery_window_sat,
    kiosk.delivery_window_sun,
    kiosk.notes,
    kiosk.components,
    kiosk.email_receipt_subject,
    kiosk.ops_team_notes,
    kiosk.geo,
    kiosk.server_url,
    kiosk.subscription_amount,
    kiosk.enable_reporting,
    kiosk.enable_monitoring,
    kiosk.employees_num,
    kiosk.kiosk_restrictions,
    ( SELECT date(to_timestamp((min("order".created))::double precision)) AS date
           FROM pantry."order"
          WHERE (("order".kiosk_id = kiosk.id) AND (("order".order_id)::text ~~ 'RE%'::text))) AS first_restock,
    ( SELECT date_trunc('month'::text, (to_timestamp((min("order".created))::double precision) + '1 mon'::interval)) AS date_trunc
           FROM pantry."order"
          WHERE (("order".kiosk_id = kiosk.id) AND (("order".order_id)::text ~~ 'RE%'::text))) AS first_full_month
   FROM pantry.kiosk
  WHERE ((kiosk.campus_id = 87) AND (kiosk.enable_reporting = 1));


ALTER TABLE public.byte_kiosks OWNER TO erpuser;

--
-- Name: inventory_history; Type: VIEW; Schema: public; Owner: erpuser
--

CREATE VIEW public.inventory_history AS
 SELECT date_trunc('month'::text, t.ts) AS month,
    date_trunc('week'::text, t.ts) AS week,
    date_trunc('day'::text, t.ts) AS date,
    date_trunc('hour'::text, t.ts) AS hour,
    date_part('dow'::text, t.ts) AS dayofweek,
    t.ts,
    t.product_id,
    t.kiosk_id,
    t.qty,
    t.product_title,
    t.kiosk_title
   FROM ( SELECT to_timestamp((ih."time")::double precision) AS ts,
            ih.product_id,
            ih.kiosk_id,
            ih.qty,
            p.title AS product_title,
            k.title AS kiosk_title
           FROM ((pantry.inventory_history ih
             JOIN pantry.product p ON ((ih.product_id = p.id)))
             JOIN pantry.kiosk k ON ((ih.kiosk_id = k.id)))) t;


ALTER TABLE public.inventory_history OWNER TO erpuser;

--
-- Name: byte_inventory_history; Type: VIEW; Schema: public; Owner: erpuser
--

CREATE VIEW public.byte_inventory_history AS
 SELECT ih.month,
    ih.week,
    ih.date,
    ih.hour,
    ih.dayofweek,
    ih.ts,
    ih.product_id,
    ih.kiosk_id,
    ih.qty,
    ih.product_title,
    ih.kiosk_title
   FROM (public.inventory_history ih
     JOIN public.byte_kiosks bk ON ((ih.kiosk_id = bk.id)));


ALTER TABLE public.byte_inventory_history OWNER TO erpuser;

--
-- Name: byte_inventory_history_eod; Type: VIEW; Schema: public; Owner: erpuser
--

CREATE VIEW public.byte_inventory_history_eod AS
 SELECT ih.month,
    ih.week,
    ih.date,
    ih.hour,
    ih.dayofweek,
    ih.ts,
    ih.product_id,
    ih.kiosk_id,
    ih.qty,
    ih.product_title,
    ih.kiosk_title
   FROM ((public.inventory_history ih
     JOIN public.byte_kiosks bk ON ((ih.kiosk_id = bk.id)))
     JOIN ( SELECT byte_inventory_history.date,
            byte_inventory_history.kiosk_id,
            byte_inventory_history.product_id,
            max(byte_inventory_history.ts) AS maxts
           FROM public.byte_inventory_history
          GROUP BY byte_inventory_history.date, byte_inventory_history.kiosk_id, byte_inventory_history.product_id) ih_eod ON (((ih_eod.kiosk_id = ih.kiosk_id) AND (ih_eod.product_id = ih.product_id) AND (ih_eod.date = ih.date))))
  WHERE (((bk.title)::text !~~* 'burn%'::text) AND ((bk.title)::text !~~* 'test%'::text));


ALTER TABLE public.byte_inventory_history_eod OWNER TO erpuser;

--
-- Name: byte_inventory_history_eod_2wks; Type: VIEW; Schema: public; Owner: erpuser
--

CREATE VIEW public.byte_inventory_history_eod_2wks AS
 SELECT ih.month,
    ih.week,
    ih.date,
    ih.hour,
    ih.dayofweek,
    ih.ts,
    ih.product_id,
    ih.kiosk_id,
    ih.qty,
    ih.product_title,
    ih.kiosk_title
   FROM ((public.inventory_history ih
     JOIN public.byte_kiosks bk ON ((ih.kiosk_id = bk.id)))
     JOIN ( SELECT byte_inventory_history.date,
            byte_inventory_history.kiosk_id,
            byte_inventory_history.product_id,
            max(byte_inventory_history.ts) AS maxts
           FROM public.byte_inventory_history
          WHERE (byte_inventory_history.ts > (now() - '14 days'::interval day))
          GROUP BY byte_inventory_history.date, byte_inventory_history.kiosk_id, byte_inventory_history.product_id) ih_eod ON (((ih_eod.kiosk_id = ih.kiosk_id) AND (ih_eod.product_id = ih.product_id) AND (ih_eod.maxts = ih.ts) AND (ih.ts > (now() - '14 days'::interval day)))))
  WHERE (((bk.title)::text !~~* 'burn%'::text) AND ((bk.title)::text !~~* 'test%'::text));


ALTER TABLE public.byte_inventory_history_eod_2wks OWNER TO erpuser;

--
-- Name: bytecodelog; Type: TABLE; Schema: public; Owner: erpuser
--

CREATE TABLE public.bytecodelog (
    email text NOT NULL,
    bytecode character(6) NOT NULL,
    created_at bigint NOT NULL,
    duration integer NOT NULL,
    expires_at bigint NOT NULL
);


ALTER TABLE public.bytecodelog OWNER TO erpuser;

--
-- Name: history_order_pipeline; Type: TABLE; Schema: public; Owner: erpuser
--

CREATE TABLE public.history_order_pipeline (
    id integer NOT NULL,
    order_id character varying(45),
    action character varying(45),
    system character varying(45),
    "user" character varying(45),
    data text,
    ts timestamp(6) with time zone
);


ALTER TABLE public.history_order_pipeline OWNER TO erpuser;

--
-- Name: history_order_pipeline_id_seq; Type: SEQUENCE; Schema: public; Owner: erpuser
--

CREATE SEQUENCE public.history_order_pipeline_id_seq
CREATE SEQUENCE public.history_order_pipeline_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.history_order_pipeline_id_seq OWNER TO erpuser;

--
-- Name: history_order_pipeline_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: erpuser
--

ALTER SEQUENCE public.history_order_pipeline_id_seq OWNED BY public.history_order_pipeline.id;


--
-- Name: kiosk_status; Type: VIEW; Schema: public; Owner: erpuser
--

CREATE VIEW public.kiosk_status AS
 SELECT tmp.id,
    tmp.kiosk_id,
    tmp.kiosk_temperature,
    tmp.kiosk_temperature_count,
    tmp.kit_temperature,
    tmp.temperature_tags,
    tmp.kiosk_temperature_source,
    tmp.power,
    tmp.battery_level,
    tmp.rfid_0,
    tmp.rfid_1,
    tmp.rfid_2,
    tmp.rfid_3,
    tmp.rfid_4,
    tmp.rfid_5,
    tmp.rfid_6,
    tmp.rfid_7,
    tmp."time",
    tmp.modem_signal_percentage,
    tmp.modem_signal_type,
    tmp.ip,
    tmp.app_uptime,
    tmp.system_uptime,
    tmp.is_locked,
    tmp.campus_id,
    tmp.ts_10min,
    tmp.title,
    tmp.ts_utc,
    tmp.ts,
    date_trunc('day'::text, tmp.ts_10min) AS date
   FROM ( SELECT ks.id,
            ks.kiosk_id,
            ks.kiosk_temperature,
            ks.kiosk_temperature_count,
            ks.kit_temperature,
            ks.temperature_tags,
            ks.kiosk_temperature_source,
            ks.power,
            ks.battery_level,
            ks.rfid_0,
            ks.rfid_1,
            ks.rfid_2,
            ks.rfid_3,
            ks.rfid_4,
            ks.rfid_5,
            ks.rfid_6,
            ks.rfid_7,
            ks."time",
            ks.modem_signal_percentage,
            ks.modem_signal_type,
            ks.ip,
            ks.app_uptime,
            ks.system_uptime,
            ks.is_locked,
            k.campus_id,
            to_timestamp((ks."time")::double precision) AS ts_10min,
            k.title,
            to_timestamp((ks."time")::double precision) AS ts_utc,
            to_timestamp((ks."time")::double precision) AS ts
           FROM (pantry.kiosk_status ks
             JOIN pantry.kiosk k ON ((ks.kiosk_id = k.id)))) tmp;


ALTER TABLE public.kiosk_status OWNER TO erpuser;

--
-- Name: product_fact; Type: TABLE; Schema: public; Owner: erpuser
--

CREATE TABLE public.product_fact (
    id integer NOT NULL,
    product_id integer,
    sku text,
    first_available_ts timestamp(6) with time zone,
    first_purchased_ts timestamp(6) with time zone,
    kiosks text,
    cnt_sales_1w integer,
    cnt_sales_30d integer,
    cnt_sales_6m integer
);


ALTER TABLE public.product_fact OWNER TO erpuser;

--
-- Name: product_fact_id_seq; Type: SEQUENCE; Schema: public; Owner: erpuser
--

CREATE SEQUENCE public.product_fact_id_seq
CREATE SEQUENCE public.product_fact_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.product_fact_id_seq OWNER TO erpuser;

--
-- Name: product_fact_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: erpuser
--

ALTER SEQUENCE public.product_fact_id_seq OWNED BY public.product_fact.id;


--
-- Name: fact_daily_campus_87; Type: TABLE; Schema: test; Owner: erpuser
--

CREATE TABLE test.fact_daily_campus_87 (
    campus_id integer,
    product_id bigint,
    date_id integer,
    sales_qty integer,
    sales_amt numeric(12,2),
    cost_amt numeric(12,2),
    gross_margin_amt numeric(12,2),
    spoils_qty integer,
    spoils_amt numeric(12,2),
    losses_qty integer,
    stocked_percent numeric(3,2),
    ip_commerce numeric(12,2),
    freedom_pay numeric(12,2),
    complimentary numeric(12,2),
    sales_after_discount numeric(12,2)
);


ALTER TABLE test.fact_daily_campus_87 OWNER TO erpuser;

--
-- Name: fact_daily_kiosk_sku_summary; Type: TABLE; Schema: test; Owner: erpuser
--

CREATE TABLE test.fact_daily_kiosk_sku_summary (
    campus_id integer NOT NULL,
    product_id bigint NOT NULL,
    kiosk_id bigint NOT NULL,
    date_id integer NOT NULL,
    sales_qty integer,
    sales_amt numeric(12,2),
    cost_amt numeric(12,2),
    gross_margin_amt numeric(12,2),
    spoils_qty integer,
    spoils_amt numeric(12,2),
    losses_qty integer,
    losses_amt numeric(12,2),
    stocked_percent numeric(3,2),
    ip_commerce numeric(12,2),
    freedom_pay numeric(12,2),
    card_smith numeric(12,2),
    complimentary numeric(12,2),
    sales_after_discount numeric(12,2)
);


ALTER TABLE test.fact_daily_kiosk_sku_summary OWNER TO erpuser;

--
-- Name: fact_monthly_kiosk_summary; Type: TABLE; Schema: test; Owner: erpuser
--

CREATE TABLE test.fact_monthly_kiosk_summary (
    campus_id integer NOT NULL,
    kiosk_id bigint NOT NULL,
    date_id integer NOT NULL,
    sales_list_price numeric(12,2),
    sales_after_discount numeric(12,2),
    food_cost numeric(12,2),
    credit_card numeric(12,2),
    freedom_pay numeric(12,2),
    complimentary numeric(12,2),
    monthly_lease numeric(12,2),
    payment_processing_fee numeric(12,2),
    connectivity_fee numeric(12,2),
    sales_tax numeric(12,2),
    tag_fee numeric(12,2),
    losses_amt numeric(12,2),
    manual_adjustment numeric(12,2),
    fee_plan_name text,
    prepaid_number_of_months bigint,
    prepaid_until character varying(20),
    licensing_subscription_fee numeric(12,2),
    tag_price numeric(12,2),
    payment_processing_rate character varying(20),
    details text
);


ALTER TABLE test.fact_monthly_kiosk_summary OWNER TO erpuser;

--
-- Name: kiosk_20190528; Type: TABLE; Schema: test; Owner: erpuser
--

CREATE TABLE test.kiosk_20190528 (
    id bigint,
    campus_id bigint,
    serial character varying(45),
    title character varying(46),
    address character varying(127),
    location_x numeric(9,6),
    location_y numeric(9,6),
    gcm_id character varying(255),
    app_vname character varying(63),
    app_vcode integer,
    archived bigint,
    creation_time bigint,
    deployment_time bigint,
    last_update bigint,
    client_name character varying(255),
    last_status bigint,
    last_inventory bigint,
    kiosk_name character varying(255),
    payment_start bigint,
    payment_stop bigint,
    features character varying(255),
    sales_tax smallint,
    default_fee_plan bigint,
    timezone character varying(50),
    estd_num_users bigint,
    tags character varying(255),
    publicly_accessible bigint,
    cardkey_required bigint,
    delivery_insns character varying(65535),
    fridge_loc_info character varying(65535),
    contact_first_name character varying(65535),
    contact_last_name character varying(65535),
    contact_email character varying(65535),
    contact_phone character varying(65535),
    accounting_email character varying(65535),
    byte_discount character varying(255),
    subsidy_info character varying(50),
    subsidy_notes character varying(65535),
    max_subscription character varying(50),
    delivery_window_mon character varying(50),
    delivery_window_tue character varying(50),
    delivery_window_wed character varying(50),
    delivery_window_thu character varying(50),
    delivery_window_fri character varying(50),
    delivery_window_sat character varying(50),
    delivery_window_sun character varying(50),
    notes character varying(2000),
    components text,
    email_receipt_subject character varying(255),
    ops_team_notes character varying(65535),
    geo character varying(3),
    server_url character varying(127),
    subscription_amount numeric(8,2),
    enable_reporting bigint,
    enable_monitoring bigint,
    employees_num bigint,
    kiosk_restrictions character varying(2000)
);


ALTER TABLE test.kiosk_20190528 OWNER TO erpuser;

--
-- Name: kiosk_log; Type: TABLE; Schema: test; Owner: erpuser
--

CREATE TABLE test.kiosk_log (
    id integer NOT NULL,
    update_count integer DEFAULT 0,
    ts timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);


ALTER TABLE test.kiosk_log OWNER TO erpuser;

--
-- Name: pick_priority_kiosk; Type: TABLE; Schema: test; Owner: erpuser
--

CREATE TABLE test.pick_priority_kiosk (
    kiosk_id integer,
    priority integer,
    start_date date,
    end_date date,
    comment text
);


ALTER TABLE test.pick_priority_kiosk OWNER TO erpuser;

--
-- Name: remittance_history; Type: TABLE; Schema: test; Owner: erpuser
--

CREATE TABLE test.remittance_history (
    period text NOT NULL,
    version text NOT NULL,
    campus_title character varying,
    campus_id bigint NOT NULL,
    name character varying,
    email character varying,
    number_of_kiosks bigint,
    client_type text,
    sales_list_price numeric,
    sales_after_discount numeric,
    complimentary numeric,
    freedom_pay numeric,
    credit_card numeric,
    monthly_lease numeric,
    connectivity_fee numeric,
    payment_processing_fee numeric,
    tag_fee numeric,
    tags_got integer,
    tag_price numeric,
    net_remittance numeric,
    net_total numeric,
    manual_adjustment numeric,
    fees_before_tags numeric,
    details text
);


ALTER TABLE test.remittance_history OWNER TO erpuser;

--
-- Name: sync_qa_kiosk_before_2way; Type: VIEW; Schema: test; Owner: erpuser
--

CREATE VIEW test.sync_qa_kiosk_before_2way AS
 SELECT kiosk_20190528.id,
    kiosk_20190528.campus_id,
    kiosk_20190528.serial,
    kiosk_20190528.title,
    kiosk_20190528.gcm_id,
    kiosk_20190528.app_vcode,
    kiosk_20190528.archived,
    kiosk_20190528.creation_time,
    kiosk_20190528.deployment_time,
    kiosk_20190528.kiosk_name,
    kiosk_20190528.features,
    kiosk_20190528.sales_tax,
    kiosk_20190528.default_fee_plan,
    kiosk_20190528.estd_num_users,
    kiosk_20190528.publicly_accessible,
    kiosk_20190528.delivery_insns,
    kiosk_20190528.fridge_loc_info,
    kiosk_20190528.byte_discount,
    kiosk_20190528.subsidy_info,
    kiosk_20190528.subsidy_notes,
    kiosk_20190528.max_subscription,
    kiosk_20190528.email_receipt_subject,
    kiosk_20190528.ops_team_notes,
    kiosk_20190528.geo,
    kiosk_20190528.server_url,
    kiosk_20190528.subscription_amount,
    kiosk_20190528.enable_reporting
   FROM test.kiosk_20190528;


ALTER TABLE test.sync_qa_kiosk_before_2way OWNER TO erpuser;

--
-- Name: sync_qa_kiosk_erp; Type: VIEW; Schema: test; Owner: erpuser
--

CREATE VIEW test.sync_qa_kiosk_erp AS
 SELECT kiosk_classic_view.id,
    kiosk_classic_view.campus_id,
    kiosk_classic_view.serial,
    kiosk_classic_view.title,
    kiosk_classic_view.gcm_id,
    kiosk_classic_view.app_vcode,
    kiosk_classic_view.archived,
    kiosk_classic_view.creation_time,
    kiosk_classic_view.deployment_time,
    kiosk_classic_view.kiosk_name,
    kiosk_classic_view.features,
    kiosk_classic_view.sales_tax,
    kiosk_classic_view.default_fee_plan,
    kiosk_classic_view.estd_num_users,
    kiosk_classic_view.publicly_accessible,
    kiosk_classic_view.delivery_insns,
    kiosk_classic_view.fridge_loc_info,
    kiosk_classic_view.byte_discount,
    kiosk_classic_view.subsidy_info,
    kiosk_classic_view.subsidy_notes,
    kiosk_classic_view.max_subscription,
    kiosk_classic_view.email_receipt_subject,
    kiosk_classic_view.ops_team_notes,
    kiosk_classic_view.geo,
    kiosk_classic_view.server_url,
    kiosk_classic_view.subscription_amount,
    kiosk_classic_view.enable_reporting
   FROM erp.kiosk_classic_view;


ALTER TABLE test.sync_qa_kiosk_erp OWNER TO erpuser;

--
-- Name: sync_qa_kiosk_iotmaster; Type: VIEW; Schema: test; Owner: erpuser
--

CREATE VIEW test.sync_qa_kiosk_iotmaster AS
 SELECT kiosk.id,
    kiosk.campus_id,
    kiosk.serial,
    kiosk.title,
    kiosk.gcm_id,
    kiosk.app_vcode,
    kiosk.archived,
    kiosk.creation_time,
    kiosk.deployment_time,
    kiosk.kiosk_name,
    kiosk.features,
    kiosk.sales_tax,
    kiosk.default_fee_plan,
    kiosk.estd_num_users,
    kiosk.publicly_accessible,
    kiosk.delivery_insns,
    kiosk.fridge_loc_info,
    kiosk.byte_discount,
    kiosk.subsidy_info,
    kiosk.subsidy_notes,
    kiosk.max_subscription,
    kiosk.email_receipt_subject,
    kiosk.ops_team_notes,
    kiosk.geo,
    kiosk.server_url,
    kiosk.subscription_amount,
    kiosk.enable_reporting
   FROM pantry.kiosk;


ALTER TABLE test.sync_qa_kiosk_iotmaster OWNER TO erpuser;

--
-- Name: deps_saved_ddl; Type: TABLE; Schema: util; Owner: erpuser
--

CREATE TABLE util.deps_saved_ddl (
    deps_id integer NOT NULL,
    deps_view_schema character varying(255),
    deps_view_name character varying(255),
    deps_ddl_to_run text
);


ALTER TABLE util.deps_saved_ddl OWNER TO erpuser;

--
-- Name: TABLE deps_saved_ddl; Type: COMMENT; Schema: util; Owner: erpuser
--

COMMENT ON TABLE util.deps_saved_ddl IS 'part of save/drop/restore dependent views suite: table to store DDL of dependent views';


--
-- Name: deps_saved_ddl_deps_id_seq; Type: SEQUENCE; Schema: util; Owner: erpuser
--

CREATE SEQUENCE util.deps_saved_ddl_deps_id_seq
CREATE SEQUENCE util.deps_saved_ddl_deps_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE util.deps_saved_ddl_deps_id_seq OWNER TO erpuser;

--
-- Name: deps_saved_ddl_deps_id_seq; Type: SEQUENCE OWNED BY; Schema: util; Owner: erpuser
--

ALTER SEQUENCE util.deps_saved_ddl_deps_id_seq OWNED BY util.deps_saved_ddl.deps_id;


--
-- Name: fcm_repeater id; Type: DEFAULT; Schema: erp; Owner: erpuser
--

ALTER TABLE ONLY erp.fcm_repeater ALTER COLUMN id SET DEFAULT nextval('erp.fcm_repeater_id_seq'::regclass);


--
-- Name: product_property_def id; Type: DEFAULT; Schema: inm; Owner: erpuser
--

ALTER TABLE ONLY inm.product_property_def ALTER COLUMN id SET DEFAULT nextval('inm.product_property_def_id_seq'::regclass);


--
-- Name: card_product_fact id; Type: DEFAULT; Schema: mixalot; Owner: erpuser
--

ALTER TABLE ONLY mixalot.card_product_fact ALTER COLUMN id SET DEFAULT nextval('mixalot.card_product_fact_id_seq'::regclass);


--
-- Name: history_order_pipeline id; Type: DEFAULT; Schema: mixalot; Owner: erpuser
--

ALTER TABLE ONLY mixalot.history_order_pipeline ALTER COLUMN id SET DEFAULT nextval('mixalot.history_order_pipeline_id_seq'::regclass);


--
-- Name: inm_data id; Type: DEFAULT; Schema: mixalot; Owner: erpuser
--

ALTER TABLE ONLY mixalot.inm_data ALTER COLUMN id SET DEFAULT nextval('mixalot.inm_data_id_seq'::regclass);


--
-- Name: kiosk_contents id; Type: DEFAULT; Schema: mixalot; Owner: erpuser
--

ALTER TABLE ONLY mixalot.kiosk_contents ALTER COLUMN id SET DEFAULT nextval('mixalot.kiosk_contents_id_seq'::regclass);


--
-- Name: kiosk_fact id; Type: DEFAULT; Schema: mixalot; Owner: erpuser
--

ALTER TABLE ONLY mixalot.kiosk_fact ALTER COLUMN id SET DEFAULT nextval('mixalot.kiosk_fact_id_seq'::regclass);


--
-- Name: log id; Type: DEFAULT; Schema: mixalot; Owner: erpuser
--

ALTER TABLE ONLY mixalot.log ALTER COLUMN id SET DEFAULT nextval('mixalot.log_id_seq'::regclass);


--
-- Name: order_fact id; Type: DEFAULT; Schema: mixalot; Owner: erpuser
--

ALTER TABLE ONLY mixalot.order_fact ALTER COLUMN id SET DEFAULT nextval('mixalot.order_fact_id_seq'::regclass);


--
-- Name: product_fact id; Type: DEFAULT; Schema: mixalot; Owner: erpuser
--

ALTER TABLE ONLY mixalot.product_fact ALTER COLUMN id SET DEFAULT nextval('mixalot.product_fact_id_seq'::regclass);


--
-- Name: sku_group id; Type: DEFAULT; Schema: mixalot; Owner: erpuser
--

ALTER TABLE ONLY mixalot.sku_group ALTER COLUMN id SET DEFAULT nextval('mixalot.sku_group_id_seq'::regclass);


--
-- Name: sku_group_def id; Type: DEFAULT; Schema: mixalot; Owner: erpuser
--

ALTER TABLE ONLY mixalot.sku_group_def ALTER COLUMN id SET DEFAULT nextval('mixalot.sku_group_def_id_seq'::regclass);


--
-- Name: sku_group_member id; Type: DEFAULT; Schema: mixalot; Owner: erpuser
--

ALTER TABLE ONLY mixalot.sku_group_member ALTER COLUMN id SET DEFAULT nextval('mixalot.sku_group_member_id_seq'::regclass);


--
-- Name: sku_property_def id; Type: DEFAULT; Schema: mixalot; Owner: erpuser
--

ALTER TABLE ONLY mixalot.sku_property_def ALTER COLUMN id SET DEFAULT nextval('mixalot.sku_property_def_id_seq'::regclass);


--
-- Name: tmp_discount_applied id; Type: DEFAULT; Schema: mixalot; Owner: erpuser
--

ALTER TABLE ONLY mixalot.tmp_discount_applied ALTER COLUMN id SET DEFAULT nextval('mixalot.tmp_discount_applied_id_seq'::regclass);


--
-- Name: tmp_kiosk_status id; Type: DEFAULT; Schema: mixalot; Owner: erpuser
--

ALTER TABLE ONLY mixalot.tmp_kiosk_status ALTER COLUMN id SET DEFAULT nextval('mixalot.tmp_kiosk_status_id_seq'::regclass);


--
-- Name: email id; Type: DEFAULT; Schema: pantry; Owner: erpuser
--

ALTER TABLE ONLY pantry.email ALTER COLUMN id SET DEFAULT nextval('pantry.email_id_seq'::regclass);


--
-- Name: empty_transaction id; Type: DEFAULT; Schema: pantry; Owner: erpuser
--

ALTER TABLE ONLY pantry.empty_transaction ALTER COLUMN id SET DEFAULT nextval('pantry.empty_transaction_id_seq'::regclass);


--
-- Name: history_epc_order id; Type: DEFAULT; Schema: pantry; Owner: erpuser
--

ALTER TABLE ONLY pantry.history_epc_order ALTER COLUMN id SET DEFAULT nextval('pantry.history_epc_order_id_seq'::regclass);


--
-- Name: inventory_request id; Type: DEFAULT; Schema: pantry; Owner: erpuser
--

ALTER TABLE ONLY pantry.inventory_request ALTER COLUMN id SET DEFAULT nextval('pantry.inventory_request_id_seq'::regclass);


--
-- Name: kiosk_catalog_downloads id; Type: DEFAULT; Schema: pantry; Owner: erpuser
--

ALTER TABLE ONLY pantry.kiosk_catalog_downloads ALTER COLUMN id SET DEFAULT nextval('pantry.kiosk_catalog_downloads_id_seq'::regclass);


--
-- Name: kiosk_components_history id; Type: DEFAULT; Schema: pantry; Owner: erpuser
--

ALTER TABLE ONLY pantry.kiosk_components_history ALTER COLUMN id SET DEFAULT nextval('pantry.kiosk_components_history_id_seq'::regclass);


--
-- Name: label_order id; Type: DEFAULT; Schema: pantry; Owner: erpuser
--

ALTER TABLE ONLY pantry.label_order ALTER COLUMN id SET DEFAULT nextval('pantry.label_order_id_seq'::regclass);


--
-- Name: pick_list_row id; Type: DEFAULT; Schema: pantry; Owner: erpuser
--

ALTER TABLE ONLY pantry.pick_list_row ALTER COLUMN id SET DEFAULT nextval('pantry.pick_list_row_id_seq'::regclass);


--
-- Name: temperature_tag_history id; Type: DEFAULT; Schema: pantry; Owner: erpuser
--

ALTER TABLE ONLY pantry.temperature_tag_history ALTER COLUMN id SET DEFAULT nextval('pantry.temperature_tag_history_id_seq'::regclass);


--
-- Name: awsdms_ddl_audit c_key; Type: DEFAULT; Schema: public; Owner: erpuser
--

ALTER TABLE ONLY public.awsdms_ddl_audit ALTER COLUMN c_key SET DEFAULT nextval('public.awsdms_ddl_audit_c_key_seq'::regclass);


--
-- Name: history_order_pipeline id; Type: DEFAULT; Schema: public; Owner: erpuser
--

ALTER TABLE ONLY public.history_order_pipeline ALTER COLUMN id SET DEFAULT nextval('public.history_order_pipeline_id_seq'::regclass);


--
-- Name: product_fact id; Type: DEFAULT; Schema: public; Owner: erpuser
--

ALTER TABLE ONLY public.product_fact ALTER COLUMN id SET DEFAULT nextval('public.product_fact_id_seq'::regclass);


--
-- Name: deps_saved_ddl deps_id; Type: DEFAULT; Schema: util; Owner: erpuser
--

ALTER TABLE ONLY util.deps_saved_ddl ALTER COLUMN deps_id SET DEFAULT nextval('util.deps_saved_ddl_deps_id_seq'::regclass);


--
-- Name: dim_campus dim_campus_pkey; Type: CONSTRAINT; Schema: dw; Owner: muriel
--

ALTER TABLE ONLY dw.dim_campus
    ADD CONSTRAINT dim_campus_pkey PRIMARY KEY (id);


--
-- Name: dim_date dim_date_pkey; Type: CONSTRAINT; Schema: dw; Owner: muriel
--

ALTER TABLE ONLY dw.dim_date
    ADD CONSTRAINT dim_date_pkey PRIMARY KEY (date_id);


--
-- Name: dim_kiosk dim_kiosk_pkey; Type: CONSTRAINT; Schema: dw; Owner: muriel
--

ALTER TABLE ONLY dw.dim_kiosk
    ADD CONSTRAINT dim_kiosk_pkey PRIMARY KEY (id);


--
-- Name: dim_product dim_product_pkey; Type: CONSTRAINT; Schema: dw; Owner: muriel
--

ALTER TABLE ONLY dw.dim_product
    ADD CONSTRAINT dim_product_pkey PRIMARY KEY (id);


--
-- Name: fact_daily_byte_foods_summary fact_daily_byte_foods_summary_pkey; Type: CONSTRAINT; Schema: dw; Owner: erpuser
--

ALTER TABLE ONLY dw.fact_daily_byte_foods_summary
    ADD CONSTRAINT fact_daily_byte_foods_summary_pkey PRIMARY KEY (date_id);


--
-- Name: fact_daily_kiosk_sku_summary fact_daily_kiosk_sku_summary_pkey; Type: CONSTRAINT; Schema: dw; Owner: muriel
--

ALTER TABLE ONLY dw.fact_daily_kiosk_sku_summary
    ADD CONSTRAINT fact_daily_kiosk_sku_summary_pkey PRIMARY KEY (campus_id, product_id, kiosk_id, date_id);


--
-- Name: fact_monthly_byte_foods_summary fact_monthly_byte_foods_summary_pkey; Type: CONSTRAINT; Schema: dw; Owner: erpuser
--

ALTER TABLE ONLY dw.fact_monthly_byte_foods_summary
    ADD CONSTRAINT fact_monthly_byte_foods_summary_pkey PRIMARY KEY (year_month);


--
-- Name: fact_monthly_kiosk_summary fact_monthly_kiosk_sku_summary_pkey; Type: CONSTRAINT; Schema: dw; Owner: erpuser
--

ALTER TABLE ONLY dw.fact_monthly_kiosk_summary
    ADD CONSTRAINT fact_monthly_kiosk_sku_summary_pkey PRIMARY KEY (campus_id, kiosk_id, date_id);


--
-- Name: address address_pkey; Type: CONSTRAINT; Schema: erp; Owner: erpuser
--

ALTER TABLE ONLY erp.address
    ADD CONSTRAINT address_pkey PRIMARY KEY (id);


--
-- Name: classic_product_allergen_tag classic_product_allergen_tag_pkey; Type: CONSTRAINT; Schema: erp; Owner: erpuser
--

ALTER TABLE ONLY erp.classic_product_allergen_tag
    ADD CONSTRAINT classic_product_allergen_tag_pkey PRIMARY KEY (product_id, tag_id);


--
-- Name: classic_product_category_tag classic_product_category_tag_pkey; Type: CONSTRAINT; Schema: erp; Owner: erpuser
--

ALTER TABLE ONLY erp.classic_product_category_tag
    ADD CONSTRAINT classic_product_category_tag_pkey PRIMARY KEY (product_id, tag_id);


--
-- Name: client_campus client_campus_pkey; Type: CONSTRAINT; Schema: erp; Owner: erpuser
--

ALTER TABLE ONLY erp.client_campus
    ADD CONSTRAINT client_campus_pkey PRIMARY KEY (client_id, campus_id);


--
-- Name: client_contact client_contact_pkey; Type: CONSTRAINT; Schema: erp; Owner: erpuser
--

ALTER TABLE ONLY erp.client_contact
    ADD CONSTRAINT client_contact_pkey PRIMARY KEY (contact_id);


--
-- Name: client_industry client_industry_pkey; Type: CONSTRAINT; Schema: erp; Owner: erpuser
--

ALTER TABLE ONLY erp.client_industry
    ADD CONSTRAINT client_industry_pkey PRIMARY KEY (client_name);


--
-- Name: client client_name_key; Type: CONSTRAINT; Schema: erp; Owner: erpuser
--

ALTER TABLE ONLY erp.client
    ADD CONSTRAINT client_name_key UNIQUE (name);


--
-- Name: client client_pkey; Type: CONSTRAINT; Schema: erp; Owner: erpuser
--

ALTER TABLE ONLY erp.client
    ADD CONSTRAINT client_pkey PRIMARY KEY (id);


--
-- Name: contact contact_pkey; Type: CONSTRAINT; Schema: erp; Owner: erpuser
--

ALTER TABLE ONLY erp.contact
    ADD CONSTRAINT contact_pkey PRIMARY KEY (id);


--
-- Name: fcm_repeater fcm_repeater_pkey; Type: CONSTRAINT; Schema: erp; Owner: erpuser
--

ALTER TABLE ONLY erp.fcm_repeater
    ADD CONSTRAINT fcm_repeater_pkey PRIMARY KEY (id);


--
-- Name: global_attribute_def global_attribute_def_name_value_key; Type: CONSTRAINT; Schema: erp; Owner: erpuser
--

ALTER TABLE ONLY erp.global_attribute_def
    ADD CONSTRAINT global_attribute_def_name_value_key UNIQUE (name, value);


--
-- Name: global_attribute_def global_attribute_def_pkey; Type: CONSTRAINT; Schema: erp; Owner: erpuser
--

ALTER TABLE ONLY erp.global_attribute_def
    ADD CONSTRAINT global_attribute_def_pkey PRIMARY KEY (id);


--
-- Name: hardware_software hardware_software_pkey; Type: CONSTRAINT; Schema: erp; Owner: erpuser
--

ALTER TABLE ONLY erp.hardware_software
    ADD CONSTRAINT hardware_software_pkey PRIMARY KEY (kiosk_id);


--
-- Name: kiosk_access_card kiosk_access_card_card_id_client_id_key; Type: CONSTRAINT; Schema: erp; Owner: erpuser
--

ALTER TABLE ONLY erp.kiosk_access_card
    ADD CONSTRAINT kiosk_access_card_card_id_client_id_key UNIQUE (card_id, client_id);


--
-- Name: kiosk_access_card kiosk_access_card_pkey; Type: CONSTRAINT; Schema: erp; Owner: erpuser
--

ALTER TABLE ONLY erp.kiosk_access_card
    ADD CONSTRAINT kiosk_access_card_pkey PRIMARY KEY (id);


--
-- Name: kiosk_accounting kiosk_accounting_pkey; Type: CONSTRAINT; Schema: erp; Owner: erpuser
--

ALTER TABLE ONLY erp.kiosk_accounting
    ADD CONSTRAINT kiosk_accounting_pkey PRIMARY KEY (kiosk_id);


--
-- Name: kiosk_attribute kiosk_attribute_pkey; Type: CONSTRAINT; Schema: erp; Owner: erpuser
--

ALTER TABLE ONLY erp.kiosk_attribute
    ADD CONSTRAINT kiosk_attribute_pkey PRIMARY KEY (kiosk_id, attribute_id);


--
-- Name: kiosk_contact kiosk_contact_pkey; Type: CONSTRAINT; Schema: erp; Owner: erpuser
--

ALTER TABLE ONLY erp.kiosk_contact
    ADD CONSTRAINT kiosk_contact_pkey PRIMARY KEY (contact_id, kiosk_id);


--
-- Name: kiosk_note kiosk_note_kiosk_id_note_type_key; Type: CONSTRAINT; Schema: erp; Owner: erpuser
--

ALTER TABLE ONLY erp.kiosk_note
    ADD CONSTRAINT kiosk_note_kiosk_id_note_type_key UNIQUE (kiosk_id, note_type);


--
-- Name: kiosk_note kiosk_note_pkey; Type: CONSTRAINT; Schema: erp; Owner: erpuser
--

ALTER TABLE ONLY erp.kiosk_note
    ADD CONSTRAINT kiosk_note_pkey PRIMARY KEY (id);


--
-- Name: kiosk kiosk_pkey; Type: CONSTRAINT; Schema: erp; Owner: erpuser
--

ALTER TABLE ONLY erp.kiosk
    ADD CONSTRAINT kiosk_pkey PRIMARY KEY (id);


--
-- Name: kiosk_restriction_by_product kiosk_restriction_by_product_pkey; Type: CONSTRAINT; Schema: erp; Owner: erpuser
--

ALTER TABLE ONLY erp.kiosk_restriction_by_product
    ADD CONSTRAINT kiosk_restriction_by_product_pkey PRIMARY KEY (kiosk_id, product_id);


--
-- Name: kiosk_restriction_by_property kiosk_restriction_by_property_pkey; Type: CONSTRAINT; Schema: erp; Owner: erpuser
--

ALTER TABLE ONLY erp.kiosk_restriction_by_property
    ADD CONSTRAINT kiosk_restriction_by_property_pkey PRIMARY KEY (kiosk_id, property_id);


--
-- Name: kiosk_status kiosk_status_pkey; Type: CONSTRAINT; Schema: erp; Owner: erpuser
--

ALTER TABLE ONLY erp.kiosk_status
    ADD CONSTRAINT kiosk_status_pkey PRIMARY KEY (kiosk_id);


--
-- Name: product_asset product_asset_pkey; Type: CONSTRAINT; Schema: erp; Owner: erpuser
--

ALTER TABLE ONLY erp.product_asset
    ADD CONSTRAINT product_asset_pkey PRIMARY KEY (product_id);


--
-- Name: product_category_def product_category_def_name_value_key; Type: CONSTRAINT; Schema: erp; Owner: erpuser
--

ALTER TABLE ONLY erp.product_category_def
    ADD CONSTRAINT product_category_def_name_value_key UNIQUE (name, value);


--
-- Name: product_category_def product_category_def_pkey; Type: CONSTRAINT; Schema: erp; Owner: erpuser
--

ALTER TABLE ONLY erp.product_category_def
    ADD CONSTRAINT product_category_def_pkey PRIMARY KEY (id);


--
-- Name: product_category product_category_pkey; Type: CONSTRAINT; Schema: erp; Owner: erpuser
--

ALTER TABLE ONLY erp.product_category
    ADD CONSTRAINT product_category_pkey PRIMARY KEY (product_id, category_id);


--
-- Name: product_handling product_handling_pkey; Type: CONSTRAINT; Schema: erp; Owner: erpuser
--

ALTER TABLE ONLY erp.product_handling
    ADD CONSTRAINT product_handling_pkey PRIMARY KEY (product_id);


--
-- Name: product_nutrition product_nutrition_pkey; Type: CONSTRAINT; Schema: erp; Owner: erpuser
--

ALTER TABLE ONLY erp.product_nutrition
    ADD CONSTRAINT product_nutrition_pkey PRIMARY KEY (product_id);


--
-- Name: product product_pkey; Type: CONSTRAINT; Schema: erp; Owner: erpuser
--

ALTER TABLE ONLY erp.product
    ADD CONSTRAINT product_pkey PRIMARY KEY (id);


--
-- Name: product_pricing product_pricing_pkey; Type: CONSTRAINT; Schema: erp; Owner: erpuser
--

ALTER TABLE ONLY erp.product_pricing
    ADD CONSTRAINT product_pricing_pkey PRIMARY KEY (product_id);


--
-- Name: product_property_def product_property_def_name_value_key; Type: CONSTRAINT; Schema: erp; Owner: erpuser
--

ALTER TABLE ONLY erp.product_property_def
    ADD CONSTRAINT product_property_def_name_value_key UNIQUE (name, value);


--
-- Name: product_property_def product_property_def_pkey; Type: CONSTRAINT; Schema: erp; Owner: erpuser
--

ALTER TABLE ONLY erp.product_property_def
    ADD CONSTRAINT product_property_def_pkey PRIMARY KEY (id);


--
-- Name: product_property product_property_pkey; Type: CONSTRAINT; Schema: erp; Owner: erpuser
--

ALTER TABLE ONLY erp.product_property
    ADD CONSTRAINT product_property_pkey PRIMARY KEY (product_id, property_id);


--
-- Name: product_property_tag product_property_tag_pkey; Type: CONSTRAINT; Schema: erp; Owner: erpuser
--

ALTER TABLE ONLY erp.product_property_tag
    ADD CONSTRAINT product_property_tag_pkey PRIMARY KEY (property_id, tag_id);


--
-- Name: product_sourcing product_sourcing_pkey; Type: CONSTRAINT; Schema: erp; Owner: erpuser
--

ALTER TABLE ONLY erp.product_sourcing
    ADD CONSTRAINT product_sourcing_pkey PRIMARY KEY (product_id);


--
-- Name: sku_group sku_group_pkey; Type: CONSTRAINT; Schema: erp; Owner: erpuser
--

ALTER TABLE ONLY erp.sku_group
    ADD CONSTRAINT sku_group_pkey PRIMARY KEY (id);


--
-- Name: tag_order tag_order_pkey; Type: CONSTRAINT; Schema: erp; Owner: erpuser
--

ALTER TABLE ONLY erp.tag_order
    ADD CONSTRAINT tag_order_pkey PRIMARY KEY (id);


--
-- Name: tag_order_stats tag_order_stats_pkey; Type: CONSTRAINT; Schema: erp; Owner: erpuser
--

ALTER TABLE ONLY erp.tag_order_stats
    ADD CONSTRAINT tag_order_stats_pkey PRIMARY KEY (product_id);


--
-- Name: tag_price tag_price_pkey; Type: CONSTRAINT; Schema: erp; Owner: erpuser
--

ALTER TABLE ONLY erp.tag_price
    ADD CONSTRAINT tag_price_pkey PRIMARY KEY (campus_id, tag_type);


--
-- Name: tag_type tag_type_pkey; Type: CONSTRAINT; Schema: erp; Owner: erpuser
--

ALTER TABLE ONLY erp.tag_type
    ADD CONSTRAINT tag_type_pkey PRIMARY KEY (id);


--
-- Name: address address_address1_address2_city_state_zip_key; Type: CONSTRAINT; Schema: erp_backup; Owner: erpuser
--

ALTER TABLE ONLY erp_backup.address
    ADD CONSTRAINT address_address1_address2_city_state_zip_key UNIQUE (address1, address2, city, state, zip);


--
-- Name: address address_pkey; Type: CONSTRAINT; Schema: erp_backup; Owner: erpuser
--

ALTER TABLE ONLY erp_backup.address
    ADD CONSTRAINT address_pkey PRIMARY KEY (id);


--
-- Name: client client_name_key; Type: CONSTRAINT; Schema: erp_backup; Owner: erpuser
--

ALTER TABLE ONLY erp_backup.client
    ADD CONSTRAINT client_name_key UNIQUE (name);


--
-- Name: client client_pkey; Type: CONSTRAINT; Schema: erp_backup; Owner: erpuser
--

ALTER TABLE ONLY erp_backup.client
    ADD CONSTRAINT client_pkey PRIMARY KEY (id);


--
-- Name: contact contact_client_id_contact_type_key; Type: CONSTRAINT; Schema: erp_backup; Owner: erpuser
--

ALTER TABLE ONLY erp_backup.contact
    ADD CONSTRAINT contact_client_id_contact_type_key UNIQUE (client_id, contact_type);


--
-- Name: contact contact_pkey; Type: CONSTRAINT; Schema: erp_backup; Owner: erpuser
--

ALTER TABLE ONLY erp_backup.contact
    ADD CONSTRAINT contact_pkey PRIMARY KEY (id);


--
-- Name: hardware_software hardware_software_pkey; Type: CONSTRAINT; Schema: erp_backup; Owner: erpuser
--

ALTER TABLE ONLY erp_backup.hardware_software
    ADD CONSTRAINT hardware_software_pkey PRIMARY KEY (kiosk_id);


--
-- Name: kiosk_accounting kiosk_accounting_pkey; Type: CONSTRAINT; Schema: erp_backup; Owner: erpuser
--

ALTER TABLE ONLY erp_backup.kiosk_accounting
    ADD CONSTRAINT kiosk_accounting_pkey PRIMARY KEY (kiosk_id);


--
-- Name: kiosk_note kiosk_note_pkey; Type: CONSTRAINT; Schema: erp_backup; Owner: erpuser
--

ALTER TABLE ONLY erp_backup.kiosk_note
    ADD CONSTRAINT kiosk_note_pkey PRIMARY KEY (id);


--
-- Name: product_property_def product_property_def_name_value_key; Type: CONSTRAINT; Schema: erp_backup; Owner: erpuser
--

ALTER TABLE ONLY erp_backup.product_property_def
    ADD CONSTRAINT product_property_def_name_value_key UNIQUE (name, value);


--
-- Name: product_property_def product_property_def_pkey; Type: CONSTRAINT; Schema: erp_backup; Owner: erpuser
--

ALTER TABLE ONLY erp_backup.product_property_def
    ADD CONSTRAINT product_property_def_pkey PRIMARY KEY (id);


--
-- Name: product_property product_property_pkey; Type: CONSTRAINT; Schema: erp_backup; Owner: erpuser
--

ALTER TABLE ONLY erp_backup.product_property
    ADD CONSTRAINT product_property_pkey PRIMARY KEY (product_id, property_id);


--
-- Name: address address_address1_key; Type: CONSTRAINT; Schema: erp_test; Owner: erpuser
--

ALTER TABLE ONLY erp_test.address
    ADD CONSTRAINT address_address1_key UNIQUE (address1);


--
-- Name: address address_pkey; Type: CONSTRAINT; Schema: erp_test; Owner: erpuser
--

ALTER TABLE ONLY erp_test.address
    ADD CONSTRAINT address_pkey PRIMARY KEY (id);


--
-- Name: client_campus client_campus_pkey; Type: CONSTRAINT; Schema: erp_test; Owner: erpuser
--

ALTER TABLE ONLY erp_test.client_campus
    ADD CONSTRAINT client_campus_pkey PRIMARY KEY (client_id, campus_id);


--
-- Name: client_contact client_contact_pkey; Type: CONSTRAINT; Schema: erp_test; Owner: erpuser
--

ALTER TABLE ONLY erp_test.client_contact
    ADD CONSTRAINT client_contact_pkey PRIMARY KEY (contact_id);


--
-- Name: client client_name_key; Type: CONSTRAINT; Schema: erp_test; Owner: erpuser
--

ALTER TABLE ONLY erp_test.client
    ADD CONSTRAINT client_name_key UNIQUE (name);


--
-- Name: client client_pkey; Type: CONSTRAINT; Schema: erp_test; Owner: erpuser
--

ALTER TABLE ONLY erp_test.client
    ADD CONSTRAINT client_pkey PRIMARY KEY (id);


--
-- Name: contact contact_pkey; Type: CONSTRAINT; Schema: erp_test; Owner: erpuser
--

ALTER TABLE ONLY erp_test.contact
    ADD CONSTRAINT contact_pkey PRIMARY KEY (id);


--
-- Name: global_attribute_def global_attribute_def_name_value_key; Type: CONSTRAINT; Schema: erp_test; Owner: erpuser
--

ALTER TABLE ONLY erp_test.global_attribute_def
    ADD CONSTRAINT global_attribute_def_name_value_key UNIQUE (name, value);


--
-- Name: global_attribute_def global_attribute_def_pkey; Type: CONSTRAINT; Schema: erp_test; Owner: erpuser
--

ALTER TABLE ONLY erp_test.global_attribute_def
    ADD CONSTRAINT global_attribute_def_pkey PRIMARY KEY (id);


--
-- Name: hardware_software hardware_software_pkey; Type: CONSTRAINT; Schema: erp_test; Owner: erpuser
--

ALTER TABLE ONLY erp_test.hardware_software
    ADD CONSTRAINT hardware_software_pkey PRIMARY KEY (kiosk_id);


--
-- Name: kiosk_accounting kiosk_accounting_pkey; Type: CONSTRAINT; Schema: erp_test; Owner: erpuser
--

ALTER TABLE ONLY erp_test.kiosk_accounting
    ADD CONSTRAINT kiosk_accounting_pkey PRIMARY KEY (kiosk_id);


--
-- Name: kiosk_audit kiosk_audit_pkey; Type: CONSTRAINT; Schema: erp_test; Owner: erpuser
--

ALTER TABLE ONLY erp_test.kiosk_audit
    ADD CONSTRAINT kiosk_audit_pkey PRIMARY KEY (kid);


--
-- Name: kiosk_contact kiosk_contact_pkey; Type: CONSTRAINT; Schema: erp_test; Owner: erpuser
--

ALTER TABLE ONLY erp_test.kiosk_contact
    ADD CONSTRAINT kiosk_contact_pkey PRIMARY KEY (contact_id, kiosk_id);


--
-- Name: kiosk_note kiosk_note_pkey; Type: CONSTRAINT; Schema: erp_test; Owner: erpuser
--

ALTER TABLE ONLY erp_test.kiosk_note
    ADD CONSTRAINT kiosk_note_pkey PRIMARY KEY (id);


--
-- Name: kiosk_status kiosk_status_pkey; Type: CONSTRAINT; Schema: erp_test; Owner: erpuser
--

ALTER TABLE ONLY erp_test.kiosk_status
    ADD CONSTRAINT kiosk_status_pkey PRIMARY KEY (kiosk_id);


--
-- Name: product_asset product_asset_pkey; Type: CONSTRAINT; Schema: erp_test; Owner: erpuser
--

ALTER TABLE ONLY erp_test.product_asset
    ADD CONSTRAINT product_asset_pkey PRIMARY KEY (product_id);


--
-- Name: product_handling product_handling_pkey; Type: CONSTRAINT; Schema: erp_test; Owner: erpuser
--

ALTER TABLE ONLY erp_test.product_handling
    ADD CONSTRAINT product_handling_pkey PRIMARY KEY (product_id);


--
-- Name: product_nutrition product_nutrition_pkey; Type: CONSTRAINT; Schema: erp_test; Owner: erpuser
--

ALTER TABLE ONLY erp_test.product_nutrition
    ADD CONSTRAINT product_nutrition_pkey PRIMARY KEY (product_id);


--
-- Name: product product_pkey; Type: CONSTRAINT; Schema: erp_test; Owner: erpuser
--

ALTER TABLE ONLY erp_test.product
    ADD CONSTRAINT product_pkey PRIMARY KEY (id);


--
-- Name: product_pricing product_pricing_pkey; Type: CONSTRAINT; Schema: erp_test; Owner: erpuser
--

ALTER TABLE ONLY erp_test.product_pricing
    ADD CONSTRAINT product_pricing_pkey PRIMARY KEY (product_id);


--
-- Name: product_property product_property_pkey; Type: CONSTRAINT; Schema: erp_test; Owner: erpuser
--

ALTER TABLE ONLY erp_test.product_property
    ADD CONSTRAINT product_property_pkey PRIMARY KEY (product_id, property_id);


--
-- Name: product_sourcing product_sourcing_pkey; Type: CONSTRAINT; Schema: erp_test; Owner: erpuser
--

ALTER TABLE ONLY erp_test.product_sourcing
    ADD CONSTRAINT product_sourcing_pkey PRIMARY KEY (product_id);


--
-- Name: configuration configuration_pkey; Type: CONSTRAINT; Schema: inm; Owner: erpuser
--

ALTER TABLE ONLY inm.configuration
    ADD CONSTRAINT configuration_pkey PRIMARY KEY (setting);


--
-- Name: kiosk_control kiosk_control_pkey; Type: CONSTRAINT; Schema: inm; Owner: erpuser
--

ALTER TABLE ONLY inm.kiosk_control
    ADD CONSTRAINT kiosk_control_pkey PRIMARY KEY (kiosk_id);


--
-- Name: kiosk_restriction_by_product_ed kiosk_restriction_by_product_ed_pkey; Type: CONSTRAINT; Schema: inm; Owner: erpuser
--

ALTER TABLE ONLY inm.kiosk_restriction_by_product_ed
    ADD CONSTRAINT kiosk_restriction_by_product_ed_pkey PRIMARY KEY (kiosk_id, product_id);


--
-- Name: kiosk_restriction_by_product kiosk_restriction_by_product_pkey; Type: CONSTRAINT; Schema: inm; Owner: erpuser
--

ALTER TABLE ONLY inm.kiosk_restriction_by_product
    ADD CONSTRAINT kiosk_restriction_by_product_pkey PRIMARY KEY (kiosk_id, product_id);


--
-- Name: kiosk_restriction_by_property kiosk_restriction_by_property_pkey; Type: CONSTRAINT; Schema: inm; Owner: erpuser
--

ALTER TABLE ONLY inm.kiosk_restriction_by_property
    ADD CONSTRAINT kiosk_restriction_by_property_pkey PRIMARY KEY (kiosk_id, property_id);


--
-- Name: kiosk_sku_group_manual_scale kiosk_sku_group_manual_scale_pkey; Type: CONSTRAINT; Schema: inm; Owner: erpuser
--

ALTER TABLE ONLY inm.kiosk_sku_group_manual_scale
    ADD CONSTRAINT kiosk_sku_group_manual_scale_pkey PRIMARY KEY (kiosk_id, sku_group_id);


--
-- Name: pick_allocation pick_allocation_pkey; Type: CONSTRAINT; Schema: inm; Owner: erpuser
--

ALTER TABLE ONLY inm.pick_allocation
    ADD CONSTRAINT pick_allocation_pkey PRIMARY KEY (pick_date, route_date, kiosk_id, sku_id);


--
-- Name: pick_demand pick_demand_pkey; Type: CONSTRAINT; Schema: inm; Owner: erpuser
--

ALTER TABLE ONLY inm.pick_demand
    ADD CONSTRAINT pick_demand_pkey PRIMARY KEY (pick_date, route_date, kiosk_id, sku_group_id);


--
-- Name: pick_inventory pick_inventory_pkey; Type: CONSTRAINT; Schema: inm; Owner: erpuser
--

ALTER TABLE ONLY inm.pick_inventory
    ADD CONSTRAINT pick_inventory_pkey PRIMARY KEY (pick_date, route_date, kiosk_id, sku_group_id);


--
-- Name: pick_list pick_list_pkey; Type: CONSTRAINT; Schema: inm; Owner: erpuser
--

ALTER TABLE ONLY inm.pick_list
    ADD CONSTRAINT pick_list_pkey PRIMARY KEY (pick_date);


--
-- Name: pick_preference_kiosk_sku pick_preference_kiosk_product_pkey; Type: CONSTRAINT; Schema: inm; Owner: erpuser
--

ALTER TABLE ONLY inm.pick_preference_kiosk_sku
    ADD CONSTRAINT pick_preference_kiosk_product_pkey PRIMARY KEY (kiosk_id, sku_id);


--
-- Name: pick_priority_kiosk pick_priority_kiosk_pkey; Type: CONSTRAINT; Schema: inm; Owner: erpuser
--

ALTER TABLE ONLY inm.pick_priority_kiosk
    ADD CONSTRAINT pick_priority_kiosk_pkey PRIMARY KEY (kiosk_id);


--
-- Name: pick_priority_sku pick_priority_sku_pkey; Type: CONSTRAINT; Schema: inm; Owner: erpuser
--

ALTER TABLE ONLY inm.pick_priority_sku
    ADD CONSTRAINT pick_priority_sku_pkey PRIMARY KEY (sku_id);


--
-- Name: pick_rejection pick_rejection_pkey; Type: CONSTRAINT; Schema: inm; Owner: erpuser
--

ALTER TABLE ONLY inm.pick_rejection
    ADD CONSTRAINT pick_rejection_pkey PRIMARY KEY (pick_date, route_date, kiosk_id, item_id, item_type, reason);


--
-- Name: pick_route pick_route_pkey; Type: CONSTRAINT; Schema: inm; Owner: erpuser
--

ALTER TABLE ONLY inm.pick_route
    ADD CONSTRAINT pick_route_pkey PRIMARY KEY (pick_date, kiosk_id, route_date);


--
-- Name: pick_substitution pick_substitution_pkey; Type: CONSTRAINT; Schema: inm; Owner: erpuser
--

ALTER TABLE ONLY inm.pick_substitution
    ADD CONSTRAINT pick_substitution_pkey PRIMARY KEY (substituting_sku_group_id, substituted_sku_group_id, pick_date);


--
-- Name: product_pick_order product_pick_order_pkey; Type: CONSTRAINT; Schema: inm; Owner: erpuser
--

ALTER TABLE ONLY inm.product_pick_order
    ADD CONSTRAINT product_pick_order_pkey PRIMARY KEY (product_id);


--
-- Name: product_pick_order_temp product_pick_order_temp_pkey; Type: CONSTRAINT; Schema: inm; Owner: erpuser
--

ALTER TABLE ONLY inm.product_pick_order_temp
    ADD CONSTRAINT product_pick_order_temp_pkey PRIMARY KEY (product_id);


--
-- Name: product_property_def product_property_def_name_value_key; Type: CONSTRAINT; Schema: inm; Owner: erpuser
--

ALTER TABLE ONLY inm.product_property_def
    ADD CONSTRAINT product_property_def_name_value_key UNIQUE (name, value);


--
-- Name: product_property_def product_property_def_pkey; Type: CONSTRAINT; Schema: inm; Owner: erpuser
--

ALTER TABLE ONLY inm.product_property_def
    ADD CONSTRAINT product_property_def_pkey PRIMARY KEY (id);


--
-- Name: product_property product_property_pkey; Type: CONSTRAINT; Schema: inm; Owner: erpuser
--

ALTER TABLE ONLY inm.product_property
    ADD CONSTRAINT product_property_pkey PRIMARY KEY (product_id, property_id);


--
-- Name: route_stop route_stop_pkey; Type: CONSTRAINT; Schema: inm; Owner: erpuser
--

ALTER TABLE ONLY inm.route_stop
    ADD CONSTRAINT route_stop_pkey PRIMARY KEY (route_date_time, driver_name, location_name, schedule_at);


--
-- Name: sku_group_attribute sku_group_attribute_pkey; Type: CONSTRAINT; Schema: inm; Owner: erpuser
--

ALTER TABLE ONLY inm.sku_group_attribute
    ADD CONSTRAINT sku_group_attribute_pkey PRIMARY KEY (id);


--
-- Name: sku_group_attribute sku_group_attribute_title_key; Type: CONSTRAINT; Schema: inm; Owner: erpuser
--

ALTER TABLE ONLY inm.sku_group_attribute
    ADD CONSTRAINT sku_group_attribute_title_key UNIQUE (title);


--
-- Name: sku_group_control sku_group_control_pkey; Type: CONSTRAINT; Schema: inm; Owner: erpuser
--

ALTER TABLE ONLY inm.sku_group_control
    ADD CONSTRAINT sku_group_control_pkey PRIMARY KEY (sku_group_id);


--
-- Name: warehouse_inventory warehouse_inventory_pkey; Type: CONSTRAINT; Schema: inm; Owner: erpuser
--

ALTER TABLE ONLY inm.warehouse_inventory
    ADD CONSTRAINT warehouse_inventory_pkey PRIMARY KEY (inventory_date, product_id);


--
-- Name: warehouse_order_history warehouse_order_history_pkey; Type: CONSTRAINT; Schema: inm; Owner: erpuser
--

ALTER TABLE ONLY inm.warehouse_order_history
    ADD CONSTRAINT warehouse_order_history_pkey PRIMARY KEY (sku, order_date, delivery_date, qty);


--
-- Name: even_id even_id_pkey; Type: CONSTRAINT; Schema: inm_test; Owner: erpuser
--

ALTER TABLE ONLY inm_test.even_id
    ADD CONSTRAINT even_id_pkey PRIMARY KEY (id);


--
-- Name: kiosk_par_level kiosk_par_level_pkey; Type: CONSTRAINT; Schema: inm_test; Owner: erpuser
--

ALTER TABLE ONLY inm_test.kiosk_par_level
    ADD CONSTRAINT kiosk_par_level_pkey PRIMARY KEY (kiosk_id, product_id);


--
-- Name: label label_pkey; Type: CONSTRAINT; Schema: inm_test; Owner: erpuser
--

ALTER TABLE ONLY inm_test.label
    ADD CONSTRAINT label_pkey PRIMARY KEY (id);


--
-- Name: odd_id odd_id_pkey; Type: CONSTRAINT; Schema: inm_test; Owner: erpuser
--

ALTER TABLE ONLY inm_test.odd_id
    ADD CONSTRAINT odd_id_pkey PRIMARY KEY (id);


--
-- Name: order order_pkey; Type: CONSTRAINT; Schema: inm_test; Owner: erpuser
--

ALTER TABLE ONLY inm_test."order"
    ADD CONSTRAINT order_pkey PRIMARY KEY (order_id);


--
-- Name: pick_allocation pick_allocation_pkey; Type: CONSTRAINT; Schema: inm_test; Owner: erpuser
--

ALTER TABLE ONLY inm_test.pick_allocation
    ADD CONSTRAINT pick_allocation_pkey PRIMARY KEY (pick_date, route_date, kiosk_id, sku_id);


--
-- Name: pick_demand pick_demand_pkey; Type: CONSTRAINT; Schema: inm_test; Owner: erpuser
--

ALTER TABLE ONLY inm_test.pick_demand
    ADD CONSTRAINT pick_demand_pkey PRIMARY KEY (pick_date, route_date, kiosk_id, sku_group_id);


--
-- Name: pick_inventory pick_inventory_pkey; Type: CONSTRAINT; Schema: inm_test; Owner: erpuser
--

ALTER TABLE ONLY inm_test.pick_inventory
    ADD CONSTRAINT pick_inventory_pkey PRIMARY KEY (pick_date, route_date, kiosk_id, sku_group_id);


--
-- Name: pick_rejection pick_rejection_pkey; Type: CONSTRAINT; Schema: inm_test; Owner: erpuser
--

ALTER TABLE ONLY inm_test.pick_rejection
    ADD CONSTRAINT pick_rejection_pkey PRIMARY KEY (pick_date, route_date, kiosk_id, item_id, item_type, reason);


--
-- Name: pick_route pick_route_pkey; Type: CONSTRAINT; Schema: inm_test; Owner: erpuser
--

ALTER TABLE ONLY inm_test.pick_route
    ADD CONSTRAINT pick_route_pkey PRIMARY KEY (pick_date, kiosk_id, route_date);


--
-- Name: pick_substitution pick_substitution_pkey; Type: CONSTRAINT; Schema: inm_test; Owner: erpuser
--

ALTER TABLE ONLY inm_test.pick_substitution
    ADD CONSTRAINT pick_substitution_pkey PRIMARY KEY (substituting_sku_group_id, substituted_sku_group_id, pick_date);


--
-- Name: temp_a temp_a_pkey; Type: CONSTRAINT; Schema: inm_test; Owner: erpuser
--

ALTER TABLE ONLY inm_test.temp_a
    ADD CONSTRAINT temp_a_pkey PRIMARY KEY (id);


--
-- Name: temp_b temp_b_pkey; Type: CONSTRAINT; Schema: inm_test; Owner: erpuser
--

ALTER TABLE ONLY inm_test.temp_b
    ADD CONSTRAINT temp_b_pkey PRIMARY KEY (id);


--
-- Name: temp_kiosk temp_kiosk_pkey; Type: CONSTRAINT; Schema: inm_test; Owner: erpuser
--

ALTER TABLE ONLY inm_test.temp_kiosk
    ADD CONSTRAINT temp_kiosk_pkey PRIMARY KEY (id);


--
-- Name: temp_test temp_test_pkey; Type: CONSTRAINT; Schema: inm_test; Owner: erpuser
--

ALTER TABLE ONLY inm_test.temp_test
    ADD CONSTRAINT temp_test_pkey PRIMARY KEY (id);


--
-- Name: test test_pkey; Type: CONSTRAINT; Schema: inm_test; Owner: erpuser
--

ALTER TABLE ONLY inm_test.test
    ADD CONSTRAINT test_pkey PRIMARY KEY (id);


--
-- Name: test_sequence test_sequence_pkey; Type: CONSTRAINT; Schema: inm_test; Owner: erpuser
--

ALTER TABLE ONLY inm_test.test_sequence
    ADD CONSTRAINT test_sequence_pkey PRIMARY KEY (id);


--
-- Name: kiosk kiosk_pkey; Type: CONSTRAINT; Schema: migration; Owner: erpuser
--

ALTER TABLE ONLY migration.kiosk
    ADD CONSTRAINT kiosk_pkey PRIMARY KEY (id);


--
-- Name: product product_pkey; Type: CONSTRAINT; Schema: migration; Owner: erpuser
--

ALTER TABLE ONLY migration.product
    ADD CONSTRAINT product_pkey PRIMARY KEY (id);


--
-- Name: reverse_product reverse_product_pkey; Type: CONSTRAINT; Schema: migration; Owner: erpuser
--

ALTER TABLE ONLY migration.reverse_product
    ADD CONSTRAINT reverse_product_pkey PRIMARY KEY (id);


--
-- Name: temp_product temp_product_pkey; Type: CONSTRAINT; Schema: migration; Owner: erpuser
--

ALTER TABLE ONLY migration.temp_product
    ADD CONSTRAINT temp_product_pkey PRIMARY KEY (id);


--
-- Name: card_product_fact card_product_fact_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: erpuser
--

ALTER TABLE ONLY mixalot.card_product_fact
    ADD CONSTRAINT card_product_fact_pkey PRIMARY KEY (id);


--
-- Name: gsheet_cache gsheet_cache_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: erpuser
--

ALTER TABLE ONLY mixalot.gsheet_cache
    ADD CONSTRAINT gsheet_cache_pkey PRIMARY KEY (id);


--
-- Name: history_order_pipeline history_order_pipeline_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: erpuser
--

ALTER TABLE ONLY mixalot.history_order_pipeline
    ADD CONSTRAINT history_order_pipeline_pkey PRIMARY KEY (id);


--
-- Name: inm_data inm_data_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: erpuser
--

ALTER TABLE ONLY mixalot.inm_data
    ADD CONSTRAINT inm_data_pkey PRIMARY KEY (id);


--
-- Name: kiosk_contents kiosk_contents_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: erpuser
--

ALTER TABLE ONLY mixalot.kiosk_contents
    ADD CONSTRAINT kiosk_contents_pkey PRIMARY KEY (id);


--
-- Name: kiosk_fact kiosk_fact_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: erpuser
--

ALTER TABLE ONLY mixalot.kiosk_fact
    ADD CONSTRAINT kiosk_fact_pkey PRIMARY KEY (id);


--
-- Name: log log_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: erpuser
--

ALTER TABLE ONLY mixalot.log
    ADD CONSTRAINT log_pkey PRIMARY KEY (id);


--
-- Name: merchandising_slot_sku_group merchandising_slot_sku_group_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: erpuser
--

ALTER TABLE ONLY mixalot.merchandising_slot_sku_group
    ADD CONSTRAINT merchandising_slot_sku_group_pkey PRIMARY KEY (sku_group_id);


--
-- Name: order_fact order_fact_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: erpuser
--

ALTER TABLE ONLY mixalot.order_fact
    ADD CONSTRAINT order_fact_pkey PRIMARY KEY (id);


--
-- Name: pick_preference_kiosk_sku pick_preference_kiosk_sku_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: erpuser
--

ALTER TABLE ONLY mixalot.pick_preference_kiosk_sku
    ADD CONSTRAINT pick_preference_kiosk_sku_pkey PRIMARY KEY (kiosk_id, sku_id);


--
-- Name: pick_priority_kiosk pick_priority_kiosk_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: erpuser
--

ALTER TABLE ONLY mixalot.pick_priority_kiosk
    ADD CONSTRAINT pick_priority_kiosk_pkey PRIMARY KEY (kiosk_id);


--
-- Name: product_fact product_fact_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: erpuser
--

ALTER TABLE ONLY mixalot.product_fact
    ADD CONSTRAINT product_fact_pkey PRIMARY KEY (id);


--
-- Name: request_log request_log_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: erpuser
--

ALTER TABLE ONLY mixalot.request_log
    ADD CONSTRAINT request_log_pkey PRIMARY KEY (request_uuid);


--
-- Name: route route_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: erpuser
--

ALTER TABLE ONLY mixalot.route
    ADD CONSTRAINT route_pkey PRIMARY KEY (route_date_time, driver_name);


--
-- Name: route_stop route_stop_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: erpuser
--

ALTER TABLE ONLY mixalot.route_stop
    ADD CONSTRAINT route_stop_pkey PRIMARY KEY (route_date_time, driver_name, location_name, schedule_at);


--
-- Name: sku_group_def sku_group_def_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: erpuser
--

ALTER TABLE ONLY mixalot.sku_group_def
    ADD CONSTRAINT sku_group_def_pkey PRIMARY KEY (id);


--
-- Name: sku_group_member sku_group_member_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: erpuser
--

ALTER TABLE ONLY mixalot.sku_group_member
    ADD CONSTRAINT sku_group_member_pkey PRIMARY KEY (id);


--
-- Name: sku_group sku_group_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: erpuser
--

ALTER TABLE ONLY mixalot.sku_group
    ADD CONSTRAINT sku_group_pkey PRIMARY KEY (id);


--
-- Name: sku_property_def sku_property_def_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: erpuser
--

ALTER TABLE ONLY mixalot.sku_property_def
    ADD CONSTRAINT sku_property_def_pkey PRIMARY KEY (id);


--
-- Name: sku_property sku_property_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: erpuser
--

ALTER TABLE ONLY mixalot.sku_property
    ADD CONSTRAINT sku_property_pkey PRIMARY KEY (sku_id, property_id);


--
-- Name: tmp_discount_applied tmp_discount_applied_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: erpuser
--

ALTER TABLE ONLY mixalot.tmp_discount_applied
    ADD CONSTRAINT tmp_discount_applied_pkey PRIMARY KEY (id);


--
-- Name: tmp_kiosk_status tmp_kiosk_status_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: erpuser
--

ALTER TABLE ONLY mixalot.tmp_kiosk_status
    ADD CONSTRAINT tmp_kiosk_status_pkey PRIMARY KEY (id);


--
-- Name: tmp_transact tmp_transact_pkey; Type: CONSTRAINT; Schema: mixalot; Owner: erpuser
--

ALTER TABLE ONLY mixalot.tmp_transact
    ADD CONSTRAINT tmp_transact_pkey PRIMARY KEY (order_id);


--
-- Name: accounting accounting_pkey; Type: CONSTRAINT; Schema: pantry; Owner: erpuser
--

ALTER TABLE ONLY pantry.accounting
    ADD CONSTRAINT accounting_pkey PRIMARY KEY (id);


--
-- Name: bad_timestamp bad_timestamp_pkey; Type: CONSTRAINT; Schema: pantry; Owner: erpuser
--

ALTER TABLE ONLY pantry.bad_timestamp
    ADD CONSTRAINT bad_timestamp_pkey PRIMARY KEY (id);


--
-- Name: campus_assets campus_assets_pkey; Type: CONSTRAINT; Schema: pantry; Owner: erpuser
--

ALTER TABLE ONLY pantry.campus_assets
    ADD CONSTRAINT campus_assets_pkey PRIMARY KEY (campus_id);


--
-- Name: campus campus_pkey; Type: CONSTRAINT; Schema: pantry; Owner: erpuser
--

ALTER TABLE ONLY pantry.campus
    ADD CONSTRAINT campus_pkey PRIMARY KEY (id);


--
-- Name: card card_pkey; Type: CONSTRAINT; Schema: pantry; Owner: erpuser
--

ALTER TABLE ONLY pantry.card
    ADD CONSTRAINT card_pkey PRIMARY KEY (id);


--
-- Name: coupon coupon_pkey; Type: CONSTRAINT; Schema: pantry; Owner: erpuser
--

ALTER TABLE ONLY pantry.coupon
    ADD CONSTRAINT coupon_pkey PRIMARY KEY (id);


--
-- Name: discount_applied discount_applied_pkey; Type: CONSTRAINT; Schema: pantry; Owner: erpuser
--

ALTER TABLE ONLY pantry.discount_applied
    ADD CONSTRAINT discount_applied_pkey PRIMARY KEY (id);


--
-- Name: discount_history discount_history_pkey; Type: CONSTRAINT; Schema: pantry; Owner: erpuser
--

ALTER TABLE ONLY pantry.discount_history
    ADD CONSTRAINT discount_history_pkey PRIMARY KEY (id);


--
-- Name: discount discount_pkey; Type: CONSTRAINT; Schema: pantry; Owner: erpuser
--

ALTER TABLE ONLY pantry.discount
    ADD CONSTRAINT discount_pkey PRIMARY KEY (id);


--
-- Name: email email_pkey; Type: CONSTRAINT; Schema: pantry; Owner: erpuser
--

ALTER TABLE ONLY pantry.email
    ADD CONSTRAINT email_pkey PRIMARY KEY (id);


--
-- Name: empty_transaction empty_transaction_pkey; Type: CONSTRAINT; Schema: pantry; Owner: erpuser
--

ALTER TABLE ONLY pantry.empty_transaction
    ADD CONSTRAINT empty_transaction_pkey PRIMARY KEY (id);


--
-- Name: fee_rates fee_rates_pkey; Type: CONSTRAINT; Schema: pantry; Owner: erpuser
--

ALTER TABLE ONLY pantry.fee_rates
    ADD CONSTRAINT fee_rates_pkey PRIMARY KEY (id);


--
-- Name: feedback feedback_pkey; Type: CONSTRAINT; Schema: pantry; Owner: erpuser
--

ALTER TABLE ONLY pantry.feedback
    ADD CONSTRAINT feedback_pkey PRIMARY KEY (id);


--
-- Name: group_campus group_campus_pkey; Type: CONSTRAINT; Schema: pantry; Owner: erpuser
--

ALTER TABLE ONLY pantry.group_campus
    ADD CONSTRAINT group_campus_pkey PRIMARY KEY (group_id, campus_id);


--
-- Name: group group_pkey; Type: CONSTRAINT; Schema: pantry; Owner: erpuser
--

ALTER TABLE ONLY pantry."group"
    ADD CONSTRAINT group_pkey PRIMARY KEY (id);


--
-- Name: history_epc_order history_epc_order_pkey; Type: CONSTRAINT; Schema: pantry; Owner: erpuser
--

ALTER TABLE ONLY pantry.history_epc_order
    ADD CONSTRAINT history_epc_order_pkey PRIMARY KEY (id);


--
-- Name: history history_pkey; Type: CONSTRAINT; Schema: pantry; Owner: erpuser
--

ALTER TABLE ONLY pantry.history
    ADD CONSTRAINT history_pkey PRIMARY KEY (id);


--
-- Name: inventory_history inventory_history_pkey; Type: CONSTRAINT; Schema: pantry; Owner: erpuser
--

ALTER TABLE ONLY pantry.inventory_history
    ADD CONSTRAINT inventory_history_pkey PRIMARY KEY (id);


--
-- Name: inventory_request inventory_request_pkey; Type: CONSTRAINT; Schema: pantry; Owner: erpuser
--

ALTER TABLE ONLY pantry.inventory_request
    ADD CONSTRAINT inventory_request_pkey PRIMARY KEY (id);


--
-- Name: kiosk_audit_log kiosk_audit_log_pkey; Type: CONSTRAINT; Schema: pantry; Owner: erpuser
--

ALTER TABLE ONLY pantry.kiosk_audit_log
    ADD CONSTRAINT kiosk_audit_log_pkey PRIMARY KEY (id);


--
-- Name: kiosk_catalog_downloads kiosk_catalog_downloads_pkey; Type: CONSTRAINT; Schema: pantry; Owner: erpuser
--

ALTER TABLE ONLY pantry.kiosk_catalog_downloads
    ADD CONSTRAINT kiosk_catalog_downloads_pkey PRIMARY KEY (id);


--
-- Name: kiosk_components_history kiosk_components_history_pkey; Type: CONSTRAINT; Schema: pantry; Owner: erpuser
--

ALTER TABLE ONLY pantry.kiosk_components_history
    ADD CONSTRAINT kiosk_components_history_pkey PRIMARY KEY (id);


--
-- Name: kiosk_par_level kiosk_par_level_pkey; Type: CONSTRAINT; Schema: pantry; Owner: erpuser
--

ALTER TABLE ONLY pantry.kiosk_par_level
    ADD CONSTRAINT kiosk_par_level_pkey PRIMARY KEY (kiosk_id, product_id);


--
-- Name: kiosk kiosk_pkey; Type: CONSTRAINT; Schema: pantry; Owner: erpuser
--

ALTER TABLE ONLY pantry.kiosk
    ADD CONSTRAINT kiosk_pkey PRIMARY KEY (id);


--
-- Name: kiosk_status kiosk_status_pkey; Type: CONSTRAINT; Schema: pantry; Owner: erpuser
--

ALTER TABLE ONLY pantry.kiosk_status
    ADD CONSTRAINT kiosk_status_pkey PRIMARY KEY (id);


--
-- Name: discount kiosk_type_pkey; Type: CONSTRAINT; Schema: pantry; Owner: erpuser
--

ALTER TABLE ONLY pantry.discount
    ADD CONSTRAINT kiosk_type_pkey UNIQUE (kiosk_id, type);


--
-- Name: kiosks_date_non_new kiosks_date_non_new_pkey; Type: CONSTRAINT; Schema: pantry; Owner: erpuser
--

ALTER TABLE ONLY pantry.kiosks_date_non_new
    ADD CONSTRAINT kiosks_date_non_new_pkey PRIMARY KEY (id);


--
-- Name: label_order label_order_pkey; Type: CONSTRAINT; Schema: pantry; Owner: erpuser
--

ALTER TABLE ONLY pantry.label_order
    ADD CONSTRAINT label_order_pkey PRIMARY KEY (id);


--
-- Name: label label_pkey; Type: CONSTRAINT; Schema: pantry; Owner: erpuser
--

ALTER TABLE ONLY pantry.label
    ADD CONSTRAINT label_pkey PRIMARY KEY (id);


--
-- Name: last_kiosk_status last_kiosk_status_pkey; Type: CONSTRAINT; Schema: pantry; Owner: erpuser
--

ALTER TABLE ONLY pantry.last_kiosk_status
    ADD CONSTRAINT last_kiosk_status_pkey PRIMARY KEY (id);


--
-- Name: manual_adjustment manual_adjustment_pkey; Type: CONSTRAINT; Schema: pantry; Owner: erpuser
--

ALTER TABLE ONLY pantry.manual_adjustment
    ADD CONSTRAINT manual_adjustment_pkey PRIMARY KEY (id);


--
-- Name: nutrition_filter nutrition_filter_pkey; Type: CONSTRAINT; Schema: pantry; Owner: erpuser
--

ALTER TABLE ONLY pantry.nutrition_filter
    ADD CONSTRAINT nutrition_filter_pkey PRIMARY KEY (id);


--
-- Name: order order_pkey; Type: CONSTRAINT; Schema: pantry; Owner: erpuser
--

ALTER TABLE ONLY pantry."order"
    ADD CONSTRAINT order_pkey PRIMARY KEY (order_id);


--
-- Name: payment_order payment_order_pkey; Type: CONSTRAINT; Schema: pantry; Owner: erpuser
--

ALTER TABLE ONLY pantry.payment_order
    ADD CONSTRAINT payment_order_pkey PRIMARY KEY (id);


--
-- Name: pick_list_row pick_list_row_pkey; Type: CONSTRAINT; Schema: pantry; Owner: erpuser
--

ALTER TABLE ONLY pantry.pick_list_row
    ADD CONSTRAINT pick_list_row_pkey PRIMARY KEY (id);


--
-- Name: product_categories product_categories_pkey; Type: CONSTRAINT; Schema: pantry; Owner: erpuser
--

ALTER TABLE ONLY pantry.product_categories
    ADD CONSTRAINT product_categories_pkey PRIMARY KEY (id);


--
-- Name: product_history product_history_pkey; Type: CONSTRAINT; Schema: pantry; Owner: erpuser
--

ALTER TABLE ONLY pantry.product_history
    ADD CONSTRAINT product_history_pkey PRIMARY KEY (id);


--
-- Name: product product_pkey; Type: CONSTRAINT; Schema: pantry; Owner: erpuser
--

ALTER TABLE ONLY pantry.product
    ADD CONSTRAINT product_pkey PRIMARY KEY (id);


--
-- Name: recent_transactions recent_transactions_pkey; Type: CONSTRAINT; Schema: pantry; Owner: erpuser
--

ALTER TABLE ONLY pantry.recent_transactions
    ADD CONSTRAINT recent_transactions_pkey PRIMARY KEY (kiosk_id);


--
-- Name: ro_order ro_order_pkey; Type: CONSTRAINT; Schema: pantry; Owner: erpuser
--

ALTER TABLE ONLY pantry.ro_order
    ADD CONSTRAINT ro_order_pkey PRIMARY KEY (order_id);


--
-- Name: role role_pkey; Type: CONSTRAINT; Schema: pantry; Owner: erpuser
--

ALTER TABLE ONLY pantry.role
    ADD CONSTRAINT role_pkey PRIMARY KEY (id);


--
-- Name: tag tag_pkey; Type: CONSTRAINT; Schema: pantry; Owner: erpuser
--

ALTER TABLE ONLY pantry.tag
    ADD CONSTRAINT tag_pkey PRIMARY KEY (id);


--
-- Name: temp_kiosk temp_kiosk_pkey; Type: CONSTRAINT; Schema: pantry; Owner: erpuser
--

ALTER TABLE ONLY pantry.temp_kiosk
    ADD CONSTRAINT temp_kiosk_pkey PRIMARY KEY (id);


--
-- Name: temp_product temp_product_pkey; Type: CONSTRAINT; Schema: pantry; Owner: erpuser
--

ALTER TABLE ONLY pantry.temp_product
    ADD CONSTRAINT temp_product_pkey PRIMARY KEY (id);


--
-- Name: temperature_tag_history temperature_tag_history_pkey; Type: CONSTRAINT; Schema: pantry; Owner: erpuser
--

ALTER TABLE ONLY pantry.temperature_tag_history
    ADD CONSTRAINT temperature_tag_history_pkey PRIMARY KEY (id);


--
-- Name: user user_pkey; Type: CONSTRAINT; Schema: pantry; Owner: erpuser
--

ALTER TABLE ONLY pantry."user"
    ADD CONSTRAINT user_pkey PRIMARY KEY (id);


--
-- Name: awsdms_ddl_audit awsdms_ddl_audit_pkey; Type: CONSTRAINT; Schema: public; Owner: erpuser
--

ALTER TABLE ONLY public.awsdms_ddl_audit
    ADD CONSTRAINT awsdms_ddl_audit_pkey PRIMARY KEY (c_key);


--
-- Name: bytecodelog bytecodelog_pkey; Type: CONSTRAINT; Schema: public; Owner: erpuser
--

ALTER TABLE ONLY public.bytecodelog
    ADD CONSTRAINT bytecodelog_pkey PRIMARY KEY (email, bytecode);


--
-- Name: history_order_pipeline history_order_pipeline_pkey; Type: CONSTRAINT; Schema: public; Owner: erpuser
--

ALTER TABLE ONLY public.history_order_pipeline
    ADD CONSTRAINT history_order_pipeline_pkey PRIMARY KEY (id);


--
-- Name: product_fact product_fact_pkey; Type: CONSTRAINT; Schema: public; Owner: erpuser
--

ALTER TABLE ONLY public.product_fact
    ADD CONSTRAINT product_fact_pkey PRIMARY KEY (id);


--
-- Name: fact_daily_kiosk_sku_summary fact_daily_kiosk_sku_summary_pkey; Type: CONSTRAINT; Schema: test; Owner: erpuser
--

ALTER TABLE ONLY test.fact_daily_kiosk_sku_summary
    ADD CONSTRAINT fact_daily_kiosk_sku_summary_pkey PRIMARY KEY (campus_id, product_id, kiosk_id, date_id);


--
-- Name: fact_monthly_kiosk_summary fact_monthly_kiosk_summary_pkey; Type: CONSTRAINT; Schema: test; Owner: erpuser
--

ALTER TABLE ONLY test.fact_monthly_kiosk_summary
    ADD CONSTRAINT fact_monthly_kiosk_summary_pkey PRIMARY KEY (campus_id, kiosk_id, date_id);


--
-- Name: kiosk_log kiosk_log_pkey; Type: CONSTRAINT; Schema: test; Owner: erpuser
--

ALTER TABLE ONLY test.kiosk_log
    ADD CONSTRAINT kiosk_log_pkey PRIMARY KEY (id);


--
-- Name: remittance_history remittance_history_pkey; Type: CONSTRAINT; Schema: test; Owner: erpuser
--

ALTER TABLE ONLY test.remittance_history
    ADD CONSTRAINT remittance_history_pkey PRIMARY KEY (campus_id, period, version);


--
-- Name: deps_saved_ddl deps_saved_ddl_pkey; Type: CONSTRAINT; Schema: util; Owner: erpuser
--

ALTER TABLE ONLY util.deps_saved_ddl
    ADD CONSTRAINT deps_saved_ddl_pkey PRIMARY KEY (deps_id);


--
-- Name: dw_fact_daily_kiosk_sku_summary_date_id; Type: INDEX; Schema: dw; Owner: muriel
--

CREATE INDEX dw_fact_daily_kiosk_sku_summary_date_id ON dw.fact_daily_kiosk_sku_summary USING btree (date_id);


--
-- Name: dw_fact_daily_kiosk_sku_summary_product_id; Type: INDEX; Schema: dw; Owner: muriel
--

CREATE INDEX dw_fact_daily_kiosk_sku_summary_product_id ON dw.fact_daily_kiosk_sku_summary USING btree (product_id);


--
-- Name: client_contact_client_id_idx; Type: INDEX; Schema: erp; Owner: erpuser
--

CREATE INDEX client_contact_client_id_idx ON erp.client_contact USING btree (client_id);


--
-- Name: client_id_contact_type; Type: INDEX; Schema: erp; Owner: erpuser
--

CREATE UNIQUE INDEX client_id_contact_type ON erp.contact USING btree (client_id, contact_type);


--
-- Name: tag_type_type_key; Type: INDEX; Schema: erp; Owner: erpuser
--

CREATE UNIQUE INDEX tag_type_type_key ON erp.tag_type USING btree (type);


--
-- Name: client_id_contact_type; Type: INDEX; Schema: erp_test; Owner: erpuser
--

CREATE UNIQUE INDEX client_id_contact_type ON erp_test.contact USING btree (client_id, contact_type);


--
-- Name: byte_created_idx; Type: INDEX; Schema: pantry; Owner: erpuser
--

CREATE INDEX byte_created_idx ON pantry."order" USING btree (created);


--
-- Name: byte_label_added_idx; Type: INDEX; Schema: pantry; Owner: erpuser
--

CREATE INDEX byte_label_added_idx ON pantry.label USING btree (to_timestamp((time_added)::double precision), product_id);


--
-- Name: byte_label_epc_idx; Type: INDEX; Schema: pantry; Owner: erpuser
--

CREATE INDEX byte_label_epc_idx ON pantry.label USING btree (epc);


--
-- Name: byte_label_kiosk_id_idx; Type: INDEX; Schema: pantry; Owner: erpuser
--

CREATE INDEX byte_label_kiosk_id_idx ON pantry.label USING btree (kiosk_id);


--
-- Name: byte_label_order_id_idx; Type: INDEX; Schema: pantry; Owner: erpuser
--

CREATE INDEX byte_label_order_id_idx ON pantry.label USING btree (order_id);


--
-- Name: byte_label_order_status_idx; Type: INDEX; Schema: pantry; Owner: erpuser
--

CREATE INDEX byte_label_order_status_idx ON pantry.label USING btree (order_id, status);


--
-- Name: byte_label_ts_idx; Type: INDEX; Schema: pantry; Owner: erpuser
--

CREATE INDEX byte_label_ts_idx ON pantry.label USING btree (to_timestamp((COALESCE(time_updated, time_created, time_added))::double precision));


--
-- Name: byte_raw_orders_ts_idx; Type: INDEX; Schema: pantry; Owner: erpuser
--

CREATE INDEX byte_raw_orders_ts_idx ON pantry."order" USING btree (to_timestamp((created)::double precision)) WHERE (campus_id = 87);


--
-- Name: byte_tickets_idx; Type: INDEX; Schema: pantry; Owner: erpuser
--

CREATE INDEX byte_tickets_idx ON pantry."order" USING btree (to_timestamp((created)::double precision)) WHERE ((campus_id = 87) AND ((state)::text = ANY (ARRAY[('Processed'::character varying)::text, ('Refunded'::character varying)::text])));


--
-- Name: byte_time_created_idx; Type: INDEX; Schema: pantry; Owner: erpuser
--

CREATE INDEX byte_time_created_idx ON pantry.label USING btree (time_created);


--
-- Name: history_epc; Type: INDEX; Schema: pantry; Owner: erpuser
--

CREATE INDEX history_epc ON pantry.history USING btree (epc);


--
-- Name: history_idx; Type: INDEX; Schema: pantry; Owner: erpuser
--

CREATE INDEX history_idx ON pantry.history USING btree (to_timestamp(("time")::double precision));


--
-- Name: history_kiosk_id; Type: INDEX; Schema: pantry; Owner: erpuser
--

CREATE INDEX history_kiosk_id ON pantry.history USING btree (kiosk_id);


--
-- Name: history_order_id; Type: INDEX; Schema: pantry; Owner: erpuser
--

CREATE INDEX history_order_id ON pantry.history USING btree (order_id);


--
-- Name: history_time; Type: INDEX; Schema: pantry; Owner: erpuser
--

CREATE INDEX history_time ON pantry.history USING btree ("time");


--
-- Name: idx_pantry_product_consumer_category; Type: INDEX; Schema: pantry; Owner: erpuser
--

CREATE INDEX idx_pantry_product_consumer_category ON pantry.product USING btree (consumer_category);


--
-- Name: inventory_history_kiosk_id_time_idx; Type: INDEX; Schema: pantry; Owner: erpuser
--

CREATE INDEX inventory_history_kiosk_id_time_idx ON pantry.inventory_history USING btree (kiosk_id, "time");


--
-- Name: kiosk_status_kiosk_id_time_idx; Type: INDEX; Schema: pantry; Owner: erpuser
--

CREATE INDEX kiosk_status_kiosk_id_time_idx ON pantry.kiosk_status USING btree (kiosk_id, "time");


--
-- Name: pantry_coupon_code_idx; Type: INDEX; Schema: pantry; Owner: erpuser
--

CREATE INDEX pantry_coupon_code_idx ON pantry.coupon USING btree (code);


--
-- Name: pantry_order_coupon_idx; Type: INDEX; Schema: pantry; Owner: erpuser
--

CREATE INDEX pantry_order_coupon_idx ON pantry."order" USING btree (coupon);


--
-- Name: pantry_order_kiosk_id; Type: INDEX; Schema: pantry; Owner: erpuser
--

CREATE INDEX pantry_order_kiosk_id ON pantry."order" USING btree (kiosk_id);


--
-- Name: pantry_order_kiosk_id_ts; Type: INDEX; Schema: pantry; Owner: erpuser
--

CREATE INDEX pantry_order_kiosk_id_ts ON pantry."order" USING btree (kiosk_id, created) WHERE ((campus_id = 87) AND ((order_id)::text !~~ 'RE%'::text));


--
-- Name: ro_order_customer_full_name_idx; Type: INDEX; Schema: pantry; Owner: erpuser
--

CREATE INDEX ro_order_customer_full_name_idx ON pantry.ro_order USING btree (customer_full_name);


--
-- Name: ro_order_to_timestamp_campus_id_idx; Type: INDEX; Schema: pantry; Owner: erpuser
--

CREATE INDEX ro_order_to_timestamp_campus_id_idx ON pantry.ro_order USING btree (to_timestamp((created)::double precision), campus_id);


--
-- Name: to_timestamp_created_state_status; Type: INDEX; Schema: pantry; Owner: erpuser
--

CREATE INDEX to_timestamp_created_state_status ON pantry."order" USING btree (to_timestamp((created)::double precision), state, status);


--
-- Name: to_timestamp_time; Type: INDEX; Schema: pantry; Owner: erpuser
--

CREATE INDEX to_timestamp_time ON pantry.kiosk_status USING btree (to_timestamp(("time")::double precision));


--
-- Name: fact_daily_kiosk_sku_summary_date_id_idx; Type: INDEX; Schema: test; Owner: erpuser
--

CREATE INDEX fact_daily_kiosk_sku_summary_date_id_idx ON test.fact_daily_kiosk_sku_summary USING btree (date_id);


--
-- Name: fact_daily_kiosk_sku_summary_product_id_idx; Type: INDEX; Schema: test; Owner: erpuser
--

CREATE INDEX fact_daily_kiosk_sku_summary_product_id_idx ON test.fact_daily_kiosk_sku_summary USING btree (product_id);


--
-- Name: campus sync_campus; Type: TRIGGER; Schema: pantry; Owner: erpuser
--

CREATE TRIGGER sync_campus BEFORE INSERT OR DELETE OR UPDATE ON pantry.campus FOR EACH ROW EXECUTE PROCEDURE pantry.sync_campus();
false TRIGGER
HERE false TRIGGER
HERE map[sync_campus:CREATE TRIGGER sync_campus BEFORE INSERT OR DELETE OR UPDATE ON pantry.campus FOR EACH ROW EXECUTE PROCEDURE pantry.sync_campus();]


--
-- Name: kiosk sync_kiosk; Type: TRIGGER; Schema: pantry; Owner: erpuser
--

CREATE TRIGGER sync_kiosk BEFORE INSERT OR DELETE OR UPDATE ON pantry.kiosk FOR EACH ROW EXECUTE PROCEDURE erp.sync_kiosk();


--
-- Name: label_order sync_label_order; Type: TRIGGER; Schema: pantry; Owner: erpuser
--

CREATE TRIGGER sync_label_order BEFORE INSERT OR DELETE OR UPDATE ON pantry.label_order FOR EACH ROW EXECUTE PROCEDURE pantry.sync_label_order();


--
-- Name: product sync_product; Type: TRIGGER; Schema: pantry; Owner: erpuser
--

CREATE TRIGGER sync_product BEFORE INSERT OR DELETE OR UPDATE ON pantry.product FOR EACH ROW EXECUTE PROCEDURE erp.sync_product();


--
-- Name: log log_order_id_fkey; Type: FK CONSTRAINT; Schema: mixalot; Owner: erpuser
--

ALTER TABLE ONLY mixalot.log
    ADD CONSTRAINT log_order_id_fkey FOREIGN KEY (order_id) REFERENCES mixalot.tmp_transact(order_id);


--
-- Name: SCHEMA campus_87; Type: ACL; Schema: -; Owner: erpuser
--

GRANT USAGE ON SCHEMA campus_87 TO rc87;


--
-- Name: SCHEMA dw; Type: ACL; Schema: -; Owner: muriel
--

GRANT ALL ON SCHEMA dw TO lambdazen;
GRANT ALL ON SCHEMA dw TO yann;
GRANT ALL ON SCHEMA dw TO readonly;
GRANT USAGE ON SCHEMA dw TO dbservice;
GRANT ALL ON SCHEMA dw TO bytedevs;
GRANT ALL ON SCHEMA dw TO tableauuser;


--
-- Name: SCHEMA erp; Type: ACL; Schema: -; Owner: erpuser
--

GRANT ALL ON SCHEMA erp TO muriel;
GRANT ALL ON SCHEMA erp TO lambdazen;
GRANT ALL ON SCHEMA erp TO yann;
GRANT USAGE ON SCHEMA erp TO report;
GRANT USAGE ON SCHEMA erp TO readonly;
GRANT USAGE ON SCHEMA erp TO dbservice;


--
-- Name: SCHEMA inm; Type: ACL; Schema: -; Owner: erpuser
--

GRANT ALL ON SCHEMA inm TO lambdazen;
GRANT ALL ON SCHEMA inm TO muriel;
GRANT ALL ON SCHEMA inm TO yann;
GRANT USAGE ON SCHEMA inm TO readonly;
GRANT USAGE ON SCHEMA inm TO dbservice;
GRANT ALL ON SCHEMA inm TO tableauuser;
GRANT ALL ON SCHEMA inm TO bartender;
GRANT ALL ON SCHEMA inm TO bytedevs;


--
-- Name: SCHEMA mixalot; Type: ACL; Schema: -; Owner: erpuser
--

GRANT USAGE ON SCHEMA mixalot TO yann;
GRANT USAGE ON SCHEMA mixalot TO readonly;
GRANT ALL ON SCHEMA mixalot TO muriel;
GRANT ALL ON SCHEMA mixalot TO lambdazen;
GRANT ALL ON SCHEMA mixalot TO tableauuser;
GRANT ALL ON SCHEMA mixalot TO bartender;
GRANT ALL ON SCHEMA mixalot TO bytedevs;


--
-- Name: SCHEMA pantry; Type: ACL; Schema: -; Owner: erpuser
--

GRANT ALL ON SCHEMA pantry TO muriel;
GRANT ALL ON SCHEMA pantry TO lambdazen;
GRANT ALL ON SCHEMA pantry TO yann;
GRANT USAGE ON SCHEMA pantry TO readonly;
GRANT USAGE ON SCHEMA pantry TO dbservice;
GRANT USAGE ON SCHEMA pantry TO jungvu;
GRANT ALL ON SCHEMA pantry TO tableauuser;
GRANT ALL ON SCHEMA pantry TO bartender;
GRANT ALL ON SCHEMA pantry TO bytedevs;


--
-- Name: SCHEMA public; Type: ACL; Schema: -; Owner: erpuser
--

REVOKE ALL ON SCHEMA public FROM rdsadmin;
REVOKE ALL ON SCHEMA public FROM PUBLIC;
GRANT ALL ON SCHEMA public TO erpuser;
GRANT ALL ON SCHEMA public TO PUBLIC;
GRANT ALL ON SCHEMA public TO yann;
GRANT ALL ON SCHEMA public TO tableauuser;
GRANT ALL ON SCHEMA public TO bartender;
GRANT ALL ON SCHEMA public TO bytedevs;


--
-- Name: SCHEMA test; Type: ACL; Schema: -; Owner: erpuser
--

GRANT ALL ON SCHEMA test TO lambdazen;
GRANT ALL ON SCHEMA test TO bartender;
GRANT ALL ON SCHEMA test TO bytedevs;


--
-- Name: SCHEMA type; Type: ACL; Schema: -; Owner: erpuser
--

GRANT ALL ON SCHEMA type TO muriel;
GRANT ALL ON SCHEMA type TO lambdazen;
GRANT ALL ON SCHEMA type TO yann;
GRANT USAGE ON SCHEMA type TO report;
GRANT ALL ON SCHEMA type TO bartender;
GRANT ALL ON SCHEMA type TO bytedevs;


--
-- Name: FUNCTION byte_losses(beginning_date date, ending_date date); Type: ACL; Schema: dw; Owner: muriel
--

GRANT ALL ON FUNCTION dw.byte_losses(beginning_date date, ending_date date) TO yann;
GRANT ALL ON FUNCTION dw.byte_losses(beginning_date date, ending_date date) TO dbservice;
GRANT ALL ON FUNCTION dw.byte_losses(beginning_date date, ending_date date) TO bytedevs;
GRANT ALL ON FUNCTION dw.byte_losses(beginning_date date, ending_date date) TO tableauuser;


--
-- Name: FUNCTION byte_restocks(beginning_date date, ending_date date); Type: ACL; Schema: dw; Owner: erpuser
--

GRANT ALL ON FUNCTION dw.byte_restocks(beginning_date date, ending_date date) TO lambdazen;
GRANT ALL ON FUNCTION dw.byte_restocks(beginning_date date, ending_date date) TO yann;
GRANT ALL ON FUNCTION dw.byte_restocks(beginning_date date, ending_date date) TO bytedevs;
GRANT ALL ON FUNCTION dw.byte_restocks(beginning_date date, ending_date date) TO tableauuser;


--
-- Name: FUNCTION byte_sales(beginning_date date, ending_date date); Type: ACL; Schema: dw; Owner: muriel
--

GRANT ALL ON FUNCTION dw.byte_sales(beginning_date date, ending_date date) TO yann;
GRANT ALL ON FUNCTION dw.byte_sales(beginning_date date, ending_date date) TO dbservice;
GRANT ALL ON FUNCTION dw.byte_sales(beginning_date date, ending_date date) TO bytedevs;
GRANT ALL ON FUNCTION dw.byte_sales(beginning_date date, ending_date date) TO tableauuser;


--
-- Name: FUNCTION byte_spoils(beginning_date date, ending_date date); Type: ACL; Schema: dw; Owner: erpuser
--

GRANT ALL ON FUNCTION dw.byte_spoils(beginning_date date, ending_date date) TO lambdazen;
GRANT ALL ON FUNCTION dw.byte_spoils(beginning_date date, ending_date date) TO yann;
GRANT ALL ON FUNCTION dw.byte_spoils(beginning_date date, ending_date date) TO bytedevs;
GRANT ALL ON FUNCTION dw.byte_spoils(beginning_date date, ending_date date) TO tableauuser;


--
-- Name: FUNCTION calculate_prorated_fee(fee numeric, month_date date, deployment_date date); Type: ACL; Schema: dw; Owner: erpuser
--

GRANT ALL ON FUNCTION dw.calculate_prorated_fee(fee numeric, month_date date, deployment_date date) TO lambdazen;
GRANT ALL ON FUNCTION dw.calculate_prorated_fee(fee numeric, month_date date, deployment_date date) TO yann;
GRANT ALL ON FUNCTION dw.calculate_prorated_fee(fee numeric, month_date date, deployment_date date) TO bytedevs;
GRANT ALL ON FUNCTION dw.calculate_prorated_fee(fee numeric, month_date date, deployment_date date) TO tableauuser;


--
-- Name: FUNCTION clear_daily_kiosk_sku_summary(beginning_date date, ending_date date); Type: ACL; Schema: dw; Owner: muriel
--

GRANT ALL ON FUNCTION dw.clear_daily_kiosk_sku_summary(beginning_date date, ending_date date) TO yann;
GRANT ALL ON FUNCTION dw.clear_daily_kiosk_sku_summary(beginning_date date, ending_date date) TO dbservice;
GRANT ALL ON FUNCTION dw.clear_daily_kiosk_sku_summary(beginning_date date, ending_date date) TO bytedevs;
GRANT ALL ON FUNCTION dw.clear_daily_kiosk_sku_summary(beginning_date date, ending_date date) TO tableauuser;


--
-- Name: FUNCTION clear_fact_monthly_kiosk_summary(month_date date); Type: ACL; Schema: dw; Owner: erpuser
--

GRANT ALL ON FUNCTION dw.clear_fact_monthly_kiosk_summary(month_date date) TO lambdazen;
GRANT ALL ON FUNCTION dw.clear_fact_monthly_kiosk_summary(month_date date) TO yann;
GRANT ALL ON FUNCTION dw.clear_fact_monthly_kiosk_summary(month_date date) TO bytedevs;
GRANT ALL ON FUNCTION dw.clear_fact_monthly_kiosk_summary(month_date date) TO tableauuser;


--
-- Name: FUNCTION export_consolidated_remittance(month_date date); Type: ACL; Schema: dw; Owner: erpuser
--

GRANT ALL ON FUNCTION dw.export_consolidated_remittance(month_date date) TO lambdazen;
GRANT ALL ON FUNCTION dw.export_consolidated_remittance(month_date date) TO yann;
GRANT ALL ON FUNCTION dw.export_consolidated_remittance(month_date date) TO bytedevs;
GRANT ALL ON FUNCTION dw.export_consolidated_remittance(month_date date) TO tableauuser;


--
-- Name: FUNCTION export_feedback(beginning_date date, ending_date date); Type: ACL; Schema: dw; Owner: erpuser
--

GRANT ALL ON FUNCTION dw.export_feedback(beginning_date date, ending_date date) TO lambdazen;
GRANT ALL ON FUNCTION dw.export_feedback(beginning_date date, ending_date date) TO yann;
GRANT ALL ON FUNCTION dw.export_feedback(beginning_date date, ending_date date) TO bytedevs;
GRANT ALL ON FUNCTION dw.export_feedback(beginning_date date, ending_date date) TO tableauuser;


--
-- Name: FUNCTION export_kiosk_performance(beginning_date date, ending_date date); Type: ACL; Schema: dw; Owner: erpuser
--

GRANT ALL ON FUNCTION dw.export_kiosk_performance(beginning_date date, ending_date date) TO lambdazen;
GRANT ALL ON FUNCTION dw.export_kiosk_performance(beginning_date date, ending_date date) TO yann;
GRANT ALL ON FUNCTION dw.export_kiosk_performance(beginning_date date, ending_date date) TO bytedevs;
GRANT ALL ON FUNCTION dw.export_kiosk_performance(beginning_date date, ending_date date) TO tableauuser;


--
-- Name: FUNCTION export_kiosk_status(kiosk_number bigint); Type: ACL; Schema: dw; Owner: erpuser
--

GRANT ALL ON FUNCTION dw.export_kiosk_status(kiosk_number bigint) TO lambdazen;
GRANT ALL ON FUNCTION dw.export_kiosk_status(kiosk_number bigint) TO yann;
GRANT ALL ON FUNCTION dw.export_kiosk_status(kiosk_number bigint) TO bytedevs;
GRANT ALL ON FUNCTION dw.export_kiosk_status(kiosk_number bigint) TO tableauuser;


--
-- Name: FUNCTION export_licensee_fee(month_date date); Type: ACL; Schema: dw; Owner: erpuser
--

GRANT ALL ON FUNCTION dw.export_licensee_fee(month_date date) TO lambdazen;
GRANT ALL ON FUNCTION dw.export_licensee_fee(month_date date) TO yann;
GRANT ALL ON FUNCTION dw.export_licensee_fee(month_date date) TO bytedevs;
GRANT ALL ON FUNCTION dw.export_licensee_fee(month_date date) TO tableauuser;


--
-- Name: FUNCTION export_losses(beginning_date date, ending_date date); Type: ACL; Schema: dw; Owner: erpuser
--

GRANT ALL ON FUNCTION dw.export_losses(beginning_date date, ending_date date) TO lambdazen;
GRANT ALL ON FUNCTION dw.export_losses(beginning_date date, ending_date date) TO yann;
GRANT ALL ON FUNCTION dw.export_losses(beginning_date date, ending_date date) TO bytedevs;
GRANT ALL ON FUNCTION dw.export_losses(beginning_date date, ending_date date) TO tableauuser;


--
-- Name: FUNCTION export_remittance(month_date date); Type: ACL; Schema: dw; Owner: erpuser
--

GRANT ALL ON FUNCTION dw.export_remittance(month_date date) TO lambdazen;
GRANT ALL ON FUNCTION dw.export_remittance(month_date date) TO yann;
GRANT ALL ON FUNCTION dw.export_remittance(month_date date) TO bytedevs;
GRANT ALL ON FUNCTION dw.export_remittance(month_date date) TO tableauuser;


--
-- Name: FUNCTION export_spoilage(beginning_date date, ending_date date); Type: ACL; Schema: dw; Owner: erpuser
--

GRANT ALL ON FUNCTION dw.export_spoilage(beginning_date date, ending_date date) TO lambdazen;
GRANT ALL ON FUNCTION dw.export_spoilage(beginning_date date, ending_date date) TO yann;
GRANT ALL ON FUNCTION dw.export_spoilage(beginning_date date, ending_date date) TO bytedevs;
GRANT ALL ON FUNCTION dw.export_spoilage(beginning_date date, ending_date date) TO tableauuser;


--
-- Name: FUNCTION export_transaction(beginning_date timestamp without time zone, ending_date timestamp without time zone, time_zone character varying); Type: ACL; Schema: dw; Owner: erpuser
--

GRANT ALL ON FUNCTION dw.export_transaction(beginning_date timestamp without time zone, ending_date timestamp without time zone, time_zone character varying) TO lambdazen;
GRANT ALL ON FUNCTION dw.export_transaction(beginning_date timestamp without time zone, ending_date timestamp without time zone, time_zone character varying) TO yann;
GRANT ALL ON FUNCTION dw.export_transaction(beginning_date timestamp without time zone, ending_date timestamp without time zone, time_zone character varying) TO bytedevs;
GRANT ALL ON FUNCTION dw.export_transaction(beginning_date timestamp without time zone, ending_date timestamp without time zone, time_zone character varying) TO tableauuser;


--
-- Name: FUNCTION export_unconsolidated_remittance(month_date date); Type: ACL; Schema: dw; Owner: erpuser
--

GRANT ALL ON FUNCTION dw.export_unconsolidated_remittance(month_date date) TO lambdazen;
GRANT ALL ON FUNCTION dw.export_unconsolidated_remittance(month_date date) TO yann;
GRANT ALL ON FUNCTION dw.export_unconsolidated_remittance(month_date date) TO bytedevs;
GRANT ALL ON FUNCTION dw.export_unconsolidated_remittance(month_date date) TO tableauuser;


--
-- Name: FUNCTION insert_hb_stat_in_daily_byte_foods_summary(beginning_date date, ending_date date); Type: ACL; Schema: dw; Owner: erpuser
--

GRANT ALL ON FUNCTION dw.insert_hb_stat_in_daily_byte_foods_summary(beginning_date date, ending_date date) TO lambdazen;
GRANT ALL ON FUNCTION dw.insert_hb_stat_in_daily_byte_foods_summary(beginning_date date, ending_date date) TO yann;
GRANT ALL ON FUNCTION dw.insert_hb_stat_in_daily_byte_foods_summary(beginning_date date, ending_date date) TO bytedevs;
GRANT ALL ON FUNCTION dw.insert_hb_stat_in_daily_byte_foods_summary(beginning_date date, ending_date date) TO tableauuser;


--
-- Name: FUNCTION insert_in_monthly_kiosk_summary(month_date date); Type: ACL; Schema: dw; Owner: muriel
--

GRANT ALL ON FUNCTION dw.insert_in_monthly_kiosk_summary(month_date date) TO yann;
GRANT ALL ON FUNCTION dw.insert_in_monthly_kiosk_summary(month_date date) TO bytedevs;
GRANT ALL ON FUNCTION dw.insert_in_monthly_kiosk_summary(month_date date) TO tableauuser;


--
-- Name: FUNCTION insert_inv_snapshot_in_daily_byte_foods_summary(beginning_date date, ending_date date); Type: ACL; Schema: dw; Owner: erpuser
--

GRANT ALL ON FUNCTION dw.insert_inv_snapshot_in_daily_byte_foods_summary(beginning_date date, ending_date date) TO lambdazen;
GRANT ALL ON FUNCTION dw.insert_inv_snapshot_in_daily_byte_foods_summary(beginning_date date, ending_date date) TO yann;
GRANT ALL ON FUNCTION dw.insert_inv_snapshot_in_daily_byte_foods_summary(beginning_date date, ending_date date) TO bytedevs;
GRANT ALL ON FUNCTION dw.insert_inv_snapshot_in_daily_byte_foods_summary(beginning_date date, ending_date date) TO tableauuser;


--
-- Name: FUNCTION insert_losses_in_daily_kiosk_sku_summary(beginning_date date, ending_date date); Type: ACL; Schema: dw; Owner: muriel
--

GRANT ALL ON FUNCTION dw.insert_losses_in_daily_kiosk_sku_summary(beginning_date date, ending_date date) TO yann;
GRANT ALL ON FUNCTION dw.insert_losses_in_daily_kiosk_sku_summary(beginning_date date, ending_date date) TO dbservice;
GRANT ALL ON FUNCTION dw.insert_losses_in_daily_kiosk_sku_summary(beginning_date date, ending_date date) TO bytedevs;
GRANT ALL ON FUNCTION dw.insert_losses_in_daily_kiosk_sku_summary(beginning_date date, ending_date date) TO tableauuser;


--
-- Name: FUNCTION insert_sales_after_discount_in_daily_kiosk_sku_summary(beginning_date date, ending_date date); Type: ACL; Schema: dw; Owner: erpuser
--

GRANT ALL ON FUNCTION dw.insert_sales_after_discount_in_daily_kiosk_sku_summary(beginning_date date, ending_date date) TO lambdazen;
GRANT ALL ON FUNCTION dw.insert_sales_after_discount_in_daily_kiosk_sku_summary(beginning_date date, ending_date date) TO yann;
GRANT ALL ON FUNCTION dw.insert_sales_after_discount_in_daily_kiosk_sku_summary(beginning_date date, ending_date date) TO bytedevs;
GRANT ALL ON FUNCTION dw.insert_sales_after_discount_in_daily_kiosk_sku_summary(beginning_date date, ending_date date) TO tableauuser;


--
-- Name: FUNCTION insert_sales_daily_byte_foods_summary(beginning_date date, ending_date date); Type: ACL; Schema: dw; Owner: erpuser
--

GRANT ALL ON FUNCTION dw.insert_sales_daily_byte_foods_summary(beginning_date date, ending_date date) TO lambdazen;
GRANT ALL ON FUNCTION dw.insert_sales_daily_byte_foods_summary(beginning_date date, ending_date date) TO yann;
GRANT ALL ON FUNCTION dw.insert_sales_daily_byte_foods_summary(beginning_date date, ending_date date) TO bytedevs;
GRANT ALL ON FUNCTION dw.insert_sales_daily_byte_foods_summary(beginning_date date, ending_date date) TO tableauuser;


--
-- Name: FUNCTION insert_sales_in_daily_kiosk_sku_summary(beginning_date date, ending_date date); Type: ACL; Schema: dw; Owner: muriel
--

GRANT ALL ON FUNCTION dw.insert_sales_in_daily_kiosk_sku_summary(beginning_date date, ending_date date) TO yann;
GRANT ALL ON FUNCTION dw.insert_sales_in_daily_kiosk_sku_summary(beginning_date date, ending_date date) TO dbservice;
GRANT ALL ON FUNCTION dw.insert_sales_in_daily_kiosk_sku_summary(beginning_date date, ending_date date) TO bytedevs;
GRANT ALL ON FUNCTION dw.insert_sales_in_daily_kiosk_sku_summary(beginning_date date, ending_date date) TO tableauuser;


--
-- Name: FUNCTION insert_sales_monthly_byte_foods_summary(month_date date); Type: ACL; Schema: dw; Owner: erpuser
--

GRANT ALL ON FUNCTION dw.insert_sales_monthly_byte_foods_summary(month_date date) TO lambdazen;
GRANT ALL ON FUNCTION dw.insert_sales_monthly_byte_foods_summary(month_date date) TO yann;
GRANT ALL ON FUNCTION dw.insert_sales_monthly_byte_foods_summary(month_date date) TO bytedevs;
GRANT ALL ON FUNCTION dw.insert_sales_monthly_byte_foods_summary(month_date date) TO tableauuser;


--
-- Name: FUNCTION insert_spoils_in_daily_kiosk_sku_summary(beginning_date date, ending_date date); Type: ACL; Schema: dw; Owner: muriel
--

GRANT ALL ON FUNCTION dw.insert_spoils_in_daily_kiosk_sku_summary(beginning_date date, ending_date date) TO yann;
GRANT ALL ON FUNCTION dw.insert_spoils_in_daily_kiosk_sku_summary(beginning_date date, ending_date date) TO dbservice;
GRANT ALL ON FUNCTION dw.insert_spoils_in_daily_kiosk_sku_summary(beginning_date date, ending_date date) TO bytedevs;
GRANT ALL ON FUNCTION dw.insert_spoils_in_daily_kiosk_sku_summary(beginning_date date, ending_date date) TO tableauuser;


--
-- Name: FUNCTION insert_stock_in_daily_kiosk_sku_summary(beginning_date date, ending_date date); Type: ACL; Schema: dw; Owner: erpuser
--

GRANT ALL ON FUNCTION dw.insert_stock_in_daily_kiosk_sku_summary(beginning_date date, ending_date date) TO lambdazen;
GRANT ALL ON FUNCTION dw.insert_stock_in_daily_kiosk_sku_summary(beginning_date date, ending_date date) TO yann;
GRANT ALL ON FUNCTION dw.insert_stock_in_daily_kiosk_sku_summary(beginning_date date, ending_date date) TO bytedevs;
GRANT ALL ON FUNCTION dw.insert_stock_in_daily_kiosk_sku_summary(beginning_date date, ending_date date) TO tableauuser;


--
-- Name: FUNCTION losses(beginning_date date, ending_date date); Type: ACL; Schema: dw; Owner: muriel
--

GRANT ALL ON FUNCTION dw.losses(beginning_date date, ending_date date) TO yann;
GRANT ALL ON FUNCTION dw.losses(beginning_date date, ending_date date) TO dbservice;
GRANT ALL ON FUNCTION dw.losses(beginning_date date, ending_date date) TO bytedevs;
GRANT ALL ON FUNCTION dw.losses(beginning_date date, ending_date date) TO tableauuser;


--
-- Name: FUNCTION non_byte_losses(beginning_date date, ending_date date); Type: ACL; Schema: dw; Owner: muriel
--

GRANT ALL ON FUNCTION dw.non_byte_losses(beginning_date date, ending_date date) TO yann;
GRANT ALL ON FUNCTION dw.non_byte_losses(beginning_date date, ending_date date) TO dbservice;
GRANT ALL ON FUNCTION dw.non_byte_losses(beginning_date date, ending_date date) TO bytedevs;
GRANT ALL ON FUNCTION dw.non_byte_losses(beginning_date date, ending_date date) TO tableauuser;


--
-- Name: FUNCTION non_byte_restocks(beginning_date date, ending_date date); Type: ACL; Schema: dw; Owner: erpuser
--

GRANT ALL ON FUNCTION dw.non_byte_restocks(beginning_date date, ending_date date) TO lambdazen;
GRANT ALL ON FUNCTION dw.non_byte_restocks(beginning_date date, ending_date date) TO yann;
GRANT ALL ON FUNCTION dw.non_byte_restocks(beginning_date date, ending_date date) TO bytedevs;
GRANT ALL ON FUNCTION dw.non_byte_restocks(beginning_date date, ending_date date) TO tableauuser;


--
-- Name: FUNCTION non_byte_sales(beginning_date date, ending_date date); Type: ACL; Schema: dw; Owner: muriel
--

GRANT ALL ON FUNCTION dw.non_byte_sales(beginning_date date, ending_date date) TO yann;
GRANT ALL ON FUNCTION dw.non_byte_sales(beginning_date date, ending_date date) TO dbservice;
GRANT ALL ON FUNCTION dw.non_byte_sales(beginning_date date, ending_date date) TO bytedevs;
GRANT ALL ON FUNCTION dw.non_byte_sales(beginning_date date, ending_date date) TO tableauuser;


--
-- Name: FUNCTION non_byte_spoils(beginning_date date, ending_date date); Type: ACL; Schema: dw; Owner: erpuser
--

GRANT ALL ON FUNCTION dw.non_byte_spoils(beginning_date date, ending_date date) TO lambdazen;
GRANT ALL ON FUNCTION dw.non_byte_spoils(beginning_date date, ending_date date) TO yann;
GRANT ALL ON FUNCTION dw.non_byte_spoils(beginning_date date, ending_date date) TO bytedevs;
GRANT ALL ON FUNCTION dw.non_byte_spoils(beginning_date date, ending_date date) TO tableauuser;


--
-- Name: FUNCTION refresh_daily_byte_foods_summary(beginning_date date, ending_date date); Type: ACL; Schema: dw; Owner: erpuser
--

GRANT ALL ON FUNCTION dw.refresh_daily_byte_foods_summary(beginning_date date, ending_date date) TO lambdazen;
GRANT ALL ON FUNCTION dw.refresh_daily_byte_foods_summary(beginning_date date, ending_date date) TO yann;
GRANT ALL ON FUNCTION dw.refresh_daily_byte_foods_summary(beginning_date date, ending_date date) TO bytedevs;
GRANT ALL ON FUNCTION dw.refresh_daily_byte_foods_summary(beginning_date date, ending_date date) TO tableauuser;


--
-- Name: FUNCTION refresh_daily_kiosk_sku_summary(beginning_date date, ending_date date); Type: ACL; Schema: dw; Owner: muriel
--

GRANT ALL ON FUNCTION dw.refresh_daily_kiosk_sku_summary(beginning_date date, ending_date date) TO yann;
GRANT ALL ON FUNCTION dw.refresh_daily_kiosk_sku_summary(beginning_date date, ending_date date) TO dbservice;
GRANT ALL ON FUNCTION dw.refresh_daily_kiosk_sku_summary(beginning_date date, ending_date date) TO bytedevs;
GRANT ALL ON FUNCTION dw.refresh_daily_kiosk_sku_summary(beginning_date date, ending_date date) TO tableauuser;


--
-- Name: FUNCTION refresh_dim_kiosk(); Type: ACL; Schema: dw; Owner: muriel
--

GRANT ALL ON FUNCTION dw.refresh_dim_kiosk() TO yann;
GRANT ALL ON FUNCTION dw.refresh_dim_kiosk() TO dbservice;
GRANT ALL ON FUNCTION dw.refresh_dim_kiosk() TO bytedevs;
GRANT ALL ON FUNCTION dw.refresh_dim_kiosk() TO tableauuser;


--
-- Name: FUNCTION refresh_dim_product(); Type: ACL; Schema: dw; Owner: muriel
--

GRANT ALL ON FUNCTION dw.refresh_dim_product() TO yann;
GRANT ALL ON FUNCTION dw.refresh_dim_product() TO dbservice;
GRANT ALL ON FUNCTION dw.refresh_dim_product() TO bytedevs;
GRANT ALL ON FUNCTION dw.refresh_dim_product() TO tableauuser;


--
-- Name: FUNCTION refresh_monthly_byte_foods_summary(month_date date); Type: ACL; Schema: dw; Owner: erpuser
--

GRANT ALL ON FUNCTION dw.refresh_monthly_byte_foods_summary(month_date date) TO lambdazen;
GRANT ALL ON FUNCTION dw.refresh_monthly_byte_foods_summary(month_date date) TO yann;
GRANT ALL ON FUNCTION dw.refresh_monthly_byte_foods_summary(month_date date) TO bytedevs;
GRANT ALL ON FUNCTION dw.refresh_monthly_byte_foods_summary(month_date date) TO tableauuser;


--
-- Name: FUNCTION refresh_monthly_kiosk_summary(month_date date); Type: ACL; Schema: dw; Owner: erpuser
--

GRANT ALL ON FUNCTION dw.refresh_monthly_kiosk_summary(month_date date) TO lambdazen;
GRANT ALL ON FUNCTION dw.refresh_monthly_kiosk_summary(month_date date) TO yann;
GRANT ALL ON FUNCTION dw.refresh_monthly_kiosk_summary(month_date date) TO bytedevs;
GRANT ALL ON FUNCTION dw.refresh_monthly_kiosk_summary(month_date date) TO tableauuser;


--
-- Name: FUNCTION restocks(beginning_date date, ending_date date); Type: ACL; Schema: dw; Owner: muriel
--

GRANT ALL ON FUNCTION dw.restocks(beginning_date date, ending_date date) TO yann;
GRANT ALL ON FUNCTION dw.restocks(beginning_date date, ending_date date) TO dbservice;
GRANT ALL ON FUNCTION dw.restocks(beginning_date date, ending_date date) TO bytedevs;
GRANT ALL ON FUNCTION dw.restocks(beginning_date date, ending_date date) TO tableauuser;


--
-- Name: FUNCTION sales(beginning_date date, ending_date date); Type: ACL; Schema: dw; Owner: muriel
--

GRANT ALL ON FUNCTION dw.sales(beginning_date date, ending_date date) TO yann;
GRANT ALL ON FUNCTION dw.sales(beginning_date date, ending_date date) TO dbservice;
GRANT ALL ON FUNCTION dw.sales(beginning_date date, ending_date date) TO bytedevs;
GRANT ALL ON FUNCTION dw.sales(beginning_date date, ending_date date) TO tableauuser;


--
-- Name: FUNCTION spoils(beginning_date date, ending_date date); Type: ACL; Schema: dw; Owner: muriel
--

GRANT ALL ON FUNCTION dw.spoils(beginning_date date, ending_date date) TO yann;
GRANT ALL ON FUNCTION dw.spoils(beginning_date date, ending_date date) TO dbservice;
GRANT ALL ON FUNCTION dw.spoils(beginning_date date, ending_date date) TO bytedevs;
GRANT ALL ON FUNCTION dw.spoils(beginning_date date, ending_date date) TO tableauuser;


--
-- Name: FUNCTION stockout(beginning_date date, ending_date date, kiosk_number bigint); Type: ACL; Schema: dw; Owner: erpuser
--

GRANT ALL ON FUNCTION dw.stockout(beginning_date date, ending_date date, kiosk_number bigint) TO lambdazen;
GRANT ALL ON FUNCTION dw.stockout(beginning_date date, ending_date date, kiosk_number bigint) TO yann;
GRANT ALL ON FUNCTION dw.stockout(beginning_date date, ending_date date, kiosk_number bigint) TO bytedevs;
GRANT ALL ON FUNCTION dw.stockout(beginning_date date, ending_date date, kiosk_number bigint) TO tableauuser;


--
-- Name: FUNCTION parse_address(address_str text); Type: ACL; Schema: erp; Owner: erpuser
--

GRANT ALL ON FUNCTION erp.parse_address(address_str text) TO muriel;
GRANT ALL ON FUNCTION erp.parse_address(address_str text) TO yann;
GRANT ALL ON FUNCTION erp.parse_address(address_str text) TO dbservice;


--
-- Name: FUNCTION parse_phone(text_to_parse text); Type: ACL; Schema: erp; Owner: erpuser
--

GRANT ALL ON FUNCTION erp.parse_phone(text_to_parse text) TO muriel;
GRANT ALL ON FUNCTION erp.parse_phone(text_to_parse text) TO yann;
GRANT ALL ON FUNCTION erp.parse_phone(text_to_parse text) TO dbservice;


--
-- Name: FUNCTION reverse_sync_kiosk(); Type: ACL; Schema: erp; Owner: erpuser
--

GRANT ALL ON FUNCTION erp.reverse_sync_kiosk() TO muriel;
GRANT ALL ON FUNCTION erp.reverse_sync_kiosk() TO yann;


--
-- Name: FUNCTION sync_kiosk(); Type: ACL; Schema: erp; Owner: erpuser
--

GRANT ALL ON FUNCTION erp.sync_kiosk() TO muriel;
GRANT ALL ON FUNCTION erp.sync_kiosk() TO yann;


--
-- Name: FUNCTION sync_kiosk_reference(); Type: ACL; Schema: erp; Owner: erpuser
--

GRANT ALL ON FUNCTION erp.sync_kiosk_reference() TO muriel;
GRANT ALL ON FUNCTION erp.sync_kiosk_reference() TO yann;


--
-- Name: FUNCTION sync_kiosk_tables(); Type: ACL; Schema: erp; Owner: erpuser
--

GRANT ALL ON FUNCTION erp.sync_kiosk_tables() TO muriel;
GRANT ALL ON FUNCTION erp.sync_kiosk_tables() TO yann;
GRANT ALL ON FUNCTION erp.sync_kiosk_tables() TO dbservice;


--
-- Name: FUNCTION sync_product(); Type: ACL; Schema: erp; Owner: erpuser
--

GRANT ALL ON FUNCTION erp.sync_product() TO muriel;
GRANT ALL ON FUNCTION erp.sync_product() TO yann;


--
-- Name: FUNCTION f_kiosk_sku_group_sku_pick_stats(pick_time timestamp with time zone); Type: ACL; Schema: inm; Owner: erpuser
--

GRANT ALL ON FUNCTION inm.f_kiosk_sku_group_sku_pick_stats(pick_time timestamp with time zone) TO lambdazen;
GRANT ALL ON FUNCTION inm.f_kiosk_sku_group_sku_pick_stats(pick_time timestamp with time zone) TO muriel;
GRANT ALL ON FUNCTION inm.f_kiosk_sku_group_sku_pick_stats(pick_time timestamp with time zone) TO yann;
GRANT ALL ON FUNCTION inm.f_kiosk_sku_group_sku_pick_stats(pick_time timestamp with time zone) TO dbservice;
GRANT ALL ON FUNCTION inm.f_kiosk_sku_group_sku_pick_stats(pick_time timestamp with time zone) TO tableauuser;
GRANT ALL ON FUNCTION inm.f_kiosk_sku_group_sku_pick_stats(pick_time timestamp with time zone) TO bartender;
GRANT ALL ON FUNCTION inm.f_kiosk_sku_group_sku_pick_stats(pick_time timestamp with time zone) TO bytedevs;


--
-- Name: FUNCTION get_pull_date(plan_window_start timestamp with time zone, plan_window_stop timestamp with time zone); Type: ACL; Schema: inm; Owner: erpuser
--

GRANT ALL ON FUNCTION inm.get_pull_date(plan_window_start timestamp with time zone, plan_window_stop timestamp with time zone) TO muriel;
GRANT ALL ON FUNCTION inm.get_pull_date(plan_window_start timestamp with time zone, plan_window_stop timestamp with time zone) TO yann;
GRANT ALL ON FUNCTION inm.get_pull_date(plan_window_start timestamp with time zone, plan_window_stop timestamp with time zone) TO dbservice;
GRANT ALL ON FUNCTION inm.get_pull_date(plan_window_start timestamp with time zone, plan_window_stop timestamp with time zone) TO tableauuser;
GRANT ALL ON FUNCTION inm.get_pull_date(plan_window_start timestamp with time zone, plan_window_stop timestamp with time zone) TO bartender;
GRANT ALL ON FUNCTION inm.get_pull_date(plan_window_start timestamp with time zone, plan_window_stop timestamp with time zone) TO bytedevs;


--
-- Name: FUNCTION get_spoilage_pull_list(); Type: ACL; Schema: inm; Owner: erpuser
--

GRANT ALL ON FUNCTION inm.get_spoilage_pull_list() TO muriel;
GRANT ALL ON FUNCTION inm.get_spoilage_pull_list() TO yann;
GRANT ALL ON FUNCTION inm.get_spoilage_pull_list() TO dbservice;
GRANT ALL ON FUNCTION inm.get_spoilage_pull_list() TO tableauuser;
GRANT ALL ON FUNCTION inm.get_spoilage_pull_list() TO bartender;
GRANT ALL ON FUNCTION inm.get_spoilage_pull_list() TO bytedevs;


--
-- Name: FUNCTION pick_check_duplicate_stop(); Type: ACL; Schema: inm; Owner: erpuser
--

GRANT ALL ON FUNCTION inm.pick_check_duplicate_stop() TO lambdazen;
GRANT ALL ON FUNCTION inm.pick_check_duplicate_stop() TO muriel;
GRANT ALL ON FUNCTION inm.pick_check_duplicate_stop() TO yann;
GRANT ALL ON FUNCTION inm.pick_check_duplicate_stop() TO dbservice;
GRANT ALL ON FUNCTION inm.pick_check_duplicate_stop() TO tableauuser;
GRANT ALL ON FUNCTION inm.pick_check_duplicate_stop() TO bartender;
GRANT ALL ON FUNCTION inm.pick_check_duplicate_stop() TO bytedevs;


--
-- Name: FUNCTION pick_check_restriction(_pick_date date); Type: ACL; Schema: inm; Owner: erpuser
--

GRANT ALL ON FUNCTION inm.pick_check_restriction(_pick_date date) TO muriel;
GRANT ALL ON FUNCTION inm.pick_check_restriction(_pick_date date) TO yann;
GRANT ALL ON FUNCTION inm.pick_check_restriction(_pick_date date) TO dbservice;
GRANT ALL ON FUNCTION inm.pick_check_restriction(_pick_date date) TO tableauuser;
GRANT ALL ON FUNCTION inm.pick_check_restriction(_pick_date date) TO bartender;
GRANT ALL ON FUNCTION inm.pick_check_restriction(_pick_date date) TO bytedevs;


--
-- Name: FUNCTION pick_get_delivery_schedule(pick_date date); Type: ACL; Schema: inm; Owner: erpuser
--

GRANT ALL ON FUNCTION inm.pick_get_delivery_schedule(pick_date date) TO lambdazen;
GRANT ALL ON FUNCTION inm.pick_get_delivery_schedule(pick_date date) TO muriel;
GRANT ALL ON FUNCTION inm.pick_get_delivery_schedule(pick_date date) TO yann;
GRANT ALL ON FUNCTION inm.pick_get_delivery_schedule(pick_date date) TO dbservice;
GRANT ALL ON FUNCTION inm.pick_get_delivery_schedule(pick_date date) TO tableauuser;
GRANT ALL ON FUNCTION inm.pick_get_delivery_schedule(pick_date date) TO bartender;
GRANT ALL ON FUNCTION inm.pick_get_delivery_schedule(pick_date date) TO bytedevs;


--
-- Name: FUNCTION pick_get_demand_weekly_by_velocity(); Type: ACL; Schema: inm; Owner: erpuser
--

GRANT ALL ON FUNCTION inm.pick_get_demand_weekly_by_velocity() TO muriel;
GRANT ALL ON FUNCTION inm.pick_get_demand_weekly_by_velocity() TO yann;
GRANT ALL ON FUNCTION inm.pick_get_demand_weekly_by_velocity() TO dbservice;
GRANT ALL ON FUNCTION inm.pick_get_demand_weekly_by_velocity() TO tableauuser;
GRANT ALL ON FUNCTION inm.pick_get_demand_weekly_by_velocity() TO bartender;
GRANT ALL ON FUNCTION inm.pick_get_demand_weekly_by_velocity() TO bytedevs;


--
-- Name: FUNCTION pick_get_demand_weekly_wo_min(); Type: ACL; Schema: inm; Owner: erpuser
--

GRANT ALL ON FUNCTION inm.pick_get_demand_weekly_wo_min() TO muriel;
GRANT ALL ON FUNCTION inm.pick_get_demand_weekly_wo_min() TO yann;
GRANT ALL ON FUNCTION inm.pick_get_demand_weekly_wo_min() TO dbservice;
GRANT ALL ON FUNCTION inm.pick_get_demand_weekly_wo_min() TO tableauuser;
GRANT ALL ON FUNCTION inm.pick_get_demand_weekly_wo_min() TO bartender;
GRANT ALL ON FUNCTION inm.pick_get_demand_weekly_wo_min() TO bytedevs;


--
-- Name: FUNCTION pick_get_order(start_ts timestamp with time zone, end_ts timestamp with time zone); Type: ACL; Schema: inm; Owner: erpuser
--

GRANT ALL ON FUNCTION inm.pick_get_order(start_ts timestamp with time zone, end_ts timestamp with time zone) TO muriel;
GRANT ALL ON FUNCTION inm.pick_get_order(start_ts timestamp with time zone, end_ts timestamp with time zone) TO yann;
GRANT ALL ON FUNCTION inm.pick_get_order(start_ts timestamp with time zone, end_ts timestamp with time zone) TO dbservice;
GRANT ALL ON FUNCTION inm.pick_get_order(start_ts timestamp with time zone, end_ts timestamp with time zone) TO tableauuser;
GRANT ALL ON FUNCTION inm.pick_get_order(start_ts timestamp with time zone, end_ts timestamp with time zone) TO bartender;
GRANT ALL ON FUNCTION inm.pick_get_order(start_ts timestamp with time zone, end_ts timestamp with time zone) TO bytedevs;


--
-- Name: FUNCTION pick_get_order_with_velocity(start_ts timestamp with time zone, end_ts timestamp with time zone); Type: ACL; Schema: inm; Owner: erpuser
--

GRANT ALL ON FUNCTION inm.pick_get_order_with_velocity(start_ts timestamp with time zone, end_ts timestamp with time zone) TO muriel;
GRANT ALL ON FUNCTION inm.pick_get_order_with_velocity(start_ts timestamp with time zone, end_ts timestamp with time zone) TO yann;
GRANT ALL ON FUNCTION inm.pick_get_order_with_velocity(start_ts timestamp with time zone, end_ts timestamp with time zone) TO dbservice;
GRANT ALL ON FUNCTION inm.pick_get_order_with_velocity(start_ts timestamp with time zone, end_ts timestamp with time zone) TO tableauuser;
GRANT ALL ON FUNCTION inm.pick_get_order_with_velocity(start_ts timestamp with time zone, end_ts timestamp with time zone) TO bartender;
GRANT ALL ON FUNCTION inm.pick_get_order_with_velocity(start_ts timestamp with time zone, end_ts timestamp with time zone) TO bytedevs;


--
-- Name: FUNCTION pick_get_plan_kiosk(pick_date date); Type: ACL; Schema: inm; Owner: erpuser
--

GRANT ALL ON FUNCTION inm.pick_get_plan_kiosk(pick_date date) TO muriel;
GRANT ALL ON FUNCTION inm.pick_get_plan_kiosk(pick_date date) TO yann;
GRANT ALL ON FUNCTION inm.pick_get_plan_kiosk(pick_date date) TO dbservice;
GRANT ALL ON FUNCTION inm.pick_get_plan_kiosk(pick_date date) TO tableauuser;
GRANT ALL ON FUNCTION inm.pick_get_plan_kiosk(pick_date date) TO bartender;
GRANT ALL ON FUNCTION inm.pick_get_plan_kiosk(pick_date date) TO bytedevs;


--
-- Name: FUNCTION pick_get_plan_kiosk(plan_window_start timestamp with time zone, plan_window_stop timestamp with time zone); Type: ACL; Schema: inm; Owner: erpuser
--

GRANT ALL ON FUNCTION inm.pick_get_plan_kiosk(plan_window_start timestamp with time zone, plan_window_stop timestamp with time zone) TO muriel;
GRANT ALL ON FUNCTION inm.pick_get_plan_kiosk(plan_window_start timestamp with time zone, plan_window_stop timestamp with time zone) TO yann;
GRANT ALL ON FUNCTION inm.pick_get_plan_kiosk(plan_window_start timestamp with time zone, plan_window_stop timestamp with time zone) TO dbservice;
GRANT ALL ON FUNCTION inm.pick_get_plan_kiosk(plan_window_start timestamp with time zone, plan_window_stop timestamp with time zone) TO tableauuser;
GRANT ALL ON FUNCTION inm.pick_get_plan_kiosk(plan_window_start timestamp with time zone, plan_window_stop timestamp with time zone) TO bartender;
GRANT ALL ON FUNCTION inm.pick_get_plan_kiosk(plan_window_start timestamp with time zone, plan_window_stop timestamp with time zone) TO bytedevs;


--
-- Name: FUNCTION pick_get_plan_kiosk_disabled_product(pick_date date); Type: ACL; Schema: inm; Owner: erpuser
--

GRANT ALL ON FUNCTION inm.pick_get_plan_kiosk_disabled_product(pick_date date) TO lambdazen;
GRANT ALL ON FUNCTION inm.pick_get_plan_kiosk_disabled_product(pick_date date) TO muriel;
GRANT ALL ON FUNCTION inm.pick_get_plan_kiosk_disabled_product(pick_date date) TO yann;
GRANT ALL ON FUNCTION inm.pick_get_plan_kiosk_disabled_product(pick_date date) TO dbservice;
GRANT ALL ON FUNCTION inm.pick_get_plan_kiosk_disabled_product(pick_date date) TO tableauuser;
GRANT ALL ON FUNCTION inm.pick_get_plan_kiosk_disabled_product(pick_date date) TO bartender;
GRANT ALL ON FUNCTION inm.pick_get_plan_kiosk_disabled_product(pick_date date) TO bytedevs;


--
-- Name: FUNCTION pick_get_plan_kiosk_optimo(plan_window_start timestamp with time zone, plan_window_stop timestamp with time zone); Type: ACL; Schema: inm; Owner: erpuser
--

GRANT ALL ON FUNCTION inm.pick_get_plan_kiosk_optimo(plan_window_start timestamp with time zone, plan_window_stop timestamp with time zone) TO muriel;
GRANT ALL ON FUNCTION inm.pick_get_plan_kiosk_optimo(plan_window_start timestamp with time zone, plan_window_stop timestamp with time zone) TO yann;
GRANT ALL ON FUNCTION inm.pick_get_plan_kiosk_optimo(plan_window_start timestamp with time zone, plan_window_stop timestamp with time zone) TO dbservice;
GRANT ALL ON FUNCTION inm.pick_get_plan_kiosk_optimo(plan_window_start timestamp with time zone, plan_window_stop timestamp with time zone) TO tableauuser;
GRANT ALL ON FUNCTION inm.pick_get_plan_kiosk_optimo(plan_window_start timestamp with time zone, plan_window_stop timestamp with time zone) TO bartender;
GRANT ALL ON FUNCTION inm.pick_get_plan_kiosk_optimo(plan_window_start timestamp with time zone, plan_window_stop timestamp with time zone) TO bytedevs;


--
-- Name: FUNCTION pick_get_plan_kiosk_projected_stock(plan_window_start timestamp with time zone, plan_window_stop timestamp with time zone); Type: ACL; Schema: inm; Owner: erpuser
--

GRANT ALL ON FUNCTION inm.pick_get_plan_kiosk_projected_stock(plan_window_start timestamp with time zone, plan_window_stop timestamp with time zone) TO lambdazen;
GRANT ALL ON FUNCTION inm.pick_get_plan_kiosk_projected_stock(plan_window_start timestamp with time zone, plan_window_stop timestamp with time zone) TO muriel;
GRANT ALL ON FUNCTION inm.pick_get_plan_kiosk_projected_stock(plan_window_start timestamp with time zone, plan_window_stop timestamp with time zone) TO yann;
GRANT ALL ON FUNCTION inm.pick_get_plan_kiosk_projected_stock(plan_window_start timestamp with time zone, plan_window_stop timestamp with time zone) TO dbservice;
GRANT ALL ON FUNCTION inm.pick_get_plan_kiosk_projected_stock(plan_window_start timestamp with time zone, plan_window_stop timestamp with time zone) TO tableauuser;
GRANT ALL ON FUNCTION inm.pick_get_plan_kiosk_projected_stock(plan_window_start timestamp with time zone, plan_window_stop timestamp with time zone) TO bartender;
GRANT ALL ON FUNCTION inm.pick_get_plan_kiosk_projected_stock(plan_window_start timestamp with time zone, plan_window_stop timestamp with time zone) TO bytedevs;


--
-- Name: FUNCTION pick_get_sales_period_ratio(start_ts timestamp with time zone, end_ts timestamp with time zone); Type: ACL; Schema: inm; Owner: erpuser
--

GRANT ALL ON FUNCTION inm.pick_get_sales_period_ratio(start_ts timestamp with time zone, end_ts timestamp with time zone) TO lambdazen;
GRANT ALL ON FUNCTION inm.pick_get_sales_period_ratio(start_ts timestamp with time zone, end_ts timestamp with time zone) TO muriel;
GRANT ALL ON FUNCTION inm.pick_get_sales_period_ratio(start_ts timestamp with time zone, end_ts timestamp with time zone) TO yann;
GRANT ALL ON FUNCTION inm.pick_get_sales_period_ratio(start_ts timestamp with time zone, end_ts timestamp with time zone) TO dbservice;
GRANT ALL ON FUNCTION inm.pick_get_sales_period_ratio(start_ts timestamp with time zone, end_ts timestamp with time zone) TO tableauuser;
GRANT ALL ON FUNCTION inm.pick_get_sales_period_ratio(start_ts timestamp with time zone, end_ts timestamp with time zone) TO bartender;
GRANT ALL ON FUNCTION inm.pick_get_sales_period_ratio(start_ts timestamp with time zone, end_ts timestamp with time zone) TO bytedevs;


--
-- Name: FUNCTION pick_get_summary(target_date date); Type: ACL; Schema: inm; Owner: erpuser
--

GRANT ALL ON FUNCTION inm.pick_get_summary(target_date date) TO muriel;
GRANT ALL ON FUNCTION inm.pick_get_summary(target_date date) TO yann;
GRANT ALL ON FUNCTION inm.pick_get_summary(target_date date) TO dbservice;
GRANT ALL ON FUNCTION inm.pick_get_summary(target_date date) TO tableauuser;
GRANT ALL ON FUNCTION inm.pick_get_summary(target_date date) TO bartender;
GRANT ALL ON FUNCTION inm.pick_get_summary(target_date date) TO bytedevs;


--
-- Name: FUNCTION pick_get_ticket(target_date date); Type: ACL; Schema: inm; Owner: erpuser
--

GRANT ALL ON FUNCTION inm.pick_get_ticket(target_date date) TO lambdazen;
GRANT ALL ON FUNCTION inm.pick_get_ticket(target_date date) TO muriel;
GRANT ALL ON FUNCTION inm.pick_get_ticket(target_date date) TO yann;
GRANT ALL ON FUNCTION inm.pick_get_ticket(target_date date) TO dbservice;
GRANT ALL ON FUNCTION inm.pick_get_ticket(target_date date) TO tableauuser;
GRANT ALL ON FUNCTION inm.pick_get_ticket(target_date date) TO bartender;
GRANT ALL ON FUNCTION inm.pick_get_ticket(target_date date) TO bytedevs;


--
-- Name: FUNCTION pick_submit(target_date date, overwrite integer, wait_time_seconds integer, OUT submit_status text); Type: ACL; Schema: inm; Owner: erpuser
--

GRANT ALL ON FUNCTION inm.pick_submit(target_date date, overwrite integer, wait_time_seconds integer, OUT submit_status text) TO muriel;
GRANT ALL ON FUNCTION inm.pick_submit(target_date date, overwrite integer, wait_time_seconds integer, OUT submit_status text) TO yann;
GRANT ALL ON FUNCTION inm.pick_submit(target_date date, overwrite integer, wait_time_seconds integer, OUT submit_status text) TO dbservice;
GRANT ALL ON FUNCTION inm.pick_submit(target_date date, overwrite integer, wait_time_seconds integer, OUT submit_status text) TO tableauuser;
GRANT ALL ON FUNCTION inm.pick_submit(target_date date, overwrite integer, wait_time_seconds integer, OUT submit_status text) TO bartender;
GRANT ALL ON FUNCTION inm.pick_submit(target_date date, overwrite integer, wait_time_seconds integer, OUT submit_status text) TO bytedevs;


--
-- Name: FUNCTION get_label_order_epc(); Type: ACL; Schema: pantry; Owner: erpuser
--

GRANT ALL ON FUNCTION pantry.get_label_order_epc() TO lambdazen;
GRANT ALL ON FUNCTION pantry.get_label_order_epc() TO muriel;
GRANT ALL ON FUNCTION pantry.get_label_order_epc() TO yann;
GRANT ALL ON FUNCTION pantry.get_label_order_epc() TO tableauuser;
GRANT ALL ON FUNCTION pantry.get_label_order_epc() TO bartender;
GRANT ALL ON FUNCTION pantry.get_label_order_epc() TO bytedevs;


--
-- Name: FUNCTION sync_campus(); Type: ACL; Schema: pantry; Owner: erpuser
--

GRANT ALL ON FUNCTION pantry.sync_campus() TO lambdazen;
GRANT ALL ON FUNCTION pantry.sync_campus() TO muriel;
GRANT ALL ON FUNCTION pantry.sync_campus() TO yann;
GRANT ALL ON FUNCTION pantry.sync_campus() TO tableauuser;
GRANT ALL ON FUNCTION pantry.sync_campus() TO bartender;
GRANT ALL ON FUNCTION pantry.sync_campus() TO bytedevs;


--
-- Name: FUNCTION sync_label_order(); Type: ACL; Schema: pantry; Owner: erpuser
--

GRANT ALL ON FUNCTION pantry.sync_label_order() TO muriel;
GRANT ALL ON FUNCTION pantry.sync_label_order() TO yann;
GRANT ALL ON FUNCTION pantry.sync_label_order() TO lambdazen;
GRANT ALL ON FUNCTION pantry.sync_label_order() TO tableauuser;
GRANT ALL ON FUNCTION pantry.sync_label_order() TO bartender;
GRANT ALL ON FUNCTION pantry.sync_label_order() TO bytedevs;


--
-- Name: FUNCTION awsdms_intercept_ddl(); Type: ACL; Schema: public; Owner: erpuser
--

GRANT ALL ON FUNCTION public.awsdms_intercept_ddl() TO tableauuser;
GRANT ALL ON FUNCTION public.awsdms_intercept_ddl() TO bartender;
GRANT ALL ON FUNCTION public.awsdms_intercept_ddl() TO bytedevs;


--
-- Name: FUNCTION dowhour(timestamp with time zone); Type: ACL; Schema: public; Owner: erpuser
--

GRANT ALL ON FUNCTION public.dowhour(timestamp with time zone) TO tableauuser;
GRANT ALL ON FUNCTION public.dowhour(timestamp with time zone) TO bartender;
GRANT ALL ON FUNCTION public.dowhour(timestamp with time zone) TO bytedevs;


--
-- Name: FUNCTION if(boolean, anyelement, anyelement); Type: ACL; Schema: public; Owner: erpuser
--

GRANT ALL ON FUNCTION public.if(boolean, anyelement, anyelement) TO tableauuser;
GRANT ALL ON FUNCTION public.if(boolean, anyelement, anyelement) TO bartender;
GRANT ALL ON FUNCTION public.if(boolean, anyelement, anyelement) TO bytedevs;


--
-- Name: FUNCTION make_odd_or_even_sequence(table_name text, sequence_field_name text, odd_or_even text); Type: ACL; Schema: public; Owner: erpuser
--

GRANT ALL ON FUNCTION public.make_odd_or_even_sequence(table_name text, sequence_field_name text, odd_or_even text) TO tableauuser;
GRANT ALL ON FUNCTION public.make_odd_or_even_sequence(table_name text, sequence_field_name text, odd_or_even text) TO bartender;
GRANT ALL ON FUNCTION public.make_odd_or_even_sequence(table_name text, sequence_field_name text, odd_or_even text) TO bytedevs;


--
-- Name: FUNCTION export_consolidated_remittance(month_date date); Type: ACL; Schema: test; Owner: erpuser
--

GRANT ALL ON FUNCTION test.export_consolidated_remittance(month_date date) TO bytedevs;
GRANT ALL ON FUNCTION test.export_consolidated_remittance(month_date date) TO bartender;


--
-- Name: FUNCTION export_transaction(beginning_date timestamp without time zone, ending_date timestamp without time zone, time_zone character varying); Type: ACL; Schema: test; Owner: erpuser
--

GRANT ALL ON FUNCTION test.export_transaction(beginning_date timestamp without time zone, ending_date timestamp without time zone, time_zone character varying) TO bytedevs;
GRANT ALL ON FUNCTION test.export_transaction(beginning_date timestamp without time zone, ending_date timestamp without time zone, time_zone character varying) TO bartender;


--
-- Name: FUNCTION insert_in_monthly_kiosk_summary(month_date date); Type: ACL; Schema: test; Owner: erpuser
--

GRANT ALL ON FUNCTION test.insert_in_monthly_kiosk_summary(month_date date) TO bytedevs;
GRANT ALL ON FUNCTION test.insert_in_monthly_kiosk_summary(month_date date) TO bartender;


--
-- Name: FUNCTION insert_sales_after_discount_in_daily_kiosk_sku_summary(beginning_date date, ending_date date); Type: ACL; Schema: test; Owner: erpuser
--

GRANT ALL ON FUNCTION test.insert_sales_after_discount_in_daily_kiosk_sku_summary(beginning_date date, ending_date date) TO bytedevs;
GRANT ALL ON FUNCTION test.insert_sales_after_discount_in_daily_kiosk_sku_summary(beginning_date date, ending_date date) TO bartender;


--
-- Name: FUNCTION spoils(beginning_date date, ending_date date); Type: ACL; Schema: test; Owner: erpuser
--

GRANT ALL ON FUNCTION test.spoils(beginning_date date, ending_date date) TO bytedevs;
GRANT ALL ON FUNCTION test.spoils(beginning_date date, ending_date date) TO bartender;


--
-- Name: FUNCTION uptime_percentage(start_date date, end_date date); Type: ACL; Schema: test; Owner: erpuser
--

GRANT ALL ON FUNCTION test.uptime_percentage(start_date date, end_date date) TO bytedevs;
GRANT ALL ON FUNCTION test.uptime_percentage(start_date date, end_date date) TO bartender;


--
-- Name: FUNCTION uptime_ratio(start_date date, end_date date); Type: ACL; Schema: test; Owner: erpuser
--

GRANT ALL ON FUNCTION test.uptime_ratio(start_date date, end_date date) TO bytedevs;
GRANT ALL ON FUNCTION test.uptime_ratio(start_date date, end_date date) TO bartender;


--
-- Name: TABLE feedback; Type: ACL; Schema: pantry; Owner: erpuser
--

GRANT ALL ON TABLE pantry.feedback TO muriel;
GRANT ALL ON TABLE pantry.feedback TO yann;
GRANT SELECT ON TABLE pantry.feedback TO readonly;
GRANT ALL ON TABLE pantry.feedback TO lambdazen;
GRANT ALL ON TABLE pantry.feedback TO dbservice;
GRANT ALL ON TABLE pantry.feedback TO jungvu;
GRANT ALL ON TABLE pantry.feedback TO tableauuser;
GRANT ALL ON TABLE pantry.feedback TO bartender;
GRANT ALL ON TABLE pantry.feedback TO bytedevs;


--
-- Name: TABLE kiosk; Type: ACL; Schema: pantry; Owner: erpuser
--

GRANT ALL ON TABLE pantry.kiosk TO muriel;
GRANT ALL ON TABLE pantry.kiosk TO yann;
GRANT SELECT ON TABLE pantry.kiosk TO readonly;
GRANT ALL ON TABLE pantry.kiosk TO lambdazen;
GRANT ALL ON TABLE pantry.kiosk TO dbservice;
GRANT ALL ON TABLE pantry.kiosk TO jungvu;
GRANT ALL ON TABLE pantry.kiosk TO tableauuser;
GRANT ALL ON TABLE pantry.kiosk TO bartender;
GRANT ALL ON TABLE pantry.kiosk TO bytedevs;


--
-- Name: TABLE "order"; Type: ACL; Schema: pantry; Owner: erpuser
--

GRANT ALL ON TABLE pantry."order" TO muriel;
GRANT ALL ON TABLE pantry."order" TO yann;
GRANT SELECT ON TABLE pantry."order" TO readonly;
GRANT ALL ON TABLE pantry."order" TO lambdazen;
GRANT ALL ON TABLE pantry."order" TO dbservice;
GRANT ALL ON TABLE pantry."order" TO jungvu;
GRANT ALL ON TABLE pantry."order" TO tableauuser;
GRANT ALL ON TABLE pantry."order" TO bartender;
GRANT ALL ON TABLE pantry."order" TO bytedevs;


--
-- Name: TABLE all_raw_orders; Type: ACL; Schema: public; Owner: erpuser
--

GRANT SELECT ON TABLE public.all_raw_orders TO yann;
GRANT SELECT ON TABLE public.all_raw_orders TO readonly;
GRANT ALL ON TABLE public.all_raw_orders TO tableauuser;
GRANT ALL ON TABLE public.all_raw_orders TO bartender;
GRANT ALL ON TABLE public.all_raw_orders TO bytedevs;


--
-- Name: TABLE _all_orders; Type: ACL; Schema: public; Owner: erpuser
--

GRANT SELECT ON TABLE public._all_orders TO yann;
GRANT SELECT ON TABLE public._all_orders TO readonly;
GRANT ALL ON TABLE public._all_orders TO tableauuser;
GRANT ALL ON TABLE public._all_orders TO bartender;
GRANT ALL ON TABLE public._all_orders TO bytedevs;


--
-- Name: TABLE all_orders; Type: ACL; Schema: public; Owner: erpuser
--

GRANT SELECT ON TABLE public.all_orders TO yann;
GRANT SELECT ON TABLE public.all_orders TO readonly;
GRANT ALL ON TABLE public.all_orders TO tableauuser;
GRANT ALL ON TABLE public.all_orders TO bartender;
GRANT ALL ON TABLE public.all_orders TO bytedevs;


--
-- Name: TABLE byte_orders; Type: ACL; Schema: public; Owner: erpuser
--

GRANT SELECT ON TABLE public.byte_orders TO yann;
GRANT SELECT ON TABLE public.byte_orders TO readonly;
GRANT ALL ON TABLE public.byte_orders TO tableauuser;
GRANT ALL ON TABLE public.byte_orders TO bartender;
GRANT ALL ON TABLE public.byte_orders TO bytedevs;


--
-- Name: TABLE byte_tickets; Type: ACL; Schema: public; Owner: erpuser
--

GRANT SELECT ON TABLE public.byte_tickets TO yann;
GRANT SELECT ON TABLE public.byte_tickets TO readonly;
GRANT ALL ON TABLE public.byte_tickets TO tableauuser;
GRANT ALL ON TABLE public.byte_tickets TO bartender;
GRANT ALL ON TABLE public.byte_tickets TO bytedevs;


--
-- Name: TABLE byte_feedback; Type: ACL; Schema: public; Owner: erpuser
--

GRANT ALL ON TABLE public.byte_feedback TO tableauuser;
GRANT ALL ON TABLE public.byte_feedback TO bartender;
GRANT ALL ON TABLE public.byte_feedback TO bytedevs;


--
-- Name: TABLE byte_feedback_monthly; Type: ACL; Schema: public; Owner: erpuser
--

GRANT ALL ON TABLE public.byte_feedback_monthly TO tableauuser;
GRANT ALL ON TABLE public.byte_feedback_monthly TO bartender;
GRANT ALL ON TABLE public.byte_feedback_monthly TO bytedevs;


--
-- Name: TABLE byte_feedback_monthly; Type: ACL; Schema: campus_87; Owner: erpuser
--

GRANT SELECT ON TABLE campus_87.byte_feedback_monthly TO rc87;


--
-- Name: TABLE campus; Type: ACL; Schema: pantry; Owner: erpuser
--

GRANT ALL ON TABLE pantry.campus TO muriel;
GRANT ALL ON TABLE pantry.campus TO yann;
GRANT SELECT ON TABLE pantry.campus TO readonly;
GRANT ALL ON TABLE pantry.campus TO lambdazen;
GRANT ALL ON TABLE pantry.campus TO dbservice;
GRANT ALL ON TABLE pantry.campus TO jungvu;
GRANT ALL ON TABLE pantry.campus TO tableauuser;
GRANT ALL ON TABLE pantry.campus TO bartender;
GRANT ALL ON TABLE pantry.campus TO bytedevs;


--
-- Name: TABLE campus; Type: ACL; Schema: campus_87; Owner: erpuser
--

GRANT SELECT ON TABLE campus_87.campus TO rc87;


--
-- Name: TABLE dim_date; Type: ACL; Schema: dw; Owner: muriel
--

GRANT ALL ON TABLE dw.dim_date TO lambdazen;
GRANT ALL ON TABLE dw.dim_date TO yann;
GRANT SELECT ON TABLE dw.dim_date TO readonly;
GRANT ALL ON TABLE dw.dim_date TO dbservice;
GRANT ALL ON TABLE dw.dim_date TO bytedevs;
GRANT ALL ON TABLE dw.dim_date TO tableauuser;


--
-- Name: TABLE dim_date; Type: ACL; Schema: campus_87; Owner: erpuser
--

GRANT SELECT ON TABLE campus_87.dim_date TO rc87;


--
-- Name: TABLE fact_daily_kiosk_sku_summary; Type: ACL; Schema: dw; Owner: muriel
--

GRANT ALL ON TABLE dw.fact_daily_kiosk_sku_summary TO lambdazen;
GRANT ALL ON TABLE dw.fact_daily_kiosk_sku_summary TO yann;
GRANT SELECT ON TABLE dw.fact_daily_kiosk_sku_summary TO readonly;
GRANT ALL ON TABLE dw.fact_daily_kiosk_sku_summary TO dbservice;
GRANT ALL ON TABLE dw.fact_daily_kiosk_sku_summary TO bytedevs;
GRANT ALL ON TABLE dw.fact_daily_kiosk_sku_summary TO tableauuser;


--
-- Name: TABLE fact_daily_kiosk_sku_summary; Type: ACL; Schema: campus_87; Owner: erpuser
--

GRANT SELECT ON TABLE campus_87.fact_daily_kiosk_sku_summary TO rc87;


--
-- Name: TABLE kiosk; Type: ACL; Schema: campus_87; Owner: erpuser
--

GRANT SELECT ON TABLE campus_87.kiosk TO rc87;


--
-- Name: TABLE kiosk_control; Type: ACL; Schema: inm; Owner: erpuser
--

GRANT ALL ON TABLE inm.kiosk_control TO lambdazen;
GRANT ALL ON TABLE inm.kiosk_control TO muriel;
GRANT INSERT,REFERENCES,DELETE,TRIGGER,TRUNCATE,UPDATE ON TABLE inm.kiosk_control TO yann;
GRANT SELECT ON TABLE inm.kiosk_control TO yann WITH GRANT OPTION;
SET SESSION AUTHORIZATION yann;
GRANT SELECT ON TABLE inm.kiosk_control TO readonly;
RESET SESSION AUTHORIZATION;
RESET SESSION AUTHORIZATION;
GRANT SELECT ON TABLE inm.kiosk_control TO readonly;
GRANT ALL ON TABLE inm.kiosk_control TO dbservice;
GRANT ALL ON TABLE inm.kiosk_control TO tableauuser;
GRANT ALL ON TABLE inm.kiosk_control TO bartender;
GRANT ALL ON TABLE inm.kiosk_control TO bytedevs;


--
-- Name: TABLE kiosk_control; Type: ACL; Schema: campus_87; Owner: erpuser
--

GRANT SELECT ON TABLE campus_87.kiosk_control TO rc87;


--
-- Name: TABLE kiosk_restriction_by_product; Type: ACL; Schema: inm; Owner: erpuser
--

GRANT ALL ON TABLE inm.kiosk_restriction_by_product TO lambdazen;
GRANT ALL ON TABLE inm.kiosk_restriction_by_product TO muriel;
GRANT ALL ON TABLE inm.kiosk_restriction_by_product TO yann;
GRANT SELECT ON TABLE inm.kiosk_restriction_by_product TO readonly;
GRANT ALL ON TABLE inm.kiosk_restriction_by_product TO dbservice;
GRANT ALL ON TABLE inm.kiosk_restriction_by_product TO tableauuser;
GRANT ALL ON TABLE inm.kiosk_restriction_by_product TO bartender;
GRANT ALL ON TABLE inm.kiosk_restriction_by_product TO bytedevs;


--
-- Name: TABLE kiosk_restriction_by_product; Type: ACL; Schema: campus_87; Owner: erpuser
--

GRANT SELECT ON TABLE campus_87.kiosk_restriction_by_product TO rc87;


--
-- Name: TABLE kiosk_restriction_by_product_ed; Type: ACL; Schema: inm; Owner: erpuser
--

GRANT ALL ON TABLE inm.kiosk_restriction_by_product_ed TO lambdazen;
GRANT ALL ON TABLE inm.kiosk_restriction_by_product_ed TO muriel;
GRANT ALL ON TABLE inm.kiosk_restriction_by_product_ed TO yann;
GRANT ALL ON TABLE inm.kiosk_restriction_by_product_ed TO tableauuser;
GRANT ALL ON TABLE inm.kiosk_restriction_by_product_ed TO bartender;
GRANT ALL ON TABLE inm.kiosk_restriction_by_product_ed TO bytedevs;


--
-- Name: TABLE kiosk_restriction_by_product_ed; Type: ACL; Schema: campus_87; Owner: erpuser
--

GRANT SELECT ON TABLE campus_87.kiosk_restriction_by_product_ed TO rc87;


--
-- Name: TABLE kiosk_restriction_by_property; Type: ACL; Schema: inm; Owner: erpuser
--

GRANT ALL ON TABLE inm.kiosk_restriction_by_property TO lambdazen;
GRANT ALL ON TABLE inm.kiosk_restriction_by_property TO muriel;
GRANT ALL ON TABLE inm.kiosk_restriction_by_property TO yann;
GRANT SELECT ON TABLE inm.kiosk_restriction_by_property TO readonly;
GRANT ALL ON TABLE inm.kiosk_restriction_by_property TO dbservice;
GRANT ALL ON TABLE inm.kiosk_restriction_by_property TO tableauuser;
GRANT ALL ON TABLE inm.kiosk_restriction_by_property TO bartender;
GRANT ALL ON TABLE inm.kiosk_restriction_by_property TO bytedevs;


--
-- Name: TABLE kiosk_restriction_by_property; Type: ACL; Schema: campus_87; Owner: erpuser
--

GRANT SELECT ON TABLE campus_87.kiosk_restriction_by_property TO rc87;


--
-- Name: TABLE kiosk_sku_group_manual_scale; Type: ACL; Schema: inm; Owner: erpuser
--

GRANT ALL ON TABLE inm.kiosk_sku_group_manual_scale TO lambdazen;
GRANT ALL ON TABLE inm.kiosk_sku_group_manual_scale TO muriel;
GRANT ALL ON TABLE inm.kiosk_sku_group_manual_scale TO yann;
GRANT SELECT ON TABLE inm.kiosk_sku_group_manual_scale TO readonly;
GRANT ALL ON TABLE inm.kiosk_sku_group_manual_scale TO dbservice;
GRANT ALL ON TABLE inm.kiosk_sku_group_manual_scale TO tableauuser;
GRANT ALL ON TABLE inm.kiosk_sku_group_manual_scale TO bartender;
GRANT ALL ON TABLE inm.kiosk_sku_group_manual_scale TO bytedevs;


--
-- Name: TABLE kiosk_sku_group_manual_scale; Type: ACL; Schema: campus_87; Owner: erpuser
--

GRANT SELECT ON TABLE campus_87.kiosk_sku_group_manual_scale TO rc87;


--
-- Name: TABLE label; Type: ACL; Schema: pantry; Owner: erpuser
--

GRANT ALL ON TABLE pantry.label TO muriel;
GRANT ALL ON TABLE pantry.label TO yann;
GRANT SELECT ON TABLE pantry.label TO readonly;
GRANT ALL ON TABLE pantry.label TO lambdazen;
GRANT ALL ON TABLE pantry.label TO dbservice;
GRANT ALL ON TABLE pantry.label TO jungvu;
GRANT ALL ON TABLE pantry.label TO tableauuser;
GRANT ALL ON TABLE pantry.label TO bartender;
GRANT ALL ON TABLE pantry.label TO bytedevs;


--
-- Name: TABLE label; Type: ACL; Schema: campus_87; Owner: erpuser
--

GRANT SELECT ON TABLE campus_87.label TO rc87;


--
-- Name: TABLE "order"; Type: ACL; Schema: campus_87; Owner: erpuser
--

GRANT SELECT ON TABLE campus_87."order" TO rc87;


--
-- Name: TABLE pick_allocation; Type: ACL; Schema: inm; Owner: erpuser
--

GRANT ALL ON TABLE inm.pick_allocation TO lambdazen;
GRANT ALL ON TABLE inm.pick_allocation TO muriel;
GRANT ALL ON TABLE inm.pick_allocation TO yann;
GRANT SELECT ON TABLE inm.pick_allocation TO readonly;
GRANT ALL ON TABLE inm.pick_allocation TO dbservice;
GRANT ALL ON TABLE inm.pick_allocation TO tableauuser;
GRANT ALL ON TABLE inm.pick_allocation TO bartender;
GRANT ALL ON TABLE inm.pick_allocation TO bytedevs;


--
-- Name: TABLE pick_allocation; Type: ACL; Schema: campus_87; Owner: erpuser
--

GRANT SELECT ON TABLE campus_87.pick_allocation TO rc87;


--
-- Name: TABLE pick_demand; Type: ACL; Schema: inm; Owner: erpuser
--

GRANT ALL ON TABLE inm.pick_demand TO lambdazen;
GRANT ALL ON TABLE inm.pick_demand TO muriel;
GRANT ALL ON TABLE inm.pick_demand TO yann;
GRANT SELECT ON TABLE inm.pick_demand TO readonly;
GRANT ALL ON TABLE inm.pick_demand TO dbservice;
GRANT ALL ON TABLE inm.pick_demand TO tableauuser;
GRANT ALL ON TABLE inm.pick_demand TO bartender;
GRANT ALL ON TABLE inm.pick_demand TO bytedevs;


--
-- Name: TABLE pick_demand; Type: ACL; Schema: campus_87; Owner: erpuser
--

GRANT SELECT ON TABLE campus_87.pick_demand TO rc87;


--
-- Name: TABLE pick_inventory; Type: ACL; Schema: inm; Owner: erpuser
--

GRANT ALL ON TABLE inm.pick_inventory TO lambdazen;
GRANT ALL ON TABLE inm.pick_inventory TO muriel;
GRANT ALL ON TABLE inm.pick_inventory TO yann;
GRANT SELECT ON TABLE inm.pick_inventory TO readonly;
GRANT ALL ON TABLE inm.pick_inventory TO dbservice;
GRANT ALL ON TABLE inm.pick_inventory TO tableauuser;
GRANT ALL ON TABLE inm.pick_inventory TO bartender;
GRANT ALL ON TABLE inm.pick_inventory TO bytedevs;


--
-- Name: TABLE pick_inventory; Type: ACL; Schema: campus_87; Owner: erpuser
--

GRANT SELECT ON TABLE campus_87.pick_inventory TO rc87;


--
-- Name: TABLE pick_list; Type: ACL; Schema: inm; Owner: erpuser
--

GRANT ALL ON TABLE inm.pick_list TO lambdazen;
GRANT ALL ON TABLE inm.pick_list TO muriel;
GRANT ALL ON TABLE inm.pick_list TO yann;
GRANT SELECT ON TABLE inm.pick_list TO readonly;
GRANT ALL ON TABLE inm.pick_list TO dbservice;
GRANT ALL ON TABLE inm.pick_list TO tableauuser;
GRANT ALL ON TABLE inm.pick_list TO bartender;
GRANT ALL ON TABLE inm.pick_list TO bytedevs;


--
-- Name: TABLE pick_list; Type: ACL; Schema: campus_87; Owner: erpuser
--

GRANT SELECT ON TABLE campus_87.pick_list TO rc87;


--
-- Name: TABLE pick_preference_kiosk_sku; Type: ACL; Schema: inm; Owner: erpuser
--

GRANT ALL ON TABLE inm.pick_preference_kiosk_sku TO lambdazen;
GRANT ALL ON TABLE inm.pick_preference_kiosk_sku TO muriel;
GRANT ALL ON TABLE inm.pick_preference_kiosk_sku TO yann;
GRANT SELECT ON TABLE inm.pick_preference_kiosk_sku TO readonly;
GRANT ALL ON TABLE inm.pick_preference_kiosk_sku TO dbservice;
GRANT ALL ON TABLE inm.pick_preference_kiosk_sku TO tableauuser;
GRANT ALL ON TABLE inm.pick_preference_kiosk_sku TO bartender;
GRANT ALL ON TABLE inm.pick_preference_kiosk_sku TO bytedevs;


--
-- Name: TABLE pick_preference_kiosk_sku; Type: ACL; Schema: campus_87; Owner: erpuser
--

GRANT SELECT ON TABLE campus_87.pick_preference_kiosk_sku TO rc87;


--
-- Name: TABLE pick_priority_kiosk; Type: ACL; Schema: inm; Owner: erpuser
--

GRANT ALL ON TABLE inm.pick_priority_kiosk TO lambdazen;
GRANT ALL ON TABLE inm.pick_priority_kiosk TO muriel;
GRANT ALL ON TABLE inm.pick_priority_kiosk TO yann;
GRANT SELECT ON TABLE inm.pick_priority_kiosk TO readonly;
GRANT ALL ON TABLE inm.pick_priority_kiosk TO dbservice;
GRANT ALL ON TABLE inm.pick_priority_kiosk TO tableauuser;
GRANT ALL ON TABLE inm.pick_priority_kiosk TO bartender;
GRANT ALL ON TABLE inm.pick_priority_kiosk TO bytedevs;


--
-- Name: TABLE pick_priority_kiosk; Type: ACL; Schema: campus_87; Owner: erpuser
--

GRANT SELECT ON TABLE campus_87.pick_priority_kiosk TO rc87;


--
-- Name: TABLE pick_priority_sku; Type: ACL; Schema: inm; Owner: erpuser
--

GRANT ALL ON TABLE inm.pick_priority_sku TO lambdazen;
GRANT ALL ON TABLE inm.pick_priority_sku TO muriel;
GRANT ALL ON TABLE inm.pick_priority_sku TO yann;
GRANT SELECT ON TABLE inm.pick_priority_sku TO readonly;
GRANT ALL ON TABLE inm.pick_priority_sku TO dbservice;
GRANT ALL ON TABLE inm.pick_priority_sku TO tableauuser;
GRANT ALL ON TABLE inm.pick_priority_sku TO bartender;
GRANT ALL ON TABLE inm.pick_priority_sku TO bytedevs;


--
-- Name: TABLE pick_priority_sku; Type: ACL; Schema: campus_87; Owner: erpuser
--

GRANT SELECT ON TABLE campus_87.pick_priority_sku TO rc87;


--
-- Name: TABLE pick_rejection; Type: ACL; Schema: inm; Owner: erpuser
--

GRANT ALL ON TABLE inm.pick_rejection TO lambdazen;
GRANT ALL ON TABLE inm.pick_rejection TO muriel;
GRANT ALL ON TABLE inm.pick_rejection TO yann;
GRANT SELECT ON TABLE inm.pick_rejection TO readonly;
GRANT ALL ON TABLE inm.pick_rejection TO dbservice;
GRANT ALL ON TABLE inm.pick_rejection TO tableauuser;
GRANT ALL ON TABLE inm.pick_rejection TO bartender;
GRANT ALL ON TABLE inm.pick_rejection TO bytedevs;


--
-- Name: TABLE pick_rejection; Type: ACL; Schema: campus_87; Owner: erpuser
--

GRANT SELECT ON TABLE campus_87.pick_rejection TO rc87;


--
-- Name: TABLE pick_route; Type: ACL; Schema: inm; Owner: erpuser
--

GRANT ALL ON TABLE inm.pick_route TO lambdazen;
GRANT ALL ON TABLE inm.pick_route TO muriel;
GRANT ALL ON TABLE inm.pick_route TO yann;
GRANT SELECT ON TABLE inm.pick_route TO readonly;
GRANT ALL ON TABLE inm.pick_route TO dbservice;
GRANT ALL ON TABLE inm.pick_route TO tableauuser;
GRANT ALL ON TABLE inm.pick_route TO bartender;
GRANT ALL ON TABLE inm.pick_route TO bytedevs;


--
-- Name: TABLE pick_route; Type: ACL; Schema: campus_87; Owner: erpuser
--

GRANT SELECT ON TABLE campus_87.pick_route TO rc87;


--
-- Name: TABLE product; Type: ACL; Schema: pantry; Owner: erpuser
--

GRANT ALL ON TABLE pantry.product TO muriel;
GRANT ALL ON TABLE pantry.product TO yann;
GRANT SELECT ON TABLE pantry.product TO readonly;
GRANT ALL ON TABLE pantry.product TO lambdazen;
GRANT ALL ON TABLE pantry.product TO dbservice;
GRANT ALL ON TABLE pantry.product TO jungvu;
GRANT ALL ON TABLE pantry.product TO tableauuser;
GRANT ALL ON TABLE pantry.product TO bartender;
GRANT ALL ON TABLE pantry.product TO bytedevs;


--
-- Name: TABLE product; Type: ACL; Schema: campus_87; Owner: erpuser
--

GRANT SELECT ON TABLE campus_87.product TO rc87;


--
-- Name: TABLE product_property; Type: ACL; Schema: inm; Owner: erpuser
--

GRANT ALL ON TABLE inm.product_property TO lambdazen;
GRANT ALL ON TABLE inm.product_property TO muriel;
GRANT ALL ON TABLE inm.product_property TO yann;
GRANT SELECT ON TABLE inm.product_property TO readonly;
GRANT ALL ON TABLE inm.product_property TO dbservice;
GRANT ALL ON TABLE inm.product_property TO tableauuser;
GRANT ALL ON TABLE inm.product_property TO bartender;
GRANT ALL ON TABLE inm.product_property TO bytedevs;


--
-- Name: TABLE product_property; Type: ACL; Schema: campus_87; Owner: erpuser
--

GRANT SELECT ON TABLE campus_87.product_property TO rc87;


--
-- Name: TABLE product_property_def; Type: ACL; Schema: inm; Owner: erpuser
--

GRANT ALL ON TABLE inm.product_property_def TO lambdazen;
GRANT ALL ON TABLE inm.product_property_def TO muriel;
GRANT ALL ON TABLE inm.product_property_def TO yann;
GRANT SELECT ON TABLE inm.product_property_def TO readonly;
GRANT ALL ON TABLE inm.product_property_def TO dbservice;
GRANT ALL ON TABLE inm.product_property_def TO tableauuser;
GRANT ALL ON TABLE inm.product_property_def TO bartender;
GRANT ALL ON TABLE inm.product_property_def TO bytedevs;


--
-- Name: TABLE product_property_def; Type: ACL; Schema: campus_87; Owner: erpuser
--

GRANT SELECT ON TABLE campus_87.product_property_def TO rc87;


--
-- Name: TABLE route_stop; Type: ACL; Schema: inm; Owner: erpuser
--

GRANT ALL ON TABLE inm.route_stop TO lambdazen;
GRANT ALL ON TABLE inm.route_stop TO muriel;
GRANT ALL ON TABLE inm.route_stop TO yann;
GRANT SELECT ON TABLE inm.route_stop TO readonly;
GRANT ALL ON TABLE inm.route_stop TO dbservice;
GRANT ALL ON TABLE inm.route_stop TO tableauuser;
GRANT ALL ON TABLE inm.route_stop TO bartender;
GRANT ALL ON TABLE inm.route_stop TO bytedevs;


--
-- Name: TABLE route_stop; Type: ACL; Schema: campus_87; Owner: erpuser
--

GRANT SELECT ON TABLE campus_87.route_stop TO rc87;


--
-- Name: TABLE sku_group_attribute; Type: ACL; Schema: inm; Owner: erpuser
--

GRANT ALL ON TABLE inm.sku_group_attribute TO lambdazen;
GRANT ALL ON TABLE inm.sku_group_attribute TO muriel;
GRANT ALL ON TABLE inm.sku_group_attribute TO yann;
GRANT SELECT ON TABLE inm.sku_group_attribute TO readonly;
GRANT ALL ON TABLE inm.sku_group_attribute TO dbservice;
GRANT ALL ON TABLE inm.sku_group_attribute TO tableauuser;
GRANT ALL ON TABLE inm.sku_group_attribute TO bartender;
GRANT ALL ON TABLE inm.sku_group_attribute TO bytedevs;


--
-- Name: TABLE sku_group_attribute; Type: ACL; Schema: campus_87; Owner: erpuser
--

GRANT SELECT ON TABLE campus_87.sku_group_attribute TO rc87;


--
-- Name: TABLE sku_group_control; Type: ACL; Schema: inm; Owner: erpuser
--

GRANT ALL ON TABLE inm.sku_group_control TO lambdazen;
GRANT ALL ON TABLE inm.sku_group_control TO muriel;
GRANT ALL ON TABLE inm.sku_group_control TO yann;
GRANT SELECT ON TABLE inm.sku_group_control TO readonly;
GRANT ALL ON TABLE inm.sku_group_control TO dbservice;
GRANT ALL ON TABLE inm.sku_group_control TO tableauuser;
GRANT ALL ON TABLE inm.sku_group_control TO bartender;
GRANT ALL ON TABLE inm.sku_group_control TO bytedevs;


--
-- Name: TABLE sku_group_control; Type: ACL; Schema: campus_87; Owner: erpuser
--

GRANT SELECT ON TABLE campus_87.sku_group_control TO rc87;


--
-- Name: TABLE warehouse_inventory; Type: ACL; Schema: inm; Owner: erpuser
--

GRANT ALL ON TABLE inm.warehouse_inventory TO lambdazen;
GRANT ALL ON TABLE inm.warehouse_inventory TO muriel;
GRANT ALL ON TABLE inm.warehouse_inventory TO yann;
GRANT SELECT ON TABLE inm.warehouse_inventory TO readonly;
GRANT ALL ON TABLE inm.warehouse_inventory TO dbservice;
GRANT ALL ON TABLE inm.warehouse_inventory TO tableauuser;
GRANT ALL ON TABLE inm.warehouse_inventory TO bartender;
GRANT ALL ON TABLE inm.warehouse_inventory TO bytedevs;


--
-- Name: TABLE warehouse_inventory; Type: ACL; Schema: campus_87; Owner: erpuser
--

GRANT SELECT ON TABLE campus_87.warehouse_inventory TO rc87;


--
-- Name: TABLE warehouse_order_history; Type: ACL; Schema: inm; Owner: erpuser
--

GRANT ALL ON TABLE inm.warehouse_order_history TO lambdazen;
GRANT ALL ON TABLE inm.warehouse_order_history TO muriel;
GRANT ALL ON TABLE inm.warehouse_order_history TO yann;
GRANT ALL ON TABLE inm.warehouse_order_history TO tableauuser;
GRANT ALL ON TABLE inm.warehouse_order_history TO bartender;
GRANT ALL ON TABLE inm.warehouse_order_history TO bytedevs;


--
-- Name: TABLE warehouse_order_history; Type: ACL; Schema: campus_87; Owner: erpuser
--

GRANT SELECT ON TABLE campus_87.warehouse_order_history TO rc87;


--
-- Name: TABLE current_inventory; Type: ACL; Schema: dw; Owner: erpuser
--

GRANT ALL ON TABLE dw.current_inventory TO lambdazen;
GRANT ALL ON TABLE dw.current_inventory TO yann;
GRANT ALL ON TABLE dw.current_inventory TO bytedevs;
GRANT ALL ON TABLE dw.current_inventory TO tableauuser;


--
-- Name: TABLE byte_current_inventory; Type: ACL; Schema: dw; Owner: erpuser
--

GRANT ALL ON TABLE dw.byte_current_inventory TO lambdazen;
GRANT ALL ON TABLE dw.byte_current_inventory TO yann;
GRANT ALL ON TABLE dw.byte_current_inventory TO bytedevs;
GRANT ALL ON TABLE dw.byte_current_inventory TO tableauuser;


--
-- Name: TABLE dim_campus; Type: ACL; Schema: dw; Owner: muriel
--

GRANT ALL ON TABLE dw.dim_campus TO lambdazen;
GRANT ALL ON TABLE dw.dim_campus TO yann;
GRANT SELECT ON TABLE dw.dim_campus TO readonly;
GRANT ALL ON TABLE dw.dim_campus TO dbservice;
GRANT ALL ON TABLE dw.dim_campus TO bytedevs;
GRANT ALL ON TABLE dw.dim_campus TO tableauuser;


--
-- Name: TABLE dim_kiosk; Type: ACL; Schema: dw; Owner: muriel
--

GRANT ALL ON TABLE dw.dim_kiosk TO lambdazen;
GRANT ALL ON TABLE dw.dim_kiosk TO yann;
GRANT SELECT ON TABLE dw.dim_kiosk TO readonly;
GRANT ALL ON TABLE dw.dim_kiosk TO dbservice;
GRANT ALL ON TABLE dw.dim_kiosk TO bytedevs;
GRANT ALL ON TABLE dw.dim_kiosk TO tableauuser;


--
-- Name: TABLE dim_product; Type: ACL; Schema: dw; Owner: muriel
--

GRANT ALL ON TABLE dw.dim_product TO lambdazen;
GRANT ALL ON TABLE dw.dim_product TO yann;
GRANT SELECT ON TABLE dw.dim_product TO readonly;
GRANT ALL ON TABLE dw.dim_product TO dbservice;
GRANT ALL ON TABLE dw.dim_product TO bytedevs;
GRANT ALL ON TABLE dw.dim_product TO tableauuser;


--
-- Name: TABLE tag; Type: ACL; Schema: pantry; Owner: erpuser
--

GRANT ALL ON TABLE pantry.tag TO muriel;
GRANT ALL ON TABLE pantry.tag TO yann;
GRANT ALL ON TABLE pantry.tag TO lambdazen;
GRANT ALL ON TABLE pantry.tag TO jungvu;
GRANT ALL ON TABLE pantry.tag TO tableauuser;
GRANT ALL ON TABLE pantry.tag TO bartender;
GRANT ALL ON TABLE pantry.tag TO bytedevs;


--
-- Name: TABLE export_inventory_lots; Type: ACL; Schema: dw; Owner: erpuser
--

GRANT ALL ON TABLE dw.export_inventory_lots TO lambdazen;
GRANT ALL ON TABLE dw.export_inventory_lots TO yann;
GRANT ALL ON TABLE dw.export_inventory_lots TO bytedevs;
GRANT ALL ON TABLE dw.export_inventory_lots TO tableauuser;


--
-- Name: TABLE fact_daily_byte_foods_summary; Type: ACL; Schema: dw; Owner: erpuser
--

GRANT ALL ON TABLE dw.fact_daily_byte_foods_summary TO lambdazen;
GRANT ALL ON TABLE dw.fact_daily_byte_foods_summary TO yann;
GRANT ALL ON TABLE dw.fact_daily_byte_foods_summary TO bytedevs;
GRANT ALL ON TABLE dw.fact_daily_byte_foods_summary TO tableauuser;


--
-- Name: TABLE fact_monthly_byte_foods_summary; Type: ACL; Schema: dw; Owner: erpuser
--

GRANT ALL ON TABLE dw.fact_monthly_byte_foods_summary TO lambdazen;
GRANT ALL ON TABLE dw.fact_monthly_byte_foods_summary TO yann;
GRANT ALL ON TABLE dw.fact_monthly_byte_foods_summary TO bytedevs;
GRANT ALL ON TABLE dw.fact_monthly_byte_foods_summary TO tableauuser;


--
-- Name: TABLE fact_monthly_kiosk_summary; Type: ACL; Schema: dw; Owner: erpuser
--

GRANT ALL ON TABLE dw.fact_monthly_kiosk_summary TO lambdazen;
GRANT ALL ON TABLE dw.fact_monthly_kiosk_summary TO yann;
GRANT ALL ON TABLE dw.fact_monthly_kiosk_summary TO bytedevs;
GRANT ALL ON TABLE dw.fact_monthly_kiosk_summary TO tableauuser;


--
-- Name: TABLE last_15_months; Type: ACL; Schema: dw; Owner: muriel
--

GRANT ALL ON TABLE dw.last_15_months TO yann;
GRANT SELECT ON TABLE dw.last_15_months TO readonly;
GRANT ALL ON TABLE dw.last_15_months TO dbservice;
GRANT ALL ON TABLE dw.last_15_months TO bytedevs;
GRANT ALL ON TABLE dw.last_15_months TO tableauuser;


--
-- Name: TABLE last_15_weeks; Type: ACL; Schema: dw; Owner: muriel
--

GRANT ALL ON TABLE dw.last_15_weeks TO yann;
GRANT SELECT ON TABLE dw.last_15_weeks TO readonly;
GRANT ALL ON TABLE dw.last_15_weeks TO dbservice;
GRANT ALL ON TABLE dw.last_15_weeks TO bytedevs;
GRANT ALL ON TABLE dw.last_15_weeks TO tableauuser;


--
-- Name: TABLE last_30_days; Type: ACL; Schema: dw; Owner: muriel
--

GRANT ALL ON TABLE dw.last_30_days TO yann;
GRANT ALL ON TABLE dw.last_30_days TO dbservice;
GRANT ALL ON TABLE dw.last_30_days TO bytedevs;
GRANT ALL ON TABLE dw.last_30_days TO tableauuser;


--
-- Name: TABLE last_30_days_kpis; Type: ACL; Schema: dw; Owner: muriel
--

GRANT ALL ON TABLE dw.last_30_days_kpis TO yann;
GRANT ALL ON TABLE dw.last_30_days_kpis TO dbservice;
GRANT ALL ON TABLE dw.last_30_days_kpis TO bytedevs;
GRANT ALL ON TABLE dw.last_30_days_kpis TO tableauuser;


--
-- Name: TABLE monthly_kpis; Type: ACL; Schema: dw; Owner: muriel
--

GRANT ALL ON TABLE dw.monthly_kpis TO yann;
GRANT SELECT ON TABLE dw.monthly_kpis TO readonly;
GRANT ALL ON TABLE dw.monthly_kpis TO dbservice;
GRANT ALL ON TABLE dw.monthly_kpis TO bytedevs;
GRANT ALL ON TABLE dw.monthly_kpis TO tableauuser;


--
-- Name: TABLE non_byte_current_inventory; Type: ACL; Schema: dw; Owner: erpuser
--

GRANT ALL ON TABLE dw.non_byte_current_inventory TO lambdazen;
GRANT ALL ON TABLE dw.non_byte_current_inventory TO yann;
GRANT ALL ON TABLE dw.non_byte_current_inventory TO bytedevs;
GRANT ALL ON TABLE dw.non_byte_current_inventory TO tableauuser;


--
-- Name: TABLE address; Type: ACL; Schema: erp; Owner: erpuser
--

GRANT ALL ON TABLE erp.address TO lambdazen;
GRANT ALL ON TABLE erp.address TO muriel;
GRANT SELECT ON TABLE erp.address TO readonly;
GRANT ALL ON TABLE erp.address TO dbservice;


--
-- Name: SEQUENCE address_id_seq; Type: ACL; Schema: erp; Owner: erpuser
--

GRANT ALL ON SEQUENCE erp.address_id_seq TO lambdazen;
GRANT ALL ON SEQUENCE erp.address_id_seq TO muriel;
GRANT ALL ON SEQUENCE erp.address_id_seq TO yann;
GRANT ALL ON SEQUENCE erp.address_id_seq TO dbservice;


--
-- Name: TABLE awsdms_apply_exceptions; Type: ACL; Schema: erp; Owner: erpuser
--

GRANT ALL ON TABLE erp.awsdms_apply_exceptions TO muriel;
GRANT ALL ON TABLE erp.awsdms_apply_exceptions TO yann;


--
-- Name: TABLE classic_product_allergen_tag; Type: ACL; Schema: erp; Owner: erpuser
--

GRANT ALL ON TABLE erp.classic_product_allergen_tag TO muriel;
GRANT ALL ON TABLE erp.classic_product_allergen_tag TO yann;


--
-- Name: TABLE classic_product_category_tag; Type: ACL; Schema: erp; Owner: erpuser
--

GRANT ALL ON TABLE erp.classic_product_category_tag TO muriel;
GRANT ALL ON TABLE erp.classic_product_category_tag TO yann;


--
-- Name: TABLE client; Type: ACL; Schema: erp; Owner: erpuser
--

GRANT ALL ON TABLE erp.client TO lambdazen;
GRANT ALL ON TABLE erp.client TO muriel;
GRANT SELECT ON TABLE erp.client TO readonly;
GRANT ALL ON TABLE erp.client TO dbservice;


--
-- Name: TABLE client_campus; Type: ACL; Schema: erp; Owner: erpuser
--

GRANT ALL ON TABLE erp.client_campus TO lambdazen;
GRANT ALL ON TABLE erp.client_campus TO muriel;
GRANT SELECT ON TABLE erp.client_campus TO readonly;
GRANT ALL ON TABLE erp.client_campus TO dbservice;


--
-- Name: TABLE client_contact; Type: ACL; Schema: erp; Owner: erpuser
--

GRANT ALL ON TABLE erp.client_contact TO lambdazen;
GRANT ALL ON TABLE erp.client_contact TO muriel;
GRANT SELECT ON TABLE erp.client_contact TO readonly;
GRANT ALL ON TABLE erp.client_contact TO dbservice;


--
-- Name: SEQUENCE client_id_seq; Type: ACL; Schema: erp; Owner: erpuser
--

GRANT ALL ON SEQUENCE erp.client_id_seq TO lambdazen;
GRANT ALL ON SEQUENCE erp.client_id_seq TO muriel;
GRANT ALL ON SEQUENCE erp.client_id_seq TO yann;
GRANT ALL ON SEQUENCE erp.client_id_seq TO dbservice;


--
-- Name: TABLE client_industry; Type: ACL; Schema: erp; Owner: erpuser
--

GRANT ALL ON TABLE erp.client_industry TO lambdazen;
GRANT ALL ON TABLE erp.client_industry TO muriel;
GRANT SELECT ON TABLE erp.client_industry TO readonly;
GRANT ALL ON TABLE erp.client_industry TO dbservice;


--
-- Name: TABLE contact; Type: ACL; Schema: erp; Owner: erpuser
--

GRANT ALL ON TABLE erp.contact TO lambdazen;
GRANT ALL ON TABLE erp.contact TO muriel;
GRANT SELECT ON TABLE erp.contact TO readonly;
GRANT ALL ON TABLE erp.contact TO dbservice;


--
-- Name: SEQUENCE contact_id_seq; Type: ACL; Schema: erp; Owner: erpuser
--

GRANT ALL ON SEQUENCE erp.contact_id_seq TO lambdazen;
GRANT ALL ON SEQUENCE erp.contact_id_seq TO muriel;
GRANT ALL ON SEQUENCE erp.contact_id_seq TO yann;
GRANT ALL ON SEQUENCE erp.contact_id_seq TO dbservice;


--
-- Name: TABLE fcm_repeater; Type: ACL; Schema: erp; Owner: erpuser
--

GRANT ALL ON TABLE erp.fcm_repeater TO muriel;
GRANT ALL ON TABLE erp.fcm_repeater TO yann;


--
-- Name: TABLE global_attribute_def; Type: ACL; Schema: erp; Owner: erpuser
--

GRANT ALL ON TABLE erp.global_attribute_def TO lambdazen;
GRANT ALL ON TABLE erp.global_attribute_def TO muriel;
GRANT SELECT ON TABLE erp.global_attribute_def TO readonly;
GRANT ALL ON TABLE erp.global_attribute_def TO dbservice;


--
-- Name: SEQUENCE global_attribute_def_id_seq; Type: ACL; Schema: erp; Owner: erpuser
--

GRANT ALL ON SEQUENCE erp.global_attribute_def_id_seq TO lambdazen;
GRANT ALL ON SEQUENCE erp.global_attribute_def_id_seq TO muriel;
GRANT ALL ON SEQUENCE erp.global_attribute_def_id_seq TO yann;
GRANT ALL ON SEQUENCE erp.global_attribute_def_id_seq TO dbservice;


--
-- Name: TABLE hardware_software; Type: ACL; Schema: erp; Owner: erpuser
--

GRANT ALL ON TABLE erp.hardware_software TO lambdazen;
GRANT ALL ON TABLE erp.hardware_software TO muriel;
GRANT SELECT ON TABLE erp.hardware_software TO readonly;
GRANT ALL ON TABLE erp.hardware_software TO dbservice;


--
-- Name: TABLE kiosk; Type: ACL; Schema: erp; Owner: erpuser
--

GRANT ALL ON TABLE erp.kiosk TO lambdazen;
GRANT ALL ON TABLE erp.kiosk TO muriel;
GRANT SELECT ON TABLE erp.kiosk TO readonly;
GRANT SELECT ON TABLE erp.kiosk TO yann;
GRANT ALL ON TABLE erp.kiosk TO dbservice;


--
-- Name: TABLE kiosk_access_card; Type: ACL; Schema: erp; Owner: erpuser
--

GRANT ALL ON TABLE erp.kiosk_access_card TO lambdazen;
GRANT ALL ON TABLE erp.kiosk_access_card TO muriel;
GRANT SELECT ON TABLE erp.kiosk_access_card TO readonly;
GRANT ALL ON TABLE erp.kiosk_access_card TO dbservice;


--
-- Name: SEQUENCE kiosk_access_card_id_seq; Type: ACL; Schema: erp; Owner: erpuser
--

GRANT ALL ON SEQUENCE erp.kiosk_access_card_id_seq TO lambdazen;
GRANT ALL ON SEQUENCE erp.kiosk_access_card_id_seq TO muriel;
GRANT ALL ON SEQUENCE erp.kiosk_access_card_id_seq TO yann;
GRANT ALL ON SEQUENCE erp.kiosk_access_card_id_seq TO dbservice;


--
-- Name: TABLE kiosk_accounting; Type: ACL; Schema: erp; Owner: erpuser
--

GRANT ALL ON TABLE erp.kiosk_accounting TO lambdazen;
GRANT ALL ON TABLE erp.kiosk_accounting TO muriel;
GRANT SELECT ON TABLE erp.kiosk_accounting TO readonly;
GRANT ALL ON TABLE erp.kiosk_accounting TO dbservice;


--
-- Name: TABLE kiosk_attribute; Type: ACL; Schema: erp; Owner: erpuser
--

GRANT ALL ON TABLE erp.kiosk_attribute TO lambdazen;
GRANT ALL ON TABLE erp.kiosk_attribute TO muriel;
GRANT SELECT ON TABLE erp.kiosk_attribute TO readonly;
GRANT ALL ON TABLE erp.kiosk_attribute TO dbservice;


--
-- Name: TABLE kiosk_contact; Type: ACL; Schema: erp; Owner: erpuser
--

GRANT ALL ON TABLE erp.kiosk_contact TO lambdazen;
GRANT ALL ON TABLE erp.kiosk_contact TO muriel;
GRANT SELECT ON TABLE erp.kiosk_contact TO readonly;
GRANT ALL ON TABLE erp.kiosk_contact TO dbservice;


--
-- Name: TABLE kiosk_delivery_window; Type: ACL; Schema: erp; Owner: erpuser
--

GRANT ALL ON TABLE erp.kiosk_delivery_window TO lambdazen;
GRANT ALL ON TABLE erp.kiosk_delivery_window TO muriel;
GRANT SELECT ON TABLE erp.kiosk_delivery_window TO readonly;
GRANT ALL ON TABLE erp.kiosk_delivery_window TO dbservice;


--
-- Name: TABLE kiosk_note; Type: ACL; Schema: erp; Owner: erpuser
--

GRANT ALL ON TABLE erp.kiosk_note TO lambdazen;
GRANT ALL ON TABLE erp.kiosk_note TO muriel;
GRANT SELECT ON TABLE erp.kiosk_note TO readonly;
GRANT ALL ON TABLE erp.kiosk_note TO dbservice;


--
-- Name: TABLE kiosk_status; Type: ACL; Schema: erp; Owner: erpuser
--

GRANT ALL ON TABLE erp.kiosk_status TO lambdazen;
GRANT ALL ON TABLE erp.kiosk_status TO muriel;
GRANT SELECT ON TABLE erp.kiosk_status TO readonly;
GRANT ALL ON TABLE erp.kiosk_status TO dbservice;


--
-- Name: TABLE kiosk_classic_view; Type: ACL; Schema: erp; Owner: erpuser
--

GRANT ALL ON TABLE erp.kiosk_classic_view TO muriel;
GRANT ALL ON TABLE erp.kiosk_classic_view TO yann;
GRANT ALL ON TABLE erp.kiosk_classic_view TO lambdazen;


--
-- Name: SEQUENCE kiosk_note_id_seq; Type: ACL; Schema: erp; Owner: erpuser
--

GRANT ALL ON SEQUENCE erp.kiosk_note_id_seq TO lambdazen;
GRANT ALL ON SEQUENCE erp.kiosk_note_id_seq TO muriel;
GRANT ALL ON SEQUENCE erp.kiosk_note_id_seq TO yann;
GRANT ALL ON SEQUENCE erp.kiosk_note_id_seq TO dbservice;


--
-- Name: TABLE kiosk_restriction_by_product; Type: ACL; Schema: erp; Owner: erpuser
--

GRANT ALL ON TABLE erp.kiosk_restriction_by_product TO lambdazen;
GRANT ALL ON TABLE erp.kiosk_restriction_by_product TO muriel;
GRANT SELECT ON TABLE erp.kiosk_restriction_by_product TO readonly;
GRANT ALL ON TABLE erp.kiosk_restriction_by_product TO dbservice;


--
-- Name: TABLE kiosk_restriction_by_property; Type: ACL; Schema: erp; Owner: erpuser
--

GRANT ALL ON TABLE erp.kiosk_restriction_by_property TO lambdazen;
GRANT ALL ON TABLE erp.kiosk_restriction_by_property TO muriel;
GRANT SELECT ON TABLE erp.kiosk_restriction_by_property TO readonly;
GRANT ALL ON TABLE erp.kiosk_restriction_by_property TO dbservice;


--
-- Name: TABLE product; Type: ACL; Schema: erp; Owner: erpuser
--

GRANT ALL ON TABLE erp.product TO lambdazen;
GRANT ALL ON TABLE erp.product TO muriel;
GRANT SELECT ON TABLE erp.product TO readonly;
GRANT ALL ON TABLE erp.product TO dbservice;


--
-- Name: TABLE product_asset; Type: ACL; Schema: erp; Owner: erpuser
--

GRANT ALL ON TABLE erp.product_asset TO lambdazen;
GRANT ALL ON TABLE erp.product_asset TO muriel;
GRANT SELECT ON TABLE erp.product_asset TO readonly;
GRANT ALL ON TABLE erp.product_asset TO dbservice;


--
-- Name: TABLE product_category; Type: ACL; Schema: erp; Owner: erpuser
--

GRANT ALL ON TABLE erp.product_category TO lambdazen;
GRANT ALL ON TABLE erp.product_category TO muriel;
GRANT SELECT ON TABLE erp.product_category TO readonly;
GRANT ALL ON TABLE erp.product_category TO dbservice;


--
-- Name: TABLE product_category_def; Type: ACL; Schema: erp; Owner: erpuser
--

GRANT ALL ON TABLE erp.product_category_def TO lambdazen;
GRANT ALL ON TABLE erp.product_category_def TO muriel;
GRANT SELECT ON TABLE erp.product_category_def TO readonly;
GRANT ALL ON TABLE erp.product_category_def TO dbservice;


--
-- Name: SEQUENCE product_category_def_id_seq; Type: ACL; Schema: erp; Owner: erpuser
--

GRANT ALL ON SEQUENCE erp.product_category_def_id_seq TO lambdazen;
GRANT ALL ON SEQUENCE erp.product_category_def_id_seq TO muriel;
GRANT ALL ON SEQUENCE erp.product_category_def_id_seq TO yann;
GRANT ALL ON SEQUENCE erp.product_category_def_id_seq TO dbservice;


--
-- Name: TABLE product_categories; Type: ACL; Schema: pantry; Owner: erpuser
--

GRANT ALL ON TABLE pantry.product_categories TO muriel;
GRANT ALL ON TABLE pantry.product_categories TO yann;
GRANT SELECT ON TABLE pantry.product_categories TO readonly;
GRANT ALL ON TABLE pantry.product_categories TO lambdazen;
GRANT ALL ON TABLE pantry.product_categories TO dbservice;
GRANT ALL ON TABLE pantry.product_categories TO jungvu;
GRANT ALL ON TABLE pantry.product_categories TO tableauuser;
GRANT ALL ON TABLE pantry.product_categories TO bartender;
GRANT ALL ON TABLE pantry.product_categories TO bytedevs;


--
-- Name: TABLE product_category_tag; Type: ACL; Schema: erp; Owner: erpuser
--

GRANT ALL ON TABLE erp.product_category_tag TO muriel;
GRANT ALL ON TABLE erp.product_category_tag TO yann;


--
-- Name: TABLE product_handling; Type: ACL; Schema: erp; Owner: erpuser
--

GRANT ALL ON TABLE erp.product_handling TO lambdazen;
GRANT ALL ON TABLE erp.product_handling TO muriel;
GRANT SELECT ON TABLE erp.product_handling TO readonly;
GRANT ALL ON TABLE erp.product_handling TO dbservice;


--
-- Name: TABLE product_nutrition; Type: ACL; Schema: erp; Owner: erpuser
--

GRANT ALL ON TABLE erp.product_nutrition TO lambdazen;
GRANT ALL ON TABLE erp.product_nutrition TO muriel;
GRANT SELECT ON TABLE erp.product_nutrition TO readonly;
GRANT ALL ON TABLE erp.product_nutrition TO dbservice;


--
-- Name: TABLE product_pricing; Type: ACL; Schema: erp; Owner: erpuser
--

GRANT ALL ON TABLE erp.product_pricing TO lambdazen;
GRANT ALL ON TABLE erp.product_pricing TO muriel;
GRANT SELECT ON TABLE erp.product_pricing TO readonly;
GRANT ALL ON TABLE erp.product_pricing TO dbservice;


--
-- Name: TABLE product_property; Type: ACL; Schema: erp; Owner: erpuser
--

GRANT ALL ON TABLE erp.product_property TO lambdazen;
GRANT ALL ON TABLE erp.product_property TO muriel;
GRANT SELECT ON TABLE erp.product_property TO readonly;
GRANT ALL ON TABLE erp.product_property TO dbservice;


--
-- Name: TABLE product_property_tag; Type: ACL; Schema: erp; Owner: erpuser
--

GRANT ALL ON TABLE erp.product_property_tag TO muriel;
GRANT ALL ON TABLE erp.product_property_tag TO yann;
GRANT ALL ON TABLE erp.product_property_tag TO lambdazen;


--
-- Name: TABLE product_sourcing; Type: ACL; Schema: erp; Owner: erpuser
--

GRANT ALL ON TABLE erp.product_sourcing TO lambdazen;
GRANT ALL ON TABLE erp.product_sourcing TO muriel;
GRANT SELECT ON TABLE erp.product_sourcing TO readonly;
GRANT ALL ON TABLE erp.product_sourcing TO dbservice;


--
-- Name: TABLE product_classic_view; Type: ACL; Schema: erp; Owner: erpuser
--

GRANT ALL ON TABLE erp.product_classic_view TO muriel;
GRANT ALL ON TABLE erp.product_classic_view TO yann;
GRANT ALL ON TABLE erp.product_classic_view TO lambdazen;


--
-- Name: TABLE product_property_def; Type: ACL; Schema: erp; Owner: erpuser
--

GRANT ALL ON TABLE erp.product_property_def TO lambdazen;
GRANT ALL ON TABLE erp.product_property_def TO muriel;
GRANT SELECT ON TABLE erp.product_property_def TO readonly;
GRANT ALL ON TABLE erp.product_property_def TO dbservice;


--
-- Name: SEQUENCE product_property_def_id_seq; Type: ACL; Schema: erp; Owner: erpuser
--

GRANT ALL ON SEQUENCE erp.product_property_def_id_seq TO lambdazen;
GRANT ALL ON SEQUENCE erp.product_property_def_id_seq TO muriel;
GRANT ALL ON SEQUENCE erp.product_property_def_id_seq TO yann;
GRANT ALL ON SEQUENCE erp.product_property_def_id_seq TO dbservice;


--
-- Name: TABLE sku_group; Type: ACL; Schema: erp; Owner: erpuser
--

GRANT ALL ON TABLE erp.sku_group TO lambdazen;
GRANT ALL ON TABLE erp.sku_group TO muriel;
GRANT SELECT ON TABLE erp.sku_group TO readonly;
GRANT ALL ON TABLE erp.sku_group TO dbservice;


--
-- Name: TABLE tag_order; Type: ACL; Schema: erp; Owner: erpuser
--

GRANT ALL ON TABLE erp.tag_order TO muriel;
GRANT ALL ON TABLE erp.tag_order TO yann;


--
-- Name: TABLE tag_order_stats; Type: ACL; Schema: erp; Owner: erpuser
--

GRANT ALL ON TABLE erp.tag_order_stats TO muriel;
GRANT ALL ON TABLE erp.tag_order_stats TO yann;


--
-- Name: TABLE tag_price; Type: ACL; Schema: erp; Owner: erpuser
--

GRANT ALL ON TABLE erp.tag_price TO muriel;
GRANT ALL ON TABLE erp.tag_price TO yann;


--
-- Name: TABLE tag_type; Type: ACL; Schema: erp; Owner: erpuser
--

GRANT ALL ON TABLE erp.tag_type TO muriel;
GRANT ALL ON TABLE erp.tag_type TO yann;


--
-- Name: TABLE v_client; Type: ACL; Schema: erp; Owner: lambdazen
--

GRANT SELECT ON TABLE erp.v_client TO erpuser;
GRANT SELECT ON TABLE erp.v_client TO yann;
GRANT SELECT ON TABLE erp.v_client TO readonly;
GRANT ALL ON TABLE erp.v_client TO dbservice;


--
-- Name: TABLE v_client_list; Type: ACL; Schema: erp; Owner: lambdazen
--

GRANT SELECT ON TABLE erp.v_client_list TO erpuser;
GRANT SELECT ON TABLE erp.v_client_list TO yann;
GRANT SELECT ON TABLE erp.v_client_list TO readonly;
GRANT ALL ON TABLE erp.v_client_list TO dbservice;


--
-- Name: TABLE last_kiosk_status; Type: ACL; Schema: pantry; Owner: erpuser
--

GRANT ALL ON TABLE pantry.last_kiosk_status TO muriel;
GRANT ALL ON TABLE pantry.last_kiosk_status TO lambdazen;
GRANT ALL ON TABLE pantry.last_kiosk_status TO yann;
GRANT SELECT ON TABLE pantry.last_kiosk_status TO readonly;
GRANT ALL ON TABLE pantry.last_kiosk_status TO dbservice;
GRANT ALL ON TABLE pantry.last_kiosk_status TO jungvu;
GRANT ALL ON TABLE pantry.last_kiosk_status TO tableauuser;
GRANT ALL ON TABLE pantry.last_kiosk_status TO bartender;
GRANT ALL ON TABLE pantry.last_kiosk_status TO bytedevs;


--
-- Name: TABLE v_kiosk; Type: ACL; Schema: erp; Owner: lambdazen
--

GRANT SELECT ON TABLE erp.v_kiosk TO erpuser;
GRANT SELECT ON TABLE erp.v_kiosk TO yann;
GRANT SELECT ON TABLE erp.v_kiosk TO readonly;
GRANT ALL ON TABLE erp.v_kiosk TO dbservice;


--
-- Name: TABLE kiosk_status; Type: ACL; Schema: pantry; Owner: erpuser
--

GRANT ALL ON TABLE pantry.kiosk_status TO muriel;
GRANT ALL ON TABLE pantry.kiosk_status TO yann;
GRANT ALL ON TABLE pantry.kiosk_status TO lambdazen;
GRANT ALL ON TABLE pantry.kiosk_status TO jungvu;
GRANT ALL ON TABLE pantry.kiosk_status TO tableauuser;
GRANT ALL ON TABLE pantry.kiosk_status TO bartender;
GRANT ALL ON TABLE pantry.kiosk_status TO bytedevs;


--
-- Name: TABLE v_kiosk_options; Type: ACL; Schema: erp; Owner: lambdazen
--

GRANT SELECT ON TABLE erp.v_kiosk_options TO erpuser;
GRANT SELECT ON TABLE erp.v_kiosk_options TO yann;
GRANT SELECT ON TABLE erp.v_kiosk_options TO readonly;
GRANT ALL ON TABLE erp.v_kiosk_options TO dbservice;


--
-- Name: TABLE v_product; Type: ACL; Schema: erp; Owner: lambdazen
--

GRANT SELECT ON TABLE erp.v_product TO erpuser;
GRANT SELECT ON TABLE erp.v_product TO yann;
GRANT SELECT ON TABLE erp.v_product TO readonly;
GRANT ALL ON TABLE erp.v_product TO dbservice;


--
-- Name: TABLE v_product_list; Type: ACL; Schema: erp; Owner: lambdazen
--

GRANT SELECT ON TABLE erp.v_product_list TO erpuser;
GRANT SELECT ON TABLE erp.v_product_list TO yann;
GRANT SELECT ON TABLE erp.v_product_list TO readonly;
GRANT ALL ON TABLE erp.v_product_list TO dbservice;


--
-- Name: TABLE v_product_options; Type: ACL; Schema: erp; Owner: lambdazen
--

GRANT SELECT ON TABLE erp.v_product_options TO erpuser;
GRANT SELECT ON TABLE erp.v_product_options TO yann;
GRANT SELECT ON TABLE erp.v_product_options TO readonly;
GRANT ALL ON TABLE erp.v_product_options TO dbservice;


--
-- Name: TABLE sku_group; Type: ACL; Schema: inm; Owner: erpuser
--

GRANT ALL ON TABLE inm.sku_group TO lambdazen;
GRANT ALL ON TABLE inm.sku_group TO muriel;
GRANT ALL ON TABLE inm.sku_group TO yann;
GRANT SELECT ON TABLE inm.sku_group TO readonly;
GRANT ALL ON TABLE inm.sku_group TO dbservice;
GRANT ALL ON TABLE inm.sku_group TO tableauuser;
GRANT ALL ON TABLE inm.sku_group TO bartender;
GRANT ALL ON TABLE inm.sku_group TO bytedevs;


--
-- Name: TABLE v_sku_group_list; Type: ACL; Schema: erp; Owner: lambdazen
--

GRANT SELECT ON TABLE erp.v_sku_group_list TO erpuser;
GRANT SELECT ON TABLE erp.v_sku_group_list TO yann;
GRANT SELECT ON TABLE erp.v_sku_group_list TO readonly;
GRANT ALL ON TABLE erp.v_sku_group_list TO dbservice;


--
-- Name: TABLE label_order; Type: ACL; Schema: pantry; Owner: erpuser
--

GRANT ALL ON TABLE pantry.label_order TO muriel;
GRANT ALL ON TABLE pantry.label_order TO yann;
GRANT ALL ON TABLE pantry.label_order TO lambdazen;
GRANT ALL ON TABLE pantry.label_order TO jungvu;
GRANT ALL ON TABLE pantry.label_order TO tableauuser;
GRANT ALL ON TABLE pantry.label_order TO bartender;
GRANT ALL ON TABLE pantry.label_order TO bytedevs;


--
-- Name: TABLE coupon; Type: ACL; Schema: pantry; Owner: erpuser
--

GRANT ALL ON TABLE pantry.coupon TO muriel;
GRANT ALL ON TABLE pantry.coupon TO yann;
GRANT SELECT ON TABLE pantry.coupon TO readonly;
GRANT ALL ON TABLE pantry.coupon TO lambdazen;
GRANT ALL ON TABLE pantry.coupon TO dbservice;
GRANT ALL ON TABLE pantry.coupon TO jungvu;
GRANT ALL ON TABLE pantry.coupon TO tableauuser;
GRANT ALL ON TABLE pantry.coupon TO bartender;
GRANT ALL ON TABLE pantry.coupon TO bytedevs;


--
-- Name: TABLE discount_applied; Type: ACL; Schema: pantry; Owner: erpuser
--

GRANT ALL ON TABLE pantry.discount_applied TO muriel;
GRANT ALL ON TABLE pantry.discount_applied TO yann;
GRANT ALL ON TABLE pantry.discount_applied TO lambdazen;
GRANT ALL ON TABLE pantry.discount_applied TO jungvu;
GRANT ALL ON TABLE pantry.discount_applied TO tableauuser;
GRANT ALL ON TABLE pantry.discount_applied TO bartender;
GRANT ALL ON TABLE pantry.discount_applied TO bytedevs;


--
-- Name: TABLE v_transaction_detail; Type: ACL; Schema: erp; Owner: lambdazen
--

GRANT ALL ON TABLE erp.v_transaction_detail TO dbservice;


--
-- Name: TABLE v_transaction_list; Type: ACL; Schema: erp; Owner: lambdazen
--

GRANT ALL ON TABLE erp.v_transaction_list TO dbservice;


--
-- Name: TABLE v_warehouse_inventory; Type: ACL; Schema: erp; Owner: lambdazen
--

GRANT SELECT ON TABLE erp.v_warehouse_inventory TO erpuser;
GRANT SELECT ON TABLE erp.v_warehouse_inventory TO yann;
GRANT SELECT ON TABLE erp.v_warehouse_inventory TO readonly;
GRANT ALL ON TABLE erp.v_warehouse_inventory TO dbservice;


--
-- Name: TABLE kiosk_product_disabled; Type: ACL; Schema: inm; Owner: erpuser
--

GRANT ALL ON TABLE inm.kiosk_product_disabled TO lambdazen;
GRANT ALL ON TABLE inm.kiosk_product_disabled TO muriel;
GRANT ALL ON TABLE inm.kiosk_product_disabled TO yann;
GRANT SELECT ON TABLE inm.kiosk_product_disabled TO readonly;
GRANT ALL ON TABLE inm.kiosk_product_disabled TO dbservice;
GRANT ALL ON TABLE inm.kiosk_product_disabled TO tableauuser;
GRANT ALL ON TABLE inm.kiosk_product_disabled TO bartender;
GRANT ALL ON TABLE inm.kiosk_product_disabled TO bytedevs;


--
-- Name: TABLE byte_products_fast; Type: ACL; Schema: public; Owner: erpuser
--

GRANT SELECT ON TABLE public.byte_products_fast TO yann;
GRANT SELECT ON TABLE public.byte_products_fast TO readonly;
GRANT ALL ON TABLE public.byte_products_fast TO tableauuser;
GRANT ALL ON TABLE public.byte_products_fast TO bartender;
GRANT ALL ON TABLE public.byte_products_fast TO bytedevs;


--
-- Name: TABLE byte_products; Type: ACL; Schema: public; Owner: erpuser
--

GRANT SELECT ON TABLE public.byte_products TO yann;
GRANT SELECT ON TABLE public.byte_products TO readonly;
GRANT ALL ON TABLE public.byte_products TO tableauuser;
GRANT ALL ON TABLE public.byte_products TO bartender;
GRANT ALL ON TABLE public.byte_products TO bytedevs;


--
-- Name: TABLE byte_label_product; Type: ACL; Schema: public; Owner: erpuser
--

GRANT SELECT ON TABLE public.byte_label_product TO yann;
GRANT SELECT ON TABLE public.byte_label_product TO readonly;
GRANT ALL ON TABLE public.byte_label_product TO tableauuser;
GRANT ALL ON TABLE public.byte_label_product TO bartender;
GRANT ALL ON TABLE public.byte_label_product TO bytedevs;


--
-- Name: TABLE byte_tickets_12weeks; Type: ACL; Schema: public; Owner: erpuser
--

GRANT SELECT ON TABLE public.byte_tickets_12weeks TO yann;
GRANT SELECT ON TABLE public.byte_tickets_12weeks TO readonly;
GRANT ALL ON TABLE public.byte_tickets_12weeks TO tableauuser;
GRANT ALL ON TABLE public.byte_tickets_12weeks TO bartender;
GRANT ALL ON TABLE public.byte_tickets_12weeks TO bytedevs;


--
-- Name: TABLE byte_epcssold_12weeks; Type: ACL; Schema: public; Owner: erpuser
--

GRANT SELECT ON TABLE public.byte_epcssold_12weeks TO yann;
GRANT SELECT ON TABLE public.byte_epcssold_12weeks TO readonly;
GRANT ALL ON TABLE public.byte_epcssold_12weeks TO tableauuser;
GRANT ALL ON TABLE public.byte_epcssold_12weeks TO bartender;
GRANT ALL ON TABLE public.byte_epcssold_12weeks TO bytedevs;


--
-- Name: TABLE v_kiosk_sale_hourly; Type: ACL; Schema: inm; Owner: erpuser
--

GRANT ALL ON TABLE inm.v_kiosk_sale_hourly TO lambdazen;
GRANT ALL ON TABLE inm.v_kiosk_sale_hourly TO muriel;
GRANT ALL ON TABLE inm.v_kiosk_sale_hourly TO yann;
GRANT SELECT ON TABLE inm.v_kiosk_sale_hourly TO readonly;
GRANT ALL ON TABLE inm.v_kiosk_sale_hourly TO dbservice;
GRANT ALL ON TABLE inm.v_kiosk_sale_hourly TO tableauuser;
GRANT ALL ON TABLE inm.v_kiosk_sale_hourly TO bartender;
GRANT ALL ON TABLE inm.v_kiosk_sale_hourly TO bytedevs;


--
-- Name: TABLE route_stop; Type: ACL; Schema: mixalot; Owner: erpuser
--

GRANT SELECT ON TABLE mixalot.route_stop TO readonly;
GRANT SELECT ON TABLE mixalot.route_stop TO yann;
GRANT ALL ON TABLE mixalot.route_stop TO muriel;
GRANT ALL ON TABLE mixalot.route_stop TO lambdazen;
GRANT ALL ON TABLE mixalot.route_stop TO tableauuser;
GRANT ALL ON TABLE mixalot.route_stop TO bartender;
GRANT ALL ON TABLE mixalot.route_stop TO bytedevs;


--
-- Name: TABLE v_kiosk_demand_plan_ratio; Type: ACL; Schema: inm; Owner: erpuser
--

GRANT ALL ON TABLE inm.v_kiosk_demand_plan_ratio TO lambdazen;
GRANT ALL ON TABLE inm.v_kiosk_demand_plan_ratio TO muriel;
GRANT ALL ON TABLE inm.v_kiosk_demand_plan_ratio TO yann;
GRANT SELECT ON TABLE inm.v_kiosk_demand_plan_ratio TO readonly;
GRANT ALL ON TABLE inm.v_kiosk_demand_plan_ratio TO dbservice;
GRANT ALL ON TABLE inm.v_kiosk_demand_plan_ratio TO tableauuser;
GRANT ALL ON TABLE inm.v_kiosk_demand_plan_ratio TO bartender;
GRANT ALL ON TABLE inm.v_kiosk_demand_plan_ratio TO bytedevs;


--
-- Name: TABLE v_kiosk_sku_enabled; Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON TABLE inm.v_kiosk_sku_enabled TO lambdazen;
GRANT ALL ON TABLE inm.v_kiosk_sku_enabled TO muriel;
GRANT ALL ON TABLE inm.v_kiosk_sku_enabled TO yann;


--
-- Name: TABLE v_kiosk_sku_group_stock_sale_spoil_history; Type: ACL; Schema: inm; Owner: dbservice
--

GRANT ALL ON TABLE inm.v_kiosk_sku_group_stock_sale_spoil_history TO lambdazen;
GRANT ALL ON TABLE inm.v_kiosk_sku_group_stock_sale_spoil_history TO muriel;
GRANT ALL ON TABLE inm.v_kiosk_sku_group_stock_sale_spoil_history TO yann;


--
-- Name: TABLE byte_tickets_3months; Type: ACL; Schema: public; Owner: erpuser
--

GRANT SELECT ON TABLE public.byte_tickets_3months TO yann;
GRANT SELECT ON TABLE public.byte_tickets_3months TO readonly;
GRANT ALL ON TABLE public.byte_tickets_3months TO tableauuser;
GRANT ALL ON TABLE public.byte_tickets_3months TO bartender;
GRANT ALL ON TABLE public.byte_tickets_3months TO bytedevs;


--
-- Name: TABLE byte_epcssold_3months; Type: ACL; Schema: public; Owner: erpuser
--

GRANT SELECT ON TABLE public.byte_epcssold_3months TO yann;
GRANT SELECT ON TABLE public.byte_epcssold_3months TO readonly;
GRANT ALL ON TABLE public.byte_epcssold_3months TO tableauuser;
GRANT ALL ON TABLE public.byte_epcssold_3months TO bartender;
GRANT ALL ON TABLE public.byte_epcssold_3months TO bytedevs;


--
-- Name: TABLE v_kiosk_sku_group_velocity_demand_week; Type: ACL; Schema: inm; Owner: erpuser
--

GRANT ALL ON TABLE inm.v_kiosk_sku_group_velocity_demand_week TO lambdazen;
GRANT ALL ON TABLE inm.v_kiosk_sku_group_velocity_demand_week TO muriel;
GRANT ALL ON TABLE inm.v_kiosk_sku_group_velocity_demand_week TO yann;
GRANT ALL ON TABLE inm.v_kiosk_sku_group_velocity_demand_week TO tableauuser;
GRANT ALL ON TABLE inm.v_kiosk_sku_group_velocity_demand_week TO bartender;
GRANT ALL ON TABLE inm.v_kiosk_sku_group_velocity_demand_week TO bytedevs;


--
-- Name: TABLE v_kiosk_sku_velocity; Type: ACL; Schema: inm; Owner: erpuser
--

GRANT ALL ON TABLE inm.v_kiosk_sku_velocity TO lambdazen;
GRANT ALL ON TABLE inm.v_kiosk_sku_velocity TO muriel;
GRANT ALL ON TABLE inm.v_kiosk_sku_velocity TO yann;
GRANT SELECT ON TABLE inm.v_kiosk_sku_velocity TO readonly;
GRANT ALL ON TABLE inm.v_kiosk_sku_velocity TO dbservice;
GRANT ALL ON TABLE inm.v_kiosk_sku_velocity TO tableauuser;
GRANT ALL ON TABLE inm.v_kiosk_sku_velocity TO bartender;
GRANT ALL ON TABLE inm.v_kiosk_sku_velocity TO bytedevs;


--
-- Name: TABLE v_kiosk_sku_group_sku_stats; Type: ACL; Schema: inm; Owner: erpuser
--

GRANT ALL ON TABLE inm.v_kiosk_sku_group_sku_stats TO lambdazen;
GRANT ALL ON TABLE inm.v_kiosk_sku_group_sku_stats TO muriel;
GRANT ALL ON TABLE inm.v_kiosk_sku_group_sku_stats TO yann;
GRANT ALL ON TABLE inm.v_kiosk_sku_group_sku_stats TO tableauuser;
GRANT ALL ON TABLE inm.v_kiosk_sku_group_sku_stats TO bartender;
GRANT ALL ON TABLE inm.v_kiosk_sku_group_sku_stats TO bytedevs;


--
-- Name: TABLE product_picking_order; Type: ACL; Schema: inm; Owner: erpuser
--

GRANT ALL ON TABLE inm.product_picking_order TO lambdazen;
GRANT ALL ON TABLE inm.product_picking_order TO muriel;
GRANT ALL ON TABLE inm.product_picking_order TO yann;
GRANT ALL ON TABLE inm.product_picking_order TO tableauuser;
GRANT ALL ON TABLE inm.product_picking_order TO bartender;
GRANT ALL ON TABLE inm.product_picking_order TO bytedevs;


--
-- Name: TABLE allocable_inventory; Type: ACL; Schema: inm; Owner: erpuser
--

GRANT ALL ON TABLE inm.allocable_inventory TO lambdazen;
GRANT ALL ON TABLE inm.allocable_inventory TO muriel;
GRANT ALL ON TABLE inm.allocable_inventory TO yann;
GRANT ALL ON TABLE inm.allocable_inventory TO tableauuser;
GRANT ALL ON TABLE inm.allocable_inventory TO bartender;
GRANT ALL ON TABLE inm.allocable_inventory TO bytedevs;


--
-- Name: TABLE configuration; Type: ACL; Schema: inm; Owner: erpuser
--

GRANT ALL ON TABLE inm.configuration TO lambdazen;
GRANT ALL ON TABLE inm.configuration TO muriel;
GRANT ALL ON TABLE inm.configuration TO yann;
GRANT SELECT ON TABLE inm.configuration TO readonly;
GRANT ALL ON TABLE inm.configuration TO dbservice;
GRANT ALL ON TABLE inm.configuration TO tableauuser;
GRANT ALL ON TABLE inm.configuration TO bartender;
GRANT ALL ON TABLE inm.configuration TO bytedevs;


--
-- Name: TABLE kiosk_projected_stock; Type: ACL; Schema: inm; Owner: erpuser
--

GRANT ALL ON TABLE inm.kiosk_projected_stock TO lambdazen;
GRANT ALL ON TABLE inm.kiosk_projected_stock TO muriel;
GRANT ALL ON TABLE inm.kiosk_projected_stock TO yann;
GRANT SELECT ON TABLE inm.kiosk_projected_stock TO readonly;
GRANT ALL ON TABLE inm.kiosk_projected_stock TO dbservice;
GRANT ALL ON TABLE inm.kiosk_projected_stock TO tableauuser;
GRANT ALL ON TABLE inm.kiosk_projected_stock TO bartender;
GRANT ALL ON TABLE inm.kiosk_projected_stock TO bytedevs;


--
-- Name: TABLE kiosk_restriction_list; Type: ACL; Schema: inm; Owner: erpuser
--

GRANT ALL ON TABLE inm.kiosk_restriction_list TO lambdazen;
GRANT ALL ON TABLE inm.kiosk_restriction_list TO muriel;
GRANT ALL ON TABLE inm.kiosk_restriction_list TO yann;
GRANT SELECT ON TABLE inm.kiosk_restriction_list TO readonly;
GRANT ALL ON TABLE inm.kiosk_restriction_list TO dbservice;
GRANT ALL ON TABLE inm.kiosk_restriction_list TO tableauuser;
GRANT ALL ON TABLE inm.kiosk_restriction_list TO bartender;
GRANT ALL ON TABLE inm.kiosk_restriction_list TO bytedevs;


--
-- Name: TABLE pick_substitution; Type: ACL; Schema: inm; Owner: erpuser
--

GRANT ALL ON TABLE inm.pick_substitution TO lambdazen;
GRANT ALL ON TABLE inm.pick_substitution TO muriel;
GRANT ALL ON TABLE inm.pick_substitution TO yann;
GRANT SELECT ON TABLE inm.pick_substitution TO readonly;
GRANT ALL ON TABLE inm.pick_substitution TO dbservice;
GRANT ALL ON TABLE inm.pick_substitution TO tableauuser;
GRANT ALL ON TABLE inm.pick_substitution TO bartender;
GRANT ALL ON TABLE inm.pick_substitution TO bytedevs;


--
-- Name: TABLE product_pick_order; Type: ACL; Schema: inm; Owner: erpuser
--

GRANT ALL ON TABLE inm.product_pick_order TO lambdazen;
GRANT ALL ON TABLE inm.product_pick_order TO muriel;
GRANT ALL ON TABLE inm.product_pick_order TO yann;
GRANT SELECT ON TABLE inm.product_pick_order TO readonly;
GRANT ALL ON TABLE inm.product_pick_order TO dbservice;
GRANT ALL ON TABLE inm.product_pick_order TO tableauuser;
GRANT ALL ON TABLE inm.product_pick_order TO bartender;
GRANT ALL ON TABLE inm.product_pick_order TO bytedevs;


--
-- Name: TABLE product_pick_order_temp; Type: ACL; Schema: inm; Owner: erpuser
--

GRANT ALL ON TABLE inm.product_pick_order_temp TO lambdazen;
GRANT ALL ON TABLE inm.product_pick_order_temp TO muriel;
GRANT ALL ON TABLE inm.product_pick_order_temp TO yann;
GRANT SELECT ON TABLE inm.product_pick_order_temp TO readonly;
GRANT ALL ON TABLE inm.product_pick_order_temp TO dbservice;
GRANT ALL ON TABLE inm.product_pick_order_temp TO tableauuser;
GRANT ALL ON TABLE inm.product_pick_order_temp TO bartender;
GRANT ALL ON TABLE inm.product_pick_order_temp TO bytedevs;


--
-- Name: SEQUENCE product_property_def_id_seq; Type: ACL; Schema: inm; Owner: erpuser
--

GRANT ALL ON SEQUENCE inm.product_property_def_id_seq TO lambdazen;
GRANT ALL ON SEQUENCE inm.product_property_def_id_seq TO muriel;
GRANT ALL ON SEQUENCE inm.product_property_def_id_seq TO yann;
GRANT ALL ON SEQUENCE inm.product_property_def_id_seq TO dbservice;
GRANT ALL ON SEQUENCE inm.product_property_def_id_seq TO tableauuser;
GRANT ALL ON SEQUENCE inm.product_property_def_id_seq TO bartender;
GRANT ALL ON SEQUENCE inm.product_property_def_id_seq TO bytedevs;


--
-- Name: TABLE v_warehouse_order_delivered_totals; Type: ACL; Schema: inm; Owner: erpuser
--

GRANT ALL ON TABLE inm.v_warehouse_order_delivered_totals TO lambdazen;
GRANT ALL ON TABLE inm.v_warehouse_order_delivered_totals TO muriel;
GRANT ALL ON TABLE inm.v_warehouse_order_delivered_totals TO yann;
GRANT ALL ON TABLE inm.v_warehouse_order_delivered_totals TO tableauuser;
GRANT ALL ON TABLE inm.v_warehouse_order_delivered_totals TO bartender;
GRANT ALL ON TABLE inm.v_warehouse_order_delivered_totals TO bytedevs;


--
-- Name: TABLE v_warehouse_ordering_rec; Type: ACL; Schema: inm; Owner: erpuser
--

GRANT ALL ON TABLE inm.v_warehouse_ordering_rec TO lambdazen;
GRANT ALL ON TABLE inm.v_warehouse_ordering_rec TO muriel;
GRANT ALL ON TABLE inm.v_warehouse_ordering_rec TO yann;
GRANT ALL ON TABLE inm.v_warehouse_ordering_rec TO tableauuser;
GRANT ALL ON TABLE inm.v_warehouse_ordering_rec TO bartender;
GRANT ALL ON TABLE inm.v_warehouse_ordering_rec TO bytedevs;


--
-- Name: TABLE card_product_fact; Type: ACL; Schema: mixalot; Owner: erpuser
--

GRANT SELECT ON TABLE mixalot.card_product_fact TO readonly;
GRANT SELECT ON TABLE mixalot.card_product_fact TO yann;
GRANT ALL ON TABLE mixalot.card_product_fact TO muriel;
GRANT ALL ON TABLE mixalot.card_product_fact TO lambdazen;
GRANT ALL ON TABLE mixalot.card_product_fact TO tableauuser;
GRANT ALL ON TABLE mixalot.card_product_fact TO bartender;
GRANT ALL ON TABLE mixalot.card_product_fact TO bytedevs;


--
-- Name: SEQUENCE card_product_fact_id_seq; Type: ACL; Schema: mixalot; Owner: erpuser
--

GRANT ALL ON SEQUENCE mixalot.card_product_fact_id_seq TO lambdazen;
GRANT ALL ON SEQUENCE mixalot.card_product_fact_id_seq TO tableauuser;
GRANT ALL ON SEQUENCE mixalot.card_product_fact_id_seq TO bartender;
GRANT ALL ON SEQUENCE mixalot.card_product_fact_id_seq TO bytedevs;


--
-- Name: TABLE gsheet_cache; Type: ACL; Schema: mixalot; Owner: erpuser
--

GRANT SELECT ON TABLE mixalot.gsheet_cache TO readonly;
GRANT SELECT ON TABLE mixalot.gsheet_cache TO yann;
GRANT ALL ON TABLE mixalot.gsheet_cache TO muriel;
GRANT ALL ON TABLE mixalot.gsheet_cache TO lambdazen;
GRANT ALL ON TABLE mixalot.gsheet_cache TO tableauuser;
GRANT ALL ON TABLE mixalot.gsheet_cache TO bartender;
GRANT ALL ON TABLE mixalot.gsheet_cache TO bytedevs;


--
-- Name: TABLE history_order_pipeline; Type: ACL; Schema: mixalot; Owner: erpuser
--

GRANT SELECT ON TABLE mixalot.history_order_pipeline TO readonly;
GRANT SELECT ON TABLE mixalot.history_order_pipeline TO yann;
GRANT ALL ON TABLE mixalot.history_order_pipeline TO muriel;
GRANT ALL ON TABLE mixalot.history_order_pipeline TO lambdazen;
GRANT ALL ON TABLE mixalot.history_order_pipeline TO tableauuser;
GRANT ALL ON TABLE mixalot.history_order_pipeline TO bartender;
GRANT ALL ON TABLE mixalot.history_order_pipeline TO bytedevs;


--
-- Name: SEQUENCE history_order_pipeline_id_seq; Type: ACL; Schema: mixalot; Owner: erpuser
--

GRANT ALL ON SEQUENCE mixalot.history_order_pipeline_id_seq TO lambdazen;
GRANT ALL ON SEQUENCE mixalot.history_order_pipeline_id_seq TO tableauuser;
GRANT ALL ON SEQUENCE mixalot.history_order_pipeline_id_seq TO bartender;
GRANT ALL ON SEQUENCE mixalot.history_order_pipeline_id_seq TO bytedevs;


--
-- Name: TABLE inm_data; Type: ACL; Schema: mixalot; Owner: erpuser
--

GRANT SELECT ON TABLE mixalot.inm_data TO readonly;
GRANT SELECT ON TABLE mixalot.inm_data TO yann;
GRANT ALL ON TABLE mixalot.inm_data TO muriel;
GRANT ALL ON TABLE mixalot.inm_data TO lambdazen;
GRANT ALL ON TABLE mixalot.inm_data TO tableauuser;
GRANT ALL ON TABLE mixalot.inm_data TO bartender;
GRANT ALL ON TABLE mixalot.inm_data TO bytedevs;


--
-- Name: SEQUENCE inm_data_id_seq; Type: ACL; Schema: mixalot; Owner: erpuser
--

GRANT ALL ON SEQUENCE mixalot.inm_data_id_seq TO lambdazen;
GRANT ALL ON SEQUENCE mixalot.inm_data_id_seq TO tableauuser;
GRANT ALL ON SEQUENCE mixalot.inm_data_id_seq TO bartender;
GRANT ALL ON SEQUENCE mixalot.inm_data_id_seq TO bytedevs;


--
-- Name: TABLE inm_kiosk_projected_stock; Type: ACL; Schema: mixalot; Owner: erpuser
--

GRANT SELECT ON TABLE mixalot.inm_kiosk_projected_stock TO readonly;
GRANT SELECT ON TABLE mixalot.inm_kiosk_projected_stock TO yann;
GRANT ALL ON TABLE mixalot.inm_kiosk_projected_stock TO muriel;
GRANT ALL ON TABLE mixalot.inm_kiosk_projected_stock TO lambdazen;
GRANT ALL ON TABLE mixalot.inm_kiosk_projected_stock TO tableauuser;
GRANT ALL ON TABLE mixalot.inm_kiosk_projected_stock TO bartender;
GRANT ALL ON TABLE mixalot.inm_kiosk_projected_stock TO bytedevs;


--
-- Name: TABLE merchandising_slot_sku_group; Type: ACL; Schema: mixalot; Owner: erpuser
--

GRANT SELECT ON TABLE mixalot.merchandising_slot_sku_group TO readonly;
GRANT SELECT ON TABLE mixalot.merchandising_slot_sku_group TO yann;
GRANT ALL ON TABLE mixalot.merchandising_slot_sku_group TO muriel;
GRANT ALL ON TABLE mixalot.merchandising_slot_sku_group TO lambdazen;
GRANT ALL ON TABLE mixalot.merchandising_slot_sku_group TO tableauuser;
GRANT ALL ON TABLE mixalot.merchandising_slot_sku_group TO bartender;
GRANT ALL ON TABLE mixalot.merchandising_slot_sku_group TO bytedevs;


--
-- Name: TABLE sku_group_def; Type: ACL; Schema: mixalot; Owner: erpuser
--

GRANT SELECT ON TABLE mixalot.sku_group_def TO readonly;
GRANT SELECT ON TABLE mixalot.sku_group_def TO yann;
GRANT ALL ON TABLE mixalot.sku_group_def TO muriel;
GRANT ALL ON TABLE mixalot.sku_group_def TO lambdazen;
GRANT ALL ON TABLE mixalot.sku_group_def TO tableauuser;
GRANT ALL ON TABLE mixalot.sku_group_def TO bartender;
GRANT ALL ON TABLE mixalot.sku_group_def TO bytedevs;


--
-- Name: TABLE inm_sku_group_title_to_merchandising_slot; Type: ACL; Schema: mixalot; Owner: erpuser
--

GRANT SELECT ON TABLE mixalot.inm_sku_group_title_to_merchandising_slot TO readonly;
GRANT SELECT ON TABLE mixalot.inm_sku_group_title_to_merchandising_slot TO yann;
GRANT ALL ON TABLE mixalot.inm_sku_group_title_to_merchandising_slot TO muriel;
GRANT ALL ON TABLE mixalot.inm_sku_group_title_to_merchandising_slot TO lambdazen;
GRANT ALL ON TABLE mixalot.inm_sku_group_title_to_merchandising_slot TO tableauuser;
GRANT ALL ON TABLE mixalot.inm_sku_group_title_to_merchandising_slot TO bartender;
GRANT ALL ON TABLE mixalot.inm_sku_group_title_to_merchandising_slot TO bytedevs;


--
-- Name: TABLE inm_sku_velocity; Type: ACL; Schema: mixalot; Owner: erpuser
--

GRANT SELECT ON TABLE mixalot.inm_sku_velocity TO readonly;
GRANT SELECT ON TABLE mixalot.inm_sku_velocity TO yann;
GRANT ALL ON TABLE mixalot.inm_sku_velocity TO muriel;
GRANT ALL ON TABLE mixalot.inm_sku_velocity TO lambdazen;
GRANT ALL ON TABLE mixalot.inm_sku_velocity TO tableauuser;
GRANT ALL ON TABLE mixalot.inm_sku_velocity TO bartender;
GRANT ALL ON TABLE mixalot.inm_sku_velocity TO bytedevs;


--
-- Name: TABLE kiosk_contents; Type: ACL; Schema: mixalot; Owner: erpuser
--

GRANT SELECT ON TABLE mixalot.kiosk_contents TO readonly;
GRANT SELECT ON TABLE mixalot.kiosk_contents TO yann;
GRANT ALL ON TABLE mixalot.kiosk_contents TO muriel;
GRANT ALL ON TABLE mixalot.kiosk_contents TO lambdazen;
GRANT ALL ON TABLE mixalot.kiosk_contents TO tableauuser;
GRANT ALL ON TABLE mixalot.kiosk_contents TO bartender;
GRANT ALL ON TABLE mixalot.kiosk_contents TO bytedevs;


--
-- Name: SEQUENCE kiosk_contents_id_seq; Type: ACL; Schema: mixalot; Owner: erpuser
--

GRANT ALL ON SEQUENCE mixalot.kiosk_contents_id_seq TO lambdazen;
GRANT ALL ON SEQUENCE mixalot.kiosk_contents_id_seq TO tableauuser;
GRANT ALL ON SEQUENCE mixalot.kiosk_contents_id_seq TO bartender;
GRANT ALL ON SEQUENCE mixalot.kiosk_contents_id_seq TO bytedevs;


--
-- Name: TABLE kiosk_fact; Type: ACL; Schema: mixalot; Owner: erpuser
--

GRANT SELECT ON TABLE mixalot.kiosk_fact TO readonly;
GRANT SELECT ON TABLE mixalot.kiosk_fact TO yann;
GRANT ALL ON TABLE mixalot.kiosk_fact TO muriel;
GRANT ALL ON TABLE mixalot.kiosk_fact TO lambdazen;
GRANT ALL ON TABLE mixalot.kiosk_fact TO tableauuser;
GRANT ALL ON TABLE mixalot.kiosk_fact TO bartender;
GRANT ALL ON TABLE mixalot.kiosk_fact TO bytedevs;


--
-- Name: SEQUENCE kiosk_fact_id_seq; Type: ACL; Schema: mixalot; Owner: erpuser
--

GRANT ALL ON SEQUENCE mixalot.kiosk_fact_id_seq TO lambdazen;
GRANT ALL ON SEQUENCE mixalot.kiosk_fact_id_seq TO tableauuser;
GRANT ALL ON SEQUENCE mixalot.kiosk_fact_id_seq TO bartender;
GRANT ALL ON SEQUENCE mixalot.kiosk_fact_id_seq TO bytedevs;


--
-- Name: TABLE last_kiosk_status; Type: ACL; Schema: mixalot; Owner: erpuser
--

GRANT SELECT ON TABLE mixalot.last_kiosk_status TO readonly;
GRANT SELECT ON TABLE mixalot.last_kiosk_status TO yann;
GRANT ALL ON TABLE mixalot.last_kiosk_status TO muriel;
GRANT ALL ON TABLE mixalot.last_kiosk_status TO lambdazen;
GRANT ALL ON TABLE mixalot.last_kiosk_status TO tableauuser;
GRANT ALL ON TABLE mixalot.last_kiosk_status TO bartender;
GRANT ALL ON TABLE mixalot.last_kiosk_status TO bytedevs;


--
-- Name: TABLE log; Type: ACL; Schema: mixalot; Owner: erpuser
--

GRANT SELECT ON TABLE mixalot.log TO readonly;
GRANT SELECT ON TABLE mixalot.log TO yann;
GRANT ALL ON TABLE mixalot.log TO muriel;
GRANT ALL ON TABLE mixalot.log TO lambdazen;
GRANT ALL ON TABLE mixalot.log TO tableauuser;
GRANT ALL ON TABLE mixalot.log TO bartender;
GRANT ALL ON TABLE mixalot.log TO bytedevs;


--
-- Name: SEQUENCE log_id_seq; Type: ACL; Schema: mixalot; Owner: erpuser
--

GRANT ALL ON SEQUENCE mixalot.log_id_seq TO lambdazen;
GRANT ALL ON SEQUENCE mixalot.log_id_seq TO tableauuser;
GRANT ALL ON SEQUENCE mixalot.log_id_seq TO bartender;
GRANT ALL ON SEQUENCE mixalot.log_id_seq TO bytedevs;


--
-- Name: TABLE order_fact; Type: ACL; Schema: mixalot; Owner: erpuser
--

GRANT SELECT ON TABLE mixalot.order_fact TO readonly;
GRANT SELECT ON TABLE mixalot.order_fact TO yann;
GRANT ALL ON TABLE mixalot.order_fact TO muriel;
GRANT ALL ON TABLE mixalot.order_fact TO lambdazen;
GRANT ALL ON TABLE mixalot.order_fact TO tableauuser;
GRANT ALL ON TABLE mixalot.order_fact TO bartender;
GRANT ALL ON TABLE mixalot.order_fact TO bytedevs;


--
-- Name: SEQUENCE order_fact_id_seq; Type: ACL; Schema: mixalot; Owner: erpuser
--

GRANT ALL ON SEQUENCE mixalot.order_fact_id_seq TO lambdazen;
GRANT ALL ON SEQUENCE mixalot.order_fact_id_seq TO tableauuser;
GRANT ALL ON SEQUENCE mixalot.order_fact_id_seq TO bartender;
GRANT ALL ON SEQUENCE mixalot.order_fact_id_seq TO bytedevs;


--
-- Name: TABLE pgdu; Type: ACL; Schema: mixalot; Owner: erpuser
--

GRANT ALL ON TABLE mixalot.pgdu TO lambdazen;
GRANT ALL ON TABLE mixalot.pgdu TO bytedevs;
GRANT ALL ON TABLE mixalot.pgdu TO tableauuser;
GRANT ALL ON TABLE mixalot.pgdu TO bartender;


--
-- Name: TABLE pick_preference_kiosk_sku; Type: ACL; Schema: mixalot; Owner: erpuser
--

GRANT SELECT ON TABLE mixalot.pick_preference_kiosk_sku TO readonly;
GRANT SELECT ON TABLE mixalot.pick_preference_kiosk_sku TO yann;
GRANT ALL ON TABLE mixalot.pick_preference_kiosk_sku TO muriel;
GRANT ALL ON TABLE mixalot.pick_preference_kiosk_sku TO lambdazen;
GRANT ALL ON TABLE mixalot.pick_preference_kiosk_sku TO tableauuser;
GRANT ALL ON TABLE mixalot.pick_preference_kiosk_sku TO bartender;
GRANT ALL ON TABLE mixalot.pick_preference_kiosk_sku TO bytedevs;


--
-- Name: TABLE pick_priority_kiosk; Type: ACL; Schema: mixalot; Owner: erpuser
--

GRANT SELECT ON TABLE mixalot.pick_priority_kiosk TO readonly;
GRANT SELECT ON TABLE mixalot.pick_priority_kiosk TO yann;
GRANT ALL ON TABLE mixalot.pick_priority_kiosk TO muriel;
GRANT ALL ON TABLE mixalot.pick_priority_kiosk TO lambdazen;
GRANT ALL ON TABLE mixalot.pick_priority_kiosk TO tableauuser;
GRANT ALL ON TABLE mixalot.pick_priority_kiosk TO bartender;
GRANT ALL ON TABLE mixalot.pick_priority_kiosk TO bytedevs;


--
-- Name: TABLE product_fact; Type: ACL; Schema: mixalot; Owner: erpuser
--

GRANT SELECT ON TABLE mixalot.product_fact TO readonly;
GRANT SELECT ON TABLE mixalot.product_fact TO yann;
GRANT ALL ON TABLE mixalot.product_fact TO muriel;
GRANT ALL ON TABLE mixalot.product_fact TO lambdazen;
GRANT ALL ON TABLE mixalot.product_fact TO tableauuser;
GRANT ALL ON TABLE mixalot.product_fact TO bartender;
GRANT ALL ON TABLE mixalot.product_fact TO bytedevs;


--
-- Name: SEQUENCE product_fact_id_seq; Type: ACL; Schema: mixalot; Owner: erpuser
--

GRANT ALL ON SEQUENCE mixalot.product_fact_id_seq TO lambdazen;
GRANT ALL ON SEQUENCE mixalot.product_fact_id_seq TO tableauuser;
GRANT ALL ON SEQUENCE mixalot.product_fact_id_seq TO bartender;
GRANT ALL ON SEQUENCE mixalot.product_fact_id_seq TO bytedevs;


--
-- Name: TABLE request_log; Type: ACL; Schema: mixalot; Owner: erpuser
--

GRANT SELECT ON TABLE mixalot.request_log TO readonly;
GRANT SELECT ON TABLE mixalot.request_log TO yann;
GRANT ALL ON TABLE mixalot.request_log TO muriel;
GRANT ALL ON TABLE mixalot.request_log TO lambdazen;
GRANT ALL ON TABLE mixalot.request_log TO tableauuser;
GRANT ALL ON TABLE mixalot.request_log TO bartender;
GRANT ALL ON TABLE mixalot.request_log TO bytedevs;


--
-- Name: TABLE route; Type: ACL; Schema: mixalot; Owner: erpuser
--

GRANT SELECT ON TABLE mixalot.route TO readonly;
GRANT SELECT ON TABLE mixalot.route TO yann;
GRANT ALL ON TABLE mixalot.route TO muriel;
GRANT ALL ON TABLE mixalot.route TO lambdazen;
GRANT ALL ON TABLE mixalot.route TO tableauuser;
GRANT ALL ON TABLE mixalot.route TO bartender;
GRANT ALL ON TABLE mixalot.route TO bytedevs;


--
-- Name: TABLE sku_group; Type: ACL; Schema: mixalot; Owner: erpuser
--

GRANT SELECT ON TABLE mixalot.sku_group TO readonly;
GRANT SELECT ON TABLE mixalot.sku_group TO yann;
GRANT ALL ON TABLE mixalot.sku_group TO muriel;
GRANT ALL ON TABLE mixalot.sku_group TO lambdazen;
GRANT ALL ON TABLE mixalot.sku_group TO tableauuser;
GRANT ALL ON TABLE mixalot.sku_group TO bartender;
GRANT ALL ON TABLE mixalot.sku_group TO bytedevs;


--
-- Name: SEQUENCE sku_group_def_id_seq; Type: ACL; Schema: mixalot; Owner: erpuser
--

GRANT ALL ON SEQUENCE mixalot.sku_group_def_id_seq TO lambdazen;
GRANT ALL ON SEQUENCE mixalot.sku_group_def_id_seq TO tableauuser;
GRANT ALL ON SEQUENCE mixalot.sku_group_def_id_seq TO bartender;
GRANT ALL ON SEQUENCE mixalot.sku_group_def_id_seq TO bytedevs;


--
-- Name: SEQUENCE sku_group_id_seq; Type: ACL; Schema: mixalot; Owner: erpuser
--

GRANT ALL ON SEQUENCE mixalot.sku_group_id_seq TO lambdazen;
GRANT ALL ON SEQUENCE mixalot.sku_group_id_seq TO tableauuser;
GRANT ALL ON SEQUENCE mixalot.sku_group_id_seq TO bartender;
GRANT ALL ON SEQUENCE mixalot.sku_group_id_seq TO bytedevs;


--
-- Name: TABLE sku_group_member; Type: ACL; Schema: mixalot; Owner: erpuser
--

GRANT SELECT ON TABLE mixalot.sku_group_member TO readonly;
GRANT SELECT ON TABLE mixalot.sku_group_member TO yann;
GRANT ALL ON TABLE mixalot.sku_group_member TO muriel;
GRANT ALL ON TABLE mixalot.sku_group_member TO lambdazen;
GRANT ALL ON TABLE mixalot.sku_group_member TO tableauuser;
GRANT ALL ON TABLE mixalot.sku_group_member TO bartender;
GRANT ALL ON TABLE mixalot.sku_group_member TO bytedevs;


--
-- Name: SEQUENCE sku_group_member_id_seq; Type: ACL; Schema: mixalot; Owner: erpuser
--

GRANT ALL ON SEQUENCE mixalot.sku_group_member_id_seq TO lambdazen;
GRANT ALL ON SEQUENCE mixalot.sku_group_member_id_seq TO tableauuser;
GRANT ALL ON SEQUENCE mixalot.sku_group_member_id_seq TO bartender;
GRANT ALL ON SEQUENCE mixalot.sku_group_member_id_seq TO bytedevs;


--
-- Name: TABLE sku_property; Type: ACL; Schema: mixalot; Owner: erpuser
--

GRANT SELECT ON TABLE mixalot.sku_property TO readonly;
GRANT SELECT ON TABLE mixalot.sku_property TO yann;
GRANT ALL ON TABLE mixalot.sku_property TO muriel;
GRANT ALL ON TABLE mixalot.sku_property TO lambdazen;
GRANT ALL ON TABLE mixalot.sku_property TO tableauuser;
GRANT ALL ON TABLE mixalot.sku_property TO bartender;
GRANT ALL ON TABLE mixalot.sku_property TO bytedevs;


--
-- Name: TABLE sku_property_def; Type: ACL; Schema: mixalot; Owner: erpuser
--

GRANT SELECT ON TABLE mixalot.sku_property_def TO readonly;
GRANT SELECT ON TABLE mixalot.sku_property_def TO yann;
GRANT ALL ON TABLE mixalot.sku_property_def TO muriel;
GRANT ALL ON TABLE mixalot.sku_property_def TO lambdazen;
GRANT ALL ON TABLE mixalot.sku_property_def TO tableauuser;
GRANT ALL ON TABLE mixalot.sku_property_def TO bartender;
GRANT ALL ON TABLE mixalot.sku_property_def TO bytedevs;


--
-- Name: SEQUENCE sku_property_def_id_seq; Type: ACL; Schema: mixalot; Owner: erpuser
--

GRANT ALL ON SEQUENCE mixalot.sku_property_def_id_seq TO lambdazen;
GRANT ALL ON SEQUENCE mixalot.sku_property_def_id_seq TO tableauuser;
GRANT ALL ON SEQUENCE mixalot.sku_property_def_id_seq TO bartender;
GRANT ALL ON SEQUENCE mixalot.sku_property_def_id_seq TO bytedevs;


--
-- Name: TABLE tmp_discount_applied; Type: ACL; Schema: mixalot; Owner: erpuser
--

GRANT SELECT ON TABLE mixalot.tmp_discount_applied TO readonly;
GRANT SELECT ON TABLE mixalot.tmp_discount_applied TO yann;
GRANT ALL ON TABLE mixalot.tmp_discount_applied TO muriel;
GRANT ALL ON TABLE mixalot.tmp_discount_applied TO lambdazen;
GRANT ALL ON TABLE mixalot.tmp_discount_applied TO tableauuser;
GRANT ALL ON TABLE mixalot.tmp_discount_applied TO bartender;
GRANT ALL ON TABLE mixalot.tmp_discount_applied TO bytedevs;


--
-- Name: SEQUENCE tmp_discount_applied_id_seq; Type: ACL; Schema: mixalot; Owner: erpuser
--

GRANT ALL ON SEQUENCE mixalot.tmp_discount_applied_id_seq TO lambdazen;
GRANT ALL ON SEQUENCE mixalot.tmp_discount_applied_id_seq TO tableauuser;
GRANT ALL ON SEQUENCE mixalot.tmp_discount_applied_id_seq TO bartender;
GRANT ALL ON SEQUENCE mixalot.tmp_discount_applied_id_seq TO bytedevs;


--
-- Name: TABLE tmp_kiosk_status; Type: ACL; Schema: mixalot; Owner: erpuser
--

GRANT SELECT ON TABLE mixalot.tmp_kiosk_status TO readonly;
GRANT SELECT ON TABLE mixalot.tmp_kiosk_status TO yann;
GRANT ALL ON TABLE mixalot.tmp_kiosk_status TO muriel;
GRANT ALL ON TABLE mixalot.tmp_kiosk_status TO lambdazen;
GRANT ALL ON TABLE mixalot.tmp_kiosk_status TO tableauuser;
GRANT ALL ON TABLE mixalot.tmp_kiosk_status TO bartender;
GRANT ALL ON TABLE mixalot.tmp_kiosk_status TO bytedevs;


--
-- Name: SEQUENCE tmp_kiosk_status_id_seq; Type: ACL; Schema: mixalot; Owner: erpuser
--

GRANT ALL ON SEQUENCE mixalot.tmp_kiosk_status_id_seq TO lambdazen;
GRANT ALL ON SEQUENCE mixalot.tmp_kiosk_status_id_seq TO tableauuser;
GRANT ALL ON SEQUENCE mixalot.tmp_kiosk_status_id_seq TO bartender;
GRANT ALL ON SEQUENCE mixalot.tmp_kiosk_status_id_seq TO bytedevs;


--
-- Name: TABLE tmp_transact; Type: ACL; Schema: mixalot; Owner: erpuser
--

GRANT SELECT ON TABLE mixalot.tmp_transact TO readonly;
GRANT SELECT ON TABLE mixalot.tmp_transact TO yann;
GRANT ALL ON TABLE mixalot.tmp_transact TO muriel;
GRANT ALL ON TABLE mixalot.tmp_transact TO lambdazen;
GRANT ALL ON TABLE mixalot.tmp_transact TO tableauuser;
GRANT ALL ON TABLE mixalot.tmp_transact TO bartender;
GRANT ALL ON TABLE mixalot.tmp_transact TO bytedevs;


--
-- Name: TABLE accounting; Type: ACL; Schema: pantry; Owner: erpuser
--

GRANT ALL ON TABLE pantry.accounting TO muriel;
GRANT ALL ON TABLE pantry.accounting TO yann;
GRANT ALL ON TABLE pantry.accounting TO lambdazen;
GRANT ALL ON TABLE pantry.accounting TO jungvu;
GRANT ALL ON TABLE pantry.accounting TO tableauuser;
GRANT ALL ON TABLE pantry.accounting TO bartender;
GRANT ALL ON TABLE pantry.accounting TO bytedevs;


--
-- Name: TABLE awsdms_apply_exceptions; Type: ACL; Schema: pantry; Owner: erpuser
--

GRANT ALL ON TABLE pantry.awsdms_apply_exceptions TO lambdazen;
GRANT ALL ON TABLE pantry.awsdms_apply_exceptions TO muriel;
GRANT ALL ON TABLE pantry.awsdms_apply_exceptions TO yann;
GRANT ALL ON TABLE pantry.awsdms_apply_exceptions TO bytedevs;
GRANT ALL ON TABLE pantry.awsdms_apply_exceptions TO tableauuser;
GRANT ALL ON TABLE pantry.awsdms_apply_exceptions TO bartender;


--
-- Name: TABLE bad_timestamp; Type: ACL; Schema: pantry; Owner: erpuser
--

GRANT ALL ON TABLE pantry.bad_timestamp TO lambdazen;
GRANT ALL ON TABLE pantry.bad_timestamp TO muriel;
GRANT ALL ON TABLE pantry.bad_timestamp TO yann;
GRANT ALL ON TABLE pantry.bad_timestamp TO tableauuser;
GRANT ALL ON TABLE pantry.bad_timestamp TO bartender;
GRANT ALL ON TABLE pantry.bad_timestamp TO bytedevs;


--
-- Name: TABLE campus_assets; Type: ACL; Schema: pantry; Owner: erpuser
--

GRANT ALL ON TABLE pantry.campus_assets TO lambdazen;
GRANT ALL ON TABLE pantry.campus_assets TO muriel;
GRANT ALL ON TABLE pantry.campus_assets TO yann;
GRANT ALL ON TABLE pantry.campus_assets TO tableauuser;
GRANT ALL ON TABLE pantry.campus_assets TO bartender;
GRANT ALL ON TABLE pantry.campus_assets TO bytedevs;


--
-- Name: TABLE card; Type: ACL; Schema: pantry; Owner: erpuser
--

GRANT ALL ON TABLE pantry.card TO muriel;
GRANT ALL ON TABLE pantry.card TO yann;
GRANT ALL ON TABLE pantry.card TO lambdazen;
GRANT ALL ON TABLE pantry.card TO tableauuser;
GRANT ALL ON TABLE pantry.card TO bartender;
GRANT ALL ON TABLE pantry.card TO bytedevs;


--
-- Name: TABLE discount; Type: ACL; Schema: pantry; Owner: erpuser
--

GRANT ALL ON TABLE pantry.discount TO muriel;
GRANT ALL ON TABLE pantry.discount TO yann;
GRANT ALL ON TABLE pantry.discount TO lambdazen;
GRANT ALL ON TABLE pantry.discount TO jungvu;
GRANT ALL ON TABLE pantry.discount TO tableauuser;
GRANT ALL ON TABLE pantry.discount TO bartender;
GRANT ALL ON TABLE pantry.discount TO bytedevs;


--
-- Name: TABLE discount_history; Type: ACL; Schema: pantry; Owner: erpuser
--

GRANT ALL ON TABLE pantry.discount_history TO muriel;
GRANT ALL ON TABLE pantry.discount_history TO yann;
GRANT ALL ON TABLE pantry.discount_history TO lambdazen;
GRANT ALL ON TABLE pantry.discount_history TO jungvu;
GRANT ALL ON TABLE pantry.discount_history TO tableauuser;
GRANT ALL ON TABLE pantry.discount_history TO bartender;
GRANT ALL ON TABLE pantry.discount_history TO bytedevs;


--
-- Name: TABLE email; Type: ACL; Schema: pantry; Owner: erpuser
--

GRANT ALL ON TABLE pantry.email TO lambdazen;
GRANT ALL ON TABLE pantry.email TO muriel;
GRANT ALL ON TABLE pantry.email TO yann;


--
-- Name: TABLE empty_transaction; Type: ACL; Schema: pantry; Owner: erpuser
--

GRANT ALL ON TABLE pantry.empty_transaction TO lambdazen;
GRANT ALL ON TABLE pantry.empty_transaction TO muriel;
GRANT ALL ON TABLE pantry.empty_transaction TO yann;
GRANT ALL ON TABLE pantry.empty_transaction TO tableauuser;
GRANT ALL ON TABLE pantry.empty_transaction TO bartender;
GRANT ALL ON TABLE pantry.empty_transaction TO bytedevs;


--
-- Name: TABLE fee_rates; Type: ACL; Schema: pantry; Owner: erpuser
--

GRANT ALL ON TABLE pantry.fee_rates TO muriel;
GRANT ALL ON TABLE pantry.fee_rates TO yann;
GRANT ALL ON TABLE pantry.fee_rates TO lambdazen;
GRANT ALL ON TABLE pantry.fee_rates TO jungvu;
GRANT ALL ON TABLE pantry.fee_rates TO tableauuser;
GRANT ALL ON TABLE pantry.fee_rates TO bartender;
GRANT ALL ON TABLE pantry.fee_rates TO bytedevs;


--
-- Name: TABLE "group"; Type: ACL; Schema: pantry; Owner: erpuser
--

GRANT ALL ON TABLE pantry."group" TO lambdazen;
GRANT ALL ON TABLE pantry."group" TO muriel;
GRANT ALL ON TABLE pantry."group" TO yann;
GRANT ALL ON TABLE pantry."group" TO tableauuser;
GRANT ALL ON TABLE pantry."group" TO bartender;
GRANT ALL ON TABLE pantry."group" TO bytedevs;


--
-- Name: TABLE group_campus; Type: ACL; Schema: pantry; Owner: erpuser
--

GRANT ALL ON TABLE pantry.group_campus TO lambdazen;
GRANT ALL ON TABLE pantry.group_campus TO muriel;
GRANT ALL ON TABLE pantry.group_campus TO yann;
GRANT ALL ON TABLE pantry.group_campus TO tableauuser;
GRANT ALL ON TABLE pantry.group_campus TO bartender;
GRANT ALL ON TABLE pantry.group_campus TO bytedevs;


--
-- Name: TABLE history; Type: ACL; Schema: pantry; Owner: erpuser
--

GRANT ALL ON TABLE pantry.history TO muriel;
GRANT ALL ON TABLE pantry.history TO yann;
GRANT SELECT ON TABLE pantry.history TO readonly;
GRANT ALL ON TABLE pantry.history TO lambdazen;
GRANT ALL ON TABLE pantry.history TO dbservice;
GRANT ALL ON TABLE pantry.history TO jungvu;
GRANT ALL ON TABLE pantry.history TO tableauuser;
GRANT ALL ON TABLE pantry.history TO bartender;
GRANT ALL ON TABLE pantry.history TO bytedevs;


--
-- Name: TABLE history_epc_order; Type: ACL; Schema: pantry; Owner: erpuser
--

GRANT ALL ON TABLE pantry.history_epc_order TO lambdazen;
GRANT ALL ON TABLE pantry.history_epc_order TO muriel;
GRANT ALL ON TABLE pantry.history_epc_order TO yann;
GRANT ALL ON TABLE pantry.history_epc_order TO tableauuser;
GRANT ALL ON TABLE pantry.history_epc_order TO bartender;
GRANT ALL ON TABLE pantry.history_epc_order TO bytedevs;


--
-- Name: TABLE inventory_history; Type: ACL; Schema: pantry; Owner: erpuser
--

GRANT ALL ON TABLE pantry.inventory_history TO muriel;
GRANT ALL ON TABLE pantry.inventory_history TO yann;
GRANT ALL ON TABLE pantry.inventory_history TO lambdazen;
GRANT ALL ON TABLE pantry.inventory_history TO jungvu;
GRANT ALL ON TABLE pantry.inventory_history TO tableauuser;
GRANT ALL ON TABLE pantry.inventory_history TO bartender;
GRANT ALL ON TABLE pantry.inventory_history TO bytedevs;


--
-- Name: TABLE inventory_request; Type: ACL; Schema: pantry; Owner: erpuser
--

GRANT ALL ON TABLE pantry.inventory_request TO lambdazen;
GRANT ALL ON TABLE pantry.inventory_request TO muriel;
GRANT ALL ON TABLE pantry.inventory_request TO yann;
GRANT ALL ON TABLE pantry.inventory_request TO tableauuser;
GRANT ALL ON TABLE pantry.inventory_request TO bartender;
GRANT ALL ON TABLE pantry.inventory_request TO bytedevs;


--
-- Name: TABLE kiosk_audit_log; Type: ACL; Schema: pantry; Owner: erpuser
--

GRANT ALL ON TABLE pantry.kiosk_audit_log TO lambdazen;
GRANT ALL ON TABLE pantry.kiosk_audit_log TO muriel;
GRANT ALL ON TABLE pantry.kiosk_audit_log TO yann;
GRANT ALL ON TABLE pantry.kiosk_audit_log TO tableauuser;
GRANT ALL ON TABLE pantry.kiosk_audit_log TO bartender;
GRANT ALL ON TABLE pantry.kiosk_audit_log TO bytedevs;


--
-- Name: TABLE kiosk_catalog_downloads; Type: ACL; Schema: pantry; Owner: erpuser
--

GRANT ALL ON TABLE pantry.kiosk_catalog_downloads TO lambdazen;
GRANT ALL ON TABLE pantry.kiosk_catalog_downloads TO muriel;
GRANT ALL ON TABLE pantry.kiosk_catalog_downloads TO yann;
GRANT ALL ON TABLE pantry.kiosk_catalog_downloads TO tableauuser;
GRANT ALL ON TABLE pantry.kiosk_catalog_downloads TO bartender;
GRANT ALL ON TABLE pantry.kiosk_catalog_downloads TO bytedevs;


--
-- Name: TABLE kiosk_components_history; Type: ACL; Schema: pantry; Owner: erpuser
--

GRANT ALL ON TABLE pantry.kiosk_components_history TO lambdazen;
GRANT ALL ON TABLE pantry.kiosk_components_history TO muriel;
GRANT ALL ON TABLE pantry.kiosk_components_history TO yann;
GRANT ALL ON TABLE pantry.kiosk_components_history TO tableauuser;
GRANT ALL ON TABLE pantry.kiosk_components_history TO bartender;
GRANT ALL ON TABLE pantry.kiosk_components_history TO bytedevs;


--
-- Name: TABLE kiosk_par_level; Type: ACL; Schema: pantry; Owner: erpuser
--

GRANT ALL ON TABLE pantry.kiosk_par_level TO muriel;
GRANT ALL ON TABLE pantry.kiosk_par_level TO yann;
GRANT ALL ON TABLE pantry.kiosk_par_level TO lambdazen;
GRANT ALL ON TABLE pantry.kiosk_par_level TO jungvu;
GRANT ALL ON TABLE pantry.kiosk_par_level TO tableauuser;
GRANT ALL ON TABLE pantry.kiosk_par_level TO bartender;
GRANT ALL ON TABLE pantry.kiosk_par_level TO bytedevs;


--
-- Name: TABLE kiosks_date_non_new; Type: ACL; Schema: pantry; Owner: erpuser
--

GRANT ALL ON TABLE pantry.kiosks_date_non_new TO muriel;
GRANT ALL ON TABLE pantry.kiosks_date_non_new TO yann;
GRANT ALL ON TABLE pantry.kiosks_date_non_new TO lambdazen;
GRANT ALL ON TABLE pantry.kiosks_date_non_new TO jungvu;
GRANT ALL ON TABLE pantry.kiosks_date_non_new TO tableauuser;
GRANT ALL ON TABLE pantry.kiosks_date_non_new TO bartender;
GRANT ALL ON TABLE pantry.kiosks_date_non_new TO bytedevs;


--
-- Name: SEQUENCE label_order_id_seq; Type: ACL; Schema: pantry; Owner: erpuser
--

GRANT ALL ON SEQUENCE pantry.label_order_id_seq TO lambdazen;
GRANT ALL ON SEQUENCE pantry.label_order_id_seq TO muriel;


--
-- Name: TABLE label_stats; Type: ACL; Schema: pantry; Owner: erpuser
--

GRANT ALL ON TABLE pantry.label_stats TO lambdazen;
GRANT ALL ON TABLE pantry.label_stats TO muriel;
GRANT ALL ON TABLE pantry.label_stats TO yann;
GRANT ALL ON TABLE pantry.label_stats TO bytedevs;
GRANT ALL ON TABLE pantry.label_stats TO tableauuser;
GRANT ALL ON TABLE pantry.label_stats TO bartender;


--
-- Name: TABLE manual_adjustment; Type: ACL; Schema: pantry; Owner: erpuser
--

GRANT ALL ON TABLE pantry.manual_adjustment TO muriel;
GRANT ALL ON TABLE pantry.manual_adjustment TO yann;
GRANT ALL ON TABLE pantry.manual_adjustment TO lambdazen;
GRANT ALL ON TABLE pantry.manual_adjustment TO jungvu;
GRANT ALL ON TABLE pantry.manual_adjustment TO tableauuser;
GRANT ALL ON TABLE pantry.manual_adjustment TO bartender;
GRANT ALL ON TABLE pantry.manual_adjustment TO bytedevs;


--
-- Name: TABLE nutrition_filter; Type: ACL; Schema: pantry; Owner: erpuser
--

GRANT ALL ON TABLE pantry.nutrition_filter TO muriel;
GRANT ALL ON TABLE pantry.nutrition_filter TO yann;
GRANT ALL ON TABLE pantry.nutrition_filter TO lambdazen;
GRANT ALL ON TABLE pantry.nutrition_filter TO jungvu;
GRANT ALL ON TABLE pantry.nutrition_filter TO tableauuser;
GRANT ALL ON TABLE pantry.nutrition_filter TO bartender;
GRANT ALL ON TABLE pantry.nutrition_filter TO bytedevs;


--
-- Name: TABLE payment_order; Type: ACL; Schema: pantry; Owner: erpuser
--

GRANT ALL ON TABLE pantry.payment_order TO lambdazen;
GRANT ALL ON TABLE pantry.payment_order TO muriel;
GRANT ALL ON TABLE pantry.payment_order TO yann;
GRANT ALL ON TABLE pantry.payment_order TO tableauuser;
GRANT ALL ON TABLE pantry.payment_order TO bartender;
GRANT ALL ON TABLE pantry.payment_order TO bytedevs;


--
-- Name: TABLE payment_order_nursing; Type: ACL; Schema: pantry; Owner: erpuser
--

GRANT ALL ON TABLE pantry.payment_order_nursing TO lambdazen;
GRANT ALL ON TABLE pantry.payment_order_nursing TO muriel;
GRANT ALL ON TABLE pantry.payment_order_nursing TO yann;
GRANT ALL ON TABLE pantry.payment_order_nursing TO tableauuser;
GRANT ALL ON TABLE pantry.payment_order_nursing TO bartender;
GRANT ALL ON TABLE pantry.payment_order_nursing TO bytedevs;


--
-- Name: TABLE pick_list_row; Type: ACL; Schema: pantry; Owner: erpuser
--

GRANT ALL ON TABLE pantry.pick_list_row TO lambdazen;
GRANT ALL ON TABLE pantry.pick_list_row TO muriel;
GRANT ALL ON TABLE pantry.pick_list_row TO yann;
GRANT ALL ON TABLE pantry.pick_list_row TO tableauuser;
GRANT ALL ON TABLE pantry.pick_list_row TO bartender;
GRANT ALL ON TABLE pantry.pick_list_row TO bytedevs;


--
-- Name: TABLE product_history; Type: ACL; Schema: pantry; Owner: erpuser
--

GRANT ALL ON TABLE pantry.product_history TO muriel;
GRANT ALL ON TABLE pantry.product_history TO yann;
GRANT ALL ON TABLE pantry.product_history TO lambdazen;
GRANT ALL ON TABLE pantry.product_history TO jungvu;
GRANT ALL ON TABLE pantry.product_history TO tableauuser;
GRANT ALL ON TABLE pantry.product_history TO bartender;
GRANT ALL ON TABLE pantry.product_history TO bytedevs;


--
-- Name: TABLE recent_transactions; Type: ACL; Schema: pantry; Owner: erpuser
--

GRANT ALL ON TABLE pantry.recent_transactions TO lambdazen;
GRANT ALL ON TABLE pantry.recent_transactions TO muriel;
GRANT ALL ON TABLE pantry.recent_transactions TO yann;
GRANT ALL ON TABLE pantry.recent_transactions TO tableauuser;
GRANT ALL ON TABLE pantry.recent_transactions TO bartender;
GRANT ALL ON TABLE pantry.recent_transactions TO bytedevs;


--
-- Name: TABLE refunds; Type: ACL; Schema: pantry; Owner: erpuser
--

GRANT ALL ON TABLE pantry.refunds TO muriel;
GRANT ALL ON TABLE pantry.refunds TO yann;
GRANT ALL ON TABLE pantry.refunds TO lambdazen;
GRANT ALL ON TABLE pantry.refunds TO jungvu;
GRANT ALL ON TABLE pantry.refunds TO tableauuser;
GRANT ALL ON TABLE pantry.refunds TO bartender;
GRANT ALL ON TABLE pantry.refunds TO bytedevs;


--
-- Name: TABLE ro_order; Type: ACL; Schema: pantry; Owner: erpuser
--

GRANT ALL ON TABLE pantry.ro_order TO lambdazen;
GRANT ALL ON TABLE pantry.ro_order TO muriel;
GRANT ALL ON TABLE pantry.ro_order TO yann;
GRANT ALL ON TABLE pantry.ro_order TO tableauuser;
GRANT ALL ON TABLE pantry.ro_order TO bartender;
GRANT ALL ON TABLE pantry.ro_order TO bytedevs;


--
-- Name: TABLE role; Type: ACL; Schema: pantry; Owner: erpuser
--

GRANT ALL ON TABLE pantry.role TO muriel;
GRANT ALL ON TABLE pantry.role TO lambdazen;
GRANT ALL ON TABLE pantry.role TO yann;
GRANT SELECT ON TABLE pantry.role TO readonly;
GRANT ALL ON TABLE pantry.role TO dbservice;
GRANT ALL ON TABLE pantry.role TO jungvu;
GRANT ALL ON TABLE pantry.role TO tableauuser;
GRANT ALL ON TABLE pantry.role TO bartender;
GRANT ALL ON TABLE pantry.role TO bytedevs;


--
-- Name: TABLE temp_kiosk; Type: ACL; Schema: pantry; Owner: erpuser
--

GRANT ALL ON TABLE pantry.temp_kiosk TO muriel;
GRANT ALL ON TABLE pantry.temp_kiosk TO yann;
GRANT ALL ON TABLE pantry.temp_kiosk TO lambdazen;
GRANT ALL ON TABLE pantry.temp_kiosk TO jungvu;
GRANT ALL ON TABLE pantry.temp_kiosk TO tableauuser;
GRANT ALL ON TABLE pantry.temp_kiosk TO bartender;
GRANT ALL ON TABLE pantry.temp_kiosk TO bytedevs;


--
-- Name: TABLE temp_product; Type: ACL; Schema: pantry; Owner: erpuser
--

GRANT ALL ON TABLE pantry.temp_product TO muriel;
GRANT ALL ON TABLE pantry.temp_product TO yann;
GRANT ALL ON TABLE pantry.temp_product TO lambdazen;
GRANT ALL ON TABLE pantry.temp_product TO jungvu;
GRANT ALL ON TABLE pantry.temp_product TO tableauuser;
GRANT ALL ON TABLE pantry.temp_product TO bartender;
GRANT ALL ON TABLE pantry.temp_product TO bytedevs;


--
-- Name: TABLE temperature_tag_history; Type: ACL; Schema: pantry; Owner: erpuser
--

GRANT ALL ON TABLE pantry.temperature_tag_history TO lambdazen;
GRANT ALL ON TABLE pantry.temperature_tag_history TO muriel;
GRANT ALL ON TABLE pantry.temperature_tag_history TO yann;


--
-- Name: TABLE "user"; Type: ACL; Schema: pantry; Owner: erpuser
--

GRANT ALL ON TABLE pantry."user" TO lambdazen;
GRANT ALL ON TABLE pantry."user" TO muriel;
GRANT ALL ON TABLE pantry."user" TO yann;
GRANT ALL ON TABLE pantry."user" TO tableauuser;
GRANT ALL ON TABLE pantry."user" TO bartender;
GRANT ALL ON TABLE pantry."user" TO bytedevs;


--
-- Name: TABLE awsdms_ddl_audit; Type: ACL; Schema: public; Owner: erpuser
--

GRANT ALL ON TABLE public.awsdms_ddl_audit TO tableauuser;
GRANT ALL ON TABLE public.awsdms_ddl_audit TO bartender;
GRANT ALL ON TABLE public.awsdms_ddl_audit TO bytedevs;


--
-- Name: SEQUENCE awsdms_ddl_audit_c_key_seq; Type: ACL; Schema: public; Owner: erpuser
--

GRANT ALL ON SEQUENCE public.awsdms_ddl_audit_c_key_seq TO tableauuser;
GRANT ALL ON SEQUENCE public.awsdms_ddl_audit_c_key_seq TO bartender;
GRANT ALL ON SEQUENCE public.awsdms_ddl_audit_c_key_seq TO bytedevs;


--
-- Name: TABLE bak_awsdms_apply_exceptions; Type: ACL; Schema: public; Owner: erpuser
--

GRANT SELECT ON TABLE public.bak_awsdms_apply_exceptions TO yann;
GRANT SELECT ON TABLE public.bak_awsdms_apply_exceptions TO readonly;
GRANT ALL ON TABLE public.bak_awsdms_apply_exceptions TO tableauuser;
GRANT ALL ON TABLE public.bak_awsdms_apply_exceptions TO bartender;
GRANT ALL ON TABLE public.bak_awsdms_apply_exceptions TO bytedevs;


--
-- Name: TABLE bak_awsdms_validation_failures_v1; Type: ACL; Schema: public; Owner: erpuser
--

GRANT SELECT ON TABLE public.bak_awsdms_validation_failures_v1 TO yann;
GRANT SELECT ON TABLE public.bak_awsdms_validation_failures_v1 TO readonly;
GRANT ALL ON TABLE public.bak_awsdms_validation_failures_v1 TO tableauuser;
GRANT ALL ON TABLE public.bak_awsdms_validation_failures_v1 TO bartender;
GRANT ALL ON TABLE public.bak_awsdms_validation_failures_v1 TO bytedevs;


--
-- Name: TABLE byte_epcssold; Type: ACL; Schema: public; Owner: erpuser
--

GRANT ALL ON TABLE public.byte_epcssold TO tableauuser;
GRANT ALL ON TABLE public.byte_epcssold TO bartender;
GRANT ALL ON TABLE public.byte_epcssold TO bytedevs;


--
-- Name: TABLE byte_feedback_weekly; Type: ACL; Schema: public; Owner: erpuser
--

GRANT ALL ON TABLE public.byte_feedback_weekly TO tableauuser;
GRANT ALL ON TABLE public.byte_feedback_weekly TO bartender;
GRANT ALL ON TABLE public.byte_feedback_weekly TO bytedevs;


--
-- Name: TABLE byte_kiosks; Type: ACL; Schema: public; Owner: erpuser
--

GRANT ALL ON TABLE public.byte_kiosks TO tableauuser;
GRANT ALL ON TABLE public.byte_kiosks TO bartender;
GRANT ALL ON TABLE public.byte_kiosks TO bytedevs;


--
-- Name: TABLE inventory_history; Type: ACL; Schema: public; Owner: erpuser
--

GRANT ALL ON TABLE public.inventory_history TO tableauuser;
GRANT ALL ON TABLE public.inventory_history TO bartender;
GRANT ALL ON TABLE public.inventory_history TO bytedevs;


--
-- Name: TABLE byte_inventory_history; Type: ACL; Schema: public; Owner: erpuser
--

GRANT ALL ON TABLE public.byte_inventory_history TO tableauuser;
GRANT ALL ON TABLE public.byte_inventory_history TO bartender;
GRANT ALL ON TABLE public.byte_inventory_history TO bytedevs;


--
-- Name: TABLE byte_inventory_history_eod; Type: ACL; Schema: public; Owner: erpuser
--

GRANT ALL ON TABLE public.byte_inventory_history_eod TO tableauuser;
GRANT ALL ON TABLE public.byte_inventory_history_eod TO bartender;
GRANT ALL ON TABLE public.byte_inventory_history_eod TO bytedevs;


--
-- Name: TABLE byte_inventory_history_eod_2wks; Type: ACL; Schema: public; Owner: erpuser
--

GRANT ALL ON TABLE public.byte_inventory_history_eod_2wks TO tableauuser;
GRANT ALL ON TABLE public.byte_inventory_history_eod_2wks TO bartender;
GRANT ALL ON TABLE public.byte_inventory_history_eod_2wks TO bytedevs;


--
-- Name: TABLE bytecodelog; Type: ACL; Schema: public; Owner: erpuser
--

GRANT SELECT ON TABLE public.bytecodelog TO yann;
GRANT SELECT ON TABLE public.bytecodelog TO readonly;
GRANT ALL ON TABLE public.bytecodelog TO tableauuser;
GRANT ALL ON TABLE public.bytecodelog TO bartender;
GRANT ALL ON TABLE public.bytecodelog TO bytedevs;


--
-- Name: TABLE history_order_pipeline; Type: ACL; Schema: public; Owner: erpuser
--

GRANT SELECT ON TABLE public.history_order_pipeline TO yann;
GRANT SELECT ON TABLE public.history_order_pipeline TO readonly;
GRANT ALL ON TABLE public.history_order_pipeline TO tableauuser;
GRANT ALL ON TABLE public.history_order_pipeline TO bartender;
GRANT ALL ON TABLE public.history_order_pipeline TO bytedevs;


--
-- Name: SEQUENCE history_order_pipeline_id_seq; Type: ACL; Schema: public; Owner: erpuser
--

GRANT ALL ON SEQUENCE public.history_order_pipeline_id_seq TO tableauuser;
GRANT ALL ON SEQUENCE public.history_order_pipeline_id_seq TO bartender;
GRANT ALL ON SEQUENCE public.history_order_pipeline_id_seq TO bytedevs;


--
-- Name: TABLE kiosk_status; Type: ACL; Schema: public; Owner: erpuser
--

GRANT ALL ON TABLE public.kiosk_status TO tableauuser;
GRANT ALL ON TABLE public.kiosk_status TO bartender;
GRANT ALL ON TABLE public.kiosk_status TO bytedevs;


--
-- Name: TABLE product_fact; Type: ACL; Schema: public; Owner: erpuser
--

GRANT SELECT ON TABLE public.product_fact TO yann;
GRANT SELECT ON TABLE public.product_fact TO readonly;
GRANT ALL ON TABLE public.product_fact TO tableauuser;
GRANT ALL ON TABLE public.product_fact TO bartender;
GRANT ALL ON TABLE public.product_fact TO bytedevs;


--
-- Name: SEQUENCE product_fact_id_seq; Type: ACL; Schema: public; Owner: erpuser
--

GRANT ALL ON SEQUENCE public.product_fact_id_seq TO tableauuser;
GRANT ALL ON SEQUENCE public.product_fact_id_seq TO bartender;
GRANT ALL ON SEQUENCE public.product_fact_id_seq TO bytedevs;


--
-- Name: TABLE fact_daily_campus_87; Type: ACL; Schema: test; Owner: erpuser
--

GRANT ALL ON TABLE test.fact_daily_campus_87 TO lambdazen;
GRANT ALL ON TABLE test.fact_daily_campus_87 TO bartender;
GRANT ALL ON TABLE test.fact_daily_campus_87 TO bytedevs;


--
-- Name: TABLE fact_daily_kiosk_sku_summary; Type: ACL; Schema: test; Owner: erpuser
--

GRANT ALL ON TABLE test.fact_daily_kiosk_sku_summary TO lambdazen;
GRANT ALL ON TABLE test.fact_daily_kiosk_sku_summary TO bytedevs;
GRANT ALL ON TABLE test.fact_daily_kiosk_sku_summary TO bartender;


--
-- Name: TABLE fact_monthly_kiosk_summary; Type: ACL; Schema: test; Owner: erpuser
--

GRANT ALL ON TABLE test.fact_monthly_kiosk_summary TO lambdazen;
GRANT ALL ON TABLE test.fact_monthly_kiosk_summary TO bytedevs;
GRANT ALL ON TABLE test.fact_monthly_kiosk_summary TO bartender;


--
-- Name: TABLE kiosk_20190528; Type: ACL; Schema: test; Owner: erpuser
--

GRANT ALL ON TABLE test.kiosk_20190528 TO lambdazen;
GRANT ALL ON TABLE test.kiosk_20190528 TO bartender;
GRANT ALL ON TABLE test.kiosk_20190528 TO bytedevs;


--
-- Name: TABLE kiosk_log; Type: ACL; Schema: test; Owner: erpuser
--

GRANT ALL ON TABLE test.kiosk_log TO lambdazen;
GRANT ALL ON TABLE test.kiosk_log TO bartender;
GRANT ALL ON TABLE test.kiosk_log TO bytedevs;


--
-- Name: TABLE pick_priority_kiosk; Type: ACL; Schema: test; Owner: erpuser
--

GRANT ALL ON TABLE test.pick_priority_kiosk TO lambdazen;
GRANT ALL ON TABLE test.pick_priority_kiosk TO bartender;
GRANT ALL ON TABLE test.pick_priority_kiosk TO bytedevs;


--
-- Name: TABLE remittance_history; Type: ACL; Schema: test; Owner: erpuser
--

GRANT ALL ON TABLE test.remittance_history TO lambdazen;
GRANT ALL ON TABLE test.remittance_history TO bytedevs;
GRANT ALL ON TABLE test.remittance_history TO bartender;


--
-- Name: TABLE sync_qa_kiosk_before_2way; Type: ACL; Schema: test; Owner: erpuser
--

GRANT ALL ON TABLE test.sync_qa_kiosk_before_2way TO lambdazen;
GRANT ALL ON TABLE test.sync_qa_kiosk_before_2way TO bartender;
GRANT ALL ON TABLE test.sync_qa_kiosk_before_2way TO bytedevs;


--
-- Name: TABLE sync_qa_kiosk_erp; Type: ACL; Schema: test; Owner: erpuser
--

GRANT ALL ON TABLE test.sync_qa_kiosk_erp TO lambdazen;
GRANT ALL ON TABLE test.sync_qa_kiosk_erp TO bartender;
GRANT ALL ON TABLE test.sync_qa_kiosk_erp TO bytedevs;


--
-- Name: TABLE sync_qa_kiosk_iotmaster; Type: ACL; Schema: test; Owner: erpuser
--

GRANT ALL ON TABLE test.sync_qa_kiosk_iotmaster TO lambdazen;
GRANT ALL ON TABLE test.sync_qa_kiosk_iotmaster TO bartender;
GRANT ALL ON TABLE test.sync_qa_kiosk_iotmaster TO bytedevs;


--
-- Name: DEFAULT PRIVILEGES FOR TABLES; Type: DEFAULT ACL; Schema: campus_87; Owner: erpuser
--

ALTER DEFAULT PRIVILEGES FOR ROLE erpuser IN SCHEMA campus_87 REVOKE ALL ON TABLES  FROM erpuser;
ALTER DEFAULT PRIVILEGES FOR ROLE erpuser IN SCHEMA campus_87 GRANT SELECT ON TABLES  TO rc87;


--
-- Name: DEFAULT PRIVILEGES FOR FUNCTIONS; Type: DEFAULT ACL; Schema: dw; Owner: erpuser
--

ALTER DEFAULT PRIVILEGES FOR ROLE erpuser IN SCHEMA dw REVOKE ALL ON FUNCTIONS  FROM PUBLIC;
ALTER DEFAULT PRIVILEGES FOR ROLE erpuser IN SCHEMA dw REVOKE ALL ON FUNCTIONS  FROM erpuser;
ALTER DEFAULT PRIVILEGES FOR ROLE erpuser IN SCHEMA dw GRANT ALL ON FUNCTIONS  TO lambdazen;
ALTER DEFAULT PRIVILEGES FOR ROLE erpuser IN SCHEMA dw GRANT ALL ON FUNCTIONS  TO yann;
ALTER DEFAULT PRIVILEGES FOR ROLE erpuser IN SCHEMA dw GRANT ALL ON FUNCTIONS  TO bytedevs;
ALTER DEFAULT PRIVILEGES FOR ROLE erpuser IN SCHEMA dw GRANT ALL ON FUNCTIONS  TO tableauuser;


--
-- Name: DEFAULT PRIVILEGES FOR FUNCTIONS; Type: DEFAULT ACL; Schema: dw; Owner: muriel
--

ALTER DEFAULT PRIVILEGES FOR ROLE muriel IN SCHEMA dw REVOKE ALL ON FUNCTIONS  FROM PUBLIC;
ALTER DEFAULT PRIVILEGES FOR ROLE muriel IN SCHEMA dw REVOKE ALL ON FUNCTIONS  FROM muriel;
ALTER DEFAULT PRIVILEGES FOR ROLE muriel IN SCHEMA dw GRANT ALL ON FUNCTIONS  TO yann;


--
-- Name: DEFAULT PRIVILEGES FOR TABLES; Type: DEFAULT ACL; Schema: dw; Owner: erpuser
--

ALTER DEFAULT PRIVILEGES FOR ROLE erpuser IN SCHEMA dw REVOKE ALL ON TABLES  FROM erpuser;
ALTER DEFAULT PRIVILEGES FOR ROLE erpuser IN SCHEMA dw GRANT ALL ON TABLES  TO lambdazen;
ALTER DEFAULT PRIVILEGES FOR ROLE erpuser IN SCHEMA dw GRANT ALL ON TABLES  TO yann;
ALTER DEFAULT PRIVILEGES FOR ROLE erpuser IN SCHEMA dw GRANT ALL ON TABLES  TO bytedevs;
ALTER DEFAULT PRIVILEGES FOR ROLE erpuser IN SCHEMA dw GRANT ALL ON TABLES  TO tableauuser;


--
-- Name: DEFAULT PRIVILEGES FOR TABLES; Type: DEFAULT ACL; Schema: dw; Owner: muriel
--

ALTER DEFAULT PRIVILEGES FOR ROLE muriel IN SCHEMA dw REVOKE ALL ON TABLES  FROM muriel;
ALTER DEFAULT PRIVILEGES FOR ROLE muriel IN SCHEMA dw GRANT ALL ON TABLES  TO yann;


--
-- Name: DEFAULT PRIVILEGES FOR FUNCTIONS; Type: DEFAULT ACL; Schema: erp; Owner: erpuser
--

ALTER DEFAULT PRIVILEGES FOR ROLE erpuser IN SCHEMA erp REVOKE ALL ON FUNCTIONS  FROM PUBLIC;
ALTER DEFAULT PRIVILEGES FOR ROLE erpuser IN SCHEMA erp REVOKE ALL ON FUNCTIONS  FROM erpuser;
ALTER DEFAULT PRIVILEGES FOR ROLE erpuser IN SCHEMA erp GRANT ALL ON FUNCTIONS  TO muriel;
ALTER DEFAULT PRIVILEGES FOR ROLE erpuser IN SCHEMA erp GRANT ALL ON FUNCTIONS  TO yann;


--
-- Name: DEFAULT PRIVILEGES FOR FUNCTIONS; Type: DEFAULT ACL; Schema: erp; Owner: muriel
--

ALTER DEFAULT PRIVILEGES FOR ROLE muriel IN SCHEMA erp REVOKE ALL ON FUNCTIONS  FROM PUBLIC;
ALTER DEFAULT PRIVILEGES FOR ROLE muriel IN SCHEMA erp REVOKE ALL ON FUNCTIONS  FROM muriel;
ALTER DEFAULT PRIVILEGES FOR ROLE muriel IN SCHEMA erp GRANT ALL ON FUNCTIONS  TO yann;


--
-- Name: DEFAULT PRIVILEGES FOR TABLES; Type: DEFAULT ACL; Schema: erp; Owner: erpuser
--

ALTER DEFAULT PRIVILEGES FOR ROLE erpuser IN SCHEMA erp REVOKE ALL ON TABLES  FROM erpuser;
ALTER DEFAULT PRIVILEGES FOR ROLE erpuser IN SCHEMA erp GRANT ALL ON TABLES  TO muriel;
ALTER DEFAULT PRIVILEGES FOR ROLE erpuser IN SCHEMA erp GRANT ALL ON TABLES  TO yann;


--
-- Name: DEFAULT PRIVILEGES FOR TABLES; Type: DEFAULT ACL; Schema: erp; Owner: muriel
--

ALTER DEFAULT PRIVILEGES FOR ROLE muriel IN SCHEMA erp REVOKE ALL ON TABLES  FROM muriel;
ALTER DEFAULT PRIVILEGES FOR ROLE muriel IN SCHEMA erp GRANT ALL ON TABLES  TO yann;


--
-- Name: DEFAULT PRIVILEGES FOR FUNCTIONS; Type: DEFAULT ACL; Schema: inm; Owner: erpuser
--

ALTER DEFAULT PRIVILEGES FOR ROLE erpuser IN SCHEMA inm REVOKE ALL ON FUNCTIONS  FROM PUBLIC;
ALTER DEFAULT PRIVILEGES FOR ROLE erpuser IN SCHEMA inm REVOKE ALL ON FUNCTIONS  FROM erpuser;
ALTER DEFAULT PRIVILEGES FOR ROLE erpuser IN SCHEMA inm GRANT ALL ON FUNCTIONS  TO lambdazen;
ALTER DEFAULT PRIVILEGES FOR ROLE erpuser IN SCHEMA inm GRANT ALL ON FUNCTIONS  TO muriel;
ALTER DEFAULT PRIVILEGES FOR ROLE erpuser IN SCHEMA inm GRANT ALL ON FUNCTIONS  TO yann;
ALTER DEFAULT PRIVILEGES FOR ROLE erpuser IN SCHEMA inm GRANT ALL ON FUNCTIONS  TO bytedevs;
ALTER DEFAULT PRIVILEGES FOR ROLE erpuser IN SCHEMA inm GRANT ALL ON FUNCTIONS  TO tableauuser;
ALTER DEFAULT PRIVILEGES FOR ROLE erpuser IN SCHEMA inm GRANT ALL ON FUNCTIONS  TO bartender;


--
-- Name: DEFAULT PRIVILEGES FOR FUNCTIONS; Type: DEFAULT ACL; Schema: inm; Owner: lambdazen
--

ALTER DEFAULT PRIVILEGES FOR ROLE lambdazen IN SCHEMA inm REVOKE ALL ON FUNCTIONS  FROM PUBLIC;
ALTER DEFAULT PRIVILEGES FOR ROLE lambdazen IN SCHEMA inm REVOKE ALL ON FUNCTIONS  FROM lambdazen;
ALTER DEFAULT PRIVILEGES FOR ROLE lambdazen IN SCHEMA inm GRANT ALL ON FUNCTIONS  TO muriel;


--
-- Name: DEFAULT PRIVILEGES FOR TABLES; Type: DEFAULT ACL; Schema: inm; Owner: erpuser
--

ALTER DEFAULT PRIVILEGES FOR ROLE erpuser IN SCHEMA inm REVOKE ALL ON TABLES  FROM erpuser;
ALTER DEFAULT PRIVILEGES FOR ROLE erpuser IN SCHEMA inm GRANT ALL ON TABLES  TO lambdazen;
ALTER DEFAULT PRIVILEGES FOR ROLE erpuser IN SCHEMA inm GRANT ALL ON TABLES  TO muriel;
ALTER DEFAULT PRIVILEGES FOR ROLE erpuser IN SCHEMA inm GRANT ALL ON TABLES  TO yann;
ALTER DEFAULT PRIVILEGES FOR ROLE erpuser IN SCHEMA inm GRANT ALL ON TABLES  TO bytedevs;
ALTER DEFAULT PRIVILEGES FOR ROLE erpuser IN SCHEMA inm GRANT ALL ON TABLES  TO tableauuser;
ALTER DEFAULT PRIVILEGES FOR ROLE erpuser IN SCHEMA inm GRANT ALL ON TABLES  TO bartender;


--
-- Name: DEFAULT PRIVILEGES FOR TABLES; Type: DEFAULT ACL; Schema: inm; Owner: lambdazen
--

ALTER DEFAULT PRIVILEGES FOR ROLE lambdazen IN SCHEMA inm REVOKE ALL ON TABLES  FROM lambdazen;
ALTER DEFAULT PRIVILEGES FOR ROLE lambdazen IN SCHEMA inm GRANT ALL ON TABLES  TO muriel;


--
-- Name: DEFAULT PRIVILEGES FOR FUNCTIONS; Type: DEFAULT ACL; Schema: mixalot; Owner: erpuser
--

ALTER DEFAULT PRIVILEGES FOR ROLE erpuser IN SCHEMA mixalot REVOKE ALL ON FUNCTIONS  FROM PUBLIC;
ALTER DEFAULT PRIVILEGES FOR ROLE erpuser IN SCHEMA mixalot REVOKE ALL ON FUNCTIONS  FROM erpuser;
ALTER DEFAULT PRIVILEGES FOR ROLE erpuser IN SCHEMA mixalot GRANT ALL ON FUNCTIONS  TO lambdazen;
ALTER DEFAULT PRIVILEGES FOR ROLE erpuser IN SCHEMA mixalot GRANT ALL ON FUNCTIONS  TO bytedevs;
ALTER DEFAULT PRIVILEGES FOR ROLE erpuser IN SCHEMA mixalot GRANT ALL ON FUNCTIONS  TO tableauuser;
ALTER DEFAULT PRIVILEGES FOR ROLE erpuser IN SCHEMA mixalot GRANT ALL ON FUNCTIONS  TO bartender;


--
-- Name: DEFAULT PRIVILEGES FOR TABLES; Type: DEFAULT ACL; Schema: mixalot; Owner: erpuser
--

ALTER DEFAULT PRIVILEGES FOR ROLE erpuser IN SCHEMA mixalot REVOKE ALL ON TABLES  FROM erpuser;
ALTER DEFAULT PRIVILEGES FOR ROLE erpuser IN SCHEMA mixalot GRANT ALL ON TABLES  TO lambdazen;
ALTER DEFAULT PRIVILEGES FOR ROLE erpuser IN SCHEMA mixalot GRANT ALL ON TABLES  TO bytedevs;
ALTER DEFAULT PRIVILEGES FOR ROLE erpuser IN SCHEMA mixalot GRANT ALL ON TABLES  TO tableauuser;
ALTER DEFAULT PRIVILEGES FOR ROLE erpuser IN SCHEMA mixalot GRANT ALL ON TABLES  TO bartender;


--
-- Name: DEFAULT PRIVILEGES FOR FUNCTIONS; Type: DEFAULT ACL; Schema: pantry; Owner: erpuser
--

ALTER DEFAULT PRIVILEGES FOR ROLE erpuser IN SCHEMA pantry REVOKE ALL ON FUNCTIONS  FROM PUBLIC;
ALTER DEFAULT PRIVILEGES FOR ROLE erpuser IN SCHEMA pantry REVOKE ALL ON FUNCTIONS  FROM erpuser;
ALTER DEFAULT PRIVILEGES FOR ROLE erpuser IN SCHEMA pantry GRANT ALL ON FUNCTIONS  TO lambdazen;
ALTER DEFAULT PRIVILEGES FOR ROLE erpuser IN SCHEMA pantry GRANT ALL ON FUNCTIONS  TO muriel;
ALTER DEFAULT PRIVILEGES FOR ROLE erpuser IN SCHEMA pantry GRANT ALL ON FUNCTIONS  TO yann;
ALTER DEFAULT PRIVILEGES FOR ROLE erpuser IN SCHEMA pantry GRANT ALL ON FUNCTIONS  TO bytedevs;
ALTER DEFAULT PRIVILEGES FOR ROLE erpuser IN SCHEMA pantry GRANT ALL ON FUNCTIONS  TO tableauuser;
ALTER DEFAULT PRIVILEGES FOR ROLE erpuser IN SCHEMA pantry GRANT ALL ON FUNCTIONS  TO bartender;


--
-- Name: DEFAULT PRIVILEGES FOR TABLES; Type: DEFAULT ACL; Schema: pantry; Owner: erpuser
--

ALTER DEFAULT PRIVILEGES FOR ROLE erpuser IN SCHEMA pantry REVOKE ALL ON TABLES  FROM erpuser;
ALTER DEFAULT PRIVILEGES FOR ROLE erpuser IN SCHEMA pantry GRANT ALL ON TABLES  TO lambdazen;
ALTER DEFAULT PRIVILEGES FOR ROLE erpuser IN SCHEMA pantry GRANT ALL ON TABLES  TO muriel;
ALTER DEFAULT PRIVILEGES FOR ROLE erpuser IN SCHEMA pantry GRANT ALL ON TABLES  TO yann;
ALTER DEFAULT PRIVILEGES FOR ROLE erpuser IN SCHEMA pantry GRANT ALL ON TABLES  TO bytedevs;
ALTER DEFAULT PRIVILEGES FOR ROLE erpuser IN SCHEMA pantry GRANT ALL ON TABLES  TO tableauuser;
ALTER DEFAULT PRIVILEGES FOR ROLE erpuser IN SCHEMA pantry GRANT ALL ON TABLES  TO bartender;


--
-- Name: DEFAULT PRIVILEGES FOR FUNCTIONS; Type: DEFAULT ACL; Schema: public; Owner: erpuser
--

ALTER DEFAULT PRIVILEGES FOR ROLE erpuser IN SCHEMA public REVOKE ALL ON FUNCTIONS  FROM PUBLIC;
ALTER DEFAULT PRIVILEGES FOR ROLE erpuser IN SCHEMA public REVOKE ALL ON FUNCTIONS  FROM erpuser;
ALTER DEFAULT PRIVILEGES FOR ROLE erpuser IN SCHEMA public GRANT ALL ON FUNCTIONS  TO bytedevs;
ALTER DEFAULT PRIVILEGES FOR ROLE erpuser IN SCHEMA public GRANT ALL ON FUNCTIONS  TO tableauuser;
ALTER DEFAULT PRIVILEGES FOR ROLE erpuser IN SCHEMA public GRANT ALL ON FUNCTIONS  TO bartender;


--
-- Name: DEFAULT PRIVILEGES FOR TABLES; Type: DEFAULT ACL; Schema: public; Owner: erpuser
--

ALTER DEFAULT PRIVILEGES FOR ROLE erpuser IN SCHEMA public REVOKE ALL ON TABLES  FROM erpuser;
ALTER DEFAULT PRIVILEGES FOR ROLE erpuser IN SCHEMA public GRANT ALL ON TABLES  TO bytedevs;
ALTER DEFAULT PRIVILEGES FOR ROLE erpuser IN SCHEMA public GRANT ALL ON TABLES  TO tableauuser;
ALTER DEFAULT PRIVILEGES FOR ROLE erpuser IN SCHEMA public GRANT ALL ON TABLES  TO bartender;


--
-- Name: DEFAULT PRIVILEGES FOR FUNCTIONS; Type: DEFAULT ACL; Schema: test; Owner: erpuser
--

ALTER DEFAULT PRIVILEGES FOR ROLE erpuser IN SCHEMA test REVOKE ALL ON FUNCTIONS  FROM PUBLIC;
ALTER DEFAULT PRIVILEGES FOR ROLE erpuser IN SCHEMA test REVOKE ALL ON FUNCTIONS  FROM erpuser;
ALTER DEFAULT PRIVILEGES FOR ROLE erpuser IN SCHEMA test GRANT ALL ON FUNCTIONS  TO bytedevs;
ALTER DEFAULT PRIVILEGES FOR ROLE erpuser IN SCHEMA test GRANT ALL ON FUNCTIONS  TO bartender;


--
-- Name: DEFAULT PRIVILEGES FOR TABLES; Type: DEFAULT ACL; Schema: test; Owner: erpuser
--

ALTER DEFAULT PRIVILEGES FOR ROLE erpuser IN SCHEMA test REVOKE ALL ON TABLES  FROM erpuser;
ALTER DEFAULT PRIVILEGES FOR ROLE erpuser IN SCHEMA test GRANT ALL ON TABLES  TO lambdazen;
ALTER DEFAULT PRIVILEGES FOR ROLE erpuser IN SCHEMA test GRANT ALL ON TABLES  TO bytedevs;
ALTER DEFAULT PRIVILEGES FOR ROLE erpuser IN SCHEMA test GRANT ALL ON TABLES  TO bartender;


--
-- Name: DEFAULT PRIVILEGES FOR FUNCTIONS; Type: DEFAULT ACL; Schema: type; Owner: erpuser
--

ALTER DEFAULT PRIVILEGES FOR ROLE erpuser IN SCHEMA type REVOKE ALL ON FUNCTIONS  FROM PUBLIC;
ALTER DEFAULT PRIVILEGES FOR ROLE erpuser IN SCHEMA type REVOKE ALL ON FUNCTIONS  FROM erpuser;
ALTER DEFAULT PRIVILEGES FOR ROLE erpuser IN SCHEMA type GRANT ALL ON FUNCTIONS  TO bytedevs;
ALTER DEFAULT PRIVILEGES FOR ROLE erpuser IN SCHEMA type GRANT ALL ON FUNCTIONS  TO bartender;


--
-- Name: DEFAULT PRIVILEGES FOR TABLES; Type: DEFAULT ACL; Schema: type; Owner: erpuser
--

ALTER DEFAULT PRIVILEGES FOR ROLE erpuser IN SCHEMA type REVOKE ALL ON TABLES  FROM erpuser;
ALTER DEFAULT PRIVILEGES FOR ROLE erpuser IN SCHEMA type GRANT ALL ON TABLES  TO muriel;
ALTER DEFAULT PRIVILEGES FOR ROLE erpuser IN SCHEMA type GRANT ALL ON TABLES  TO bytedevs;
ALTER DEFAULT PRIVILEGES FOR ROLE erpuser IN SCHEMA type GRANT ALL ON TABLES  TO bartender;


--
-- Name: awsdms_intercept_ddl; Type: EVENT TRIGGER; Schema: -; Owner: rdsadmin
--

CREATE EVENT TRIGGER awsdms_intercept_ddl ON ddl_command_end
   EXECUTE FUNCTION public.awsdms_intercept_ddl();


ALTER EVENT TRIGGER awsdms_intercept_ddl OWNER TO rdsadmin;

--
-- PostgreSQL database dump complete
--

Done with file for ERP Read $d number of lines
%!(EXTRA int=11842)Done with file Read
 11842  number of lines
IOT ERP
report; is missing from ERP->CREATE SCHEMA<-
beta; is missing from ERP->CREATE SCHEMA<-
inm_beta; is missing from ERP->CREATE SCHEMA<-
dms7; is missing from ERP->CREATE SCHEMA<-
iplanner; is missing from ERP->CREATE SCHEMA<-
monitor; is missing from ERP->CREATE SCHEMA<-
rptg; is missing from ERP->CREATE SCHEMA<-
develop; is missing from ERP->CREATE SCHEMA<-
inm_backup; is missing from ERP->CREATE SCHEMA<-
byt_devops; is missing from ERP->CREATE SCHEMA<-
byte_pgdu; is missing from ERP->CREATE SCHEMA<-
	CREATE SCHEMA : 19
inm_backup is missing from ERP->ALTER SCHEMA<-
inm_beta is missing from ERP->ALTER SCHEMA<-
rptg is missing from ERP->ALTER SCHEMA<-
iplanner is missing from ERP->ALTER SCHEMA<-
report is missing from ERP->ALTER SCHEMA<-
beta is missing from ERP->ALTER SCHEMA<-
dms7 is missing from ERP->ALTER SCHEMA<-
monitor is missing from ERP->ALTER SCHEMA<-
byt_devops is missing from ERP->ALTER SCHEMA<-
byte_pgdu is missing from ERP->ALTER SCHEMA<-
develop is missing from ERP->ALTER SCHEMA<-
	ALTER SCHEMA : 19
IOT->ERP
	missing v1: 0
	missing v2: 22
	Totaling : 38


campus_87 is missing from IOT->ALTER SCHEMA<-
dw is missing from IOT->ALTER SCHEMA<-
erp is missing from IOT->ALTER SCHEMA<-
migration is missing from IOT->ALTER SCHEMA<-
type is missing from IOT->ALTER SCHEMA<-
erp_backup is missing from IOT->ALTER SCHEMA<-
erp_test is missing from IOT->ALTER SCHEMA<-
inm_restore_0625 is missing from IOT->ALTER SCHEMA<-
	ALTER SCHEMA : 16
campus_87; is missing from IOT->CREATE SCHEMA<-
inm_restore_0625; is missing from IOT->CREATE SCHEMA<-
migration; is missing from IOT->CREATE SCHEMA<-
type; is missing from IOT->CREATE SCHEMA<-
erp; is missing from IOT->CREATE SCHEMA<-
erp_backup; is missing from IOT->CREATE SCHEMA<-
erp_test; is missing from IOT->CREATE SCHEMA<-
dw; is missing from IOT->CREATE SCHEMA<-
	CREATE SCHEMA : 16
ERP->IOT
	missing v1: 0
	missing v2: 16
	Totaling : 32

Writing file: Schema-IOT-To-ERP.sql
wrote 704 bytes
Writing file: Schema-ERP-To-IOT.sql
wrote 505 bytes
IOT ERP
rptg.temp_yann_boardq3 is missing from ERP->CREATE TABLE<-
inm_test.kiosk_20190508 is missing from ERP->CREATE TABLE<-
inm_test.product_20190508 is missing from ERP->CREATE TABLE<-
mixalot.merchandising_slot is missing from ERP->CREATE TABLE<-
pantry.history_kiosk_service_version is missing from ERP->CREATE TABLE<-
pantry.restock_item is missing from ERP->CREATE TABLE<-
public.awsdms_heartbeat is missing from ERP->CREATE TABLE<-
develop.unused_user_mapping is missing from ERP->CREATE TABLE<-
fnrenames.temp_sync_order_2018_12_13 is missing from ERP->CREATE TABLE<-
inm_backup.pick_route is missing from ERP->CREATE TABLE<-
test.kiosk_20190605 is missing from ERP->CREATE TABLE<-
pantry.dc_inventory is missing from ERP->CREATE TABLE<-
inm_test.plan_kiosks is missing from ERP->CREATE TABLE<-
mixalot.discount_rule is missing from ERP->CREATE TABLE<-
mixalot.kiosk_restriction is missing from ERP->CREATE TABLE<-
aws_dms.awsdms_status is missing from ERP->CREATE TABLE<-
fnrenames.overstock_multiplier is missing from ERP->CREATE TABLE<-
inm_beta.pick_preference_kiosk_sku is missing from ERP->CREATE TABLE<-
inm_beta.pick_allocation is missing from ERP->CREATE TABLE<-
inm_test.broken_product is missing from ERP->CREATE TABLE<-
inm_test.kiosk_20190531_test_update is missing from ERP->CREATE TABLE<-
inm_test.kiosk_20190810 is missing from ERP->CREATE TABLE<-
public.mkt_camp_20170123_whats_new_in_kiosk is missing from ERP->CREATE TABLE<-
inm_backup.pick_preference_kiosk_sku_20190120 is missing from ERP->CREATE TABLE<-
pantry.event is missing from ERP->CREATE TABLE<-
public.byte_kp_grid2 is missing from ERP->CREATE TABLE<-
beta.temp_sync_label_2018_12_13 is missing from ERP->CREATE TABLE<-
inm.sku_group is missing from ERP->CREATE TABLE<-
pantry.current_label_status_365days is missing from ERP->CREATE TABLE<-
pantry.permission_mapping is missing from ERP->CREATE TABLE<-
test.kiosk_20190612 is missing from ERP->CREATE TABLE<-
beta.kiosks is missing from ERP->CREATE TABLE<-
inm_backup.sku_velocity_20190120 is missing from ERP->CREATE TABLE<-
pantry.tmp_eng_495_cards_to_update is missing from ERP->CREATE TABLE<-
public.tmp_dormant2 is missing from ERP->CREATE TABLE<-
test.locked_kiosk_by_command is missing from ERP->CREATE TABLE<-
test.request_log_sold_epc is missing from ERP->CREATE TABLE<-
develop.last_kiosk_status is missing from ERP->CREATE TABLE<-
pantry.history_kiosk_attribute is missing from ERP->CREATE TABLE<-
pantry.tmp_order_may_6_preapr23 is missing from ERP->CREATE TABLE<-
public.byte_kp_grid is missing from ERP->CREATE TABLE<-
public.kiosk is missing from ERP->CREATE TABLE<-
inm_backup.pick_allocation is missing from ERP->CREATE TABLE<-
mixalot.temp_sku_group_volume is missing from ERP->CREATE TABLE<-
pantry.history_kiosk_device is missing from ERP->CREATE TABLE<-
pantry.running_service is missing from ERP->CREATE TABLE<-
public.awsdms_apply_exceptions is missing from ERP->CREATE TABLE<-
aws_dms.awsdms_history is missing from ERP->CREATE TABLE<-
develop.card is missing from ERP->CREATE TABLE<-
inm.temp_pick_order is missing from ERP->CREATE TABLE<-
inm_backup.kiosk_control is missing from ERP->CREATE TABLE<-
inm_test.inm_kiosk_hourly_sale is missing from ERP->CREATE TABLE<-
test.accounting_bkup_20200204_partial is missing from ERP->CREATE TABLE<-
beta.route_stop is missing from ERP->CREATE TABLE<-
develop.coupon is missing from ERP->CREATE TABLE<-
test.kiosk_20200304 is missing from ERP->CREATE TABLE<-
mixalot.temp_sku_to_skugroup is missing from ERP->CREATE TABLE<-
pantry.tmp_april23_error_order_fixes is missing from ERP->CREATE TABLE<-
pantry.tmp_revert_order_status is missing from ERP->CREATE TABLE<-
beta.kiosk_sku_group_manual_scale is missing from ERP->CREATE TABLE<-
develop.fee_rates is missing from ERP->CREATE TABLE<-
mixalot.sku_def is missing from ERP->CREATE TABLE<-
pantry.spoilage is missing from ERP->CREATE TABLE<-
test.lost_wall_clock_orders is missing from ERP->CREATE TABLE<-
beta.temp_product is missing from ERP->CREATE TABLE<-
develop.accounting is missing from ERP->CREATE TABLE<-
inm_beta.sku_group_control is missing from ERP->CREATE TABLE<-
inm_test.kiosk_software is missing from ERP->CREATE TABLE<-
pantry.transact_comp is missing from ERP->CREATE TABLE<-
test.cron_broken is missing from ERP->CREATE TABLE<-
develop.permission is missing from ERP->CREATE TABLE<-
develop.transact_cs is missing from ERP->CREATE TABLE<-
inm_beta.product_property is missing from ERP->CREATE TABLE<-
develop.product_history is missing from ERP->CREATE TABLE<-
fnrenames.tmp_payment_information is missing from ERP->CREATE TABLE<-
mixalot.temp_test is missing from ERP->CREATE TABLE<-
develop.campus is missing from ERP->CREATE TABLE<-
develop.cron is missing from ERP->CREATE TABLE<-
develop.history_epc_order is missing from ERP->CREATE TABLE<-
public.awsdms_status is missing from ERP->CREATE TABLE<-
pantry.stockout is missing from ERP->CREATE TABLE<-
pantry.tmp_orderstoerror is missing from ERP->CREATE TABLE<-
pantry.tmp_price_finalized_order_ids is missing from ERP->CREATE TABLE<-
pantry.order_meta is missing from ERP->CREATE TABLE<-
pantry.tmp_may4_error_order_fixes is missing from ERP->CREATE TABLE<-
inm.sku_property_def is missing from ERP->CREATE TABLE<-
inm_backup.kiosk_product_disabled is missing from ERP->CREATE TABLE<-
test.request_log_order is missing from ERP->CREATE TABLE<-
public.byte_kp_sales_avgdowhour is missing from ERP->CREATE TABLE<-
public.campaigns is missing from ERP->CREATE TABLE<-
inm_beta.pick_priority_kiosk is missing from ERP->CREATE TABLE<-
pantry.tmp_payment_order is missing from ERP->CREATE TABLE<-
beta.temp_nutrition_filter is missing from ERP->CREATE TABLE<-
develop.kiosk_par_level is missing from ERP->CREATE TABLE<-
develop.role is missing from ERP->CREATE TABLE<-
beta.missing_hash is missing from ERP->CREATE TABLE<-
pantry.cron is missing from ERP->CREATE TABLE<-
mixalot.last_kiosk_status is missing from ERP->CREATE TABLE<-
public.awsdms_validation_failures_v1 is missing from ERP->CREATE TABLE<-
develop.sessions is missing from ERP->CREATE TABLE<-
inm_beta.kiosk_restriction_by_property is missing from ERP->CREATE TABLE<-
inm_beta.pick_substitution is missing from ERP->CREATE TABLE<-
inm_backup.pick_inventory is missing from ERP->CREATE TABLE<-
inm_beta.pick_priority_sku is missing from ERP->CREATE TABLE<-
pantry.tmp_march1_rollingback_auths is missing from ERP->CREATE TABLE<-
beta.temp_sku_group_attribute is missing from ERP->CREATE TABLE<-
develop.manual_adjustment is missing from ERP->CREATE TABLE<-
dms7.awsdms_suspended_tables is missing from ERP->CREATE TABLE<-
develop.refunds is missing from ERP->CREATE TABLE<-
inm.sku_def is missing from ERP->CREATE TABLE<-
pantry.temp_kiosk_backup is missing from ERP->CREATE TABLE<-
pantry.facing_category is missing from ERP->CREATE TABLE<-
inm_test.restricted is missing from ERP->CREATE TABLE<-
mixalot.product_kiosk_fact is missing from ERP->CREATE TABLE<-
test.campus_20190620 is missing from ERP->CREATE TABLE<-
beta.route is missing from ERP->CREATE TABLE<-
beta.temp_fc_default_level is missing from ERP->CREATE TABLE<-
develop."order" is missing from ERP->CREATE TABLE<-
test.discount_20190614 is missing from ERP->CREATE TABLE<-
test.kiosk_bkup_20200204 is missing from ERP->CREATE TABLE<-
pantry.global_attribute_def is missing from ERP->CREATE TABLE<-
pantry.tmp_watcher is missing from ERP->CREATE TABLE<-
public.kiosk_first_seen is missing from ERP->CREATE TABLE<-
test.accounting_partial_backup_20191101 is missing from ERP->CREATE TABLE<-
dms7.awsdms_apply_exceptions is missing from ERP->CREATE TABLE<-
mixalot.kiosk_restriction_by_sku is missing from ERP->CREATE TABLE<-
mixalot.pick is missing from ERP->CREATE TABLE<-
pantry.permission is missing from ERP->CREATE TABLE<-
pantry.product_kiosk_price_offset is missing from ERP->CREATE TABLE<-
monitor.cron_state is missing from ERP->CREATE TABLE<-
pantry.kiosk_attribute is missing from ERP->CREATE TABLE<-
develop."group" is missing from ERP->CREATE TABLE<-
develop.group_campus is missing from ERP->CREATE TABLE<-
inm_backup.sku_group_def is missing from ERP->CREATE TABLE<-
pantry.par_history is missing from ERP->CREATE TABLE<-
test.vantiv_20190801b is missing from ERP->CREATE TABLE<-
develop.ro_order is missing from ERP->CREATE TABLE<-
inm.bringg_delivery is missing from ERP->CREATE TABLE<-
public.track_dashboard is missing from ERP->CREATE TABLE<-
develop.contract is missing from ERP->CREATE TABLE<-
inm_beta.pick_inventory is missing from ERP->CREATE TABLE<-
inm_backup.kiosk_restriction_by_product is missing from ERP->CREATE TABLE<-
public.mkt_camp_20170111_sku_revival_sonoma is missing from ERP->CREATE TABLE<-
public.tmp_dormant is missing from ERP->CREATE TABLE<-
public.track_inventory is missing from ERP->CREATE TABLE<-
beta.temp_pick_preference_kiosk_sku is missing from ERP->CREATE TABLE<-
inm.kiosk_attribute is missing from ERP->CREATE TABLE<-
mixalot.tally is missing from ERP->CREATE TABLE<-
public.awsdms_history is missing from ERP->CREATE TABLE<-
develop.label_order is missing from ERP->CREATE TABLE<-
develop.tag is missing from ERP->CREATE TABLE<-
inm_backup.pick_substitution is missing from ERP->CREATE TABLE<-
inm_backup.ku_group_attribute is missing from ERP->CREATE TABLE<-
inm_beta.pick_route is missing from ERP->CREATE TABLE<-
inm_test.inm_kiosk_restock is missing from ERP->CREATE TABLE<-
inm_test.tag_2019_05_15 is missing from ERP->CREATE TABLE<-
beta.sku_group_attribute is missing from ERP->CREATE TABLE<-
beta.temp_sync_order_2018_12_13 is missing from ERP->CREATE TABLE<-
public.customers is missing from ERP->CREATE TABLE<-
test.kiosk_20190606 is missing from ERP->CREATE TABLE<-
test.order_complimentary_eng_2292 is missing from ERP->CREATE TABLE<-
develop.label is missing from ERP->CREATE TABLE<-
develop.par_history is missing from ERP->CREATE TABLE<-
dms7.awsdms_status is missing from ERP->CREATE TABLE<-
pantry.kiosk_device is missing from ERP->CREATE TABLE<-
public.awsdms_suspended_tables is missing from ERP->CREATE TABLE<-
inm.sku_property is missing from ERP->CREATE TABLE<-
inm_test.kiosk_par_level_bkup is missing from ERP->CREATE TABLE<-
inm_beta.kiosk_product_disabled is missing from ERP->CREATE TABLE<-
inm_test.backup_inm_data_09_16 is missing from ERP->CREATE TABLE<-
mixalot.temp_ms_to_sg is missing from ERP->CREATE TABLE<-
beta.card is missing from ERP->CREATE TABLE<-
beta.warehouse_inventory_history is missing from ERP->CREATE TABLE<-
test.transactions_pending_sync is missing from ERP->CREATE TABLE<-
develop.transact_ipc is missing from ERP->CREATE TABLE<-
inm_test.route_stop is missing from ERP->CREATE TABLE<-
mixalot.kiosk_restriction_by_property is missing from ERP->CREATE TABLE<-
mixalot.server is missing from ERP->CREATE TABLE<-
pantry.tmp_may4_pricefinalize_order_fixes is missing from ERP->CREATE TABLE<-
public.byte_kp_oos_grid is missing from ERP->CREATE TABLE<-
develop.role_mapping is missing from ERP->CREATE TABLE<-
pantry.currency_symbol is missing from ERP->CREATE TABLE<-
beta.sku_group_control is missing from ERP->CREATE TABLE<-
inm_test.kiosk_20190531 is missing from ERP->CREATE TABLE<-
inm.temp_velocity is missing from ERP->CREATE TABLE<-
pantry.tmp_process_order_vantiv is missing from ERP->CREATE TABLE<-
public.byte_kp_sales_grid is missing from ERP->CREATE TABLE<-
test.campus_20190605 is missing from ERP->CREATE TABLE<-
beta.pick_demand is missing from ERP->CREATE TABLE<-
develop.inventory_history is missing from ERP->CREATE TABLE<-
pantry.temp_product_backup is missing from ERP->CREATE TABLE<-
test.kiosk_20190918 is missing from ERP->CREATE TABLE<-
inm_beta.pick_list is missing from ERP->CREATE TABLE<-
mixalot.inm_gsheets_kiosk_restriction is missing from ERP->CREATE TABLE<-
pantry.campus_attribute is missing from ERP->CREATE TABLE<-
pantry.transact_fp is missing from ERP->CREATE TABLE<-
rptg.temp_yann_q1 is missing from ERP->CREATE TABLE<-
inm_backup.product_property is missing from ERP->CREATE TABLE<-
pantry.tmp_process_order_txt is missing from ERP->CREATE TABLE<-
test.accounting_partial_bkup_20200131 is missing from ERP->CREATE TABLE<-
test.kiosk_20190611 is missing from ERP->CREATE TABLE<-
test.kiosk_serial_20190916 is missing from ERP->CREATE TABLE<-
develop.transact_fp is missing from ERP->CREATE TABLE<-
inm_test.inm_kiosk_skugroup_sale is missing from ERP->CREATE TABLE<-
mixalot.tmp_unit is missing from ERP->CREATE TABLE<-
pantry.contract is missing from ERP->CREATE TABLE<-
beta.temp_test2 is missing from ERP->CREATE TABLE<-
develop.event is missing from ERP->CREATE TABLE<-
develop."user" is missing from ERP->CREATE TABLE<-
public."pantry.kiosk" is missing from ERP->CREATE TABLE<-
test.temp_pending is missing from ERP->CREATE TABLE<-
inm_backup.kiosk_sku_group_manual_scale is missing from ERP->CREATE TABLE<-
pantry.history_global_attribute_def is missing from ERP->CREATE TABLE<-
monitor.opt_connect is missing from ERP->CREATE TABLE<-
test.order_epc_pending_sync is missing from ERP->CREATE TABLE<-
beta.kiosk_projected_stock is missing from ERP->CREATE TABLE<-
dms7.awsdms_history is missing from ERP->CREATE TABLE<-
public.byte_kp_oos_avgdowhour is missing from ERP->CREATE TABLE<-
test.vantiv_20190801 is missing from ERP->CREATE TABLE<-
develop.product is missing from ERP->CREATE TABLE<-
inm_backup.kiosk_restriction_by_property is missing from ERP->CREATE TABLE<-
mixalot.merchandising_slot_def is missing from ERP->CREATE TABLE<-
mixalot.gsheets_kiosk_restriction is missing from ERP->CREATE TABLE<-
pantry.role_mapping is missing from ERP->CREATE TABLE<-
public.iplanner_inventory is missing from ERP->CREATE TABLE<-
beta.temp_test is missing from ERP->CREATE TABLE<-
develop.transact_comp is missing from ERP->CREATE TABLE<-
beta.test is missing from ERP->CREATE TABLE<-
inm_beta.kiosk_restriction_by_product is missing from ERP->CREATE TABLE<-
test.reauth_2019_07_priced_finalized_orders is missing from ERP->CREATE TABLE<-
mixalot.test_time is missing from ERP->CREATE TABLE<-
pantry.transact_express is missing from ERP->CREATE TABLE<-
develop.feedback is missing from ERP->CREATE TABLE<-
inm_beta.sku_group is missing from ERP->CREATE TABLE<-
test.request_log_epc_order is missing from ERP->CREATE TABLE<-
test.backup_eng_2669_order is missing from ERP->CREATE TABLE<-
test.kiosk is missing from ERP->CREATE TABLE<-
test.locked_kiosk_via_pw is missing from ERP->CREATE TABLE<-
pantry.tmp_payment_order_with_id is missing from ERP->CREATE TABLE<-
inm_test.inm_kiosk_weekly_sale is missing from ERP->CREATE TABLE<-
pantry.kiosk_service_version is missing from ERP->CREATE TABLE<-
pantry.product_stats_by_kiosk is missing from ERP->CREATE TABLE<-
pantry.tmp_order_transaction_id_map is missing from ERP->CREATE TABLE<-
public.byte_kp_oos is missing from ERP->CREATE TABLE<-
public.byte_kp_sales_first is missing from ERP->CREATE TABLE<-
test.eng2903 is missing from ERP->CREATE TABLE<-
mixalot.kiosk is missing from ERP->CREATE TABLE<-
inm_test.test_hours is missing from ERP->CREATE TABLE<-
mixalot.card_fact is missing from ERP->CREATE TABLE<-
mixalot.temp_kiosk_restriction is missing from ERP->CREATE TABLE<-
pantry.transact_ipc is missing from ERP->CREATE TABLE<-
public.int_kiosk_weekly_sale is missing from ERP->CREATE TABLE<-
develop.discount_history is missing from ERP->CREATE TABLE<-
inm_backup.sku_group_control is missing from ERP->CREATE TABLE<-
inm_test.kiosk_audit is missing from ERP->CREATE TABLE<-
test.kiosk_payment_start is missing from ERP->CREATE TABLE<-
fnrenames.a is missing from ERP->CREATE TABLE<-
pantry.tmp_cards_to_update is missing from ERP->CREATE TABLE<-
inm_beta.pick_rejection is missing from ERP->CREATE TABLE<-
mixalot.sku_group_sku is missing from ERP->CREATE TABLE<-
pantry.product_20190507 is missing from ERP->CREATE TABLE<-
develop.current_label_status_365days is missing from ERP->CREATE TABLE<-
develop.temp is missing from ERP->CREATE TABLE<-
develop.discount is missing from ERP->CREATE TABLE<-
inm_beta.kiosk_control is missing from ERP->CREATE TABLE<-
public.byte_kp_sales is missing from ERP->CREATE TABLE<-
test.november_order is missing from ERP->CREATE TABLE<-
develop.spoilage is missing from ERP->CREATE TABLE<-
develop.tmp_watcher is missing from ERP->CREATE TABLE<-
public.customer_campaigns is missing from ERP->CREATE TABLE<-
mixalot.warehouse_order_history is missing from ERP->CREATE TABLE<-
inm_beta.kiosk_sku_group_manual_scale is missing from ERP->CREATE TABLE<-
beta.temp_inv is missing from ERP->CREATE TABLE<-
inm.kiosk_restriction_by_sku is missing from ERP->CREATE TABLE<-
develop.kiosk_status is missing from ERP->CREATE TABLE<-
pantry.tmp_backup_order_before_05_03_process_will is missing from ERP->CREATE TABLE<-
inm_backup.pick_demand is missing from ERP->CREATE TABLE<-
inm_test.product_20190514 is missing from ERP->CREATE TABLE<-
pantry.tmp_eng_3692 is missing from ERP->CREATE TABLE<-
pantry.tmp_order_eng_1915 is missing from ERP->CREATE TABLE<-
test.fee_rate_bkup_20200131 is missing from ERP->CREATE TABLE<-
test.order_with_1970_and_2000_dates is missing from ERP->CREATE TABLE<-
develop.history is missing from ERP->CREATE TABLE<-
fnrenames.overstock_multiplier2 is missing from ERP->CREATE TABLE<-
mixalot.pick_priority_sku is missing from ERP->CREATE TABLE<-
pantry.delivery_schedule is missing from ERP->CREATE TABLE<-
public.inm_kiosk_weekly_sale is missing from ERP->CREATE TABLE<-
develop.kiosk is missing from ERP->CREATE TABLE<-
inm.kiosk_product_disabled is missing from ERP->CREATE TABLE<-
inm_backup.pick_priority_kiosk is missing from ERP->CREATE TABLE<-
inm_beta.pick_demand is missing from ERP->CREATE TABLE<-
inm_beta.warehouse_inventory is missing from ERP->CREATE TABLE<-
aws_dms.awsdms_suspended_tables is missing from ERP->CREATE TABLE<-
develop.permission_mapping is missing from ERP->CREATE TABLE<-
develop.timezone_mapping is missing from ERP->CREATE TABLE<-
pantry.history_campus_attribute is missing from ERP->CREATE TABLE<-
pantry.product_request is missing from ERP->CREATE TABLE<-
public.tmp_reboots_log is missing from ERP->CREATE TABLE<-
	CREATE TABLE : 399
inm_test.inm_kiosk_restock is missing from ERP->ALTER TABLE<-
pantry.restock_item_id_seq is missing from ERP->ALTER TABLE<-
public.kiosk_id_seq is missing from ERP->ALTER TABLE<-
public.byte_epcssold_30days is missing from ERP->ALTER TABLE<-
public.dashboard_monthly_stats is missing from ERP->ALTER TABLE<-
byte_pgdu.pgdudetail is missing from ERP->ALTER TABLE<-
inm_backup.sku_group_def is missing from ERP->ALTER TABLE<-
pantry.role_mapping is missing from ERP->ALTER TABLE<-
public.awsdms_validation_failures_v1 is missing from ERP->ALTER TABLE<-
beta.sku_group_control is missing from ERP->ALTER TABLE<-
fnrenames.nutrition_filter_id_seq is missing from ERP->ALTER TABLE<-
inm.view_sku_sku_group is missing from ERP->ALTER TABLE<-
public.dp_stockouts_weekly_product_pct is missing from ERP->ALTER TABLE<-
develop.feedback is missing from ERP->ALTER TABLE<-
fnrenames.overstock_multiplier is missing from ERP->ALTER TABLE<-
develop."group" is missing from ERP->ALTER TABLE<-
develop.kiosk_par_level is missing from ERP->ALTER TABLE<-
mixalot.tmp_unit is missing from ERP->ALTER TABLE<-
pantry.running_service is missing from ERP->ALTER TABLE<-
public.byte_tickets_1year is missing from ERP->ALTER TABLE<-
public.user_retention_6months is missing from ERP->ALTER TABLE<-
test.accounting_bkup_20200204_partial is missing from ERP->ALTER TABLE<-
develop.current_label_status_365days is missing from ERP->ALTER TABLE<-
mixalot.inm_byte_kiosk is missing from ERP->ALTER TABLE<-
pantry.facing_category_id_seq is missing from ERP->ALTER TABLE<-
pantry.tmp_price_finalized_order_ids is missing from ERP->ALTER TABLE<-
inm_beta.pick_priority_kiosk is missing from ERP->ALTER TABLE<-
mixalot.test_time_id_seq is missing from ERP->ALTER TABLE<-
monitor.cron_state is missing from ERP->ALTER TABLE<-
beta.temp_pick_preference_kiosk_sku is missing from ERP->ALTER TABLE<-
develop.tmp_watcher is missing from ERP->ALTER TABLE<-
inm_backup.ku_group_attribute is missing from ERP->ALTER TABLE<-
public.byte_epcssold_6weeks is missing from ERP->ALTER TABLE<-
develop.last_kiosk_status is missing from ERP->ALTER TABLE<-
pantry.transact_comp is missing from ERP->ALTER TABLE<-
public.byte_tickets_6days is missing from ERP->ALTER TABLE<-
public.campaigns is missing from ERP->ALTER TABLE<-
public.date_hours_2016 is missing from ERP->ALTER TABLE<-
test.vantiv_20190801 is missing from ERP->ALTER TABLE<-
pantry.par_history is missing from ERP->ALTER TABLE<-
pantry.transact_express is missing from ERP->ALTER TABLE<-
public.byte_epcssold_2weeks is missing from ERP->ALTER TABLE<-
test.transactions_pending_sync_id_seq is missing from ERP->ALTER TABLE<-
rptg.current_inventory is missing from ERP->ALTER TABLE<-
test.temp_pending is missing from ERP->ALTER TABLE<-
fnrenames.temp_sync_order_2018_12_13 is missing from ERP->ALTER TABLE<-
pantry.campus_id_seq is missing from ERP->ALTER TABLE<-
pantry.tag_id_seq is missing from ERP->ALTER TABLE<-
public.byte_tickets_2015 is missing from ERP->ALTER TABLE<-
public.byte_epcssold_6days is missing from ERP->ALTER TABLE<-
public.byte_stockouts_by_category_week_all is missing from ERP->ALTER TABLE<-
byt_devops.pgdu_pretty is missing from ERP->ALTER TABLE<-
pantry.contract_id_seq is missing from ERP->ALTER TABLE<-
public.tmp_reboots_log is missing from ERP->ALTER TABLE<-
pantry.payment_order_id_seq is missing from ERP->ALTER TABLE<-
public.dp_epcssold_2015 is missing from ERP->ALTER TABLE<-
public."pantry.kiosk_id_seq" is missing from ERP->ALTER TABLE<-
beta.temp_test3 is missing from ERP->ALTER TABLE<-
beta.warehouse_inventory_history is missing from ERP->ALTER TABLE<-
inm_test.inm_kiosk_weekly_sale is missing from ERP->ALTER TABLE<-
inm_test.kiosk_audit is missing from ERP->ALTER TABLE<-
public.track_dashboard_id_seq is missing from ERP->ALTER TABLE<-
dms7.awsdms_status is missing from ERP->ALTER TABLE<-
public.byte_spoilage_by_category_week_crosstab is missing from ERP->ALTER TABLE<-
public.dp_spoilage_weekly_kiosk_pct is missing from ERP->ALTER TABLE<-
public.dp_spoilage_daily_pct is missing from ERP->ALTER TABLE<-
public.dp_stockouts_weekly_kiosk_product_pct is missing from ERP->ALTER TABLE<-
public.user_retention_4weeks is missing from ERP->ALTER TABLE<-
byt_devops.pgdudetail_pretty is missing from ERP->ALTER TABLE<-
pantry.card_id_seq is missing from ERP->ALTER TABLE<-
public.dbg_stockout_runs_weighted is missing from ERP->ALTER TABLE<-
mixalot.pick is missing from ERP->ALTER TABLE<-
mixalot.tally is missing from ERP->ALTER TABLE<-
monitor.kiosk_not_heard is missing from ERP->ALTER TABLE<-
develop.kiosk_status is missing from ERP->ALTER TABLE<-
fnrenames.history_id_seq is missing from ERP->ALTER TABLE<-
inm_beta.pick_route is missing from ERP->ALTER TABLE<-
public.byte_epcssold_6months is missing from ERP->ALTER TABLE<-
public.inm_kiosk_weekly_sale is missing from ERP->ALTER TABLE<-
public.track_dashboard is missing from ERP->ALTER TABLE<-
public.kiosk is missing from ERP->ALTER TABLE<-
develop.cron is missing from ERP->ALTER TABLE<-
inm_test.broken_product is missing from ERP->ALTER TABLE<-
mixalot.gsheets_kiosk_restriction is missing from ERP->ALTER TABLE<-
pantry.dc_inventory is missing from ERP->ALTER TABLE<-
public.byte_tickets_365days is missing from ERP->ALTER TABLE<-
public.byte_tickets_4days is missing from ERP->ALTER TABLE<-
public.byte_epcssold_90days is missing from ERP->ALTER TABLE<-
public.user_retention_8weeks is missing from ERP->ALTER TABLE<-
inm_beta.pick_allocation is missing from ERP->ALTER TABLE<-
pantry.label_id_seq is missing from ERP->ALTER TABLE<-
pantry.product_kiosk_price_offset is missing from ERP->ALTER TABLE<-
test.eng2903 is missing from ERP->ALTER TABLE<-
pantry.tmp_order_eng_1915 is missing from ERP->ALTER TABLE<-
public.dowhours is missing from ERP->ALTER TABLE<-
public."pantry.kiosk" is missing from ERP->ALTER TABLE<-
beta.temp_sync_order_2018_12_13 is missing from ERP->ALTER TABLE<-
pantry.manual_adjustment_id_seq is missing from ERP->ALTER TABLE<-
pantry.tmp_march1_rollingback_auths is missing from ERP->ALTER TABLE<-
inm.kiosk_projected_stock_sku_level is missing from ERP->ALTER TABLE<-
pantry.spoilage_id_seq is missing from ERP->ALTER TABLE<-
fnrenames.label_id_seq is missing from ERP->ALTER TABLE<-
pantry.coupon_id_seq is missing from ERP->ALTER TABLE<-
pantry.tmp_cards_to_update is missing from ERP->ALTER TABLE<-
public.byte_epcssold_2016 is missing from ERP->ALTER TABLE<-
public.dp_spoilage_2017 is missing from ERP->ALTER TABLE<-
public.track_inventory is missing from ERP->ALTER TABLE<-
develop.ro_order is missing from ERP->ALTER TABLE<-
inm_test.kiosk_20190810 is missing from ERP->ALTER TABLE<-
test.kiosk_20190611 is missing from ERP->ALTER TABLE<-
public.byte_product_stats_by_kiosk is missing from ERP->ALTER TABLE<-
public.byte_stockouts_by_category_week_newold is missing from ERP->ALTER TABLE<-
public.stockout_dowhours is missing from ERP->ALTER TABLE<-
test.fee_rate_bkup_20200131 is missing from ERP->ALTER TABLE<-
iplanner.insync_kiosk_v1 is missing from ERP->ALTER TABLE<-
pantry.history_kiosk_device is missing from ERP->ALTER TABLE<-
pantry.product_20190507 is missing from ERP->ALTER TABLE<-
public.dp_spoilage_weekly_product_pct is missing from ERP->ALTER TABLE<-
public.user_retention_52weeks is missing from ERP->ALTER TABLE<-
test.request_log_order is missing from ERP->ALTER TABLE<-
pantry.stockout is missing from ERP->ALTER TABLE<-
public.byte_sales_by_week is missing from ERP->ALTER TABLE<-
public.user_retention_2months is missing from ERP->ALTER TABLE<-
test.request_log_sold_epc is missing from ERP->ALTER TABLE<-
fnrenames.card_id_seq is missing from ERP->ALTER TABLE<-
fnrenames.overstock_multiplier2 is missing from ERP->ALTER TABLE<-
pantry.transact_fp_id_seq is missing from ERP->ALTER TABLE<-
public.byte_epcssold_360days is missing from ERP->ALTER TABLE<-
pantry.last_kiosk_status_id_seq is missing from ERP->ALTER TABLE<-
pantry.tmp_eng_495_cards_to_update is missing from ERP->ALTER TABLE<-
public.byte_spoilage_by_category_week_all is missing from ERP->ALTER TABLE<-
develop.discount_history is missing from ERP->ALTER TABLE<-
develop.transact_comp is missing from ERP->ALTER TABLE<-
inm_backup.pick_preference_kiosk_sku_20190120 is missing from ERP->ALTER TABLE<-
public.sys_conninfo is missing from ERP->ALTER TABLE<-
public.dbg_stockout_dowhours_weighted is missing from ERP->ALTER TABLE<-
public.dp_products is missing from ERP->ALTER TABLE<-
public.dp_stockouts_4weeks is missing from ERP->ALTER TABLE<-
public.spoilagepct_by_shelflife_120d is missing from ERP->ALTER TABLE<-
beta.pick_demand is missing from ERP->ALTER TABLE<-
mixalot.server_id_seq is missing from ERP->ALTER TABLE<-
pantry.transact_comp_id_seq is missing from ERP->ALTER TABLE<-
public.byte_kp_grid2 is missing from ERP->ALTER TABLE<-
rptg.temp_yann_boardq3 is missing from ERP->ALTER TABLE<-
public.dbg_stockout_dowhours_weighted_stats is missing from ERP->ALTER TABLE<-
public.dp_spoilage_daily_kiosk_pct is missing from ERP->ALTER TABLE<-
test.order_complimentary_eng_2292 is missing from ERP->ALTER TABLE<-
pantry.discount_id_seq is missing from ERP->ALTER TABLE<-
public.byte_epcssold_1day is missing from ERP->ALTER TABLE<-
public.byte_epcssold_1month is missing from ERP->ALTER TABLE<-
public.inventory_current is missing from ERP->ALTER TABLE<-
beta.temp_test2 is missing from ERP->ALTER TABLE<-
develop.unused_user_mapping is missing from ERP->ALTER TABLE<-
fnrenames.kiosk_id_seq is missing from ERP->ALTER TABLE<-
public.byte_epcssold_3days is missing from ERP->ALTER TABLE<-
public.dp_spoilage_weekly_pct is missing from ERP->ALTER TABLE<-
public.byte_tickets_90days is missing from ERP->ALTER TABLE<-
beta.pick_demand_id_seq is missing from ERP->ALTER TABLE<-
pantry.product_request is missing from ERP->ALTER TABLE<-
public.byte_dc_inventory_history is missing from ERP->ALTER TABLE<-
byt_devops.pgdutotal_pretty is missing from ERP->ALTER TABLE<-
develop.coupon is missing from ERP->ALTER TABLE<-
pantry.kiosk_device is missing from ERP->ALTER TABLE<-
pantry.kiosk_status_id_seq is missing from ERP->ALTER TABLE<-
pantry.cron_id_seq is missing from ERP->ALTER TABLE<-
pantry.feedback_id_seq is missing from ERP->ALTER TABLE<-
pantry.tmp_process_order_txt is missing from ERP->ALTER TABLE<-
public.byte_epcssold_4days is missing from ERP->ALTER TABLE<-
beta.route is missing from ERP->ALTER TABLE<-
beta.temp_product is missing from ERP->ALTER TABLE<-
develop.tag is missing from ERP->ALTER TABLE<-
mixalot.inm_warehouse_sku_enabled is missing from ERP->ALTER TABLE<-
public.byte_tickets_60days is missing from ERP->ALTER TABLE<-
public.byte_epcssold_7days is missing from ERP->ALTER TABLE<-
public.mkt_camp_20170123_whats_new_in_kiosk is missing from ERP->ALTER TABLE<-
pantry.campus_attribute is missing from ERP->ALTER TABLE<-
pantry.permission_id_seq is missing from ERP->ALTER TABLE<-
public.byte_epcssold_2017 is missing from ERP->ALTER TABLE<-
public.byte_users_products_4months is missing from ERP->ALTER TABLE<-
aws_dms.awsdms_history is missing from ERP->ALTER TABLE<-
byt_devops.pgdu_union_pretty is missing from ERP->ALTER TABLE<-
inm_test.restricted is missing from ERP->ALTER TABLE<-
mixalot.temp_test_id_seq is missing from ERP->ALTER TABLE<-
public.dashboard_weekly_stats is missing from ERP->ALTER TABLE<-
public.kiosk_sales_by_dayofweek is missing from ERP->ALTER TABLE<-
public.sales_by_category_120d is missing from ERP->ALTER TABLE<-
public.customers_customer_id_seq is missing from ERP->ALTER TABLE<-
public.byte_addicted_users_120days is missing from ERP->ALTER TABLE<-
test.reauth_2019_07_priced_finalized_orders is missing from ERP->ALTER TABLE<-
public.byte_inventory_current_lots is missing from ERP->ALTER TABLE<-
public.byte_kp_grid is missing from ERP->ALTER TABLE<-
public.dp_stockouts_8weeks is missing from ERP->ALTER TABLE<-
public.int_kiosk_weekly_sale is missing from ERP->ALTER TABLE<-
mixalot.temp_ms_to_sg is missing from ERP->ALTER TABLE<-
pantry.role_id_seq is missing from ERP->ALTER TABLE<-
public.byte_tickets_12months is missing from ERP->ALTER TABLE<-
public.byte_epcssold_fast is missing from ERP->ALTER TABLE<-
inm.bringg_delivery is missing from ERP->ALTER TABLE<-
inm_backup.kiosk_product_disabled is missing from ERP->ALTER TABLE<-
public.byte_tickets_1day is missing from ERP->ALTER TABLE<-
public.byte_tickets_3weeks is missing from ERP->ALTER TABLE<-
test.campus_20190620 is missing from ERP->ALTER TABLE<-
inm_beta.pick_list is missing from ERP->ALTER TABLE<-
inm_test.backup_inm_data_09_16 is missing from ERP->ALTER TABLE<-
pantry.tmp_april23_error_order_fixes is missing from ERP->ALTER TABLE<-
public.user_retention_3weeks is missing from ERP->ALTER TABLE<-
test.locked_kiosk_by_command is missing from ERP->ALTER TABLE<-
develop.refunds is missing from ERP->ALTER TABLE<-
public.sales_by_shelflife_120d is missing from ERP->ALTER TABLE<-
public.sys_table_sizes is missing from ERP->ALTER TABLE<-
public.dp_stockouts_weekly_sold_join is missing from ERP->ALTER TABLE<-
byt_devops.pgdutotal is missing from ERP->ALTER TABLE<-
pantry.user_id_seq is missing from ERP->ALTER TABLE<-
pantry.spoilage is missing from ERP->ALTER TABLE<-
pantry.tmp_revert_order_status is missing from ERP->ALTER TABLE<-
public.byte_tickets_1month is missing from ERP->ALTER TABLE<-
public.byte_kp_oos_avgdowhour is missing from ERP->ALTER TABLE<-
dms7.awsdms_apply_exceptions is missing from ERP->ALTER TABLE<-
inm_backup.pick_substitution is missing from ERP->ALTER TABLE<-
pantry.contract is missing from ERP->ALTER TABLE<-
pantry.discount_applied_id_seq is missing from ERP->ALTER TABLE<-
public.stockout_avg_kiosk_cat_sales_dowhour is missing from ERP->ALTER TABLE<-
public.byte_epcssold_2months is missing from ERP->ALTER TABLE<-
public.byte_kiosks_with_perm_subsidy is missing from ERP->ALTER TABLE<-
test.kiosk_20190612 is missing from ERP->ALTER TABLE<-
test.november_order is missing from ERP->ALTER TABLE<-
pantry.facing_category is missing from ERP->ALTER TABLE<-
pantry.delivery_schedule is missing from ERP->ALTER TABLE<-
public.byte_tickets_5days is missing from ERP->ALTER TABLE<-
public.dp_inventory_current is missing from ERP->ALTER TABLE<-
inm_beta.kiosk_restriction_by_property is missing from ERP->ALTER TABLE<-
pantry.current_label_status_365days is missing from ERP->ALTER TABLE<-
public.byte_tickets_1week is missing from ERP->ALTER TABLE<-
public.byte_tickets_10weeks is missing from ERP->ALTER TABLE<-
public.byte_kp_sales is missing from ERP->ALTER TABLE<-
public.dp_epcssold_8weeks is missing from ERP->ALTER TABLE<-
monitor.opt_connect is missing from ERP->ALTER TABLE<-
public.byte_tickets_6months is missing from ERP->ALTER TABLE<-
public.byte_tickets_8weeks is missing from ERP->ALTER TABLE<-
public.campaigns_campaign_id_seq is missing from ERP->ALTER TABLE<-
rptg.temp_yann_q1 is missing from ERP->ALTER TABLE<-
byt_devops.pgdudetail is missing from ERP->ALTER TABLE<-
inm_beta.pick_demand is missing from ERP->ALTER TABLE<-
inm_test.kiosk_20190531_test_update is missing from ERP->ALTER TABLE<-
pantry.tmp_eng_3692 is missing from ERP->ALTER TABLE<-
inm.warehouse_ordering is missing from ERP->ALTER TABLE<-
pantry.kiosk_attribute is missing from ERP->ALTER TABLE<-
inm.kiosk_projected_minimum is missing from ERP->ALTER TABLE<-
mixalot.sku_group_sku is missing from ERP->ALTER TABLE<-
fnrenames.kiosk_status_id_seq is missing from ERP->ALTER TABLE<-
public.awsdms_heartbeat_hb_key_seq is missing from ERP->ALTER TABLE<-
public.byte_tickets_2017 is missing from ERP->ALTER TABLE<-
public.dp_spoilage_daily_product_pct is missing from ERP->ALTER TABLE<-
pantry.order_meta is missing from ERP->ALTER TABLE<-
public.byte_epcssold_60days is missing from ERP->ALTER TABLE<-
public.user_retention_12months is missing from ERP->ALTER TABLE<-
test.kiosk_payment_start is missing from ERP->ALTER TABLE<-
develop.history is missing from ERP->ALTER TABLE<-
mixalot.card_fact is missing from ERP->ALTER TABLE<-
test.kiosk_bkup_20200204 is missing from ERP->ALTER TABLE<-
develop.accounting is missing from ERP->ALTER TABLE<-
mixalot.inm_kiosk_sku_disabled is missing from ERP->ALTER TABLE<-
test.vantiv_20190801b is missing from ERP->ALTER TABLE<-
public.dp_stockouts_weekly_kiosk_pct is missing from ERP->ALTER TABLE<-
develop.product is missing from ERP->ALTER TABLE<-
public.byte_tickets_4weeks is missing from ERP->ALTER TABLE<-
public.byte_stockouts_by_week is missing from ERP->ALTER TABLE<-
public.awsdms_apply_exceptions is missing from ERP->ALTER TABLE<-
public.byte_tickets_6weeks is missing from ERP->ALTER TABLE<-
public.byte_tickets_9months is missing from ERP->ALTER TABLE<-
pantry.kiosk_audit_log_id_seq is missing from ERP->ALTER TABLE<-
pantry.tmp_watcher is missing from ERP->ALTER TABLE<-
test.order_epc_pending_sync is missing from ERP->ALTER TABLE<-
inm.sku_def is missing from ERP->ALTER TABLE<-
mixalot.warehouse_order_history is missing from ERP->ALTER TABLE<-
pantry.product_kiosk_price_offset_id_seq is missing from ERP->ALTER TABLE<-
public.customer_campaigns is missing from ERP->ALTER TABLE<-
mixalot.inm_gsheets_kiosk_restriction is missing from ERP->ALTER TABLE<-
public.byte_tickets_180days is missing from ERP->ALTER TABLE<-
public.track_inventory_id_seq is missing from ERP->ALTER TABLE<-
test.cron_broken is missing from ERP->ALTER TABLE<-
inm_backup.pick_priority_kiosk is missing from ERP->ALTER TABLE<-
mixalot.product_kiosk_fact_id_seq is missing from ERP->ALTER TABLE<-
mixalot.temp_sku_to_skugroup is missing from ERP->ALTER TABLE<-
public.byte_tickets_5weeks is missing from ERP->ALTER TABLE<-
inm_test.tag_2019_05_15 is missing from ERP->ALTER TABLE<-
mixalot.kiosk_restriction is missing from ERP->ALTER TABLE<-
pantry.tmp_order_transaction_id_map is missing from ERP->ALTER TABLE<-
public.category_stats_120d is missing from ERP->ALTER TABLE<-
public.dp_inventory_history is missing from ERP->ALTER TABLE<-
public.dp_spoilage_weekly_sold_join is missing from ERP->ALTER TABLE<-
develop.group_campus is missing from ERP->ALTER TABLE<-
public.iplanner_inventory is missing from ERP->ALTER TABLE<-
public.byte_epcssold_9months is missing from ERP->ALTER TABLE<-
pantry.group_id_seq is missing from ERP->ALTER TABLE<-
beta.missing_hash is missing from ERP->ALTER TABLE<-
inm_test.product_20190508 is missing from ERP->ALTER TABLE<-
mixalot.v_kiosk_inventory_log is missing from ERP->ALTER TABLE<-
inm.sku_property is missing from ERP->ALTER TABLE<-
public.stockout_weighted is missing from ERP->ALTER TABLE<-
test.lost_wall_clock_orders is missing from ERP->ALTER TABLE<-
public.dp_epcssold_2016 is missing from ERP->ALTER TABLE<-
test.kiosk_20200304 is missing from ERP->ALTER TABLE<-
mixalot.product_kiosk_fact is missing from ERP->ALTER TABLE<-
pantry.temp_product_backup is missing from ERP->ALTER TABLE<-
pantry.transact_fp is missing from ERP->ALTER TABLE<-
public.awsdms_history is missing from ERP->ALTER TABLE<-
public.byte_tickets_2days is missing from ERP->ALTER TABLE<-
public.spoilage_by_shelflife_30d is missing from ERP->ALTER TABLE<-
develop.contract is missing from ERP->ALTER TABLE<-
develop."user" is missing from ERP->ALTER TABLE<-
public.byte_kp_sales_grid is missing from ERP->ALTER TABLE<-
public.latest_label_records is missing from ERP->ALTER TABLE<-
public.user_retention_3months is missing from ERP->ALTER TABLE<-
beta.sku_group_attribute is missing from ERP->ALTER TABLE<-
public.dp_stockouts is missing from ERP->ALTER TABLE<-
public.dp_stockouts_weekly_pct is missing from ERP->ALTER TABLE<-
public.user_retention_10weeks is missing from ERP->ALTER TABLE<-
develop.product_history is missing from ERP->ALTER TABLE<-
inm_backup.kiosk_sku_group_manual_scale is missing from ERP->ALTER TABLE<-
mixalot.v_kiosk_status_log is missing from ERP->ALTER TABLE<-
public.byte_tickets_3days is missing from ERP->ALTER TABLE<-
mixalot.merchandising_slot_id_seq is missing from ERP->ALTER TABLE<-
public.byte_epcssold_12months is missing from ERP->ALTER TABLE<-
public.byte_epcssold_4months is missing from ERP->ALTER TABLE<-
public.dp_spoilage_2016 is missing from ERP->ALTER TABLE<-
beta.temp_fc_default_level is missing from ERP->ALTER TABLE<-
mixalot.merchandising_slot_def is missing from ERP->ALTER TABLE<-
pantry.permission is missing from ERP->ALTER TABLE<-
pantry.tmp_process_order_vantiv is missing from ERP->ALTER TABLE<-
public.spoilagepct_by_shelflife_30d is missing from ERP->ALTER TABLE<-
public.sys_activity is missing from ERP->ALTER TABLE<-
inm_backup.pick_allocation is missing from ERP->ALTER TABLE<-
inm_backup.sku_velocity_20190120 is missing from ERP->ALTER TABLE<-
pantry.campus_attribute_id_seq is missing from ERP->ALTER TABLE<-
public.byte_spoilage is missing from ERP->ALTER TABLE<-
beta.card is missing from ERP->ALTER TABLE<-
beta.temp_nutrition_filter is missing from ERP->ALTER TABLE<-
develop.role is missing from ERP->ALTER TABLE<-
public.valid_bytecodes is missing from ERP->ALTER TABLE<-
test.kiosk_20190918 is missing from ERP->ALTER TABLE<-
fnrenames.discount_history_id_seq is missing from ERP->ALTER TABLE<-
inm_backup.pick_route is missing from ERP->ALTER TABLE<-
mixalot.card_fact_id_seq is missing from ERP->ALTER TABLE<-
public.dp_epcssold_4weeks is missing from ERP->ALTER TABLE<-
beta.kiosk_projected_stock is missing from ERP->ALTER TABLE<-
develop.inventory_history is missing from ERP->ALTER TABLE<-
test.accounting_partial_backup_20191101 is missing from ERP->ALTER TABLE<-
pantry.global_attribute_def is missing from ERP->ALTER TABLE<-
public.byte_kp_oos is missing from ERP->ALTER TABLE<-
test.accounting_partial_bkup_20200131 is missing from ERP->ALTER TABLE<-
beta.temp_sku_group_attribute is missing from ERP->ALTER TABLE<-
inm_beta.sku_group is missing from ERP->ALTER TABLE<-
mixalot.kiosk is missing from ERP->ALTER TABLE<-
test.order_with_1970_and_2000_dates is missing from ERP->ALTER TABLE<-
public.byte_epcssold_1week is missing from ERP->ALTER TABLE<-
public.dp_spoilage is missing from ERP->ALTER TABLE<-
develop.transact_fp is missing from ERP->ALTER TABLE<-
inm_test.kiosk_20190508 is missing from ERP->ALTER TABLE<-
pantry.history_global_attribute_def is missing from ERP->ALTER TABLE<-
develop.history_epc_order is missing from ERP->ALTER TABLE<-
inm_beta.pick_inventory is missing from ERP->ALTER TABLE<-
inm_test.plan_kiosks is missing from ERP->ALTER TABLE<-
mixalot.v_kiosk_request_log is missing from ERP->ALTER TABLE<-
pantry.fee_rates_id_seq is missing from ERP->ALTER TABLE<-
public.byte_epcssold_180days is missing from ERP->ALTER TABLE<-
public.byte_epcssold_4weeks is missing from ERP->ALTER TABLE<-
develop.transact_ipc is missing from ERP->ALTER TABLE<-
inm_beta.pick_priority_sku is missing from ERP->ALTER TABLE<-
inm_test.inm_kiosk_skugroup_sale is missing from ERP->ALTER TABLE<-
inm_test.kiosk_par_level_bkup is missing from ERP->ALTER TABLE<-
test.request_log_sold_epc_id_seq is missing from ERP->ALTER TABLE<-
develop.permission_mapping is missing from ERP->ALTER TABLE<-
develop.timezone_mapping is missing from ERP->ALTER TABLE<-
inm.kiosk_restriction_by_sku is missing from ERP->ALTER TABLE<-
inm_test.kiosk_software is missing from ERP->ALTER TABLE<-
public.byte_kp_sales_first is missing from ERP->ALTER TABLE<-
public.dp_spoilage_monthly_product_pct is missing from ERP->ALTER TABLE<-
develop.kiosk is missing from ERP->ALTER TABLE<-
mixalot.v_node_kiosk_status_log is missing from ERP->ALTER TABLE<-
pantry.product_request_id_seq is missing from ERP->ALTER TABLE<-
pantry.bad_timestamp_id_seq is missing from ERP->ALTER TABLE<-
beta.route_stop is missing from ERP->ALTER TABLE<-
develop.spoilage is missing from ERP->ALTER TABLE<-
mixalot.inm_kiosk_restriction_list is missing from ERP->ALTER TABLE<-
public.user_retention_tickets is missing from ERP->ALTER TABLE<-
inm_backup.sku_group_control is missing from ERP->ALTER TABLE<-
inm_test.inm_kiosk_hourly_sale is missing from ERP->ALTER TABLE<-
public.byte_tickets_2016 is missing from ERP->ALTER TABLE<-
public.byte_epcssold_120days is missing from ERP->ALTER TABLE<-
public.byte_epcssold_10weeks is missing from ERP->ALTER TABLE<-
public.byte_spoilage_by_sku_2months is missing from ERP->ALTER TABLE<-
develop.permission is missing from ERP->ALTER TABLE<-
pantry.delivery_schedule_id_seq is missing from ERP->ALTER TABLE<-
pantry.tmp_orderstoerror is missing from ERP->ALTER TABLE<-
public.dbg_stockout_weighted is missing from ERP->ALTER TABLE<-
public.tmp_dormant2 is missing from ERP->ALTER TABLE<-
develop.manual_adjustment is missing from ERP->ALTER TABLE<-
public.byte_epcssold_3weeks is missing from ERP->ALTER TABLE<-
public.byte_restockings is missing from ERP->ALTER TABLE<-
beta.kiosk_sku_group_manual_scale is missing from ERP->ALTER TABLE<-
beta.test is missing from ERP->ALTER TABLE<-
byt_devops.pgdu is missing from ERP->ALTER TABLE<-
develop.discount is missing from ERP->ALTER TABLE<-
public.spoilage_by_category_120d is missing from ERP->ALTER TABLE<-
public.user_retention_9months is missing from ERP->ALTER TABLE<-
mixalot.sku_def is missing from ERP->ALTER TABLE<-
pantry.transact_ipc is missing from ERP->ALTER TABLE<-
pantry.discount_history_id_seq is missing from ERP->ALTER TABLE<-
pantry.history_campus_attribute is missing from ERP->ALTER TABLE<-
develop.temp is missing from ERP->ALTER TABLE<-
inm_beta.warehouse_inventory is missing from ERP->ALTER TABLE<-
mixalot.inm_sku_enabled is missing from ERP->ALTER TABLE<-
public.byte_tickets_120days is missing from ERP->ALTER TABLE<-
public.inventory_current_lots is missing from ERP->ALTER TABLE<-
beta.temp_inv is missing from ERP->ALTER TABLE<-
inm.kiosk_attribute is missing from ERP->ALTER TABLE<-
pantry.stockout_id_seq is missing from ERP->ALTER TABLE<-
pantry.transact_ipc_id_seq is missing from ERP->ALTER TABLE<-
public.byte_epcssold_2015 is missing from ERP->ALTER TABLE<-
public.byte_kiosks_by_week is missing from ERP->ALTER TABLE<-
public.dp_spoilage_monthly_kiosk_pct is missing from ERP->ALTER TABLE<-
beta.temp_test2_id_seq is missing from ERP->ALTER TABLE<-
mixalot.pick_priority_sku is missing from ERP->ALTER TABLE<-
pantry.tmp_process_order is missing from ERP->ALTER TABLE<-
public.customers is missing from ERP->ALTER TABLE<-
test.discount_20190614 is missing from ERP->ALTER TABLE<-
develop.card is missing from ERP->ALTER TABLE<-
develop.par_history is missing from ERP->ALTER TABLE<-
inm_beta.allocable_inventory is missing from ERP->ALTER TABLE<-
public.byte_kp_sales_avgdowhour is missing from ERP->ALTER TABLE<-
public.byte_stockouts_by_category_week is missing from ERP->ALTER TABLE<-
public.spoilage_by_shelflife_120d is missing from ERP->ALTER TABLE<-
pantry.product_history_id_seq is missing from ERP->ALTER TABLE<-
public.mkt_camp_20170111_sku_revival_sonoma is missing from ERP->ALTER TABLE<-
mixalot.sku_attribute_def_id_seq is missing from ERP->ALTER TABLE<-
pantry.nutrition_filter_id_seq is missing from ERP->ALTER TABLE<-
public.user_retention_26weeks is missing from ERP->ALTER TABLE<-
public.awsdms_heartbeat is missing from ERP->ALTER TABLE<-
fnrenames.product_id_seq is missing from ERP->ALTER TABLE<-
mixalot.inm_dc_inventory is missing from ERP->ALTER TABLE<-
mixalot.v_kiosk_item_log is missing from ERP->ALTER TABLE<-
pantry.currency_symbol is missing from ERP->ALTER TABLE<-
public.byte_label_product_fast is missing from ERP->ALTER TABLE<-
pantry.history_id_seq is missing from ERP->ALTER TABLE<-
public.byte_epcssold_45days is missing from ERP->ALTER TABLE<-
public.lastwk_hrs is missing from ERP->ALTER TABLE<-
develop.label is missing from ERP->ALTER TABLE<-
mixalot.inm_demand is missing from ERP->ALTER TABLE<-
pantry.par_history_id_seq is missing from ERP->ALTER TABLE<-
aws_dms.awsdms_status is missing from ERP->ALTER TABLE<-
inm_beta.pick_rejection is missing from ERP->ALTER TABLE<-
mixalot.kiosk_restriction_by_property is missing from ERP->ALTER TABLE<-
mixalot.kiosk_status is missing from ERP->ALTER TABLE<-
public.awsdms_status is missing from ERP->ALTER TABLE<-
public.dp_spoilage_monthly_kiosk_product_pct is missing from ERP->ALTER TABLE<-
report.dependency is missing from ERP->ALTER TABLE<-
public.dbg_stockout_weighted_stats is missing from ERP->ALTER TABLE<-
beta.kiosks is missing from ERP->ALTER TABLE<-
pantry.kiosk_cd_id_seq is missing from ERP->ALTER TABLE<-
public.byte_restockings_labels is missing from ERP->ALTER TABLE<-
public.byte_tickets_yesterday is missing from ERP->ALTER TABLE<-
pantry.component_history_id_seq is missing from ERP->ALTER TABLE<-
public.awsdms_suspended_tables is missing from ERP->ALTER TABLE<-
test.kiosk_20190606 is missing from ERP->ALTER TABLE<-
inm_backup.kiosk_restriction_by_product is missing from ERP->ALTER TABLE<-
inm_beta.pick_substitution is missing from ERP->ALTER TABLE<-
mixalot.merchandising_slot_def_id_seq is missing from ERP->ALTER TABLE<-
inm_beta.pick_preference_kiosk_sku is missing from ERP->ALTER TABLE<-
pantry.event is missing from ERP->ALTER TABLE<-
pantry.restock_item is missing from ERP->ALTER TABLE<-
public.stockout_dowhours_weighted is missing from ERP->ALTER TABLE<-
develop.campus is missing from ERP->ALTER TABLE<-
pantry.product_categories_id_seq is missing from ERP->ALTER TABLE<-
pantry.kiosk_service_version is missing from ERP->ALTER TABLE<-
pantry.tmp_payment_order is missing from ERP->ALTER TABLE<-
public.sys_uptime is missing from ERP->ALTER TABLE<-
dms7.awsdms_history is missing from ERP->ALTER TABLE<-
dms7.awsdms_suspended_tables is missing from ERP->ALTER TABLE<-
pantry.history_kiosk_service_version is missing from ERP->ALTER TABLE<-
public.tmp_dormant is missing from ERP->ALTER TABLE<-
public.byte_spoilage_stockouts_by_week is missing from ERP->ALTER TABLE<-
public.byte_tickets_7days is missing from ERP->ALTER TABLE<-
public.dp_spoilage_4weeks is missing from ERP->ALTER TABLE<-
public.dp_spoilage_daily_sold_join is missing from ERP->ALTER TABLE<-
public.kiosk_first_seen is missing from ERP->ALTER TABLE<-
beta.temp_test_id_seq is missing from ERP->ALTER TABLE<-
mixalot.temp_sku_group_volume is missing from ERP->ALTER TABLE<-
pantry.inventory_history_id_seq is missing from ERP->ALTER TABLE<-
public.user_retention_1week is missing from ERP->ALTER TABLE<-
public.dp_spoilage_monthly_sold_join is missing from ERP->ALTER TABLE<-
mixalot.history_order_id_seq is missing from ERP->ALTER TABLE<-
pantry.kiosk_id_seq is missing from ERP->ALTER TABLE<-
inm_beta.sku_group_control is missing from ERP->ALTER TABLE<-
mixalot.merchandising_slot is missing from ERP->ALTER TABLE<-
mixalot.test_time is missing from ERP->ALTER TABLE<-
pantry.product_id_seq is missing from ERP->ALTER TABLE<-
byt_devops.pgdu_union is missing from ERP->ALTER TABLE<-
inm_beta.kiosk_restriction_by_product is missing from ERP->ALTER TABLE<-
pantry.tmp_order_may_6_preapr23 is missing from ERP->ALTER TABLE<-
public.byte_tickets_2weeks is missing from ERP->ALTER TABLE<-
public.dp_epcssold_2017 is missing from ERP->ALTER TABLE<-
inm_test.kiosk_20190531 is missing from ERP->ALTER TABLE<-
inm_test.product_20190514 is missing from ERP->ALTER TABLE<-
public.byte_epcssold_365days is missing from ERP->ALTER TABLE<-
develop.event is missing from ERP->ALTER TABLE<-
inm.temp_velocity is missing from ERP->ALTER TABLE<-
inm_backup.kiosk_restriction_by_property is missing from ERP->ALTER TABLE<-
public.byte_tickets_today is missing from ERP->ALTER TABLE<-
public.dp_spoilage_monthly_pct is missing from ERP->ALTER TABLE<-
public.user_retention_6weeks is missing from ERP->ALTER TABLE<-
test.kiosk_serial_20190916 is missing from ERP->ALTER TABLE<-
aws_dms.awsdms_suspended_tables is missing from ERP->ALTER TABLE<-
public.dp_kiosks is missing from ERP->ALTER TABLE<-
mixalot.temp_test is missing from ERP->ALTER TABLE<-
public.sys_slow_queries is missing from ERP->ALTER TABLE<-
fnrenames.tag_id_seq is missing from ERP->ALTER TABLE<-
inm_backup.product_property is missing from ERP->ALTER TABLE<-
inm_beta.product_property is missing from ERP->ALTER TABLE<-
inm_test.test_hours is missing from ERP->ALTER TABLE<-
public.spoilagepct_by_shelflife_45d is missing from ERP->ALTER TABLE<-
beta.temp_sync_label_2018_12_13 is missing from ERP->ALTER TABLE<-
pantry.permission_mapping is missing from ERP->ALTER TABLE<-
public.sales_by_shelflife_30d is missing from ERP->ALTER TABLE<-
pantry.tmp_payment_order_with_id is missing from ERP->ALTER TABLE<-
public.byte_epcssold_8weeks is missing from ERP->ALTER TABLE<-
public.cogs_by_category_120d is missing from ERP->ALTER TABLE<-
mixalot.kiosk_restriction_by_sku is missing from ERP->ALTER TABLE<-
pantry.cron is missing from ERP->ALTER TABLE<-
pantry.history_kiosk_attribute is missing from ERP->ALTER TABLE<-
public.byte_inventory_current is missing from ERP->ALTER TABLE<-
public.byte_spoilage_by_category_week_newold is missing from ERP->ALTER TABLE<-
public.dp_stockouts_2017 is missing from ERP->ALTER TABLE<-
public.user_retention_2weeks is missing from ERP->ALTER TABLE<-
mixalot.pgdu_bytes is missing from ERP->ALTER TABLE<-
mixalot.v_node_kiosk_request_log is missing from ERP->ALTER TABLE<-
pantry.event_id_seq is missing from ERP->ALTER TABLE<-
pantry.order_meta_id_seq is missing from ERP->ALTER TABLE<-
test.campus_20190605 is missing from ERP->ALTER TABLE<-
test.transactions_pending_sync is missing from ERP->ALTER TABLE<-
public.stockout_runs_weighted is missing from ERP->ALTER TABLE<-
public.dp_spoilage_monthly_calc is missing from ERP->ALTER TABLE<-
mixalot.server is missing from ERP->ALTER TABLE<-
pantry.tmp_backup_order_before_05_03_process_will is missing from ERP->ALTER TABLE<-
pantry.transact_express_id_seq is missing from ERP->ALTER TABLE<-
public.byte_users_multiple_fridges is missing from ERP->ALTER TABLE<-
public.byte_raw_orders is missing from ERP->ALTER TABLE<-
public.byte_spoilage_by_week is missing from ERP->ALTER TABLE<-
public.byte_stockouts_by_category_week_crosstab is missing from ERP->ALTER TABLE<-
public.dp_epcssold is missing from ERP->ALTER TABLE<-
beta.temp_test is missing from ERP->ALTER TABLE<-
develop.label_order is missing from ERP->ALTER TABLE<-
develop."order" is missing from ERP->ALTER TABLE<-
public.byte_epcssold_1year is missing from ERP->ALTER TABLE<-
pantry.currency_symbol_id_seq is missing from ERP->ALTER TABLE<-
public.byte_tickets_45days is missing from ERP->ALTER TABLE<-
public.byte_spoilage_by_category_week is missing from ERP->ALTER TABLE<-
public.byte_tickets_2months is missing from ERP->ALTER TABLE<-
public.byte_kiosks_date_non_new is missing from ERP->ALTER TABLE<-
public.byte_tickets_labels is missing from ERP->ALTER TABLE<-
public.dp_spoilage_8weeks is missing from ERP->ALTER TABLE<-
develop.transact_cs is missing from ERP->ALTER TABLE<-
inm.sku_property_def is missing from ERP->ALTER TABLE<-
public.user_retention_4months is missing from ERP->ALTER TABLE<-
test.kiosk is missing from ERP->ALTER TABLE<-
test.request_log_epc_order is missing from ERP->ALTER TABLE<-
public.byte_tickets_4months is missing from ERP->ALTER TABLE<-
public.byte_epcssold_5days is missing from ERP->ALTER TABLE<-
inm_beta.kiosk_sku_group_manual_scale is missing from ERP->ALTER TABLE<-
pantry.accounting_id_seq is missing from ERP->ALTER TABLE<-
test.locked_kiosk_via_pw is missing from ERP->ALTER TABLE<-
pantry.product_stats_by_kiosk is missing from ERP->ALTER TABLE<-
public.sales_by_shelflife_45d is missing from ERP->ALTER TABLE<-
test.backup_eng_2669_order is missing from ERP->ALTER TABLE<-
inm_backup.kiosk_control is missing from ERP->ALTER TABLE<-
inm_backup.pick_inventory is missing from ERP->ALTER TABLE<-
inm_beta.kiosk_control is missing from ERP->ALTER TABLE<-
public.dp_spoilage_daily_kiosk_product_pct is missing from ERP->ALTER TABLE<-
develop.role_mapping is missing from ERP->ALTER TABLE<-
fnrenames.a is missing from ERP->ALTER TABLE<-
inm_backup.pick_demand is missing from ERP->ALTER TABLE<-
pantry.temp_kiosk_backup is missing from ERP->ALTER TABLE<-
mixalot.lineitem_id_seq is missing from ERP->ALTER TABLE<-
pantry.kiosks_date_non_new_id_seq is missing from ERP->ALTER TABLE<-
public.spoilage_by_shelflife_45d is missing from ERP->ALTER TABLE<-
develop.sessions is missing from ERP->ALTER TABLE<-
inm_beta.kiosk_product_disabled is missing from ERP->ALTER TABLE<-
public.user_retention_12weeks is missing from ERP->ALTER TABLE<-
public.user_retention_1month is missing from ERP->ALTER TABLE<-
develop.fee_rates is missing from ERP->ALTER TABLE<-
public.byte_tickets_360days is missing from ERP->ALTER TABLE<-
public.byte_epcssold_5weeks is missing from ERP->ALTER TABLE<-
public.dp_spoilage_weekly_kiosk_product_pct is missing from ERP->ALTER TABLE<-
test.kiosk_20190605 is missing from ERP->ALTER TABLE<-
iplanner.facing_category_v1 is missing from ERP->ALTER TABLE<-
pantry.kiosk_attribute_id_seq is missing from ERP->ALTER TABLE<-
public.byte_tickets_30days is missing from ERP->ALTER TABLE<-
public.byte_epcssold_2days is missing from ERP->ALTER TABLE<-
public.byte_stockouts is missing from ERP->ALTER TABLE<-
public.dp_stockouts_2016 is missing from ERP->ALTER TABLE<-
inm.temp_pick_order is missing from ERP->ALTER TABLE<-
inm_test.route_stop is missing from ERP->ALTER TABLE<-
mixalot.temp_kiosk_restriction is missing from ERP->ALTER TABLE<-
pantry.global_attribute_def_id_seq is missing from ERP->ALTER TABLE<-
pantry.tmp_may4_pricefinalize_order_fixes is missing from ERP->ALTER TABLE<-
public.byte_kp_oos_grid is missing from ERP->ALTER TABLE<-
public.dp_stockouts_weekly_calc is missing from ERP->ALTER TABLE<-
fnrenames.tmp_payment_information is missing from ERP->ALTER TABLE<-
mixalot.discount_rule is missing from ERP->ALTER TABLE<-
pantry.kiosk_device_id_seq is missing from ERP->ALTER TABLE<-
pantry.tmp_may4_error_order_fixes is missing from ERP->ALTER TABLE<-
	ALTER TABLE : 777
IOT->ERP
	missing v1: 0
	missing v2: 909
	Totaling : 1176


erp.fcm_repeater is missing from IOT->CREATE TABLE<-
dw.dim_campus is missing from IOT->CREATE TABLE<-
erp_test.product_property is missing from IOT->CREATE TABLE<-
inm_restore_0625.kiosk_restriction_by_property_gs is missing from IOT->CREATE TABLE<-
erp.global_attribute_def is missing from IOT->CREATE TABLE<-
erp.product is missing from IOT->CREATE TABLE<-
test.fact_daily_campus_87 is missing from IOT->CREATE TABLE<-
erp.contact is missing from IOT->CREATE TABLE<-
erp.kiosk_contact is missing from IOT->CREATE TABLE<-
erp_backup.product_property is missing from IOT->CREATE TABLE<-
fnrenames.awsdms_apply_exceptions is missing from IOT->CREATE TABLE<-
inm_test.kiosk_sku_group_manual_scale_20190624 is missing from IOT->CREATE TABLE<-
erp.product_pricing is missing from IOT->CREATE TABLE<-
pantry.temp_kiosk is missing from IOT->CREATE TABLE<-
erp_test.global_attribute_def is missing from IOT->CREATE TABLE<-
inm_restore_0625.kiosk_restriction_by_property is missing from IOT->CREATE TABLE<-
erp.classic_product_allergen_tag is missing from IOT->CREATE TABLE<-
erp.kiosk_access_card is missing from IOT->CREATE TABLE<-
erp_test.client is missing from IOT->CREATE TABLE<-
erp_test.client_contact is missing from IOT->CREATE TABLE<-
erp_test.product is missing from IOT->CREATE TABLE<-
inm.warehouse_order_history is missing from IOT->CREATE TABLE<-
erp_backup.address is missing from IOT->CREATE TABLE<-
erp_backup.product_property_def is missing from IOT->CREATE TABLE<-
inm_test.temp_a is missing from IOT->CREATE TABLE<-
erp.product_nutrition is missing from IOT->CREATE TABLE<-
erp_test.product_pricing is missing from IOT->CREATE TABLE<-
inm_test.bkup_kiosk_product_disabled_20190408 is missing from IOT->CREATE TABLE<-
erp.kiosk_restriction_by_product is missing from IOT->CREATE TABLE<-
inm_restore_0625.sku_group_control is missing from IOT->CREATE TABLE<-
inm_test.odd_id is missing from IOT->CREATE TABLE<-
erp_test.sku_group is missing from IOT->CREATE TABLE<-
inm_test.test_sequence is missing from IOT->CREATE TABLE<-
test.fact_monthly_kiosk_summary is missing from IOT->CREATE TABLE<-
erp_test.address is missing from IOT->CREATE TABLE<-
erp_test.kiosk_status is missing from IOT->CREATE TABLE<-
erp.kiosk_attribute is missing from IOT->CREATE TABLE<-
migration.product is missing from IOT->CREATE TABLE<-
public.product_fact is missing from IOT->CREATE TABLE<-
inm_restore_0625.kiosk_sku_group_manual_scale is missing from IOT->CREATE TABLE<-
inm_test.label is missing from IOT->CREATE TABLE<-
inm.route_stop is missing from IOT->CREATE TABLE<-
erp.kiosk_delivery_window is missing from IOT->CREATE TABLE<-
erp.product_asset is missing from IOT->CREATE TABLE<-
inm.product_pick_order_temp is missing from IOT->CREATE TABLE<-
inm_test.test2 is missing from IOT->CREATE TABLE<-
test.kiosk_log is missing from IOT->CREATE TABLE<-
dw.dim_product is missing from IOT->CREATE TABLE<-
erp.tag_order_stats is missing from IOT->CREATE TABLE<-
inm_test.route_stop_20190616 is missing from IOT->CREATE TABLE<-
inm_test.temp_test is missing from IOT->CREATE TABLE<-
erp.classic_product_category_tag is missing from IOT->CREATE TABLE<-
erp.tag_price is missing from IOT->CREATE TABLE<-
test.fact_daily_kiosk_sku_summary is missing from IOT->CREATE TABLE<-
erp_test.client_industry is missing from IOT->CREATE TABLE<-
public.history_order_pipeline is missing from IOT->CREATE TABLE<-
public.bak_awsdms_validation_failures_v1 is missing from IOT->CREATE TABLE<-
erp_backup.contact is missing from IOT->CREATE TABLE<-
inm_restore_0625.product_property is missing from IOT->CREATE TABLE<-
inm_test.kiosk_projected_stock is missing from IOT->CREATE TABLE<-
erp_test.product_nutrition is missing from IOT->CREATE TABLE<-
migration.temp_product is missing from IOT->CREATE TABLE<-
dw.dim_date is missing from IOT->CREATE TABLE<-
erp_test.contact is missing from IOT->CREATE TABLE<-
erp_test.kiosk is missing from IOT->CREATE TABLE<-
dw.fact_daily_kiosk_sku_summary is missing from IOT->CREATE TABLE<-
inm_restore_0625.kiosk_control is missing from IOT->CREATE TABLE<-
erp_test.product_asset is missing from IOT->CREATE TABLE<-
inm_restore_0625.kiosk_sku_group_manual_scale_gs is missing from IOT->CREATE TABLE<-
erp.kiosk_status is missing from IOT->CREATE TABLE<-
migration.kiosk is missing from IOT->CREATE TABLE<-
erp_backup.hardware_software is missing from IOT->CREATE TABLE<-
inm_restore_0625.diff_kiosk_control is missing from IOT->CREATE TABLE<-
inm_test.temp_b is missing from IOT->CREATE TABLE<-
pantry.awsdms_apply_exceptions is missing from IOT->CREATE TABLE<-
erp_backup.kiosk_note is missing from IOT->CREATE TABLE<-
erp_test.kiosk_accounting is missing from IOT->CREATE TABLE<-
inm_restore_0625.diff_kiosk_restriction_by_property is missing from IOT->CREATE TABLE<-
inm_restore_0625.sku_group_control_gs is missing from IOT->CREATE TABLE<-
dw.fact_daily_byte_foods_summary is missing from IOT->CREATE TABLE<-
fnrenames.awsdms_validation_failures_v1 is missing from IOT->CREATE TABLE<-
inm_restore_0625.diff_kiosk_sku_group_manual_scale is missing from IOT->CREATE TABLE<-
erp.client_campus is missing from IOT->CREATE TABLE<-
erp.sku_group is missing from IOT->CREATE TABLE<-
erp_test.kiosk_contact is missing from IOT->CREATE TABLE<-
erp.product_category is missing from IOT->CREATE TABLE<-
erp.client_contact is missing from IOT->CREATE TABLE<-
erp_backup.kiosk is missing from IOT->CREATE TABLE<-
erp_test.client_campus is missing from IOT->CREATE TABLE<-
erp_backup.kiosk_accounting is missing from IOT->CREATE TABLE<-
erp.product_category_def is missing from IOT->CREATE TABLE<-
inm_restore_0625.product_property_gs is missing from IOT->CREATE TABLE<-
dw.fact_monthly_kiosk_summary is missing from IOT->CREATE TABLE<-
erp_backup.client is missing from IOT->CREATE TABLE<-
pantry.temp_product is missing from IOT->CREATE TABLE<-
erp.product_property is missing from IOT->CREATE TABLE<-
migration.reverse_product is missing from IOT->CREATE TABLE<-
erp.address is missing from IOT->CREATE TABLE<-
erp.client is missing from IOT->CREATE TABLE<-
dw.dim_kiosk is missing from IOT->CREATE TABLE<-
erp.tag_order is missing from IOT->CREATE TABLE<-
erp.awsdms_apply_exceptions is missing from IOT->CREATE TABLE<-
erp_test.product_handling is missing from IOT->CREATE TABLE<-
erp_test.kiosk_note is missing from IOT->CREATE TABLE<-
public.bak_awsdms_apply_exceptions is missing from IOT->CREATE TABLE<-
erp.kiosk_note is missing from IOT->CREATE TABLE<-
erp.tag_type is missing from IOT->CREATE TABLE<-
inm.product_pick_order is missing from IOT->CREATE TABLE<-
inm_test.bkup_kiosk_product_disabled is missing from IOT->CREATE TABLE<-
inm.kiosk_restriction_by_product_ed is missing from IOT->CREATE TABLE<-
erp.product_handling is missing from IOT->CREATE TABLE<-
test.pick_priority_kiosk is missing from IOT->CREATE TABLE<-
erp_test.kiosk_audit is missing from IOT->CREATE TABLE<-
inm_test.bkup_kiosk_restriction_by_product is missing from IOT->CREATE TABLE<-
test.kiosk_20190528 is missing from IOT->CREATE TABLE<-
test.remittance_history is missing from IOT->CREATE TABLE<-
erp.hardware_software is missing from IOT->CREATE TABLE<-
inm_restore_0625.kiosk_control_gs is missing from IOT->CREATE TABLE<-
erp.product_property_def is missing from IOT->CREATE TABLE<-
erp_test.product_sourcing is missing from IOT->CREATE TABLE<-
erp.kiosk is missing from IOT->CREATE TABLE<-
inm_test.even_id is missing from IOT->CREATE TABLE<-
inm_test."order" is missing from IOT->CREATE TABLE<-
erp.client_industry is missing from IOT->CREATE TABLE<-
erp.product_property_tag is missing from IOT->CREATE TABLE<-
dw.fact_monthly_byte_foods_summary is missing from IOT->CREATE TABLE<-
erp.kiosk_accounting is missing from IOT->CREATE TABLE<-
erp.kiosk_restriction_by_property is missing from IOT->CREATE TABLE<-
erp.product_sourcing is missing from IOT->CREATE TABLE<-
erp_test.hardware_software is missing from IOT->CREATE TABLE<-
	CREATE TABLE : 231
erp.v_campus_list is missing from IOT->ALTER TABLE<-
erp.fcm_repeater is missing from IOT->ALTER TABLE<-
erp.kiosk_restriction_by_product is missing from IOT->ALTER TABLE<-
fnrenames.v_warehouse_ordering_rec is missing from IOT->ALTER TABLE<-
inm.v_warehouse_order_delivered_totals is missing from IOT->ALTER TABLE<-
campus_87."order" is missing from IOT->ALTER TABLE<-
erp_test.kiosk_status is missing from IOT->ALTER TABLE<-
erp_test.product_asset is missing from IOT->ALTER TABLE<-
inm_restore_0625.kiosk_control_gs is missing from IOT->ALTER TABLE<-
erp_backup.product_property_def is missing from IOT->ALTER TABLE<-
inm_test.bkup_kiosk_product_disabled_20190408 is missing from IOT->ALTER TABLE<-
inm_test.temp_b is missing from IOT->ALTER TABLE<-
pantry.temp_product is missing from IOT->ALTER TABLE<-
erp_test.client_campus is missing from IOT->ALTER TABLE<-
erp_test.contact is missing from IOT->ALTER TABLE<-
inm_test.kiosk_sku_group_manual_scale_20190624 is missing from IOT->ALTER TABLE<-
inm_test.odd_id is missing from IOT->ALTER TABLE<-
campus_87.pick_preference_kiosk_sku is missing from IOT->ALTER TABLE<-
inm.product_pick_order_temp is missing from IOT->ALTER TABLE<-
inm_restore_0625.diff_kiosk_control is missing from IOT->ALTER TABLE<-
inm_test.even_id is missing from IOT->ALTER TABLE<-
test.sync_qa_kiosk_erp is missing from IOT->ALTER TABLE<-
erp.product_property_tag is missing from IOT->ALTER TABLE<-
erp_backup.client is missing from IOT->ALTER TABLE<-
inm_test.test_sequence is missing from IOT->ALTER TABLE<-
mixalot.history_order_pipeline_id_seq is missing from IOT->ALTER TABLE<-
campus_87.pick_demand is missing from IOT->ALTER TABLE<-
campus_87.sku_group_control is missing from IOT->ALTER TABLE<-
campus_87.pick_rejection is missing from IOT->ALTER TABLE<-
campus_87.pick_list is missing from IOT->ALTER TABLE<-
erp.v_product is missing from IOT->ALTER TABLE<-
inm_test.bkup_kiosk_restriction_by_product is missing from IOT->ALTER TABLE<-
pantry.awsdms_apply_exceptions is missing from IOT->ALTER TABLE<-
erp.tag_type is missing from IOT->ALTER TABLE<-
erp.client_industry is missing from IOT->ALTER TABLE<-
migration.kiosk_dest_to_match is missing from IOT->ALTER TABLE<-
migration.v_product is missing from IOT->ALTER TABLE<-
test.pick_priority_kiosk is missing from IOT->ALTER TABLE<-
campus_87.pick_route is missing from IOT->ALTER TABLE<-
erp_test.product_handling is missing from IOT->ALTER TABLE<-
campus_87.route_stop is missing from IOT->ALTER TABLE<-
erp.kiosk_status is missing from IOT->ALTER TABLE<-
erp.sku_group is missing from IOT->ALTER TABLE<-
campus_87.kiosk is missing from IOT->ALTER TABLE<-
campus_87.product_property is missing from IOT->ALTER TABLE<-
dw.dim_kiosk is missing from IOT->ALTER TABLE<-
erp_backup.kiosk_note is missing from IOT->ALTER TABLE<-
test.remittance_history is missing from IOT->ALTER TABLE<-
campus_87.kiosk_control is missing from IOT->ALTER TABLE<-
erp.client is missing from IOT->ALTER TABLE<-
erp.client_contact is missing from IOT->ALTER TABLE<-
erp.product is missing from IOT->ALTER TABLE<-
erp.product_nutrition is missing from IOT->ALTER TABLE<-
erp.tag_price is missing from IOT->ALTER TABLE<-
erp_test.client is missing from IOT->ALTER TABLE<-
dw.fact_monthly_byte_foods_summary is missing from IOT->ALTER TABLE<-
public.history_order_pipeline is missing from IOT->ALTER TABLE<-
erp.kiosk_attribute is missing from IOT->ALTER TABLE<-
erp_backup.contact is missing from IOT->ALTER TABLE<-
inm_test.temp_a is missing from IOT->ALTER TABLE<-
migration.kiosk is missing from IOT->ALTER TABLE<-
dw.last_15_months is missing from IOT->ALTER TABLE<-
dw.fact_daily_byte_foods_summary is missing from IOT->ALTER TABLE<-
erp_backup.address is missing from IOT->ALTER TABLE<-
erp_test.product_nutrition is missing from IOT->ALTER TABLE<-
inm_test.even_id_seq is missing from IOT->ALTER TABLE<-
dw.fact_daily_kiosk_sku_summary is missing from IOT->ALTER TABLE<-
inm_test.label is missing from IOT->ALTER TABLE<-
inm_restore_0625.kiosk_restriction_by_property_gs is missing from IOT->ALTER TABLE<-
erp.product_classic_view is missing from IOT->ALTER TABLE<-
erp_test.sku_group is missing from IOT->ALTER TABLE<-
erp_backup.product_property is missing from IOT->ALTER TABLE<-
inm_restore_0625.sku_group_control_gs is missing from IOT->ALTER TABLE<-
migration.product is missing from IOT->ALTER TABLE<-
erp.fcm_repeater_id_seq is missing from IOT->ALTER TABLE<-
erp_test.kiosk_contact is missing from IOT->ALTER TABLE<-
inm_test.route_stop_20190616 is missing from IOT->ALTER TABLE<-
campus_87.fact_daily_kiosk_sku_summary is missing from IOT->ALTER TABLE<-
inm_restore_0625.kiosk_control is missing from IOT->ALTER TABLE<-
dw.fact_monthly_kiosk_summary is missing from IOT->ALTER TABLE<-
erp.address is missing from IOT->ALTER TABLE<-
erp.v_tag_order_list is missing from IOT->ALTER TABLE<-
campus_87.label is missing from IOT->ALTER TABLE<-
erp_test.client_industry is missing from IOT->ALTER TABLE<-
erp.awsdms_apply_exceptions is missing from IOT->ALTER TABLE<-
erp.tag_order_stats is missing from IOT->ALTER TABLE<-
inm_restore_0625.kiosk_restriction_by_property is missing from IOT->ALTER TABLE<-
dw.dim_date is missing from IOT->ALTER TABLE<-
dw.last_30_days is missing from IOT->ALTER TABLE<-
inm_restore_0625.sku_group_control is missing from IOT->ALTER TABLE<-
migration.sync_qa_product_source is missing from IOT->ALTER TABLE<-
campus_87.kiosk_restriction_by_product_ed is missing from IOT->ALTER TABLE<-
erp.kiosk_delivery_window is missing from IOT->ALTER TABLE<-
erp.product_property is missing from IOT->ALTER TABLE<-
erp_backup.product_classic_view is missing from IOT->ALTER TABLE<-
migration.reverse_product is missing from IOT->ALTER TABLE<-
campus_87.product is missing from IOT->ALTER TABLE<-
erp.v_client_list is missing from IOT->ALTER TABLE<-
erp.v_kiosk_inventory is missing from IOT->ALTER TABLE<-
dw.last_15_weeks is missing from IOT->ALTER TABLE<-
erp_test.global_attribute_def is missing from IOT->ALTER TABLE<-
inm.warehouse_order_history is missing from IOT->ALTER TABLE<-
erp.product_handling is missing from IOT->ALTER TABLE<-
fnrenames.awsdms_apply_exceptions is missing from IOT->ALTER TABLE<-
inm.product_picking_order is missing from IOT->ALTER TABLE<-
migration.sync_qa_product_dest is missing from IOT->ALTER TABLE<-
campus_87.campus is missing from IOT->ALTER TABLE<-
campus_87.product_property_def is missing from IOT->ALTER TABLE<-
erp_test.hardware_software is missing from IOT->ALTER TABLE<-
test.sync_qa_kiosk_before_2way is missing from IOT->ALTER TABLE<-
campus_87.pick_allocation is missing from IOT->ALTER TABLE<-
erp_test.kiosk is missing from IOT->ALTER TABLE<-
test.kiosk_log is missing from IOT->ALTER TABLE<-
campus_87.dim_date is missing from IOT->ALTER TABLE<-
erp.classic_product_allergen_tag is missing from IOT->ALTER TABLE<-
erp.v_transaction_list is missing from IOT->ALTER TABLE<-
erp_backup.kiosk_accounting is missing from IOT->ALTER TABLE<-
inm_test.test2 is missing from IOT->ALTER TABLE<-
dw.dim_product is missing from IOT->ALTER TABLE<-
erp_backup.hardware_software is missing from IOT->ALTER TABLE<-
mixalot.inm_kiosk_projected_stock is missing from IOT->ALTER TABLE<-
erp.kiosk_contact is missing from IOT->ALTER TABLE<-
erp_backup.kiosk is missing from IOT->ALTER TABLE<-
erp_test.kiosk_note is missing from IOT->ALTER TABLE<-
mixalot.sku_property_def_id_seq is missing from IOT->ALTER TABLE<-
test.fact_daily_kiosk_sku_summary is missing from IOT->ALTER TABLE<-
campus_87.warehouse_inventory is missing from IOT->ALTER TABLE<-
test.sync_qa_kiosk_iotmaster is missing from IOT->ALTER TABLE<-
campus_87.kiosk_sku_group_manual_scale is missing from IOT->ALTER TABLE<-
campus_87.sku_group_attribute is missing from IOT->ALTER TABLE<-
erp_test.client_contact is missing from IOT->ALTER TABLE<-
inm_test.bkup_kiosk_product_disabled is missing from IOT->ALTER TABLE<-
erp.kiosk_restriction_by_property is missing from IOT->ALTER TABLE<-
inm_restore_0625.kiosk_sku_group_manual_scale_gs is missing from IOT->ALTER TABLE<-
erp.product_sourcing is missing from IOT->ALTER TABLE<-
erp.v_kiosk_options is missing from IOT->ALTER TABLE<-
pantry.temp_kiosk is missing from IOT->ALTER TABLE<-
dw.current_inventory is missing from IOT->ALTER TABLE<-
campus_87.warehouse_order_history is missing from IOT->ALTER TABLE<-
erp_test.product_property is missing from IOT->ALTER TABLE<-
fnrenames.awsdms_validation_failures_v1 is missing from IOT->ALTER TABLE<-
erp.product_pricing is missing from IOT->ALTER TABLE<-
erp.v_product_list is missing from IOT->ALTER TABLE<-
erp_test.product_pricing is missing from IOT->ALTER TABLE<-
test.fact_monthly_kiosk_summary is missing from IOT->ALTER TABLE<-
inm.kiosk_restriction_by_product_ed is missing from IOT->ALTER TABLE<-
dw.non_byte_current_inventory is missing from IOT->ALTER TABLE<-
erp.classic_product_category_tag is missing from IOT->ALTER TABLE<-
erp_test.kiosk_classic_view is missing from IOT->ALTER TABLE<-
inm_test.kiosk_classic_view is missing from IOT->ALTER TABLE<-
campus_87.pick_inventory is missing from IOT->ALTER TABLE<-
migration.temp_product is missing from IOT->ALTER TABLE<-
erp_test.kiosk_audit is missing from IOT->ALTER TABLE<-
erp.kiosk_access_card is missing from IOT->ALTER TABLE<-
erp.product_property_def is missing from IOT->ALTER TABLE<-
erp.tag_order is missing from IOT->ALTER TABLE<-
dw.byte_current_inventory is missing from IOT->ALTER TABLE<-
inm_restore_0625.diff_kiosk_restriction_by_property is missing from IOT->ALTER TABLE<-
inm_restore_0625.product_property_gs is missing from IOT->ALTER TABLE<-
erp.client_campus is missing from IOT->ALTER TABLE<-
erp.kiosk_accounting is missing from IOT->ALTER TABLE<-
public.bak_awsdms_validation_failures_v1 is missing from IOT->ALTER TABLE<-
public.product_fact is missing from IOT->ALTER TABLE<-
campus_87.byte_feedback_monthly is missing from IOT->ALTER TABLE<-
dw.dim_campus is missing from IOT->ALTER TABLE<-
erp.contact is missing from IOT->ALTER TABLE<-
erp.kiosk_note is missing from IOT->ALTER TABLE<-
erp.kiosk_classic_view is missing from IOT->ALTER TABLE<-
campus_87.kiosk_restriction_by_property is missing from IOT->ALTER TABLE<-
public.product_fact_id_seq is missing from IOT->ALTER TABLE<-
inm.route_stop is missing from IOT->ALTER TABLE<-
erp.v_kiosk_list is missing from IOT->ALTER TABLE<-
inm_test."order" is missing from IOT->ALTER TABLE<-
inm_test.even_id_id_seq is missing from IOT->ALTER TABLE<-
erp.kiosk is missing from IOT->ALTER TABLE<-
erp.v_warehouse_inventory is missing from IOT->ALTER TABLE<-
dw.export_inventory_lots is missing from IOT->ALTER TABLE<-
erp.product_asset is missing from IOT->ALTER TABLE<-
erp.v_kiosk_heartbeat is missing from IOT->ALTER TABLE<-
campus_87.pick_priority_sku is missing from IOT->ALTER TABLE<-
inm_test.temp_test is missing from IOT->ALTER TABLE<-
public.history_order_pipeline_id_seq is missing from IOT->ALTER TABLE<-
erp.product_category_tag is missing from IOT->ALTER TABLE<-
erp.v_kiosk is missing from IOT->ALTER TABLE<-
public.bak_awsdms_apply_exceptions is missing from IOT->ALTER TABLE<-
campus_87.pick_priority_kiosk is missing from IOT->ALTER TABLE<-
campus_87.kiosk_restriction_by_product is missing from IOT->ALTER TABLE<-
erp.global_attribute_def is missing from IOT->ALTER TABLE<-
erp.hardware_software is missing from IOT->ALTER TABLE<-
erp_test.product_sourcing is missing from IOT->ALTER TABLE<-
inm_restore_0625.kiosk_sku_group_manual_scale is missing from IOT->ALTER TABLE<-
test.kiosk_20190528 is missing from IOT->ALTER TABLE<-
dw.last_30_days_kpis is missing from IOT->ALTER TABLE<-
erp.product_category is missing from IOT->ALTER TABLE<-
erp.v_product_options is missing from IOT->ALTER TABLE<-
inm_restore_0625.product_property is missing from IOT->ALTER TABLE<-
test.fact_daily_campus_87 is missing from IOT->ALTER TABLE<-
dw.monthly_kpis is missing from IOT->ALTER TABLE<-
erp.v_client is missing from IOT->ALTER TABLE<-
erp.v_sku_group_list is missing from IOT->ALTER TABLE<-
erp_test.kiosk_accounting is missing from IOT->ALTER TABLE<-
erp_test.product is missing from IOT->ALTER TABLE<-
erp.product_category_def is missing from IOT->ALTER TABLE<-
erp.v_transaction_detail is missing from IOT->ALTER TABLE<-
erp.v_warehouse_inventory_entry is missing from IOT->ALTER TABLE<-
erp_test.address is missing from IOT->ALTER TABLE<-
inm.product_pick_order is missing from IOT->ALTER TABLE<-
inm_restore_0625.diff_kiosk_sku_group_manual_scale is missing from IOT->ALTER TABLE<-
migration.kiosk_source_to_match is missing from IOT->ALTER TABLE<-
inm_test.kiosk_projected_stock is missing from IOT->ALTER TABLE<-
	ALTER TABLE : 376
ERP->IOT
	missing v1: 0
	missing v2: 340
	Totaling : 607

Writing file: Tables-IOT-To-ERP.sql
wrote 142120 bytes
Writing file: Tables-ERP-To-IOT.sql
wrote 58498 bytes
IOT ERP
public.byte_tickets_4days is missing from ERP->CREATE VIEW<-
public.byte_spoilage_by_sku_2months is missing from ERP->CREATE VIEW<-
public.dp_epcssold_2016 is missing from ERP->CREATE VIEW<-
public.dp_spoilage_monthly_calc is missing from ERP->CREATE VIEW<-
byt_devops.pgdu is missing from ERP->CREATE VIEW<-
inm.warehouse_ordering is missing from ERP->CREATE VIEW<-
public.byte_epcssold_10weeks is missing from ERP->CREATE VIEW<-
public.byte_epcssold_5days is missing from ERP->CREATE VIEW<-
public.byte_stockouts_by_category_week_newold is missing from ERP->CREATE VIEW<-
public.user_retention_12months is missing from ERP->CREATE VIEW<-
public.byte_epcssold_9months is missing from ERP->CREATE VIEW<-
mixalot.v_kiosk_inventory_log is missing from ERP->CREATE VIEW<-
public.byte_addicted_users_120days is missing from ERP->CREATE VIEW<-
public.byte_epcssold_1month is missing from ERP->CREATE VIEW<-
public.byte_epcssold_3days is missing from ERP->CREATE VIEW<-
public.dp_spoilage_weekly_sold_join is missing from ERP->CREATE VIEW<-
public.dp_spoilage_weekly_product_pct is missing from ERP->CREATE VIEW<-
public.user_retention_3weeks is missing from ERP->CREATE VIEW<-
byt_devops.pgdutotal is missing from ERP->CREATE VIEW<-
mixalot.v_kiosk_item_log is missing from ERP->CREATE VIEW<-
public.dp_spoilage_daily_sold_join is missing from ERP->CREATE VIEW<-
public.byte_spoilage_by_week is missing from ERP->CREATE VIEW<-
public.byte_stockouts_by_category_week is missing from ERP->CREATE VIEW<-
public.dp_spoilage_daily_kiosk_product_pct is missing from ERP->CREATE VIEW<-
public.dp_stockouts_weekly_pct is missing from ERP->CREATE VIEW<-
mixalot.inm_warehouse_sku_enabled is missing from ERP->CREATE VIEW<-
mixalot.kiosk_status is missing from ERP->CREATE VIEW<-
public.byte_epcssold_1day is missing from ERP->CREATE VIEW<-
public.byte_tickets_365days is missing from ERP->CREATE VIEW<-
public.sales_by_shelflife_120d is missing from ERP->CREATE VIEW<-
monitor.kiosk_not_heard is missing from ERP->CREATE VIEW<-
public.byte_epcssold_1week is missing from ERP->CREATE VIEW<-
public.byte_epcssold_6weeks is missing from ERP->CREATE VIEW<-
public.dp_spoilage_monthly_sold_join is missing from ERP->CREATE VIEW<-
public.byte_epcssold_4months is missing from ERP->CREATE VIEW<-
byt_devops.pgdu_pretty is missing from ERP->CREATE VIEW<-
public.byte_epcssold_180days is missing from ERP->CREATE VIEW<-
public.byte_stockouts_by_week is missing from ERP->CREATE VIEW<-
public.stockout_weighted is missing from ERP->CREATE VIEW<-
public.dp_spoilage_daily_product_pct is missing from ERP->CREATE VIEW<-
public.dp_stockouts_8weeks is missing from ERP->CREATE VIEW<-
public.spoilagepct_by_shelflife_30d is missing from ERP->CREATE VIEW<-
public.byte_kiosks_date_non_new is missing from ERP->CREATE VIEW<-
public.byte_label_product_fast is missing from ERP->CREATE VIEW<-
public.stockout_dowhours_weighted is missing from ERP->CREATE VIEW<-
public.byte_tickets_1week is missing from ERP->CREATE VIEW<-
public.user_retention_8weeks is missing from ERP->CREATE VIEW<-
public.byte_dc_inventory_history is missing from ERP->CREATE VIEW<-
public.spoilagepct_by_shelflife_45d is missing from ERP->CREATE VIEW<-
public.byte_tickets_60days is missing from ERP->CREATE VIEW<-
public.byte_kiosks_with_perm_subsidy is missing from ERP->CREATE VIEW<-
public.byte_users_products_4months is missing from ERP->CREATE VIEW<-
public.spoilage_by_category_120d is missing from ERP->CREATE VIEW<-
public.byte_epcssold_2016 is missing from ERP->CREATE VIEW<-
public.byte_spoilage_stockouts_by_week is missing from ERP->CREATE VIEW<-
iplanner.insync_kiosk_v1 is missing from ERP->CREATE VIEW<-
mixalot.v_node_kiosk_request_log is missing from ERP->CREATE VIEW<-
public.byte_epcssold_2015 is missing from ERP->CREATE VIEW<-
public.byte_epcssold_7days is missing from ERP->CREATE VIEW<-
public.byte_epcssold_90days is missing from ERP->CREATE VIEW<-
public.byte_restockings is missing from ERP->CREATE VIEW<-
public.sys_table_sizes is missing from ERP->CREATE VIEW<-
public.byte_tickets_90days is missing from ERP->CREATE VIEW<-
public.byte_inventory_current is missing from ERP->CREATE VIEW<-
public.dashboard_monthly_stats is missing from ERP->CREATE VIEW<-
public.dbg_stockout_weighted is missing from ERP->CREATE VIEW<-
mixalot.v_node_kiosk_status_log is missing from ERP->CREATE VIEW<-
public.byte_tickets_2months is missing from ERP->CREATE VIEW<-
public.dp_stockouts_2017 is missing from ERP->CREATE VIEW<-
public.user_retention_9months is missing from ERP->CREATE VIEW<-
public.dowhours is missing from ERP->CREATE VIEW<-
public.dp_spoilage_daily_kiosk_pct is missing from ERP->CREATE VIEW<-
mixalot.inm_kiosk_restriction_list is missing from ERP->CREATE VIEW<-
public.byte_tickets_4weeks is missing from ERP->CREATE VIEW<-
public.byte_tickets_7days is missing from ERP->CREATE VIEW<-
public.dp_spoilage_monthly_kiosk_product_pct is missing from ERP->CREATE VIEW<-
public.user_retention_10weeks is missing from ERP->CREATE VIEW<-
public.byte_tickets_2017 is missing from ERP->CREATE VIEW<-
public.byte_spoilage_by_category_week_all is missing from ERP->CREATE VIEW<-
public.dashboard_weekly_stats is missing from ERP->CREATE VIEW<-
byt_devops.pgdu_union_pretty is missing from ERP->CREATE VIEW<-
public.byte_tickets_180days is missing from ERP->CREATE VIEW<-
public.byte_inventory_current_lots is missing from ERP->CREATE VIEW<-
public.byte_epcssold_60days is missing from ERP->CREATE VIEW<-
public.dp_inventory_current is missing from ERP->CREATE VIEW<-
public.dp_spoilage_4weeks is missing from ERP->CREATE VIEW<-
public.byte_stockouts_by_category_week_all is missing from ERP->CREATE VIEW<-
public.sales_by_shelflife_45d is missing from ERP->CREATE VIEW<-
iplanner.facing_category_v1 is missing from ERP->CREATE VIEW<-
public.byte_epcssold_12months is missing from ERP->CREATE VIEW<-
public.stockout_dowhours is missing from ERP->CREATE VIEW<-
public.dp_spoilage_daily_pct is missing from ERP->CREATE VIEW<-
public.dp_spoilage_weekly_pct is missing from ERP->CREATE VIEW<-
public.kiosk_sales_by_dayofweek is missing from ERP->CREATE VIEW<-
public.user_retention_52weeks is missing from ERP->CREATE VIEW<-
public.user_retention_1month is missing from ERP->CREATE VIEW<-
mixalot.inm_dc_inventory is missing from ERP->CREATE VIEW<-
public.byte_restockings_labels is missing from ERP->CREATE VIEW<-
public.sys_slow_queries is missing from ERP->CREATE VIEW<-
public.date_hours_2016 is missing from ERP->CREATE VIEW<-
public.dp_stockouts_weekly_product_pct is missing from ERP->CREATE VIEW<-
mixalot.inm_byte_kiosk is missing from ERP->CREATE VIEW<-
public.byte_tickets_4months is missing from ERP->CREATE VIEW<-
public.dp_spoilage_monthly_pct is missing from ERP->CREATE VIEW<-
report.dependency is missing from ERP->CREATE VIEW<-
rptg.current_inventory is missing from ERP->CREATE VIEW<-
byt_devops.pgdudetail_pretty is missing from ERP->CREATE VIEW<-
public.byte_tickets_6days is missing from ERP->CREATE VIEW<-
public.byte_tickets_labels is missing from ERP->CREATE VIEW<-
public.dp_epcssold is missing from ERP->CREATE VIEW<-
beta.temp_test3 is missing from ERP->CREATE VIEW<-
inm.kiosk_projected_minimum is missing from ERP->CREATE VIEW<-
public.dbg_stockout_dowhours_weighted is missing from ERP->CREATE VIEW<-
byt_devops.pgdutotal_pretty is missing from ERP->CREATE VIEW<-
public.byte_spoilage is missing from ERP->CREATE VIEW<-
public.spoilagepct_by_shelflife_120d is missing from ERP->CREATE VIEW<-
public.byte_tickets_360days is missing from ERP->CREATE VIEW<-
public.byte_tickets_yesterday is missing from ERP->CREATE VIEW<-
public.dp_stockouts_weekly_sold_join is missing from ERP->CREATE VIEW<-
inm.view_sku_sku_group is missing from ERP->CREATE VIEW<-
public.byte_tickets_3weeks is missing from ERP->CREATE VIEW<-
public.dp_stockouts_weekly_kiosk_product_pct is missing from ERP->CREATE VIEW<-
public.byte_tickets_2016 is missing from ERP->CREATE VIEW<-
public.byte_epcssold_3weeks is missing from ERP->CREATE VIEW<-
public.stockout_avg_kiosk_cat_sales_dowhour is missing from ERP->CREATE VIEW<-
public.dbg_stockout_dowhours_weighted_stats is missing from ERP->CREATE VIEW<-
inm_beta.allocable_inventory is missing from ERP->CREATE VIEW<-
public.byte_tickets_5weeks is missing from ERP->CREATE VIEW<-
public.byte_epcssold_fast is missing from ERP->CREATE VIEW<-
public.byte_stockouts_by_category_week_crosstab is missing from ERP->CREATE VIEW<-
public.user_retention_4months is missing from ERP->CREATE VIEW<-
public.byte_epcssold_2days is missing from ERP->CREATE VIEW<-
public.byte_epcssold_30days is missing from ERP->CREATE VIEW<-
public.byte_tickets_today is missing from ERP->CREATE VIEW<-
public.user_retention_6weeks is missing from ERP->CREATE VIEW<-
public.byte_sales_by_week is missing from ERP->CREATE VIEW<-
public.byte_users_multiple_fridges is missing from ERP->CREATE VIEW<-
public.dp_epcssold_8weeks is missing from ERP->CREATE VIEW<-
public.dp_inventory_history is missing from ERP->CREATE VIEW<-
byte_pgdu.pgdudetail is missing from ERP->CREATE VIEW<-
public.sys_activity is missing from ERP->CREATE VIEW<-
public.byte_epcssold_2017 is missing from ERP->CREATE VIEW<-
public.spoilage_by_shelflife_45d is missing from ERP->CREATE VIEW<-
public.valid_bytecodes is missing from ERP->CREATE VIEW<-
public.byte_epcssold_8weeks is missing from ERP->CREATE VIEW<-
public.category_stats_120d is missing from ERP->CREATE VIEW<-
mixalot.pgdu_bytes is missing from ERP->CREATE VIEW<-
public.byte_tickets_1day is missing from ERP->CREATE VIEW<-
public.byte_spoilage_by_category_week_crosstab is missing from ERP->CREATE VIEW<-
public.latest_label_records is missing from ERP->CREATE VIEW<-
byt_devops.pgdu_union is missing from ERP->CREATE VIEW<-
public.byte_epcssold_4days is missing from ERP->CREATE VIEW<-
public.byte_tickets_8weeks is missing from ERP->CREATE VIEW<-
public.dp_spoilage_monthly_kiosk_pct is missing from ERP->CREATE VIEW<-
public.byte_tickets_1year is missing from ERP->CREATE VIEW<-
public.byte_epcssold_2weeks is missing from ERP->CREATE VIEW<-
public.byte_product_stats_by_kiosk is missing from ERP->CREATE VIEW<-
mixalot.v_kiosk_request_log is missing from ERP->CREATE VIEW<-
public.byte_stockouts is missing from ERP->CREATE VIEW<-
public.dp_stockouts_weekly_calc is missing from ERP->CREATE VIEW<-
public.dp_spoilage_8weeks is missing from ERP->CREATE VIEW<-
public.dp_spoilage_weekly_kiosk_product_pct is missing from ERP->CREATE VIEW<-
public.user_retention_12weeks is missing from ERP->CREATE VIEW<-
public.dp_epcssold_4weeks is missing from ERP->CREATE VIEW<-
public.byte_epcssold_45days is missing from ERP->CREATE VIEW<-
public.lastwk_hrs is missing from ERP->CREATE VIEW<-
public.byte_tickets_1month is missing from ERP->CREATE VIEW<-
public.byte_epcssold_2months is missing from ERP->CREATE VIEW<-
public.byte_tickets_6weeks is missing from ERP->CREATE VIEW<-
public.spoilage_by_shelflife_120d is missing from ERP->CREATE VIEW<-
public.byte_epcssold_120days is missing from ERP->CREATE VIEW<-
public.byte_tickets_45days is missing from ERP->CREATE VIEW<-
public.cogs_by_category_120d is missing from ERP->CREATE VIEW<-
public.byte_tickets_2days is missing from ERP->CREATE VIEW<-
public.dp_kiosks is missing from ERP->CREATE VIEW<-
public.dp_stockouts is missing from ERP->CREATE VIEW<-
public.dp_stockouts_weekly_kiosk_pct is missing from ERP->CREATE VIEW<-
public.user_retention_26weeks is missing from ERP->CREATE VIEW<-
public.byte_tickets_12months is missing from ERP->CREATE VIEW<-
public.byte_tickets_6months is missing from ERP->CREATE VIEW<-
public.byte_tickets_9months is missing from ERP->CREATE VIEW<-
public.dp_stockouts_4weeks is missing from ERP->CREATE VIEW<-
public.sales_by_shelflife_30d is missing from ERP->CREATE VIEW<-
public.user_retention_4weeks is missing from ERP->CREATE VIEW<-
byt_devops.pgdudetail is missing from ERP->CREATE VIEW<-
public.byte_tickets_2weeks is missing from ERP->CREATE VIEW<-
public.byte_spoilage_by_category_week_newold is missing from ERP->CREATE VIEW<-
public.dbg_stockout_runs_weighted is missing from ERP->CREATE VIEW<-
public.user_retention_2weeks is missing from ERP->CREATE VIEW<-
public.inventory_current_lots is missing from ERP->CREATE VIEW<-
public.byte_raw_orders is missing from ERP->CREATE VIEW<-
public.spoilage_by_shelflife_30d is missing from ERP->CREATE VIEW<-
public.byte_epcssold_365days is missing from ERP->CREATE VIEW<-
public.byte_tickets_3days is missing from ERP->CREATE VIEW<-
public.dp_spoilage is missing from ERP->CREATE VIEW<-
public.dp_spoilage_2017 is missing from ERP->CREATE VIEW<-
inm.kiosk_projected_stock_sku_level is missing from ERP->CREATE VIEW<-
mixalot.v_kiosk_status_log is missing from ERP->CREATE VIEW<-
public.byte_epcssold_360days is missing from ERP->CREATE VIEW<-
public.user_retention_6months is missing from ERP->CREATE VIEW<-
public.dp_epcssold_2015 is missing from ERP->CREATE VIEW<-
public.sys_conninfo is missing from ERP->CREATE VIEW<-
public.user_retention_2months is missing from ERP->CREATE VIEW<-
public.byte_tickets_10weeks is missing from ERP->CREATE VIEW<-
public.byte_epcssold_6months is missing from ERP->CREATE VIEW<-
public.byte_kiosks_by_week is missing from ERP->CREATE VIEW<-
public.byte_epcssold_6days is missing from ERP->CREATE VIEW<-
public.inventory_current is missing from ERP->CREATE VIEW<-
public.byte_spoilage_by_category_week is missing from ERP->CREATE VIEW<-
public.user_retention_3months is missing from ERP->CREATE VIEW<-
public.user_retention_1week is missing from ERP->CREATE VIEW<-
public.byte_epcssold_5weeks is missing from ERP->CREATE VIEW<-
public.sales_by_category_120d is missing from ERP->CREATE VIEW<-
mixalot.inm_kiosk_sku_disabled is missing from ERP->CREATE VIEW<-
pantry.tmp_process_order is missing from ERP->CREATE VIEW<-
public.byte_tickets_120days is missing from ERP->CREATE VIEW<-
public.dp_stockouts_2016 is missing from ERP->CREATE VIEW<-
public.dp_products is missing from ERP->CREATE VIEW<-
public.dp_spoilage_weekly_kiosk_pct is missing from ERP->CREATE VIEW<-
public.sys_uptime is missing from ERP->CREATE VIEW<-
public.user_retention_tickets is missing from ERP->CREATE VIEW<-
mixalot.inm_demand is missing from ERP->CREATE VIEW<-
mixalot.inm_sku_enabled is missing from ERP->CREATE VIEW<-
public.byte_tickets_30days is missing from ERP->CREATE VIEW<-
public.byte_epcssold_4weeks is missing from ERP->CREATE VIEW<-
public.byte_epcssold_1year is missing from ERP->CREATE VIEW<-
public.byte_tickets_2015 is missing from ERP->CREATE VIEW<-
public.dp_epcssold_2017 is missing from ERP->CREATE VIEW<-
public.stockout_runs_weighted is missing from ERP->CREATE VIEW<-
public.dbg_stockout_weighted_stats is missing from ERP->CREATE VIEW<-
public.dp_spoilage_2016 is missing from ERP->CREATE VIEW<-
public.byte_tickets_5days is missing from ERP->CREATE VIEW<-
public.dp_spoilage_monthly_product_pct is missing from ERP->CREATE VIEW<-
	CREATE VIEW : 270
IOT->ERP
	missing v1: 0
	missing v2: 233
	Totaling : 270


fnrenames.v_warehouse_ordering_rec is missing from IOT->CREATE VIEW<-
campus_87.kiosk_restriction_by_property is missing from IOT->CREATE VIEW<-
campus_87."order" is missing from IOT->CREATE VIEW<-
campus_87.pick_preference_kiosk_sku is missing from IOT->CREATE VIEW<-
campus_87.sku_group_attribute is missing from IOT->CREATE VIEW<-
erp.v_product_options is missing from IOT->CREATE VIEW<-
erp.v_transaction_detail is missing from IOT->CREATE VIEW<-
campus_87.byte_feedback_monthly is missing from IOT->CREATE VIEW<-
dw.export_inventory_lots is missing from IOT->CREATE VIEW<-
campus_87.pick_priority_sku is missing from IOT->CREATE VIEW<-
test.sync_qa_kiosk_iotmaster is missing from IOT->CREATE VIEW<-
erp.product_classic_view is missing from IOT->CREATE VIEW<-
erp.v_product_list is missing from IOT->CREATE VIEW<-
migration.sync_qa_product_dest is missing from IOT->CREATE VIEW<-
campus_87.pick_route is missing from IOT->CREATE VIEW<-
campus_87.label is missing from IOT->CREATE VIEW<-
dw.last_15_months is missing from IOT->CREATE VIEW<-
erp.v_kiosk_list is missing from IOT->CREATE VIEW<-
inm.product_picking_order is missing from IOT->CREATE VIEW<-
dw.last_30_days is missing from IOT->CREATE VIEW<-
dw.non_byte_current_inventory is missing from IOT->CREATE VIEW<-
erp_test.kiosk_classic_view is missing from IOT->CREATE VIEW<-
migration.kiosk_dest_to_match is missing from IOT->CREATE VIEW<-
campus_87.pick_list is missing from IOT->CREATE VIEW<-
campus_87.pick_rejection is missing from IOT->CREATE VIEW<-
campus_87.product_property_def is missing from IOT->CREATE VIEW<-
campus_87.route_stop is missing from IOT->CREATE VIEW<-
erp.v_campus_list is missing from IOT->CREATE VIEW<-
erp.v_kiosk_heartbeat is missing from IOT->CREATE VIEW<-
erp.v_warehouse_inventory_entry is missing from IOT->CREATE VIEW<-
mixalot.last_kiosk_status is missing from IOT->CREATE VIEW<-
campus_87.pick_allocation is missing from IOT->CREATE VIEW<-
migration.kiosk_source_to_match is missing from IOT->CREATE VIEW<-
campus_87.product is missing from IOT->CREATE VIEW<-
dw.byte_current_inventory is missing from IOT->CREATE VIEW<-
inm.sku_group is missing from IOT->CREATE VIEW<-
campus_87.product_property is missing from IOT->CREATE VIEW<-
dw.current_inventory is missing from IOT->CREATE VIEW<-
erp.v_client is missing from IOT->CREATE VIEW<-
dw.monthly_kpis is missing from IOT->CREATE VIEW<-
erp.v_product is missing from IOT->CREATE VIEW<-
test.sync_qa_kiosk_before_2way is missing from IOT->CREATE VIEW<-
campus_87.sku_group_control is missing from IOT->CREATE VIEW<-
erp.v_client_list is missing from IOT->CREATE VIEW<-
campus_87.kiosk_restriction_by_product_ed is missing from IOT->CREATE VIEW<-
erp.v_kiosk_inventory is missing from IOT->CREATE VIEW<-
inm_test.kiosk_classic_view is missing from IOT->CREATE VIEW<-
mixalot.inm_kiosk_projected_stock is missing from IOT->CREATE VIEW<-
erp.v_transaction_list is missing from IOT->CREATE VIEW<-
test.sync_qa_kiosk_erp is missing from IOT->CREATE VIEW<-
campus_87.fact_daily_kiosk_sku_summary is missing from IOT->CREATE VIEW<-
campus_87.pick_inventory is missing from IOT->CREATE VIEW<-
inm.v_warehouse_order_delivered_totals is missing from IOT->CREATE VIEW<-
campus_87.campus is missing from IOT->CREATE VIEW<-
campus_87.pick_demand is missing from IOT->CREATE VIEW<-
campus_87.warehouse_inventory is missing from IOT->CREATE VIEW<-
inm.kiosk_product_disabled is missing from IOT->CREATE VIEW<-
campus_87.dim_date is missing from IOT->CREATE VIEW<-
dw.last_30_days_kpis is missing from IOT->CREATE VIEW<-
campus_87.pick_priority_kiosk is missing from IOT->CREATE VIEW<-
erp.product_category_tag is missing from IOT->CREATE VIEW<-
erp.v_sku_group_list is missing from IOT->CREATE VIEW<-
campus_87.kiosk_restriction_by_product is missing from IOT->CREATE VIEW<-
campus_87.kiosk_sku_group_manual_scale is missing from IOT->CREATE VIEW<-
campus_87.warehouse_order_history is missing from IOT->CREATE VIEW<-
erp.kiosk_classic_view is missing from IOT->CREATE VIEW<-
campus_87.kiosk_control is missing from IOT->CREATE VIEW<-
erp.v_kiosk is missing from IOT->CREATE VIEW<-
erp.v_tag_order_list is missing from IOT->CREATE VIEW<-
erp_backup.product_classic_view is missing from IOT->CREATE VIEW<-
migration.v_product is missing from IOT->CREATE VIEW<-
campus_87.kiosk is missing from IOT->CREATE VIEW<-
dw.last_15_weeks is missing from IOT->CREATE VIEW<-
erp.v_kiosk_options is missing from IOT->CREATE VIEW<-
erp.v_warehouse_inventory is missing from IOT->CREATE VIEW<-
migration.sync_qa_product_source is missing from IOT->CREATE VIEW<-
	CREATE VIEW : 113
ERP->IOT
	missing v1: 0
	missing v2: 76
	Totaling : 113

Writing file: Views-IOT-To-ERP.sql
wrote 286733 bytes
Writing file: Views-ERP-To-IOT.sql
wrote 73730 bytes
IOT ERP
ON is missing from ERP->CREATE UNIQUE last_kiosk_status_id<-
	CREATE UNIQUE last_kiosk_status_id : 1
ON is missing from ERP->CREATE UNIQUE vantiv_20190801_referencenumber_idx<-
	CREATE UNIQUE vantiv_20190801_referencenumber_idx : 1
LANGUAGE is missing from ERP->CREATE OR PROCEDURAL<-
	CREATE OR PROCEDURAL : 1
	ALTER SEQUENCE : 1
ON is missing from ERP->CREATE UNIQUE awsdms_history_task_history_index<-
	CREATE UNIQUE awsdms_history_task_history_index : 1
ON is missing from ERP->CREATE UNIQUE awsdms_status_task_status_index<-
	CREATE UNIQUE awsdms_status_task_status_index : 1
ON is missing from ERP->CREATE UNIQUE awsdms_suspended_tables_task_suspended_tables_index<-
	CREATE UNIQUE awsdms_suspended_tables_task_suspended_tables_index : 1
public.byte_kp_sales is missing from ERP->CREATE INDEX ON<-
public.byte_kp_sales_avgdowhour is missing from ERP->CREATE INDEX ON<-
pantry.history_epc_order is missing from ERP->CREATE INDEX ON<-
pantry.inventory_request is missing from ERP->CREATE INDEX ON<-
pantry.tmp_payment_order_with_id is missing from ERP->CREATE INDEX ON<-
public.bytecodelog is missing from ERP->CREATE INDEX ON<-
mixalot.kiosk_restriction_by_property is missing from ERP->CREATE INDEX ON<-
mixalot.sku_property is missing from ERP->CREATE INDEX ON<-
pantry.product_stats_by_kiosk is missing from ERP->CREATE INDEX ON<-
mixalot.request_log is missing from ERP->CREATE INDEX ON<-
pantry.spoilage is missing from ERP->CREATE INDEX ON<-
pantry.stockout is missing from ERP->CREATE INDEX ON<-
public.byte_kp_grid is missing from ERP->CREATE INDEX ON<-
public.byte_kp_oos_avgdowhour is missing from ERP->CREATE INDEX ON<-
inm.sku_property is missing from ERP->CREATE INDEX ON<-
mixalot.kiosk_restriction_by_sku is missing from ERP->CREATE INDEX ON<-
	CREATE INDEX ON : 21
	GRANT ALL : 4
	GRANT SELECT : 1
	ALTER DEFAULT : 1
plperl is missing from ERP->ALTER PROCEDURAL<-
	ALTER PROCEDURAL : 1
pantry.facing_category_id_seq is missing from ERP->CREATE SEQUENCE<-
pantry.manual_adjustment_id_seq is missing from ERP->CREATE SEQUENCE<-
fnrenames.product_id_seq is missing from ERP->CREATE SEQUENCE<-
fnrenames.tag_id_seq is missing from ERP->CREATE SEQUENCE<-
pantry.component_history_id_seq is missing from ERP->CREATE SEQUENCE<-
pantry.transact_express_id_seq is missing from ERP->CREATE SEQUENCE<-
fnrenames.card_id_seq is missing from ERP->CREATE SEQUENCE<-
pantry.coupon_id_seq is missing from ERP->CREATE SEQUENCE<-
public."pantry.kiosk_id_seq" is missing from ERP->CREATE SEQUENCE<-
pantry.discount_id_seq is missing from ERP->CREATE SEQUENCE<-
pantry.user_id_seq is missing from ERP->CREATE SEQUENCE<-
pantry.kiosk_status_id_seq is missing from ERP->CREATE SEQUENCE<-
pantry.permission_id_seq is missing from ERP->CREATE SEQUENCE<-
pantry.tag_id_seq is missing from ERP->CREATE SEQUENCE<-
mixalot.server_id_seq is missing from ERP->CREATE SEQUENCE<-
pantry.kiosk_cd_id_seq is missing from ERP->CREATE SEQUENCE<-
fnrenames.kiosk_id_seq is missing from ERP->CREATE SEQUENCE<-
mixalot.product_kiosk_fact_id_seq is missing from ERP->CREATE SEQUENCE<-
pantry.cron_id_seq is missing from ERP->CREATE SEQUENCE<-
pantry.fee_rates_id_seq is missing from ERP->CREATE SEQUENCE<-
public.track_inventory_id_seq is missing from ERP->CREATE SEQUENCE<-
pantry.group_id_seq is missing from ERP->CREATE SEQUENCE<-
pantry.last_kiosk_status_id_seq is missing from ERP->CREATE SEQUENCE<-
public.campaigns_campaign_id_seq is missing from ERP->CREATE SEQUENCE<-
public.customers_customer_id_seq is missing from ERP->CREATE SEQUENCE<-
pantry.payment_order_id_seq is missing from ERP->CREATE SEQUENCE<-
beta.pick_demand_id_seq is missing from ERP->CREATE SEQUENCE<-
fnrenames.label_id_seq is missing from ERP->CREATE SEQUENCE<-
mixalot.lineitem_id_seq is missing from ERP->CREATE SEQUENCE<-
pantry.order_meta_id_seq is missing from ERP->CREATE SEQUENCE<-
pantry.product_kiosk_price_offset_id_seq is missing from ERP->CREATE SEQUENCE<-
fnrenames.history_id_seq is missing from ERP->CREATE SEQUENCE<-
pantry.role_id_seq is missing from ERP->CREATE SEQUENCE<-
public.kiosk_id_seq is missing from ERP->CREATE SEQUENCE<-
beta.temp_test_id_seq is missing from ERP->CREATE SEQUENCE<-
mixalot.merchandising_slot_def_id_seq is missing from ERP->CREATE SEQUENCE<-
mixalot.merchandising_slot_id_seq is missing from ERP->CREATE SEQUENCE<-
pantry.feedback_id_seq is missing from ERP->CREATE SEQUENCE<-
pantry.kiosk_attribute_id_seq is missing from ERP->CREATE SEQUENCE<-
pantry.kiosk_audit_log_id_seq is missing from ERP->CREATE SEQUENCE<-
pantry.nutrition_filter_id_seq is missing from ERP->CREATE SEQUENCE<-
pantry.product_history_id_seq is missing from ERP->CREATE SEQUENCE<-
mixalot.card_fact_id_seq is missing from ERP->CREATE SEQUENCE<-
mixalot.test_time_id_seq is missing from ERP->CREATE SEQUENCE<-
fnrenames.kiosk_status_id_seq is missing from ERP->CREATE SEQUENCE<-
pantry.accounting_id_seq is missing from ERP->CREATE SEQUENCE<-
pantry.kiosk_device_id_seq is missing from ERP->CREATE SEQUENCE<-
pantry.transact_ipc_id_seq is missing from ERP->CREATE SEQUENCE<-
pantry.discount_applied_id_seq is missing from ERP->CREATE SEQUENCE<-
pantry.event_id_seq is missing from ERP->CREATE SEQUENCE<-
pantry.kiosk_id_seq is missing from ERP->CREATE SEQUENCE<-
test.transactions_pending_sync_id_seq is missing from ERP->CREATE SEQUENCE<-
beta.temp_test2_id_seq is missing from ERP->CREATE SEQUENCE<-
pantry.stockout_id_seq is missing from ERP->CREATE SEQUENCE<-
mixalot.history_order_id_seq is missing from ERP->CREATE SEQUENCE<-
pantry.par_history_id_seq is missing from ERP->CREATE SEQUENCE<-
pantry.restock_item_id_seq is missing from ERP->CREATE SEQUENCE<-
pantry.delivery_schedule_id_seq is missing from ERP->CREATE SEQUENCE<-
pantry.inventory_history_id_seq is missing from ERP->CREATE SEQUENCE<-
pantry.transact_fp_id_seq is missing from ERP->CREATE SEQUENCE<-
test.request_log_sold_epc_id_seq is missing from ERP->CREATE SEQUENCE<-
mixalot.sku_attribute_def_id_seq is missing from ERP->CREATE SEQUENCE<-
pantry.history_id_seq is missing from ERP->CREATE SEQUENCE<-
public.awsdms_heartbeat_hb_key_seq is missing from ERP->CREATE SEQUENCE<-
pantry.campus_attribute_id_seq is missing from ERP->CREATE SEQUENCE<-
pantry.global_attribute_def_id_seq is missing from ERP->CREATE SEQUENCE<-
fnrenames.nutrition_filter_id_seq is missing from ERP->CREATE SEQUENCE<-
pantry.contract_id_seq is missing from ERP->CREATE SEQUENCE<-
pantry.transact_comp_id_seq is missing from ERP->CREATE SEQUENCE<-
mixalot.temp_test_id_seq is missing from ERP->CREATE SEQUENCE<-
pantry.currency_symbol_id_seq is missing from ERP->CREATE SEQUENCE<-
pantry.spoilage_id_seq is missing from ERP->CREATE SEQUENCE<-
pantry.product_categories_id_seq is missing from ERP->CREATE SEQUENCE<-
pantry.bad_timestamp_id_seq is missing from ERP->CREATE SEQUENCE<-
pantry.kiosks_date_non_new_id_seq is missing from ERP->CREATE SEQUENCE<-
pantry.product_id_seq is missing from ERP->CREATE SEQUENCE<-
fnrenames.discount_history_id_seq is missing from ERP->CREATE SEQUENCE<-
pantry.card_id_seq is missing from ERP->CREATE SEQUENCE<-
pantry.label_id_seq is missing from ERP->CREATE SEQUENCE<-
pantry.campus_id_seq is missing from ERP->CREATE SEQUENCE<-
pantry.discount_history_id_seq is missing from ERP->CREATE SEQUENCE<-
pantry.product_request_id_seq is missing from ERP->CREATE SEQUENCE<-
public.track_dashboard_id_seq is missing from ERP->CREATE SEQUENCE<-
	CREATE SEQUENCE : 107
ON is missing from ERP->CREATE UNIQUE order_id_unique<-
	CREATE UNIQUE order_id_unique : 1
	CREATE EVENT awsdms_intercept_ddl : 1
EXISTS is missing from ERP->CREATE EXTENSION NOT<-
	CREATE EXTENSION NOT : 1
inm_beta.text100 is missing from ERP->CREATE DOMAIN AS<-
	CREATE DOMAIN AS : 2
	ALTER DOMAIN : 1
ON is missing from ERP->CREATE UNIQUE tag_name_id<-
	CREATE UNIQUE tag_name_id : 1
ON is missing from ERP->CREATE UNIQUE tag_unique_constraint_index<-
	CREATE UNIQUE tag_unique_constraint_index : 1
	GRANT USAGE : 1
	SELECT pg_catalog.set_config('search_path', : 1
inm.kiosk_projected_stock_sku_level is missing from ERP->COMMENT ON<-
inm is missing from ERP->COMMENT ON<-
pg_trgm is missing from ERP->COMMENT ON<-
inm_backup is missing from ERP->COMMENT ON<-
inm_test is missing from ERP->COMMENT ON<-
mixalot.sku_group_def is missing from ERP->COMMENT ON<-
beta is missing from ERP->COMMENT ON<-
pantry.history_kiosk_device is missing from ERP->COMMENT ON<-
pantry.history_kiosk_service_version is missing from ERP->COMMENT ON<-
pantry.history_campus_attribute is missing from ERP->COMMENT ON<-
pantry.history_global_attribute_def is missing from ERP->COMMENT ON<-
pantry.history_kiosk_attribute is missing from ERP->COMMENT ON<-
inm_beta is missing from ERP->COMMENT ON<-
monitor is missing from ERP->COMMENT ON<-
intarray is missing from ERP->COMMENT ON<-
inm.pick_check_restriction(_pick_date is missing from ERP->COMMENT ON<-
mixalot.sku_group_sku is missing from ERP->COMMENT ON<-
mixalot.temp_ms_to_sg is missing from ERP->COMMENT ON<-
mixalot.temp_sku_to_skugroup is missing from ERP->COMMENT ON<-
btree_gin is missing from ERP->COMMENT ON<-
tablefunc is missing from ERP->COMMENT ON<-
inm.kiosk_projected_minimum is missing from ERP->COMMENT ON<-
mixalot.merchandising_slot_sku_group is missing from ERP->COMMENT ON<-
mixalot.sku_property is missing from ERP->COMMENT ON<-
pantry.order_meta is missing from ERP->COMMENT ON<-
pg_stat_statements is missing from ERP->COMMENT ON<-
mixalot.sku_def is missing from ERP->COMMENT ON<-
	COMMENT ON : 31
	ALTER EVENT : 1
	REVOKE ALL SCHEMA : 1
IOT->ERP
	missing v1: 0
	missing v2: 138
	Totaling : 185


numeric(6,2); is missing from IOT->CREATE DOMAIN AS<-
numeric(5,2); is missing from IOT->CREATE DOMAIN AS<-
numeric(8,2); is missing from IOT->CREATE DOMAIN AS<-
smallint is missing from IOT->CREATE DOMAIN AS<-
	CREATE DOMAIN AS : 5
erp.client_contact is missing from IOT->CREATE INDEX ON<-
pantry.ro_order is missing from IOT->CREATE INDEX ON<-
test.fact_daily_kiosk_sku_summary is missing from IOT->CREATE INDEX ON<-
dw.fact_daily_kiosk_sku_summary is missing from IOT->CREATE INDEX ON<-
pantry.product is missing from IOT->CREATE INDEX ON<-
pantry.kiosk_status is missing from IOT->CREATE INDEX ON<-
	CREATE INDEX ON : 11
ON is missing from IOT->CREATE UNIQUE tag_type_type_key<-
	CREATE UNIQUE tag_type_type_key : 1
	ALTER DEFAULT : 1
	SELECT pg_catalog.set_config('search_path', : 1
	ALTER DOMAIN : 1
erp.fcm_repeater_id_seq is missing from IOT->CREATE SEQUENCE<-
mixalot.sku_property_def_id_seq is missing from IOT->CREATE SEQUENCE<-
public.history_order_pipeline_id_seq is missing from IOT->CREATE SEQUENCE<-
mixalot.history_order_pipeline_id_seq is missing from IOT->CREATE SEQUENCE<-
public.product_fact_id_seq is missing from IOT->CREATE SEQUENCE<-
inm_test.even_id_seq is missing from IOT->CREATE SEQUENCE<-
inm_test.even_id_id_seq is missing from IOT->CREATE SEQUENCE<-
	CREATE SEQUENCE : 31
	ALTER SEQUENCE : 1
	GRANT USAGE : 1
	CREATE EVENT awsdms_intercept_ddl : 1
	ALTER EVENT : 1
	REVOKE ALL SCHEMA : 1
	GRANT SELECT : 1
TABLE is missing from IOT->GRANT INSERT,REFERENCES,DELETE,TRIGGER,TRUNCATE,UPDATE<-
	GRANT INSERT,REFERENCES,DELETE,TRIGGER,TRUNCATE,UPDATE : 1
AUTHORIZATION; is missing from IOT->RESET SESSION<-
	RESET SESSION : 1
pantry.get_label_order_epc() is missing from IOT->COMMENT ON<-
inm.warehouse_order_history is missing from IOT->COMMENT ON<-
erp.kiosk_accounting is missing from IOT->COMMENT ON<-
dw.sales(beginning_date is missing from IOT->COMMENT ON<-
inm.kiosk_projected_stock is missing from IOT->COMMENT ON<-
dw.non_byte_sales(beginning_date is missing from IOT->COMMENT ON<-
inm.pick_demand is missing from IOT->COMMENT ON<-
dw.dim_product is missing from IOT->COMMENT ON<-
erp.product_pricing is missing from IOT->COMMENT ON<-
dw.export_feedback(beginning_date is missing from IOT->COMMENT ON<-
inm.pick_allocation is missing from IOT->COMMENT ON<-
erp.product_handling is missing from IOT->COMMENT ON<-
erp.client_contact is missing from IOT->COMMENT ON<-
erp.kiosk_restriction_by_product is missing from IOT->COMMENT ON<-
dw.insert_losses_in_daily_kiosk_sku_summary(beginning_date is missing from IOT->COMMENT ON<-
dw.non_byte_losses(beginning_date is missing from IOT->COMMENT ON<-
dw.export_inventory_lots is missing from IOT->COMMENT ON<-
dw.fact_daily_byte_foods_summary is missing from IOT->COMMENT ON<-
erp.address is missing from IOT->COMMENT ON<-
dw.insert_sales_daily_byte_foods_summary(beginning_date is missing from IOT->COMMENT ON<-
inm.get_pull_date(plan_window_start is missing from IOT->COMMENT ON<-
inm.pick_preference_kiosk_sku is missing from IOT->COMMENT ON<-
dw.refresh_dim_product() is missing from IOT->COMMENT ON<-
erp.classic_product_category_tag is missing from IOT->COMMENT ON<-
erp.product_nutrition is missing from IOT->COMMENT ON<-
dw.fact_daily_kiosk_sku_summary is missing from IOT->COMMENT ON<-
inm.pick_list is missing from IOT->COMMENT ON<-
erp.kiosk is missing from IOT->COMMENT ON<-
erp.kiosk_attribute is missing from IOT->COMMENT ON<-
erp.product_property is missing from IOT->COMMENT ON<-
inm.pick_get_demand_weekly_wo_min() is missing from IOT->COMMENT ON<-
dw.byte_spoils(beginning_date is missing from IOT->COMMENT ON<-
inm.sku_group_control is missing from IOT->COMMENT ON<-
erp.product_category_def is missing from IOT->COMMENT ON<-
erp.product_sourcing is missing from IOT->COMMENT ON<-
dw.clear_fact_monthly_kiosk_summary(month_date is missing from IOT->COMMENT ON<-
erp.hardware_software is missing from IOT->COMMENT ON<-
dw.export_kiosk_status(kiosk_number is missing from IOT->COMMENT ON<-
dw.fact_monthly_kiosk_summary is missing from IOT->COMMENT ON<-
erp.product is missing from IOT->COMMENT ON<-
erp.product_asset is missing from IOT->COMMENT ON<-
erp.tag_order is missing from IOT->COMMENT ON<-
erp.kiosk_restriction_by_property is missing from IOT->COMMENT ON<-
inm.kiosk_restriction_by_property is missing from IOT->COMMENT ON<-
dw.last_15_months is missing from IOT->COMMENT ON<-
erp.tag_type is missing from IOT->COMMENT ON<-
dw.byte_sales(beginning_date is missing from IOT->COMMENT ON<-
inm.kiosk_restriction_by_product is missing from IOT->COMMENT ON<-
erp.kiosk_contact is missing from IOT->COMMENT ON<-
erp.kiosk_delivery_window is missing from IOT->COMMENT ON<-
dw.insert_hb_stat_in_daily_byte_foods_summary(beginning_date is missing from IOT->COMMENT ON<-
dw.losses(beginning_date is missing from IOT->COMMENT ON<-
dw.current_inventory is missing from IOT->COMMENT ON<-
dw.dim_kiosk is missing from IOT->COMMENT ON<-
erp.kiosk_status is missing from IOT->COMMENT ON<-
inm.configuration is missing from IOT->COMMENT ON<-
inm.route_stop is missing from IOT->COMMENT ON<-
inm.sku_group_attribute is missing from IOT->COMMENT ON<-
dw.last_15_weeks is missing from IOT->COMMENT ON<-
erp.tag_price is missing from IOT->COMMENT ON<-
dw.insert_sales_in_daily_kiosk_sku_summary(beginning_date is missing from IOT->COMMENT ON<-
dw.non_byte_spoils(beginning_date is missing from IOT->COMMENT ON<-
dw.restocks(beginning_date is missing from IOT->COMMENT ON<-
inm.pick_route is missing from IOT->COMMENT ON<-
erp.client_industry is missing from IOT->COMMENT ON<-
inm.pick_rejection is missing from IOT->COMMENT ON<-
erp.product_property_tag is missing from IOT->COMMENT ON<-
inm.pick_substitution is missing from IOT->COMMENT ON<-
inm.kiosk_sku_group_manual_scale is missing from IOT->COMMENT ON<-
erp.global_attribute_def is missing from IOT->COMMENT ON<-
dw.insert_stock_in_daily_kiosk_sku_summary(beginning_date is missing from IOT->COMMENT ON<-
dw.refresh_daily_byte_foods_summary(beginning_date is missing from IOT->COMMENT ON<-
dw.refresh_monthly_kiosk_summary(month_date is missing from IOT->COMMENT ON<-
erp.kiosk_note is missing from IOT->COMMENT ON<-
erp.product_property_def is missing from IOT->COMMENT ON<-
dw.clear_daily_kiosk_sku_summary(beginning_date is missing from IOT->COMMENT ON<-
dw.refresh_dim_kiosk() is missing from IOT->COMMENT ON<-
dw.dim_campus is missing from IOT->COMMENT ON<-
dw.dim_date is missing from IOT->COMMENT ON<-
inm.product_property is missing from IOT->COMMENT ON<-
erp.contact is missing from IOT->COMMENT ON<-
erp.product_category is missing from IOT->COMMENT ON<-
inm.pick_inventory is missing from IOT->COMMENT ON<-
inm.product_property_def is missing from IOT->COMMENT ON<-
dw.byte_losses(beginning_date is missing from IOT->COMMENT ON<-
inm.kiosk_control is missing from IOT->COMMENT ON<-
dw.last_30_days is missing from IOT->COMMENT ON<-
inm.warehouse_inventory is missing from IOT->COMMENT ON<-
inm.pick_priority_sku is missing from IOT->COMMENT ON<-
dw.byte_current_inventory is missing from IOT->COMMENT ON<-
dw.insert_inv_snapshot_in_daily_byte_foods_summary(beginning_date is missing from IOT->COMMENT ON<-
dw.insert_spoils_in_daily_kiosk_sku_summary(beginning_date is missing from IOT->COMMENT ON<-
erp.client is missing from IOT->COMMENT ON<-
erp.tag_order_stats is missing from IOT->COMMENT ON<-
inm.f_kiosk_sku_group_sku_pick_stats(pick_time is missing from IOT->COMMENT ON<-
erp.sku_group is missing from IOT->COMMENT ON<-
dw.refresh_daily_kiosk_sku_summary(beginning_date is missing from IOT->COMMENT ON<-
inm.get_spoilage_pull_list() is missing from IOT->COMMENT ON<-
inm.pick_priority_kiosk is missing from IOT->COMMENT ON<-
erp.client_campus is missing from IOT->COMMENT ON<-
erp.kiosk_access_card is missing from IOT->COMMENT ON<-
dw.spoils(beginning_date is missing from IOT->COMMENT ON<-
	COMMENT ON : 106
ON is missing from IOT->CREATE UNIQUE client_id_contact_type<-
	CREATE UNIQUE client_id_contact_type : 1
	GRANT ALL : 4
ERP->IOT
	missing v1: 0
	missing v2: 123
	Totaling : 170

Writing file: Other-IOT-To-ERP.sql
wrote 16156 bytes
Writing file: Other-ERP-To-IOT.sql
wrote 11529 bytes
IOT ERP
default_with_oids is missing from ERP->SET<-
	SET : 11
IOT->ERP
	missing v1: 0
	missing v2: 1
	Totaling : 11


SESSION is missing from IOT->SET<-
	SET : 11
ERP->IOT
	missing v1: 0
	missing v2: 1
	Totaling : 11

Writing file: Set-IOT-To-ERP.sql
wrote 31 bytes
Writing file: Set-ERP-To-IOT.sql
wrote 32 bytes
IOT ERP
beta.pick_get_order_by_sales_4wk_avg is missing from ERP->CREATE FUNCTION<-
pantry.fn_kiosk_status_insert is missing from ERP->CREATE FUNCTION<-
public.checkpoint is missing from ERP->CREATE FUNCTION<-
rptg.non_byte_losses is missing from ERP->CREATE FUNCTION<-
beta.pick_get_delivery_schedule_optimo is missing from ERP->CREATE FUNCTION<-
mixalot.backup_pick_allocation is missing from ERP->CREATE FUNCTION<-
mixalot.pick_get_summary is missing from ERP->CREATE FUNCTION<-
pantry.fn_audit_global_attribute_def is missing from ERP->CREATE FUNCTION<-
rptg.byte_sales is missing from ERP->CREATE FUNCTION<-
pantry.fn_product_stats_by_kiosk is missing from ERP->CREATE FUNCTION<-
public.monthly_infographic_data is missing from ERP->CREATE FUNCTION<-
beta.compare_pick_vs_delivery_by_sku is missing from ERP->CREATE FUNCTION<-
beta.compare_pick_vs_delivery_v3 is missing from ERP->CREATE FUNCTION<-
inm.get_all_pull_list is missing from ERP->CREATE FUNCTION<-
inm_backup.pick_get_delivery_schedule is missing from ERP->CREATE FUNCTION<-
pantry.fn_order_insert is missing from ERP->CREATE FUNCTION<-
beta.sku_pick_order is missing from ERP->CREATE FUNCTION<-
fnrenames.fn_kiosk_audit_log_insert is missing from ERP->CREATE FUNCTION<-
mixalot.pick_get_gsheets_plan_demand is missing from ERP->CREATE FUNCTION<-
mixalot.pick_get_plan_demand is missing from ERP->CREATE FUNCTION<-
pantry.fn_label_delete is missing from ERP->CREATE FUNCTION<-
pantry.fn_order_update is missing from ERP->CREATE FUNCTION<-
pantry.fn_spoilage_insert is missing from ERP->CREATE FUNCTION<-
inm.pick_get_plan_kiosk_bringg is missing from ERP->CREATE FUNCTION<-
inm_backup.pick_get_plan_kiosk_bringg is missing from ERP->CREATE FUNCTION<-
inm_beta.pick_get_sales_period_ratio is missing from ERP->CREATE FUNCTION<-
inm_test.pick_get_plan_demand is missing from ERP->CREATE FUNCTION<-
public.pickpack is missing from ERP->CREATE FUNCTION<-
rptg.pick_audit is missing from ERP->CREATE FUNCTION<-
inm.allocation_ratio_by_sku_group_test is missing from ERP->CREATE FUNCTION<-
public.make_odd_or_even_sequence is missing from ERP->CREATE FUNCTION<-
rptg.sales is missing from ERP->CREATE FUNCTION<-
beta.bringg_vs_optimo_delta is missing from ERP->CREATE FUNCTION<-
inm_beta.pick_get_order_with_velocity is missing from ERP->CREATE FUNCTION<-
pantry.fn_card_insert is missing from ERP->CREATE FUNCTION<-
beta.compare_pick_vs_delivery_ignore_null is missing from ERP->CREATE FUNCTION<-
beta.compare_pick_vs_delivery_test is missing from ERP->CREATE FUNCTION<-
inm.allocation_ratio_by_sku_group is missing from ERP->CREATE FUNCTION<-
inm_test.test_demand is missing from ERP->CREATE FUNCTION<-
pantry.fn_campus_insert is missing from ERP->CREATE FUNCTION<-
beta.compare_pick_vs_delivery_v2 is missing from ERP->CREATE FUNCTION<-
inm.sync_restriction_by_property is missing from ERP->CREATE FUNCTION<-
inm_beta.pick_get_order is missing from ERP->CREATE FUNCTION<-
inm_test.pick_inventory_insert is missing from ERP->CREATE FUNCTION<-
pantry.fn_audit_kiosk_device is missing from ERP->CREATE FUNCTION<-
util.fix_orders_using_request_log is missing from ERP->CREATE FUNCTION<-
inm_beta.pick_get_demand_weekly_by_velocity is missing from ERP->CREATE FUNCTION<-
inm_test.compare_pick_vs_delivery is missing from ERP->CREATE FUNCTION<-
inm_test.pick_get_plan_demand_w_manual is missing from ERP->CREATE FUNCTION<-
public.hex_to_int is missing from ERP->CREATE FUNCTION<-
fnrenames.fn_kiosk_audit_log_update is missing from ERP->CREATE FUNCTION<-
inm_beta.pick_get_demand_weekly_wo_min is missing from ERP->CREATE FUNCTION<-
inm_beta.pick_get_plan_kiosk_projected_stock is missing from ERP->CREATE FUNCTION<-
pantry.fn_ro_order_set_order is missing from ERP->CREATE FUNCTION<-
util.extract_request_log_epc_order is missing from ERP->CREATE FUNCTION<-
inm.get_performance_pull_list is missing from ERP->CREATE FUNCTION<-
inm.pick_get_delivery_schedule_optimo is missing from ERP->CREATE FUNCTION<-
inm_test.pick_get_order_with_sales_ratio is missing from ERP->CREATE FUNCTION<-
pantry.fn_discount_insert is missing from ERP->CREATE FUNCTION<-
pantry.kiosk_guardrails_ssl_cert_bytetech_co is missing from ERP->CREATE FUNCTION<-
mixalot.pick_inventory_insert is missing from ERP->CREATE FUNCTION<-
pantry.fn_label_insert is missing from ERP->CREATE FUNCTION<-
pantry.fn_product_update is missing from ERP->CREATE FUNCTION<-
inm_beta.pick_get_plan_kiosk is missing from ERP->CREATE FUNCTION<-
inm_beta.pick_get_plan_kiosk_disabled_product is missing from ERP->CREATE FUNCTION<-
pantry.fn_ro_order_update_full_price is missing from ERP->CREATE FUNCTION<-
pantry.fn_audit_kiosk_service_version is missing from ERP->CREATE FUNCTION<-
pantry.get_permissions is missing from ERP->CREATE FUNCTION<-
beta.pick_get_order_by_sales_4wks_availability is missing from ERP->CREATE FUNCTION<-
beta.test_insert is missing from ERP->CREATE FUNCTION<-
mixalot.pick_demand_insert is missing from ERP->CREATE FUNCTION<-
pantry.fn_audit_campus_attribute is missing from ERP->CREATE FUNCTION<-
public.path_check is missing from ERP->CREATE FUNCTION<-
public.user_retention_by_month is missing from ERP->CREATE FUNCTION<-
fnrenames.fn_ro_order_update_full_price is missing from ERP->CREATE FUNCTION<-
inm_backup.pick_get_order_with_sales_ratio is missing from ERP->CREATE FUNCTION<-
pantry.key_loc_lookup is missing from ERP->CREATE FUNCTION<-
public.user_retention_by_week is missing from ERP->CREATE FUNCTION<-
mixalot.pick_allocation_insert is missing from ERP->CREATE FUNCTION<-
inm_test.pick_get_sales_period_ratio is missing from ERP->CREATE FUNCTION<-
beta.get_label_stats_v0 is missing from ERP->CREATE FUNCTION<-
inm_backup.pick_get_demand_weekly_by_velocity is missing from ERP->CREATE FUNCTION<-
inm_test.pick_check_restriction is missing from ERP->CREATE FUNCTION<-
public.shelf_life_bucket is missing from ERP->CREATE FUNCTION<-
mixalot.pick_ticket is missing from ERP->CREATE FUNCTION<-
mixalot.sku_pick_order is missing from ERP->CREATE FUNCTION<-
pantry.hierarchy is missing from ERP->CREATE FUNCTION<-
report.dependency_tree is missing from ERP->CREATE FUNCTION<-
pantry.fn_product_insert is missing from ERP->CREATE FUNCTION<-
rptg.non_byte_sales is missing from ERP->CREATE FUNCTION<-
beta.get_label_stats is missing from ERP->CREATE FUNCTION<-
beta.pick_audit is missing from ERP->CREATE FUNCTION<-
pantry.fn_add_to_watch is missing from ERP->CREATE FUNCTION<-
inm_backup.pick_get_demand_weekly_wo_min_20190108 is missing from ERP->CREATE FUNCTION<-
mixalot.plan_kiosk is missing from ERP->CREATE FUNCTION<-
pantry.fn_discount_update is missing from ERP->CREATE FUNCTION<-
inm_backup.pick_get_order_with_velocity is missing from ERP->CREATE FUNCTION<-
pantry.fn_kiosk_audit_log_update is missing from ERP->CREATE FUNCTION<-
pantry.fn_product_delete is missing from ERP->CREATE FUNCTION<-
rptg.byte_losses is missing from ERP->CREATE FUNCTION<-
beta.pick_get_order_by_sales_4wk is missing from ERP->CREATE FUNCTION<-
mixalot.pick_get_delivery_schedule is missing from ERP->CREATE FUNCTION<-
pantry.fn_kiosk_audit_log_insert is missing from ERP->CREATE FUNCTION<-
rptg.spoils is missing from ERP->CREATE FUNCTION<-
inm_backup.pick_get_demand_weekly_by_velocity_20190108 is missing from ERP->CREATE FUNCTION<-
inm_backup.pick_get_ticket is missing from ERP->CREATE FUNCTION<-
pantry.fn_discount_delete is missing from ERP->CREATE FUNCTION<-
beta.compare_pick_vs_delivery is missing from ERP->CREATE FUNCTION<-
inm_beta.pick_get_sales_period_ratio_4wks is missing from ERP->CREATE FUNCTION<-
pantry.fn_kiosk_update is missing from ERP->CREATE FUNCTION<-
pantry.fn_audit_kiosk_attribute is missing from ERP->CREATE FUNCTION<-
pantry.fn_label_update is missing from ERP->CREATE FUNCTION<-
rptg.losses is missing from ERP->CREATE FUNCTION<-
mixalot.set_sequence_val_max is missing from ERP->CREATE FUNCTION<-
public.fmt_ts is missing from ERP->CREATE FUNCTION<-
public.if is missing from ERP->CREATE FUNCTION<-
rptg.restocks is missing from ERP->CREATE FUNCTION<-
	CREATE FUNCTION : 139
public.pick_get_next_delivery is missing from ERP->ALTER FUNCTION<-
rptg.non_byte_losses is missing from ERP->ALTER FUNCTION<-
rptg.sales is missing from ERP->ALTER FUNCTION<-
inm_test.test_demand is missing from ERP->ALTER FUNCTION<-
pantry.fn_audit_kiosk_attribute is missing from ERP->ALTER FUNCTION<-
public.is_older_software_version is missing from ERP->ALTER FUNCTION<-
inm_backup.pick_get_delivery_schedule is missing from ERP->ALTER FUNCTION<-
mixalot.pick_allocation_insert is missing from ERP->ALTER FUNCTION<-
pantry.fn_kiosk_status_insert is missing from ERP->ALTER FUNCTION<-
beta.compare_pick_vs_delivery is missing from ERP->ALTER FUNCTION<-
pantry.fn_discount_delete is missing from ERP->ALTER FUNCTION<-
inm_test.pick_get_sales_period_ratio is missing from ERP->ALTER FUNCTION<-
pantry.fn_kiosk_update is missing from ERP->ALTER FUNCTION<-
pantry.fn_order_insert is missing from ERP->ALTER FUNCTION<-
public.f_nr_stockout_minutes is missing from ERP->ALTER FUNCTION<-
beta.get_label_stats is missing from ERP->ALTER FUNCTION<-
pantry.fn_card_insert is missing from ERP->ALTER FUNCTION<-
inm_backup.pick_get_plan_kiosk_bringg is missing from ERP->ALTER FUNCTION<-
inm_test.compare_pick_vs_delivery is missing from ERP->ALTER FUNCTION<-
pantry.fn_audit_campus_attribute is missing from ERP->ALTER FUNCTION<-
rptg.byte_sales is missing from ERP->ALTER FUNCTION<-
beta.get_label_stats_v0 is missing from ERP->ALTER FUNCTION<-
mixalot.pick_ticket is missing from ERP->ALTER FUNCTION<-
inm.get_performance_pull_list is missing from ERP->ALTER FUNCTION<-
mixalot.pick_get_delivery_schedule is missing from ERP->ALTER FUNCTION<-
pantry.fn_label_delete is missing from ERP->ALTER FUNCTION<-
pantry.fn_audit_kiosk_service_version is missing from ERP->ALTER FUNCTION<-
pantry.fn_product_delete is missing from ERP->ALTER FUNCTION<-
rptg.pick_audit is missing from ERP->ALTER FUNCTION<-
inm_test.pick_inventory_insert is missing from ERP->ALTER FUNCTION<-
pantry.fn_add_to_watch is missing from ERP->ALTER FUNCTION<-
pantry.fn_discount_insert is missing from ERP->ALTER FUNCTION<-
beta.pick_get_delivery_schedule_optimo is missing from ERP->ALTER FUNCTION<-
inm_beta.pick_get_plan_kiosk_projected_stock is missing from ERP->ALTER FUNCTION<-
pantry.fn_campus_insert is missing from ERP->ALTER FUNCTION<-
pantry.fn_kiosk_audit_log_update is missing from ERP->ALTER FUNCTION<-
beta.pick_audit is missing from ERP->ALTER FUNCTION<-
inm_test.pick_check_restriction is missing from ERP->ALTER FUNCTION<-
pantry.fn_spoilage_insert is missing from ERP->ALTER FUNCTION<-
pantry.get_permissions is missing from ERP->ALTER FUNCTION<-
public.user_retention_by_week is missing from ERP->ALTER FUNCTION<-
rptg.restocks is missing from ERP->ALTER FUNCTION<-
pantry.fn_product_update is missing from ERP->ALTER FUNCTION<-
mixalot.pick_summary is missing from ERP->ALTER FUNCTION<-
pantry.fn_discount_update is missing from ERP->ALTER FUNCTION<-
pantry.fn_label_update is missing from ERP->ALTER FUNCTION<-
pantry.fn_product_stats_by_kiosk is missing from ERP->ALTER FUNCTION<-
inm_beta.pick_get_order_with_velocity is missing from ERP->ALTER FUNCTION<-
inm_beta.pick_get_sales_period_ratio_4wks is missing from ERP->ALTER FUNCTION<-
inm_backup.pick_get_ticket is missing from ERP->ALTER FUNCTION<-
mixalot.pick_demand_insert is missing from ERP->ALTER FUNCTION<-
pantry.fn_kiosk_audit_log_insert is missing from ERP->ALTER FUNCTION<-
pantry.fn_ro_order_update_full_price is missing from ERP->ALTER FUNCTION<-
public.hash_to_bigint is missing from ERP->ALTER FUNCTION<-
public.hex_to_int is missing from ERP->ALTER FUNCTION<-
beta.compare_pick_vs_delivery_test is missing from ERP->ALTER FUNCTION<-
pantry.hierarchy is missing from ERP->ALTER FUNCTION<-
inm_backup.pick_get_order_with_velocity is missing from ERP->ALTER FUNCTION<-
inm_beta.pick_get_plan_kiosk_disabled_product is missing from ERP->ALTER FUNCTION<-
inm_test.pick_get_plan_demand is missing from ERP->ALTER FUNCTION<-
inm_test.pick_get_plan_demand_w_manual is missing from ERP->ALTER FUNCTION<-
util.fix_orders_using_request_log is missing from ERP->ALTER FUNCTION<-
beta.pick_get_order_by_sales_4wk_avg is missing from ERP->ALTER FUNCTION<-
fnrenames.fn_ro_order_update_full_price is missing from ERP->ALTER FUNCTION<-
inm_beta.pick_get_demand_weekly_by_velocity is missing from ERP->ALTER FUNCTION<-
public.user_retention_by_month is missing from ERP->ALTER FUNCTION<-
report.dependency_tree is missing from ERP->ALTER FUNCTION<-
beta.compare_pick_vs_delivery_by_sku is missing from ERP->ALTER FUNCTION<-
inm.pick_get_delivery_schedule_optimo is missing from ERP->ALTER FUNCTION<-
pantry.kiosk_guardrails_ssl_cert_bytetech_co is missing from ERP->ALTER FUNCTION<-
inm.sync_restriction_by_property is missing from ERP->ALTER FUNCTION<-
inm_test.pick_get_order_with_sales_ratio is missing from ERP->ALTER FUNCTION<-
fnrenames.fn_kiosk_audit_log_update is missing from ERP->ALTER FUNCTION<-
mixalot.pick_get_summary is missing from ERP->ALTER FUNCTION<-
pantry.fn_label_insert is missing from ERP->ALTER FUNCTION<-
pantry.fn_order_update is missing from ERP->ALTER FUNCTION<-
rptg.spoils is missing from ERP->ALTER FUNCTION<-
beta.compare_pick_vs_delivery_ignore_null is missing from ERP->ALTER FUNCTION<-
mixalot.set_sequence_val_max is missing from ERP->ALTER FUNCTION<-
inm_beta.pick_get_sales_period_ratio is missing from ERP->ALTER FUNCTION<-
mixalot.pick_get_gsheets_plan_demand is missing from ERP->ALTER FUNCTION<-
inm_backup.pick_get_order_with_sales_ratio is missing from ERP->ALTER FUNCTION<-
inm_beta.pick_get_plan_kiosk is missing from ERP->ALTER FUNCTION<-
pantry.fn_audit_global_attribute_def is missing from ERP->ALTER FUNCTION<-
beta.sku_pick_order is missing from ERP->ALTER FUNCTION<-
inm_beta.pick_get_order is missing from ERP->ALTER FUNCTION<-
mixalot.backup_pick_allocation is missing from ERP->ALTER FUNCTION<-
mixalot.plan_kiosk is missing from ERP->ALTER FUNCTION<-
util.extract_request_log_epc_order is missing from ERP->ALTER FUNCTION<-
fnrenames.fn_kiosk_audit_log_insert is missing from ERP->ALTER FUNCTION<-
inm_backup.pick_get_demand_weekly_wo_min_20190108 is missing from ERP->ALTER FUNCTION<-
beta.pick_get_order_by_sales_4wk is missing from ERP->ALTER FUNCTION<-
fnrenames.pick_get_order_with_velocity is missing from ERP->ALTER FUNCTION<-
inm.allocation_ratio_by_sku_group_test is missing from ERP->ALTER FUNCTION<-
rptg.non_byte_sales is missing from ERP->ALTER FUNCTION<-
beta.compare_pick_vs_delivery_v3 is missing from ERP->ALTER FUNCTION<-
inm.get_all_pull_list is missing from ERP->ALTER FUNCTION<-
public.stockout_hours is missing from ERP->ALTER FUNCTION<-
rptg.byte_losses is missing from ERP->ALTER FUNCTION<-
pantry.fn_product_insert is missing from ERP->ALTER FUNCTION<-
pantry.key_loc_lookup is missing from ERP->ALTER FUNCTION<-
inm_beta.pick_get_demand_weekly_wo_min is missing from ERP->ALTER FUNCTION<-
beta.compare_pick_vs_delivery_v2 is missing from ERP->ALTER FUNCTION<-
rptg.losses is missing from ERP->ALTER FUNCTION<-
mixalot.pick_get_plan_demand is missing from ERP->ALTER FUNCTION<-
public.set_sequence_val_max is missing from ERP->ALTER FUNCTION<-
beta.bringg_vs_optimo_delta is missing from ERP->ALTER FUNCTION<-
beta.pick_get_order_by_sales_4wks_availability is missing from ERP->ALTER FUNCTION<-
inm.pick_get_plan_kiosk_bringg is missing from ERP->ALTER FUNCTION<-
inm_backup.pick_get_demand_weekly_by_velocity is missing from ERP->ALTER FUNCTION<-
inm_backup.pick_get_demand_weekly_by_velocity_20190108 is missing from ERP->ALTER FUNCTION<-
mixalot.sku_pick_order is missing from ERP->ALTER FUNCTION<-
pantry.fn_audit_kiosk_device is missing from ERP->ALTER FUNCTION<-
pantry.fn_ro_order_set_order is missing from ERP->ALTER FUNCTION<-
public.monthly_infographic_data is missing from ERP->ALTER FUNCTION<-
beta.test_insert is missing from ERP->ALTER FUNCTION<-
inm.allocation_ratio_by_sku_group is missing from ERP->ALTER FUNCTION<-
	ALTER FUNCTION : 139
IOT->ERP
	missing v1: 0
	missing v2: 234
	Totaling : 278


inm.pick_check_duplicate_stop is missing from IOT->CREATE FUNCTION<-
pantry.get_label_order_epc is missing from IOT->CREATE FUNCTION<-
dw.insert_in_monthly_kiosk_summary is missing from IOT->CREATE FUNCTION<-
dw.refresh_monthly_byte_foods_summary is missing from IOT->CREATE FUNCTION<-
erp.parse_phone is missing from IOT->CREATE FUNCTION<-
test.export_transaction is missing from IOT->CREATE FUNCTION<-
dw.byte_spoils is missing from IOT->CREATE FUNCTION<-
dw.export_transaction is missing from IOT->CREATE FUNCTION<-
dw.insert_hb_stat_in_daily_byte_foods_summary is missing from IOT->CREATE FUNCTION<-
dw.stockout is missing from IOT->CREATE FUNCTION<-
dw.non_byte_restocks is missing from IOT->CREATE FUNCTION<-
inm_test.get_pull_date is missing from IOT->CREATE FUNCTION<-
inm_test.get_pull_date_enhanced is missing from IOT->CREATE FUNCTION<-
erp.sync_kiosk is missing from IOT->CREATE FUNCTION<-
erp_test.sync_kiosk is missing from IOT->CREATE FUNCTION<-
dw.export_consolidated_remittance is missing from IOT->CREATE FUNCTION<-
dw.refresh_daily_byte_foods_summary is missing from IOT->CREATE FUNCTION<-
dw.refresh_dim_product is missing from IOT->CREATE FUNCTION<-
test.uptime_percentage is missing from IOT->CREATE FUNCTION<-
inm_test.pick_get_delivery_schedule is missing from IOT->CREATE FUNCTION<-
public.dowhour is missing from IOT->CREATE FUNCTION<-
dw.export_kiosk_performance is missing from IOT->CREATE FUNCTION<-
dw.losses is missing from IOT->CREATE FUNCTION<-
fnrenames.parse_phone is missing from IOT->CREATE FUNCTION<-
dw.export_losses is missing from IOT->CREATE FUNCTION<-
dw.insert_losses_in_daily_kiosk_sku_summary is missing from IOT->CREATE FUNCTION<-
dw.insert_sales_monthly_byte_foods_summary is missing from IOT->CREATE FUNCTION<-
dw.refresh_monthly_kiosk_summary is missing from IOT->CREATE FUNCTION<-
erp_test.fn_ro_order_update_full_price is missing from IOT->CREATE FUNCTION<-
dw.clear_fact_monthly_kiosk_summary is missing from IOT->CREATE FUNCTION<-
dw.export_feedback is missing from IOT->CREATE FUNCTION<-
dw.export_kiosk_status is missing from IOT->CREATE FUNCTION<-
migration.test_get_product_record is missing from IOT->CREATE FUNCTION<-
pantry.sync_label_order is missing from IOT->CREATE FUNCTION<-
dw.byte_sales is missing from IOT->CREATE FUNCTION<-
dw.insert_sales_after_discount_in_daily_kiosk_sku_summary is missing from IOT->CREATE FUNCTION<-
erp_test.test is missing from IOT->CREATE FUNCTION<-
dw.spoils is missing from IOT->CREATE FUNCTION<-
erp_test.parse_address is missing from IOT->CREATE FUNCTION<-
dw.byte_losses is missing from IOT->CREATE FUNCTION<-
dw.insert_stock_in_daily_kiosk_sku_summary is missing from IOT->CREATE FUNCTION<-
dw.sales is missing from IOT->CREATE FUNCTION<-
test.export_consolidated_remittance is missing from IOT->CREATE FUNCTION<-
dw.insert_spoils_in_daily_kiosk_sku_summary is missing from IOT->CREATE FUNCTION<-
dw.non_byte_sales is missing from IOT->CREATE FUNCTION<-
erp.reverse_sync_kiosk is missing from IOT->CREATE FUNCTION<-
dw.clear_daily_kiosk_sku_summary is missing from IOT->CREATE FUNCTION<-
dw.refresh_dim_kiosk is missing from IOT->CREATE FUNCTION<-
dw.restocks is missing from IOT->CREATE FUNCTION<-
dw.non_byte_spoils is missing from IOT->CREATE FUNCTION<-
erp.sync_product is missing from IOT->CREATE FUNCTION<-
fnrenames.parse_address is missing from IOT->CREATE FUNCTION<-
dw.export_licensee_fee is missing from IOT->CREATE FUNCTION<-
dw.export_remittance is missing from IOT->CREATE FUNCTION<-
dw.insert_sales_in_daily_kiosk_sku_summary is missing from IOT->CREATE FUNCTION<-
dw.byte_restocks is missing from IOT->CREATE FUNCTION<-
dw.refresh_daily_kiosk_sku_summary is missing from IOT->CREATE FUNCTION<-
erp.parse_address is missing from IOT->CREATE FUNCTION<-
erp_test.parse_phone is missing from IOT->CREATE FUNCTION<-
erp_test.reverse_sync_kiosk is missing from IOT->CREATE FUNCTION<-
pantry.sync_campus is missing from IOT->CREATE FUNCTION<-
dw.calculate_prorated_fee is missing from IOT->CREATE FUNCTION<-
dw.export_spoilage is missing from IOT->CREATE FUNCTION<-
dw.non_byte_losses is missing from IOT->CREATE FUNCTION<-
test.uptime_ratio is missing from IOT->CREATE FUNCTION<-
erp.sync_kiosk_reference is missing from IOT->CREATE FUNCTION<-
	CREATE FUNCTION : 88
pantry.sync_label_order is missing from IOT->ALTER FUNCTION<-
dw.export_spoilage is missing from IOT->ALTER FUNCTION<-
erp.parse_address is missing from IOT->ALTER FUNCTION<-
erp.sync_kiosk is missing from IOT->ALTER FUNCTION<-
dw.export_kiosk_status is missing from IOT->ALTER FUNCTION<-
dw.losses is missing from IOT->ALTER FUNCTION<-
dw.sales is missing from IOT->ALTER FUNCTION<-
erp_test.parse_address is missing from IOT->ALTER FUNCTION<-
dw.insert_sales_daily_byte_foods_summary is missing from IOT->ALTER FUNCTION<-
dw.non_byte_restocks is missing from IOT->ALTER FUNCTION<-
erp_test.reverse_sync_kiosk is missing from IOT->ALTER FUNCTION<-
dw.export_unconsolidated_remittance is missing from IOT->ALTER FUNCTION<-
dw.insert_sales_in_daily_kiosk_sku_summary is missing from IOT->ALTER FUNCTION<-
test.uptime_ratio is missing from IOT->ALTER FUNCTION<-
dw.export_remittance is missing from IOT->ALTER FUNCTION<-
dw.non_byte_losses is missing from IOT->ALTER FUNCTION<-
dw.stockout is missing from IOT->ALTER FUNCTION<-
fnrenames.some_f is missing from IOT->ALTER FUNCTION<-
dw.export_kiosk_performance is missing from IOT->ALTER FUNCTION<-
dw.refresh_dim_kiosk is missing from IOT->ALTER FUNCTION<-
erp_test.test is missing from IOT->ALTER FUNCTION<-
pantry.get_label_order_epc is missing from IOT->ALTER FUNCTION<-
dw.non_byte_spoils is missing from IOT->ALTER FUNCTION<-
dw.refresh_daily_byte_foods_summary is missing from IOT->ALTER FUNCTION<-
dw.refresh_monthly_kiosk_summary is missing from IOT->ALTER FUNCTION<-
dw.byte_sales is missing from IOT->ALTER FUNCTION<-
dw.byte_spoils is missing from IOT->ALTER FUNCTION<-
dw.insert_inv_snapshot_in_daily_byte_foods_summary is missing from IOT->ALTER FUNCTION<-
dw.refresh_monthly_byte_foods_summary is missing from IOT->ALTER FUNCTION<-
fnrenames.parse_address is missing from IOT->ALTER FUNCTION<-
inm_test.get_pull_date is missing from IOT->ALTER FUNCTION<-
dw.byte_restocks is missing from IOT->ALTER FUNCTION<-
dw.clear_fact_monthly_kiosk_summary is missing from IOT->ALTER FUNCTION<-
dw.export_losses is missing from IOT->ALTER FUNCTION<-
inm.pick_check_duplicate_stop is missing from IOT->ALTER FUNCTION<-
migration.test_get_product_record is missing from IOT->ALTER FUNCTION<-
dw.clear_daily_kiosk_sku_summary is missing from IOT->ALTER FUNCTION<-
dw.export_licensee_fee is missing from IOT->ALTER FUNCTION<-
dw.non_byte_sales is missing from IOT->ALTER FUNCTION<-
erp_test.parse_phone is missing from IOT->ALTER FUNCTION<-
fnrenames.parse_phone is missing from IOT->ALTER FUNCTION<-
dw.export_consolidated_remittance is missing from IOT->ALTER FUNCTION<-
dw.insert_stock_in_daily_kiosk_sku_summary is missing from IOT->ALTER FUNCTION<-
dw.spoils is missing from IOT->ALTER FUNCTION<-
erp.parse_phone is missing from IOT->ALTER FUNCTION<-
erp.reverse_sync_kiosk is missing from IOT->ALTER FUNCTION<-
inm_test.pick_get_delivery_schedule is missing from IOT->ALTER FUNCTION<-
test.export_consolidated_remittance is missing from IOT->ALTER FUNCTION<-
dw.calculate_prorated_fee is missing from IOT->ALTER FUNCTION<-
dw.insert_losses_in_daily_kiosk_sku_summary is missing from IOT->ALTER FUNCTION<-
dw.refresh_dim_product is missing from IOT->ALTER FUNCTION<-
erp.sync_kiosk_tables is missing from IOT->ALTER FUNCTION<-
erp_test.fn_ro_order_update_full_price is missing from IOT->ALTER FUNCTION<-
test.uptime_percentage is missing from IOT->ALTER FUNCTION<-
inm_test.get_pull_date_enhanced is missing from IOT->ALTER FUNCTION<-
dw.insert_hb_stat_in_daily_byte_foods_summary is missing from IOT->ALTER FUNCTION<-
dw.refresh_daily_kiosk_sku_summary is missing from IOT->ALTER FUNCTION<-
dw.restocks is missing from IOT->ALTER FUNCTION<-
erp.sync_product is missing from IOT->ALTER FUNCTION<-
dw.byte_losses is missing from IOT->ALTER FUNCTION<-
dw.insert_sales_monthly_byte_foods_summary is missing from IOT->ALTER FUNCTION<-
pantry.sync_campus is missing from IOT->ALTER FUNCTION<-
dw.export_feedback is missing from IOT->ALTER FUNCTION<-
dw.insert_spoils_in_daily_kiosk_sku_summary is missing from IOT->ALTER FUNCTION<-
erp_test.sync_product is missing from IOT->ALTER FUNCTION<-
test.spoils is missing from IOT->ALTER FUNCTION<-
	ALTER FUNCTION : 88
ERP->IOT
	missing v1: 0
	missing v2: 132
	Totaling : 176

Writing file: Functions-IOT-To-ERP.sql
wrote 205349 bytes
Writing file: Functions-ERP-To-IOT.sql
wrote 210616 bytes
IOT ERP
set_default_pick_date is missing from ERP->TRIGGER<-
discount_delete is missing from ERP->TRIGGER<-
product_update is missing from ERP->TRIGGER<-
trg_kiosk_service_version is missing from ERP->TRIGGER<-
card_insert is missing from ERP->TRIGGER<-
discount_update is missing from ERP->TRIGGER<-
label_update is missing from ERP->TRIGGER<-
trg_kiosk_attribute is missing from ERP->TRIGGER<-
label_insert is missing from ERP->TRIGGER<-
before_insert_product_stats_by_kiosk is missing from ERP->TRIGGER<-
before_insert_spoilage is missing from ERP->TRIGGER<-
campus_insert is missing from ERP->TRIGGER<-
discount_insert is missing from ERP->TRIGGER<-
guardrails_ssl_cert_bytetech_co is missing from ERP->TRIGGER<-
kiosk_audit_log_update is missing from ERP->TRIGGER<-
kiosk_status_insert is missing from ERP->TRIGGER<-
order_insert is missing from ERP->TRIGGER<-
trg_campus_attribute is missing from ERP->TRIGGER<-
trg_global_attribute_def is missing from ERP->TRIGGER<-
trg_kiosk_device is missing from ERP->TRIGGER<-
kiosk_audit_log_insert is missing from ERP->TRIGGER<-
kiosk_update is missing from ERP->TRIGGER<-
label_delete is missing from ERP->TRIGGER<-
order_update is missing from ERP->TRIGGER<-
product_delete is missing from ERP->TRIGGER<-
product_insert is missing from ERP->TRIGGER<-
	TRIGGER : 26
IOT->ERP
	missing v1: 0
	missing v2: 26
	Totaling : 26


sync_campus is missing from IOT->TRIGGER<-
sync_kiosk is missing from IOT->TRIGGER<-
sync_label_order is missing from IOT->TRIGGER<-
sync_product is missing from IOT->TRIGGER<-
	TRIGGER : 4
ERP->IOT
	missing v1: 0
	missing v2: 4
	Totaling : 4

Writing file: Trigger-IOT-To-ERP.sql
wrote 3485 bytes
Writing file: Trigger-ERP-To-IOT.sql
wrote 533 bytes
